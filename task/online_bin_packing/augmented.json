{
  "best_fit_negative_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -slack\n    score[slack < 0] = -np.inf\n    return score\n",
  "best_fit_inverse_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    eps = 1e-12\n    score = 1.0 / (slack + eps)\n    score[slack < 0] = -np.inf\n    return score\n",
  "best_fit_quadratic_penalty": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -(slack ** 2)\n    score[slack < 0] = -np.inf\n    return score\n",
  "best_fit_exponential_decay": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.exp(-np.maximum(slack, 0.0))\n    score[slack < 0] = -np.inf\n    return score\n",
  "worst_fit_positive_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = slack\n    score[slack < 0] = -np.inf\n    return score\n",
  "worst_fit_sqrt_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.sqrt(np.maximum(slack, 0.0))\n    score[slack < 0] = -np.inf\n    return score\n",
  "almost_worst_fit_second_best": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = slack.copy()\n    score[slack < 0] = -np.inf\n    if np.isfinite(score).any():\n        j = int(np.nanargmax(score))\n        score[j] = score[j] - (np.nanstd(score[np.isfinite(score)]) + 1e-9)\n    return score\n",
  "minimize_waste_with_sliver_guard": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -slack\n    score[slack < 0] = -np.inf\n    finite = np.isfinite(score)\n    if finite.any():\n        cap_ref = np.nanmax(bins[finite]) + 1e-12\n        sliver = 0.05 * cap_ref\n        score[(slack >= 0) & (slack < sliver)] -= 0.5 * cap_ref\n    return score\n",
  "mid_slack_target_fraction": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    target = 0.15 * np.maximum(bins, 1e-12)\n    score = -np.abs(slack - target)\n    score[slack < 0] = -np.inf\n    return score\n",
  "tight_fit_then_balance": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    feasible = slack >= 0\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if feasible.any():\n        primary = -slack\n        med = np.median(slack[feasible])\n        secondary = -np.abs(slack - med)\n        score[feasible] = primary[feasible] + 0.05 * secondary[feasible]\n    return score\n",
  "capacity_normalized_best_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    frac = slack / np.maximum(bins, 1e-12)\n    score = -frac\n    score[slack < 0] = -np.inf\n    return score\n",
  "prefer_exact_fit_bonus": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -slack\n    score[slack < 0] = -np.inf\n    tol = 1e-9\n    score[np.abs(slack) <= tol] += 1e6\n    return score\n",
  "large_item_roomy_small_item_tight": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        cap_ref = np.nanmax(bins[feasible]) + 1e-12\n        big = item >= 0.6 * cap_ref\n        score[feasible] = (slack[feasible] if big else -slack[feasible])\n    return score\n",
  "quantile_target_slack_25": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        target = np.quantile(slack[feasible], 0.25)\n        score[feasible] = -np.abs(slack[feasible] - target)\n    return score\n",
  "zscore_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        mu = np.mean(s)\n        sd = np.std(s) + 1e-12\n        score[feasible] = -(s - mu) / sd\n    return score\n",
  "guard_band_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        cap_ref = np.nanmax(bins[feasible]) + 1e-12\n        low, high = 0.02 * cap_ref, 0.35 * cap_ref\n        mid = 0.5 * (low + high)\n        score[feasible] = -np.abs(slack[feasible] - mid) - 0.1 * slack[feasible]\n        score[(slack >= 0) & (slack < low)] -= cap_ref\n        score[(slack > high)] -= 0.25 * cap_ref\n    return score\n",
  "spread_remaining_capacities": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        mu = np.mean(slack[feasible])\n        score[feasible] = np.abs(slack[feasible] - mu) - 0.05 * slack[feasible]\n    return score\n",
  "temperature_scaled_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        temp = np.std(slack[feasible]) + 1e-9\n        score[feasible] = -slack[feasible] / temp\n    return score\n",
  "harmonic_tight_and_not_too_small": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        a = slack[feasible] + 1e-12\n        b = 1.0 / (bins[feasible] + 1e-12)\n        score[feasible] = 2.0 / (a + b)\n    return score\n",
  "small_items_best_large_items_worst": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        cap_ref = np.nanmax(bins[feasible]) + 1e-12\n        large = item >= 0.5 * cap_ref\n        score[feasible] = (slack[feasible] if large else -slack[feasible])\n    return score\n",
  "capacity_near_small_integer_multiple_of_item": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        k = np.clip(np.round(bins / max(item, 1e-12)), 1, 5)\n        target = k * item\n        score[feasible] = -np.abs(bins[feasible] - target[feasible]) - 0.05 * slack[feasible]\n    return score\n",
  "penalize_too_small_gap_relative_item": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = -slack\n    score[slack < 0] = -np.inf\n    small_gap = (slack >= 0) & (slack < 0.25 * item)\n    score[small_gap] -= 10.0 * (0.25 * item - slack[small_gap])\n    return score\n",
  "worst_fit_with_big_gap_penalty": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = slack\n    score[slack < 0] = -np.inf\n    feasible = slack >= 0\n    if feasible.any():\n        hi = np.quantile(slack[feasible], 0.80)\n        too_big = slack > hi\n        score[too_big] -= (slack[too_big] - hi)\n    return score\n",
  "rank_best_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        order = np.argsort(s)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n        score[feasible] = -ranks\n    return score\n",
  "rank_worst_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        order = np.argsort(-s)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n        score[feasible] = -ranks\n    return score\n",
  "best_fit_with_deterministic_jitter": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = -slack\n    score[slack < 0] = -np.inf\n    feasible = slack >= 0\n    if feasible.any():\n        idx = np.arange(bins.size, dtype=float)\n        jitter = np.sin((idx + 1.0) * (item + 1.234567)) * 1e-6\n        score[feasible] += jitter[feasible]\n    return score\n",
  "huber_slack_penalty": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        delta = np.median(slack[feasible]) + 1e-12\n        s = slack[feasible]\n        huber = np.where(s <= delta, -(s**2)/(2*delta), -(s - delta/2))\n        score[feasible] = huber\n    return score\n",
  "tight_fit_plus_capacity_skew_control": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        mu = np.mean(bins[feasible])\n        cap_term = -np.abs(bins - mu)\n        score[feasible] = -slack[feasible] + 0.01 * cap_term[feasible]\n    return score\n",
  "cdf_quantile_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        order = np.argsort(s)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n        q = ranks / max(1.0, order.size - 1.0)\n        score[feasible] = -q\n    return score\n",
  "sigmoid_negative_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    z = -np.maximum(slack, 0.0)\n    score = 1.0 / (1.0 + np.exp(-z))\n    score[slack < 0] = -np.inf\n    return score\n",
  "log_barrier_best_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    eps = 1e-12\n    score = -np.log(slack + eps)\n    score[slack < 0] = -np.inf\n    return score\n",
  "robust_mad_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        med = np.median(s)\n        mad = np.median(np.abs(s - med)) + 1e-12\n        z = (s - med) / (1.4826 * mad)\n        score[feasible] = -z\n    return score\n",
  "reserve_large_bins_top_decile": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -slack\n    score[slack < 0] = -np.inf\n    feasible = slack >= 0\n    if feasible.any():\n        q90 = np.quantile(bins[feasible], 0.90)\n        big = (bins >= q90) & feasible\n        score[big] -= 0.25 * (bins[big] - q90)\n    return score\n",
  "capacity_aware_best_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        cap_scale = np.mean(bins[feasible]) + 1e-12\n        score[feasible] = -slack[feasible] - 0.05 * (bins[feasible] / cap_scale)\n    return score\n",
  "fill_ratio_then_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        fill = item / np.maximum(bins, 1e-12)\n        score[feasible] = 10.0 * fill[feasible] - slack[feasible]\n    return score\n",
  "avoid_half_full_deadzone": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        fill = (bins - slack) / np.maximum(bins, 1e-12)\n        score[feasible] = -slack[feasible] + 0.1 * np.abs(fill[feasible] - 0.5)\n    return score\n",
  "target_complementary_gap_equal_item": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = -np.abs(slack - item)\n    score[slack < 0] = -np.inf\n    return score\n",
  "adaptive_sigmoid_target_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        target = np.median(s)\n        scale = (np.std(s) + 1e-9)\n        z = (target - slack) / scale\n        score[feasible] = 1.0 / (1.0 + np.exp(-z[feasible]))\n    return score\n",
  "kde_rarity_slack_preference": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        h = (np.std(s) + 1e-9)\n        diffs = (s[:, None] - s[None, :]) / h\n        density = np.sum(np.exp(-0.5 * diffs**2), axis=1)\n        score[feasible] = -density\n    return score\n",
  "variance_reduction_post_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        mu = np.mean(slack[feasible])\n        score[feasible] = -(slack[feasible] - mu) ** 2 - 0.01 * slack[feasible]\n    return score\n",
  "heavy_tail_penalty_on_extreme_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        mu = np.mean(s)\n        sd = np.std(s) + 1e-12\n        z = (s - mu) / sd\n        score[feasible] = -np.abs(z) ** 3 - 0.02 * s\n    return score\n",
  "piecewise_small_item_spread_large_item_tight": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        med_bin = np.median(bins[feasible])\n        small = item <= 0.25 * med_bin\n        if small:\n            mu = np.mean(slack[feasible])\n            score[feasible] = np.abs(slack[feasible] - mu) - 0.01 * slack[feasible]\n        else:\n            score[feasible] = -slack[feasible]\n    return score\n",
  "exponential_overflow_guard": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        scale = (np.mean(slack[feasible]) + 1e-9)\n        score[feasible] = -slack[feasible] - np.exp(slack[feasible] / scale)\n    return score\n",
  "triangular_peak_at_quantile_40": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        peak = np.quantile(s, 0.40)\n        width = (np.quantile(s, 0.90) - np.quantile(s, 0.10)) + 1e-9\n        score[feasible] = 1.0 - (np.abs(slack[feasible] - peak) / width)\n    return score\n",
  "cosine_match_bin_slack_profile": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        mu_bin = np.mean(bins[feasible])\n        mu_slack = np.mean(slack[feasible])\n        v1 = np.stack([bins[feasible], slack[feasible]], axis=1)\n        v2 = np.array([mu_bin, mu_slack], dtype=float)\n        num = v1 @ v2\n        den = (np.linalg.norm(v1, axis=1) * (np.linalg.norm(v2) + 1e-12) + 1e-12)\n        score[feasible] = num / den - 0.02 * slack[feasible]\n    return score\n",
  "lexicographic_rank_then_capacity_center": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        order = np.argsort(s)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n        medb = np.median(bins[feasible])\n        center = -np.abs(bins[feasible] - medb)\n        score[feasible] = -ranks + 0.001 * center\n    return score\n",
  "quantized_slack_prefer_round_remainders": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        q = (np.median(s) / 4.0) + 1e-9\n        k = np.round(slack / q)\n        dist = np.abs(slack - k * q)\n        score[feasible] = -dist[feasible] - 0.05 * slack[feasible]\n    return score\n",
  "softmin_slack_with_logsumexp_scale": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        scale = (np.mean(s) + 1e-9) * np.log(1.0 + s.size)\n        score[feasible] = -slack[feasible] / scale\n    return score\n",
  "golden_ratio_dithered_best_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = -slack\n    score[slack < 0] = -np.inf\n    feasible = slack >= 0\n    if feasible.any():\n        phi = (1.0 + np.sqrt(5.0)) / 2.0\n        idx = np.arange(bins.size, dtype=float) + 1.0\n        d = np.mod(idx * phi, 1.0)\n        score[feasible] += 1e-6 * (d[feasible] - 0.5)\n    return score\n",
  "percentile_guard_avoid_tails": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        lo = np.quantile(s, 0.15)\n        hi = np.quantile(s, 0.85)\n        mid = 0.5 * (lo + hi)\n        score[feasible] = -np.abs(slack[feasible] - mid) - 0.02 * slack[feasible]\n        left = feasible & (slack < lo)\n        right = feasible & (slack > hi)\n        score[left] -= (lo - slack[left])\n        score[right] -= (slack[right] - hi)\n    return score\n",
  "entropy_flatten_slack_histogram": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        lo, hi = np.min(s), np.max(s)\n        if hi - lo < 1e-12:\n            score[feasible] = 0.0\n            return score\n        nb = 10\n        edges = np.linspace(lo, hi, nb + 1)\n        idx = np.clip(np.digitize(s, edges) - 1, 0, nb - 1)\n        counts = np.bincount(idx, minlength=nb).astype(float)\n        rarity = 1.0 / (counts[idx] + 1e-12)\n        score[feasible] = rarity - 0.01 * s\n    return score\n",
  "tukey_biweight_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        med = np.median(s)\n        mad = np.median(np.abs(s - med)) + 1e-12\n        c = 4.685\n        u = (s - med) / (c * 1.4826 * mad)\n        w = (1 - u**2)\n        w[np.abs(u) >= 1] = 0.0\n        w = w**2\n        score[feasible] = w - 0.02 * s\n    return score\n",
  "cauchy_target_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        target = np.median(s)\n        scale = np.std(s) + 1e-9\n        z = (slack[feasible] - target) / scale\n        score[feasible] = 1.0 / (1.0 + z**2) - 0.01 * s\n    return score\n",
  "borda_rank_slack_and_capacity": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        b = bins[feasible]\n        r_slack = np.argsort(np.argsort(s))  # smaller slack -> lower rank\n        medb = np.median(b)\n        r_mid = np.argsort(np.argsort(np.abs(b - medb)))\n        score[feasible] = -(r_slack + 0.5 * r_mid).astype(float)\n    return score\n",
  "capacity_outlier_penalty_plus_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        b = bins[feasible]\n        mu, sd = np.mean(b), (np.std(b) + 1e-12)\n        out = np.abs(b - mu) / sd\n        score[feasible] = -slack[feasible] - 0.1 * out\n    return score\n",
  "avoid_ultra_tight_bottom_decile_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -slack\n    score[slack < 0] = -np.inf\n    feasible = slack >= 0\n    if feasible.any():\n        p10 = np.quantile(slack[feasible], 0.10)\n        ultra_tight = feasible & (slack <= p10)\n        score[ultra_tight] -= (p10 - slack[ultra_tight] + 1e-12) * 0.5\n    return score\n",
  "softplus_barrier_target_fraction_20": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        target = 0.20 * np.maximum(bins, 1e-12)\n        k = 8.0\n        x = k * (np.abs(slack - target) / (np.maximum(bins, 1e-12)))\n        softplus = np.log1p(np.exp(x))\n        score[feasible] = -softplus[feasible] - 0.01 * slack[feasible]\n    return score\n",
  "logit_fill_target_70": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        fill = item / np.maximum(bins, 1e-12)\n        target = 0.70\n        z = -(np.abs(fill - target)) * 12.0\n        score[feasible] = 1.0 / (1.0 + np.exp(-z[feasible])) - 0.02 * slack[feasible]\n    return score\n",
  "minimize_fractional_slack_squared": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    frac = slack / np.maximum(bins, 1e-12)\n    score = -(frac ** 2)\n    score[slack < 0] = -np.inf\n    return score\n",
  "sawtooth_modulo_item_multiple_bias": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any() and item > 1e-12:\n        k = np.round(slack[feasible] / item)\n        dist = np.abs(slack[feasible] - k * item)\n        score[feasible] = -dist - 0.05 * slack[feasible]\n    return score\n",
  "prefer_power_of_two_fraction_remainder": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        frac = slack[feasible] / np.maximum(bins[feasible], 1e-12)\n        targets = np.array([0.5, 0.25, 0.125, 0.0625, 0.03125], dtype=float)\n        d = np.min(np.abs(frac[:, None] - targets[None, :]), axis=1)\n        score[feasible] = -d - 0.02 * slack[feasible]\n    return score\n",
  "two_sided_guard_band_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        hi = np.quantile(s, 0.80)\n        lo = 0.20 * item\n        center = 0.5 * (lo + hi)\n        score[feasible] = -np.abs(slack[feasible] - center)\n        score[feasible & (slack < lo)] -= (lo - slack[feasible & (slack < lo)])\n        score[feasible & (slack > hi)] -= (slack[feasible & (slack > hi)] - hi)\n    return score\n",
  "harmonic_slack_capped": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    eps = 1e-12\n    raw = 1.0 / (slack + eps)\n    raw[slack < 0] = -np.inf\n    finite = np.isfinite(raw)\n    if finite.any():\n        cap = np.quantile(raw[finite], 0.95)\n        raw[finite] = np.minimum(raw[finite], cap)\n    return raw\n",
  "sqrt_tightness_smooth": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -np.sqrt(np.maximum(slack, 0.0))\n    score[slack < 0] = -np.inf\n    return score\n",
  "dynamic_alpha_tightness_by_bin_cv": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        b = bins[feasible]\n        cv = (np.std(b) / (np.mean(b) + 1e-12))\n        p = 1.0 + 2.0 * np.clip(cv, 0.0, 1.0)\n        score[feasible] = -(slack[feasible] ** p)\n    return score\n",
  "middle_capacity_preference_with_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        b = bins[feasible]\n        med = np.median(b)\n        score[feasible] = -np.abs(b - med) - 0.2 * slack[feasible]\n    return score\n",
  "reserve_bottom_quartile_for_small_items": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        b = bins[feasible]\n        q25 = np.quantile(b, 0.25)\n        cap_ref = np.max(b) + 1e-12\n        is_small = item <= 0.15 * cap_ref\n        base = -slack[feasible]\n        score[feasible] = base\n        if is_small:\n            small_bins = feasible & (bins <= q25)\n            score[small_bins] -= 0.5 * (q25 - bins[small_bins])\n    return score\n",
  "quadrant_rule_high_fill_or_low_waste": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        fill = item / np.maximum(bins, 1e-12)\n        p25 = np.quantile(slack[feasible], 0.25)\n        good = (fill >= 0.85) | (slack <= p25)\n        score[feasible] = -slack[feasible]\n        score[feasible & good] += 0.2\n    return score\n",
  "projected_pairing_probability_exp": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        scale = max(item, 1e-9)\n        sim = np.exp(-((slack[feasible] - item) / scale) ** 2)\n        score[feasible] = sim - 0.03 * slack[feasible]\n    return score\n",
  "temperature_scaled_boltzmann_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        q1, q3 = np.quantile(s, 0.25), np.quantile(s, 0.75)\n        T = (q3 - q1) + 1e-9\n        score[feasible] = np.exp(-s / T)\n    return score\n",
  "minimize_relative_slack_to_item_target_20pct": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any() and item > 1e-12:\n        rel = slack[feasible] / item\n        score[feasible] = -np.abs(rel - 0.20) - 0.02 * slack[feasible]\n    return score\n",
  "percentile_rank_slack_then_penalize_edges": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        order = np.argsort(s)\n        r = np.empty_like(order, dtype=float)\n        r[order] = np.linspace(0.0, 1.0, num=order.size)\n        edge_pen = np.minimum(r, 1.0 - r)\n        score[feasible] = -(r + 0.2 * (0.5 - edge_pen))\n    return score\n",
  "l1_target_vector_bin_and_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        b = bins[feasible]\n        s = slack[feasible]\n        tb, ts = np.median(b), np.median(s)\n        score[feasible] = -(np.abs(b - tb) + np.abs(s - ts))\n    return score\n",
  "bimodal_preference_tight_or_roomy": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        p20, p80 = np.quantile(s, 0.20), np.quantile(s, 0.80)\n        tight = slack[feasible] <= p20\n        roomy = slack[feasible] >= p80\n        mid = ~(tight | roomy)\n        out = np.zeros_like(s)\n        out[tight] = 1.0 - (s[tight] / (p20 + 1e-12))\n        out[roomy] = 0.5 + (s[roomy] - p80) / (np.max(s) - p80 + 1e-12)\n        out[mid] = -0.5 - np.abs(s[mid] - np.median(s)) / (np.std(s) + 1e-12)\n        score[feasible] = out\n    return score\n",
  "inverse_capacity_weighted_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        invcap = 1.0 / (bins[feasible] + 1e-12)\n        score[feasible] = -slack[feasible] * (1.0 + 5.0 * (1.0 - invcap / np.max(invcap)))\n    return score\n",
  "gini_like_balance_proxy": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        med = np.median(s)\n        q1, q3 = np.quantile(s, 0.25), np.quantile(s, 0.75)\n        iqr = (q3 - q1) + 1e-12\n        z = np.abs(s - med) / iqr\n        score[feasible] = -z - 0.01 * s\n    return score\n",
  "minimize_slack_times_capacity_deviation": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        medb = np.median(bins[feasible]) + 1e-12\n        dev = np.abs(bins[feasible] - medb) / medb\n        score[feasible] = -slack[feasible] * (1.0 + 0.5 * dev)\n    return score\n",
  "softmaxed_best_fit_temperature_by_scale": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        T = (np.mean(s) + 1e-9)\n        score[feasible] = -s / T\n    return score\n",
  "huber_loss_around_target_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        target = np.median(s)\n        delta = (np.std(s) + 1e-9)\n        r = s - target\n        huber = np.where(np.abs(r) <= delta, 0.5 * r**2, delta * (np.abs(r) - 0.5 * delta))\n        score[feasible] = -huber - 0.01 * s\n    return score\n",
  "winsorized_best_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        cap = np.quantile(s, 0.95)\n        s2 = np.minimum(s, cap)\n        score[feasible] = -s2\n    return score\n",
  "maximize_post_fill_margin_from_quarters": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        fill = item / np.maximum(bins, 1e-12)\n        anchors = np.array([0.25, 0.50, 0.75])\n        d = np.min(np.abs(fill[feasible][:, None] - anchors[None, :]), axis=1)\n        score[feasible] = d - 0.05 * slack[feasible]\n    return score\n",
  "knee_point_preference_on_sorted_slacks": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        ss = np.sort(s)\n        n = ss.size\n        if n <= 2:\n            score[feasible] = -s\n            return score\n        x = np.linspace(0.0, 1.0, n)\n        y = (ss - ss[0]) / (ss[-1] - ss[0] + 1e-12)\n        line = x\n        knee = np.argmax(np.abs(y - line))\n        target = ss[knee]\n        score[feasible] = -np.abs(s - target) - 0.01 * s\n    return score\n",
  "minimize_second_order_slack_difference": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        mu = np.mean(s)\n        score[feasible] = -(s - mu) ** 2 - 0.02 * s\n    return score\n",
  "quantile_band_pass_then_best_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        p30, p70 = np.quantile(s, 0.30), np.quantile(s, 0.70)\n        in_band = feasible & (slack >= p30) & (slack <= p70)\n        score[feasible] = -slack[feasible]\n        score[in_band] += 0.2\n    return score\n",
  "prefer_geometric_mean_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible] + 1e-12\n        gm = np.exp(np.mean(np.log(s)))\n        score[feasible] = -np.abs((slack[feasible] + 1e-12) - gm) - 0.01 * slack[feasible]\n    return score\n",
  "rank_by_slack_then_penalize_high_capacity": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        b = bins[feasible]\n        order = np.argsort(s)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n        cap_rank = np.argsort(np.argsort(b)).astype(float) / max(b.size - 1, 1)\n        score[feasible] = -ranks - 0.3 * cap_rank\n    return score\n",
  "slope_limited_linear_penalty": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        thr = np.quantile(s, 0.60)\n        penal = np.minimum(s, thr) + 0.2 * np.maximum(s - thr, 0.0)\n        score[feasible] = -penal\n    return score\n",
  "prefer_slack_near_item_iqr_scaled": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        q1, q3 = np.quantile(s, 0.25), np.quantile(s, 0.75)\n        iqr = (q3 - q1) + 1e-9\n        score[feasible] = -np.abs(s - item) / iqr - 0.01 * s\n    return score\n",
  "minimize_slack_times_log_capacity": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        w = np.log(np.maximum(bins[feasible], 1e-12) + 1.0)\n        score[feasible] = -(slack[feasible] * w)\n    return score\n",
  "prefer_small_bin_if_multiple_feasible_else_roomy": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    k = int(np.sum(feasible))\n    if k > 0:\n        if k >= 4:\n            score[feasible] = -bins[feasible] - 0.1 * slack[feasible]\n        else:\n            score[feasible] = slack[feasible] - 0.05 * bins[feasible]\n    return score\n",
  "piecewise_penalize_mid_slack_interval": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        p40, p60 = np.quantile(s, 0.40), np.quantile(s, 0.60)\n        score[feasible] = -s\n        mid = feasible & (slack >= p40) & (slack <= p60)\n        score[mid] -= 0.3 * (p60 - p40 + 1e-12)\n    return score\n",
  "max_margin_from_feasible_min_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        mn = np.min(s)\n        margin = np.abs(s - (mn + 0.05 * (np.max(s) - mn + 1e-12)))\n        score[feasible] = -margin - 0.01 * s\n    return score\n",
  "prefer_slack_near_capacity_percentile_35": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        b = bins[feasible]\n        target = np.quantile(b, 0.35)\n        score[feasible] = -np.abs(slack[feasible] - 0.15 * target) - 0.02 * slack[feasible]\n    return score\n",
  "minimize_lognormalized_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -np.log1p(np.maximum(slack, 0.0))\n    score[slack < 0] = -np.inf\n    return score\n",
  "prefer_slack_near_mean_capacity_minus_item": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        mu_b = np.mean(bins[feasible])\n        target = max(mu_b - item, 0.0)\n        score[feasible] = -np.abs(slack[feasible] - target) - 0.01 * slack[feasible]\n    return score\n",
  "asymmetric_penalty_small_slack_over_big_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        cap = np.max(bins[feasible]) + 1e-12\n        sliver = 0.05 * cap\n        penalty = np.where(s < sliver, 5.0 * (sliver - s), 0.2 * s)\n        score[feasible] = -penalty\n    return score\n",
  "median_absolute_deviation_capacity_centering": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        b = bins[feasible]\n        med = np.median(b)\n        mad = np.median(np.abs(b - med)) + 1e-12\n        z = np.abs(b - med) / (1.4826 * mad)\n        score[feasible] = -z - 0.1 * slack[feasible]\n    return score\n",
  "prefer_slack_near_triangular_median_iqr": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        med = np.median(s)\n        q1, q3 = np.quantile(s, 0.25), np.quantile(s, 0.75)\n        width = (q3 - q1) + 1e-9\n        score[feasible] = 1.0 - (np.abs(s - med) / width) - 0.02 * s\n    return score\n",
  "prefer_high_fill_and_low_capacity": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        fill = item / np.maximum(bins[feasible], 1e-12)\n        cap_norm = bins[feasible] / (np.max(bins[feasible]) + 1e-12)\n        score[feasible] = 2.0 * fill - 0.8 * cap_norm - 0.05 * slack[feasible]\n    return score\n",
  "minimize_slack_to_capacity_ratio_then_exact_bonus": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        frac = slack[feasible] / np.maximum(bins[feasible], 1e-12)\n        score[feasible] = -frac\n        tol = 1e-9\n        near = feasible & (np.abs(slack) <= tol)\n        score[near] += 10.0\n    return score\n",
  "prefer_capacity_near_item_plus_median_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        med_slack = np.median(slack[feasible])\n        target_cap = item + med_slack\n        score[feasible] = -np.abs(bins[feasible] - target_cap) - 0.05 * slack[feasible]\n    return score\n",
  "iqr_normalized_best_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        q1, q3 = np.quantile(s, 0.25), np.quantile(s, 0.75)\n        iqr = (q3 - q1) + 1e-9\n        score[feasible] = -(s / iqr)\n    return score\n",
  "best_fit_negative_slack_aug_0": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Basic score: negative slack (smaller slack \u2192 higher score)\n    score = -slack\n\n    # Invert sign for infeasible bins\n    score = np.where(slack < 0, -np.inf, score)\n\n    # Deterministic noise for tie\u2011breaking (index\u2011based)\n    noise = 1e-6 * np.arange(len(bins))\n    score += noise\n\n    # Clip to avoid extreme values that could break downstream code\n    return np.clip(score, -1e12, 1e12)\n\n",
  "best_fit_negative_slack_aug_1": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Hyper\u2011parameters: weight on slack vs. average bin capacity\n    weight_slack = 0.7\n    weight_avg   = 0.3\n\n    # Avoid division by zero when computing the mean\n    avg_cap = np.mean(bins) + 1e-12\n\n    # Linear combination of weighted terms\n    score = -slack * weight_slack + avg_cap * weight_avg\n\n    # Mark infeasible bins\n    score = np.where(slack < 0, -np.inf, score)\n\n    # Clip to a safe numeric range\n    return np.clip(score, -1e12, 1e12)\n\n",
  "best_fit_negative_slack_aug_2": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    n = bins.size\n    scores = np.empty(n, dtype=float)\n\n    idx = 0\n    while idx < n:\n        slack = bins[idx] - float(item)\n        if slack >= 0:\n            # Deterministic noise added to break ties\n            scores[idx] = -slack + 1e-6 * idx\n        else:\n            scores[idx] = -np.inf\n        idx += 1\n\n    # Clip to prevent extreme values\n    return np.clip(scores, -1e12, 1e12)\n\n",
  "best_fit_negative_slack_aug_3": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Compute a stable soft\u2011min probability distribution\n    exp_neg = np.exp(-slack - 1e-12)          # epsilon for numerical stability\n    softmin = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n    # Convert to a score (negative log probability)\n    score = -np.log(softmin + 1e-12)\n\n    # Infeasible bins get -inf\n    score = np.where(slack < 0, -np.inf, score)\n\n    # Clip to a safe numeric range\n    return np.clip(score, -1e12, 1e12)\n\n",
  "best_fit_inverse_slack_aug_4": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    eps = 1e-12\n\n    # Slack after placing the item\n    slack = bins - float(item)\n\n    # Avoid division by zero and keep only feasible bins\n    safe_slack = np.clip(slack, a_min=eps, a_max=None)\n    score = 1.0 / safe_slack\n    score = np.where(slack >= 0, score, -np.inf)\n\n    # Deterministic noise for stable tie\u2011breaking\n    noise = 1e-15 * np.arange(len(score))\n    return score + noise\n\n",
  "best_fit_inverse_slack_aug_5": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    eps = 1e-12\n\n    slack = bins - float(item)\n    mean_slack = np.mean(slack)\n\n    # Score relative to the average slack\n    score = 1.0 / (slack - mean_slack + eps)\n    score = np.where(slack >= 0, score, -np.inf)\n\n    # Small noise for tie\u2011breaking\n    noise = 1e-15 * np.arange(len(score))\n    return score + noise\n\n",
  "best_fit_inverse_slack_aug_6": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    eps = 1e-12\n\n    slack = bins - float(item)\n    score = 1.0 / (slack + eps)\n    score = np.where(slack >= 0, score, -np.inf)\n\n    # Restrict to the three highest scores\n    k = 3\n    if len(score) > k:\n        topk_idx = np.argpartition(score, -k)[-k:]\n        mask = np.full_like(score, -np.inf, dtype=float)\n        mask[topk_idx] = score[topk_idx]\n        score = mask\n\n    return score\n\n",
  "best_fit_quadratic_penalty_aug_7": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n\n    # free space in each bin\n    free_space = bins_arr - float(item)\n    # avoid extreme values that could overflow when squaring\n    free_space = np.clip(free_space, -1e12, 1e12)\n\n    # quadratic penalty\n    score = -np.square(free_space)\n\n    # infeasible bins get the worst possible score\n    score = np.where(free_space < 0, -np.inf, score)\n\n    return score\n\n",
  "best_fit_quadratic_penalty_aug_8": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n\n    slack = bins_arr - float(item)\n\n    # normalise to keep the scale stable and avoid division by zero\n    denom = np.max(np.abs(slack)) + 1e-12\n    norm_slack = slack / denom\n\n    # weighted combination of quadratic and linear penalties\n    score = -(0.7 * np.square(norm_slack) + 0.3 * norm_slack)\n\n    # penalise infeasible bins\n    score = np.where(slack < 0, -np.inf, score)\n\n    # keep the score within a reasonable range\n    score = np.clip(score, -1e12, 0)\n\n    return score\n\n",
  "best_fit_quadratic_penalty_aug_9": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n\n    slack = bins_arr - float(item)\n\n    # deterministic noise: small incremental values\n    noise = 1e-6 * np.arange(len(bins_arr))\n    noise = np.clip(noise, -1e-6, 1e-6)\n\n    # normalise slack to avoid extreme exponent values\n    denom = np.max(np.abs(slack)) + 1e-12\n    norm_slack = slack / denom\n\n    tau = 0.5 + 1e-12  # temperature parameter for the softmin\n\n    # soft\u2011minimum score (higher is better)\n    score = -np.exp(-norm_slack**2 / tau) + noise\n\n    # infeasible bins receive the worst score\n    score = np.where(slack < 0, -np.inf, score)\n\n    return score\n\n",
  "best_fit_quadratic_penalty_aug_10": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n\n    slack = bins_arr - float(item)\n    # clip to avoid overflow in subsequent operations\n    slack = np.clip(slack, -1e12, 1e12)\n\n    # define a threshold to switch from quadratic to linear penalty\n    threshold = 10.0\n\n    # quadratic penalty for |slack| <= threshold\n    quad_penalty = np.square(slack)\n\n    # linear penalty for |slack| > threshold\n    linear_penalty = 2 * threshold * np.abs(slack) - threshold**2\n\n    # combine penalties\n    penalty = np.where(np.abs(slack) <= threshold, quad_penalty, linear_penalty)\n\n    score = -penalty\n\n    # infeasible bins get the worst score\n    score = np.where(slack < 0, -np.inf, score)\n\n    # clip final score to a safe range\n    score = np.clip(score, -1e12, 0)\n\n    return score\n\n",
  "best_fit_exponential_decay_aug_11": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n    remaining = arr - float(item)\n    # Clip to avoid extreme exponents\n    remaining = np.clip(remaining, -1e6, None)\n    scores = np.exp(-np.maximum(remaining, 0.0))\n    # Bins that cannot accommodate the item are penalized\n    scores[remaining < 0] = -np.inf\n    # Small deterministic noise to break ties\n    noise = np.arange(len(scores)) * 1e-9\n    return scores + noise\n\n",
  "best_fit_exponential_decay_aug_12": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    vec = np.asarray(bins, dtype=float)\n    slack = vec - float(item)\n    # Emphasize tighter fits by scaling slack\n    weighted = 0.7 * slack\n    weighted = np.clip(weighted, -1e5, None)\n    # Denominator prevents division by zero\n    denom = 1.0 + np.abs(weighted)\n    scores = np.exp(-weighted / denom)\n    scores[slack < 0] = -np.inf\n    return scores\n\n",
  "best_fit_exponential_decay_aug_13": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    rng = np.random.default_rng(seed=42)\n    bins_arr = np.asarray(bins, dtype=float)\n    slack = bins_arr - float(item)\n    slack = np.clip(slack, -1e5, None)\n    raw = np.exp(-slack)\n    # Deterministic pseudo\u2011random noise\n    noise = rng.standard_normal(len(raw)) * 1e-8\n    raw += noise\n    raw[slack < 0] = -np.inf\n    return raw\n\n",
  "best_fit_exponential_decay_aug_14": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n    original_slack = arr - float(item)\n    # Clip to avoid extremely small denominators\n    slack = np.clip(original_slack, 1e-12, None)\n    scores = 1.0 / (1.0 + slack)\n    scores[original_slack < 0] = -np.inf\n    noise = np.arange(len(scores)) * 1e-9\n    return scores + noise\n\n",
  "worst_fit_positive_slack_aug_15": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    # Ensure a float array and compute slack\n    avail = np.asarray(bins, dtype=float)\n    slack = avail - float(item)\n\n    # Clip slack to avoid extreme values that could cause overflow\n    slack = np.clip(slack, -1e6, 1e6)\n\n    # Replace infeasible bins with -inf\n    score = np.where(slack >= 0, slack, -np.inf)\n    return score\n\n",
  "worst_fit_positive_slack_aug_16": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    avail = np.asarray(bins, dtype=float)\n    slack = avail - float(item)\n\n    # Keep values within a safe range\n    slack = np.clip(slack, -1e6, 1e6)\n\n    # Weighted combination of slack and raw capacity\n    score = 0.9 * slack + 0.1 * avail\n    return score\n\n",
  "worst_fit_positive_slack_aug_17": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    avail = np.asarray(bins, dtype=float)\n    slack = avail - float(item)\n\n    # Clip to avoid extreme values\n    slack = np.clip(slack, -1e6, 1e6)\n\n    # Small deterministic noise proportional to the index\n    noise = np.arange(len(avail), dtype=float) * 1e-6\n\n    # Infeasible bins get -inf; add noise only to feasible ones\n    score = np.where(slack >= 0, slack + noise, -np.inf)\n    return score\n\n",
  "worst_fit_positive_slack_aug_18": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    avail = np.asarray(bins, dtype=float)\n    slack = avail - float(item)\n\n    # Clip and mask infeasible bins\n    slack = np.clip(slack, -1e6, 1e6)\n    slack = np.where(slack >= 0, slack, -np.inf)\n\n    # Compute a stable softmax over the feasible slacks\n    max_slack = np.max(slack)\n    exp_vals = np.exp(slack / (1e-12 + max_slack))\n    softmax = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    return softmax\n\n",
  "worst_fit_sqrt_slack_aug_19": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n\n    # Compute slack and clip to avoid negative values\n    slack = np.clip(caps - float(item), 0.0, None)\n\n    # Add a tiny epsilon inside the sqrt to keep the operation numerically stable\n    score = np.sqrt(slack + 1e-12)\n\n    # Explicitly mark infeasible bins\n    infeasible = caps < float(item)\n    score[infeasible] = -np.inf\n\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-8 * np.arange(len(score))\n    return score + noise\n\n",
  "worst_fit_sqrt_slack_aug_20": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n\n    # Raw slack (can be negative)\n    slack_raw = caps - float(item)\n\n    # Clip slack to a non\u2011negative range for the sqrt part\n    slack = np.clip(slack_raw, 0.0, None)\n\n    # Tunable weight and scaling for the score\n    weight = 0.75\n    scale = 1.25\n\n    # Compute the score with a denominator that includes a tiny epsilon\n    score = weight * np.sqrt(slack + 1e-12) / (scale + slack * 0.1 + 1e-12)\n\n    # Mark infeasible bins\n    score[slack_raw < 0] = -np.inf\n    return score\n\n",
  "worst_fit_sqrt_slack_aug_21": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - float(item)\n\n    # Compute sqrt with a tiny epsilon\n    sqrt_part = np.sqrt(np.maximum(slack, 0.0) + 1e-12)\n\n    # Add deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(len(sqrt_part))\n    score = sqrt_part + noise\n\n    # Use np.where to set infeasible bins to -inf\n    score = np.where(slack < 0, -np.inf, score)\n    return score\n\n",
  "worst_fit_sqrt_slack_aug_22": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack_raw = caps - float(item)\n\n    # Clip slack to avoid negative values in the exponential\n    slack = np.clip(slack_raw, 0.0, None)\n\n    # Softmin probabilities (negative slack \u2192 higher priority)\n    exp_vals = np.exp(-slack + 1e-12)\n    denom = np.sum(exp_vals) + 1e-12\n    score = exp_vals / denom\n\n    # Mark infeasible bins with -inf\n    score = np.where(slack_raw < 0, -np.inf, score)\n    return score\n\n",
  "almost_worst_fit_second_best_aug_23": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    residual = capacities - item\n    # Score is slack if feasible, otherwise a large negative value\n    scores = np.where(residual >= 0, residual, -1e12)\n    # Deterministic tie\u2011breaker\n    scores += np.random.rand(len(scores)) * 1e-9\n    if np.any(np.isfinite(scores)):\n        idx = int(np.argmax(scores))\n        finite_scores = scores[np.isfinite(scores)]\n        scores[idx] -= (np.std(finite_scores) + 1e-9)\n    return scores\n\n",
  "almost_worst_fit_second_best_aug_24": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - item\n    mask = slack >= 0\n    scores = np.full_like(slack, -np.inf)\n    if np.any(mask):\n        # Pick the top\u2011k most slack bins\n        top_k = 5\n        idxs = np.argpartition(-slack[mask], top_k-1)[:top_k]\n        global_idxs = np.where(mask)[0][idxs]\n        rng = np.random.default_rng()\n        # Random priority among the top\u2011k bins\n        scores[global_idxs] = rng.random(len(global_idxs))\n    return scores\n\n",
  "almost_worst_fit_second_best_aug_25": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - item\n    scores = np.where(slack >= 0, slack, -np.inf)\n    if np.any(np.isfinite(scores)):\n        mean_slack = np.mean(scores[np.isfinite(scores)]) + 1e-12\n        scores = scores / (mean_slack + 1e-12)\n        scores = np.clip(scores, 0, 1)\n        std_slack = np.std(scores[np.isfinite(scores)]) + 1e-12\n        scores -= std_slack\n        # Small deterministic noise\n        scores += np.arange(len(scores)) * 1e-13\n    return scores\n\n",
  "almost_worst_fit_second_best_aug_26": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - item\n    # Keep values in a reasonable range\n    slack = np.clip(slack, -1e6, 1e6)\n    mask = slack >= 0\n    scores = np.full_like(slack, -np.inf)\n    if np.any(mask):\n        temp = 1e-9 + np.median(slack[mask])\n        soft_vals = np.exp(-slack[mask] / temp)\n        scores[mask] = soft_vals\n        scores[mask] /= (np.sum(soft_vals) + 1e-12)\n        mean_score = np.mean(scores[mask]) + 1e-12\n        scores[mask] -= mean_score\n        scores = np.clip(scores, 0, None)\n    return scores\n\n",
  "minimize_waste_with_sliver_guard_aug_27": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n\n    # Compute available space (slack) with clipping to avoid extreme values\n    slack = np.clip(bins - float(item), -1e12, 1e12)\n\n    # Base score: larger slack gives a smaller (more negative) score\n    score = -slack\n\n    # Infeasible bins are penalised with negative infinity\n    score[slack < 0] = -np.inf\n\n    # Deterministic noise for stable tie\u2011breaking\n    noise = 1e-8 * np.arange(bins.size)\n    score += noise\n\n    # Adjust for tiny slivers that would waste capacity\n    finite = np.isfinite(score)\n    if finite.any():\n        cap_ref = np.nanmax(bins[finite]) + 1e-12\n        sliver = 0.05 * cap_ref + 1e-12\n        mask = (slack >= 0) & (slack < sliver)\n        score[mask] -= 0.5 * cap_ref\n\n    return score\n\n",
  "minimize_waste_with_sliver_guard_aug_28": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n\n    # Compute slack with clipping\n    slack = np.clip(bins - float(item), -1e12, 1e12)\n\n    # Feasibility mask\n    feasible = slack >= 0\n\n    # Reference capacity from median of feasible bins\n    cap_ref = np.nanmedian(bins[feasible]) + 1e-12\n\n    # Soft\u2011min style score: lower slack \u2192 higher score\n    scale = cap_ref + 1e-12\n    score = np.exp(-slack / scale)\n    score[~feasible] = -np.inf\n\n    # Small deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(bins.size)\n    score += noise\n\n    # Penalise slivers\n    sliver = 0.10 * cap_ref + 1e-12\n    mask = (slack >= 0) & (slack < sliver)\n    score[mask] -= 0.3 * cap_ref\n\n    return score\n\n",
  "minimize_waste_with_sliver_guard_aug_29": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    n = bins.size\n    score = np.empty(n, dtype=float)\n\n    # Deterministic noise\n    noise = 1e-7 * np.arange(n)\n\n    # Explicit loop over bins\n    for i in range(n):\n        slack = bins[i] - float(item)\n        if slack < 0:\n            score[i] = -np.inf\n        else:\n            score[i] = -slack + noise[i]\n\n    # Reference capacity from maximum feasible bin\n    finite = np.isfinite(score)\n    if finite.any():\n        cap_ref = np.nanmax(bins[finite]) + 1e-12\n        sliver = 0.07 * cap_ref + 1e-12\n        for i in range(n):\n            if finite[i]:\n                slack = bins[i] - float(item)\n                if 0 <= slack < sliver:\n                    score[i] -= 0.4 * cap_ref\n\n    return score\n\n",
  "minimize_waste_with_sliver_guard_aug_30": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n\n    # Compute slack with clipping\n    slack = np.clip(bins - float(item), -1e12, 1e12)\n    feasible = slack >= 0\n\n    # Reference capacity from median of all bins\n    cap_ref = np.nanmedian(bins) + 1e-12\n\n    # Ratio of slack to reference capacity\n    ratio = np.full_like(bins, -np.inf, dtype=float)\n    ratio[feasible] = slack[feasible] / (cap_ref + 1e-12)\n\n    # Soft\u2011max style transformation of ratios\n    if feasible.any():\n        max_ratio = np.max(ratio[feasible])\n    else:\n        max_ratio = 0.0\n    exp_ratio = np.exp(ratio - max_ratio)\n    exp_ratio[~feasible] = 0.0\n    score = exp_ratio\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(bins.size)\n    score += noise\n\n    # Penalise slivers\n    sliver = 0.08 * cap_ref + 1e-12\n    mask = (slack >= 0) & (slack < sliver)\n    score[mask] -= 0.2 * cap_ref\n\n    return score\n\n",
  "mid_slack_target_fraction_aug_31": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    # Slack after placing the item\n    slack = bins_arr - item\n    # Target remainder set to 20\u202f% of bin capacity (tuned from 15\u202f%)\n    target = 0.20 * np.maximum(bins_arr, 1e-12)\n    # Raw score: higher when slack is close to target\n    score = -np.abs(slack - target)\n    # Small deterministic noise for stable tie\u2011breaking\n    noise = np.arange(len(bins_arr)) * 1e-8\n    score += noise\n    # Items that overflow a bin get -inf\n    score[slack < 0] = -np.inf\n    return score\n\n",
  "mid_slack_target_fraction_aug_32": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    scores = []\n    for idx, b in enumerate(bins_arr):\n        slack = b - item\n        # Clip slack to avoid extreme negatives before scoring\n        slack = np.clip(slack, -1e12, None)\n        target = 0.12 * max(b, 1e-12)          # tuned target weight\n        diff = abs(slack - target)\n        sc = -diff\n        # Deterministic noise for tie\u2011breaking\n        sc += idx * 1e-7\n        if slack < 0:\n            sc = -np.inf\n        scores.append(sc)\n    return np.array(scores)\n\n",
  "mid_slack_target_fraction_aug_33": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack = bins_arr - item\n    target = 0.15 * np.maximum(bins_arr, 1e-12)\n    # Proxy for |x| using square root of squared difference\n    diff = np.sqrt(np.square(slack - target))\n    score = -diff\n    # Bound the score to avoid extreme values\n    score = np.clip(score, -1.0, 0.0)\n    # Deterministic noise for tie\u2011breaking\n    noise = np.linspace(0, 1e-6, len(bins_arr))\n    score += noise\n    # Penalize overflow\n    score[slack < 0] = -np.inf\n    return score\n\n",
  "mid_slack_target_fraction_aug_34": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack = bins_arr - item\n    target = 0.15 * np.maximum(bins_arr, 1e-12)\n    diff = np.abs(slack - target)\n    tau = 0.1\n    # Soft\u2011min transformation with epsilon to avoid division by zero\n    score = -np.exp(-diff / (tau + 1e-12))\n    # Clip to keep scores in a reasonable range\n    score = np.clip(score, -1.0, 0.0)\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(bins_arr)) * 1e-9\n    score += noise\n    # Overflow penalty\n    score[slack < 0] = -np.inf\n    return score\n\n",
  "tight_fit_then_balance_aug_35": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    residual = capacities - item\n\n    feasible = residual >= 0\n    score = np.full(capacities.shape, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        primary = -residual\n        med = np.median(residual[feasible])\n        secondary = -np.abs(residual - med)\n        score[feasible] = primary[feasible] + 0.05 * secondary[feasible]\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(capacities.size).reshape(capacities.shape) * 1e-9\n    score += noise\n\n    # clip to keep scores in a reasonable range\n    return np.clip(score, -1e6, 0.0)\n\n",
  "tight_fit_then_balance_aug_36": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    residual = capacities - item\n\n    # clip residual to avoid extreme values that could cause overflow\n    residual = np.clip(residual, 0, 1e6)\n\n    feasible = residual >= 0\n    score = np.full(capacities.shape, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        primary = -residual\n        mean_val = np.mean(residual[feasible])\n        secondary = -np.abs(residual - mean_val)\n        score[feasible] = primary[feasible] + 0.1 * secondary[feasible]\n\n    # add small deterministic noise to break ties\n    noise = np.random.uniform(-1e-10, 1e-10, size=capacities.shape)\n    score += noise\n\n    return np.clip(score, -1e6, 0.0)\n\n",
  "tight_fit_then_balance_aug_37": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    residual = capacities - item\n\n    feasible = residual >= 0\n    score = np.full(capacities.shape, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        primary_weight = 0.7\n        secondary_weight = 0.3\n\n        primary = -residual\n        med = np.median(residual[feasible])\n        secondary = -np.abs(residual - med)\n\n        # Soft\u2011min: exp(-weight * component)\n        exp_primary = np.exp(primary_weight * primary)\n        exp_secondary = np.exp(secondary_weight * secondary)\n        softmin = -np.log(exp_primary * exp_secondary + 1e-12)  # epsilon\n\n        score[feasible] = softmin[feasible]\n\n    # keep scores bounded\n    return np.clip(score, -1e6, 0.0)\n\n",
  "tight_fit_then_balance_aug_38": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    residual = capacities - item\n\n    feasible = residual >= 0\n    score = np.full(capacities.shape, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        primary = -residual\n        max_val = np.max(residual[feasible])\n        secondary = -np.abs(residual - max_val)\n        score[feasible] = primary[feasible] + 0.05 * secondary[feasible]\n\n    # random noise for the top\u2011k bins to break ties\n    top_k = 3\n    if np.any(feasible):\n        top_indices = np.argpartition(score, -top_k)[-top_k:]\n        noise = np.random.uniform(-1e-9, 1e-9, size=capacities.shape)\n        score[top_indices] += noise[top_indices]\n\n    return np.clip(score, -1e6, 0.0)\n\n",
  "capacity_normalized_best_fit_aug_39": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - float(item)\n    denom = np.maximum(caps, 1e-12)          # avoid division by zero\n    frac = slack / denom\n    frac = np.clip(frac, 0.0, 1.0)            # enforce valid range\n    score = -frac\n    score = np.where(slack < 0, -np.inf, score)\n    return score\n\n",
  "capacity_normalized_best_fit_aug_40": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    denom = np.maximum(bins, 1e-12)\n    frac = slack / denom\n    # Soft\u2011min: lower frac \u2192 higher score\n    temp = 0.3\n    exp_vals = np.exp(-frac / temp)\n    score = -np.log(exp_vals + 1e-12)        # invert to keep \u201chigher is better\u201d\n    # Deterministic noise: 1e-8 * index\n    noise = 1e-8 * np.arange(len(bins))\n    score += noise\n    score = np.where(slack < 0, -np.inf, score)\n    return score\n\n",
  "capacity_normalized_best_fit_aug_41": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    denom = np.maximum(bins, 1e-12)\n    frac = slack / denom\n    median_frac = np.median(frac)\n    # Normalise by the median to keep the scale comparable across different inputs\n    score = -(frac / (median_frac + 1e-12))\n    # Linear deterministic bias\n    bias = 1e-9 * np.arange(len(bins))\n    score += bias\n    score = np.where(slack < 0, -np.inf, score)\n    return score\n\n",
  "capacity_normalized_best_fit_aug_42": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    denom = np.maximum(bins, 1e-12)\n    frac = slack / denom\n    max_frac = np.max(frac)\n    # Normalise by the maximum fraction and clip to avoid extreme values\n    score = -(frac / (max_frac + 1e-12))\n    score = np.clip(score, -1.0, 0.0)\n    score = np.where(slack < 0, -np.inf, score)\n    return score\n\n",
  "prefer_exact_fit_bonus_aug_43": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n\n    # Slack (remaining space) clipped to avoid extreme values\n    slack = np.clip(bins - float(item), -1e6, 1e6)\n\n    # Base score: larger slack \u2192 lower score\n    score = -slack\n    score = np.where(slack < 0, -np.inf, score)\n\n    # Bonus for exact or near\u2011exact fit\n    tol = 1e-9\n    exact_bonus = np.where(np.abs(slack) <= tol, 1e6, 0.0)\n\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(len(bins))\n\n    return score + exact_bonus + noise\n\n",
  "prefer_exact_fit_bonus_aug_44": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n\n    slack = np.clip(bins - float(item), -1e6, 1e6)\n\n    # Raw score: negative slack, huge bonus for exact fit\n    raw = -slack\n    raw = np.where(slack < 0, -np.inf, raw)\n    tol = 1e-9\n    raw += np.where(np.abs(slack) <= tol, 1e6, 0.0)\n\n    # Softmax transformation (numerically stable)\n    exp_raw = np.exp(raw - np.max(raw))\n    denom = np.sum(exp_raw) + 1e-12  # epsilon to avoid division by zero\n    return exp_raw / denom\n\n",
  "prefer_exact_fit_bonus_aug_45": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n\n    slack = np.clip(bins - float(item), -1e6, 1e6)\n\n    # Base penalty\n    base = -slack\n    base = np.where(slack < 0, -np.inf, base)\n\n    # Identify the k best fits (smallest slack)\n    k = 3\n    idx = np.argsort(slack)\n    bonus = np.zeros_like(bins)\n    bonus[idx[:k]] = 5e5  # bonus for top\u2011k bins\n\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(len(bins))\n\n    return base + bonus + noise\n\n",
  "prefer_exact_fit_bonus_aug_46": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n\n    slack = np.clip(bins - float(item), -1e3, 1e3)\n\n    # Diminishing penalty: larger slack \u2192 smaller absolute value\n    denom = 1.0 + np.abs(slack) + 1e-12  # epsilon to avoid division by zero\n    score = -slack / denom\n\n    score = np.where(slack < 0, -np.inf, score)\n\n    # Bonus for exact or near\u2011exact fit\n    tol = 1e-9\n    score += np.where(np.abs(slack) <= tol, 1e6, 0.0)\n\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(len(bins))\n\n    return score + noise\n\n",
  "large_item_roomy_small_item_tight_aug_47": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack_arr = bins_arr - item_val\n    # Ensure slack is never negative\n    slack_arr = np.clip(slack_arr, 0, None)\n\n    score_arr = np.full_like(bins_arr, -np.inf, dtype=float)\n    feasible_mask = slack_arr >= 0\n\n    if np.any(feasible_mask):\n        cap_ref = np.nanmax(bins_arr[feasible_mask]) + 1e-12\n        big_item = item_val >= 0.6 * cap_ref\n        # Deterministic tie\u2011breaking noise\n        noise = np.arange(len(bins_arr)) * 1e-9\n        if big_item:\n            score_arr[feasible_mask] = slack_arr[feasible_mask] + noise[feasible_mask]\n        else:\n            score_arr[feasible_mask] = -slack_arr[feasible_mask] + noise[feasible_mask]\n    return score_arr\n\n",
  "large_item_roomy_small_item_tight_aug_48": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack_arr = bins_arr - item_val\n    score_arr = np.full_like(bins_arr, -np.inf, dtype=float)\n    feasible_mask = slack_arr >= 0\n\n    if np.any(feasible_mask):\n        cap_ref = np.nanmax(bins_arr[feasible_mask]) + 1e-12\n        big_item = item_val >= 0.7 * cap_ref\n        # Scale slack differently for large vs small items\n        if big_item:\n            score_arr[feasible_mask] = 1.2 * slack_arr[feasible_mask]\n        else:\n            score_arr[feasible_mask] = -0.8 * slack_arr[feasible_mask]\n        # Clip scores to avoid extreme values\n        max_val = np.nanmax(np.abs(score_arr[feasible_mask]))\n        score_arr[feasible_mask] = np.clip(score_arr[feasible_mask], -max_val, max_val)\n    return score_arr\n\n",
  "large_item_roomy_small_item_tight_aug_49": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack_arr = bins_arr - item_val\n    score_arr = np.full_like(bins_arr, -np.inf, dtype=float)\n    feasible_mask = slack_arr >= 0\n\n    if np.any(feasible_mask):\n        # Soft\u2011min weighting with a small temperature\n        temp = 0.5\n        weights = np.exp(-slack_arr[feasible_mask] / (temp + 1e-12))\n        weights = np.clip(weights, 0, 1e6)\n        probs = weights / (np.sum(weights) + 1e-12)\n        score_arr[feasible_mask] = probs\n        # Add deterministic noise for tie\u2011breaking\n        noise = np.linspace(0, 1e-8, len(bins_arr))\n        score_arr[feasible_mask] += noise[feasible_mask]\n    return score_arr\n\n",
  "large_item_roomy_small_item_tight_aug_50": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_vec = np.asarray(bins, dtype=float)\n    item_float = float(item)\n\n    n = bins_vec.size\n    score_vec = np.full(n, -np.inf, dtype=float)\n    idx = 0\n    while idx < n:\n        slack = bins_vec[idx] - item_float\n        if slack >= 0:\n            cap_ref = np.nanmax(bins_vec) + 1e-12\n            if item_float >= 0.5 * cap_ref:\n                score_vec[idx] = slack\n            else:\n                score_vec[idx] = -slack\n        idx += 1\n\n    # Deterministic noise with a fixed RNG seed\n    rng = np.random.default_rng(42)\n    noise = rng.random(n) * 1e-9\n    score_vec += noise\n\n    # Clip to avoid extreme values\n    score_vec = np.clip(score_vec, -1e6, 1e6)\n    return score_vec\n\n",
  "quantile_target_slack_25_aug_51": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    EPS = 1e-12\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Initialize all scores to -inf\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    # Identify feasible bins\n    feasible = slack >= 0\n    if feasible.any():\n        # Target is the mean slack of feasible bins\n        target = np.mean(slack[feasible]) + EPS\n        # Deterministic noise for tie\u2011breaking\n        noise = 1e-6 * np.arange(len(bins))\n        # Compute absolute deviation from the target\n        diff = np.abs(slack[feasible] - target)\n        score[feasible] = -diff + noise[feasible]\n    return score\n\n",
  "quantile_target_slack_25_aug_52": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    EPS = 1e-12\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        # Median of feasible slacks\n        target = np.quantile(slack[feasible], 0.5)\n        # Normalized deviation (soft\u2011min)\n        dev = np.abs(slack[feasible] - target)\n        norm = np.max(dev) + EPS\n        score[feasible] = -dev / norm\n        # Add small noise for deterministic tie\u2011breaking\n        score[feasible] += 1e-8 * np.arange(np.sum(feasible))\n        # Clip to a reasonable range\n        score = np.clip(score, -1.0, 0.0)\n    return score\n\n",
  "quantile_target_slack_25_aug_53": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    EPS = 1e-12\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        # Target is the maximum feasible slack\n        target = np.max(slack[feasible]) + EPS\n        # Deterministic noise\n        noise = 1e-6 * np.arange(len(bins))\n        diff = np.abs(slack[feasible] - target)\n        score[feasible] = -diff + noise[feasible]\n    return score\n\n",
  "quantile_target_slack_25_aug_54": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    EPS = 1e-12\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        # Use the 75th percentile as target\n        target = np.quantile(slack[feasible], 0.75)\n        diff = np.abs(slack[feasible] - target)\n        # Select top\u2011k (k = 3) bins with smallest deviation\n        k = min(3, np.sum(feasible))\n        top_k_idx = np.argpartition(diff, k-1)[:k]\n        # Assign scores only to top\u2011k bins\n        idx = np.nonzero(feasible)[0]\n        selected = idx[top_k_idx]\n        score[selected] = -diff[top_k_idx]\n        # Add deterministic noise for tie\u2011breaking\n        score[selected] += 1e-8 * np.arange(k)\n    return score\n\n",
  "zscore_tightness_aug_55": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    # Slack cannot be negative for feasible bins\n    slack = np.clip(bins - item, a_min=0, a_max=None)\n\n    # Initialise all scores as -inf (unfeasible)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack > 0\n    if np.any(feasible):\n        s = slack[feasible]\n        med = np.median(s)\n        mad = np.median(np.abs(s - med)) + 1e-12\n        # Small deterministic noise to break ties\n        noise = np.arange(len(bins)) * 1e-6\n        score[feasible] = -(s - med) / mad + noise[feasible]\n\n    return score\n\n",
  "zscore_tightness_aug_56": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n\n    # Compute slack for each bin\n    slack_list = [b - item for b in bins]\n    # Build score list with -inf for infeasible bins\n    scores = [-np.inf if s < 0 else s for s in slack_list]\n\n    feasible_slack = [s for s in slack_list if s >= 0]\n    if feasible_slack:\n        # Adjusted mean (weighting) and spread\n        mu = np.mean(feasible_slack) * 0.8\n        sigma = np.std(feasible_slack) + 1e-12\n        for i, s in enumerate(scores):\n            if s != -np.inf:\n                scores[i] = -(s - mu) / (sigma * 0.9)\n\n    scores = np.array(scores)\n    # Deterministic noise for tie\u2011breaking\n    scores += np.arange(len(bins)) * 1e-7\n    # Clip to keep values within a reasonable range\n    scores = np.clip(scores, -1e6, 0)\n\n    return scores\n\n",
  "zscore_tightness_aug_57": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    feasible = slack >= 0\n\n    # Initialise all scores as -inf\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n        # Soft\u2011min probability (larger slack \u2192 smaller probability)\n        exp_vals = np.exp(-s / 0.5)\n        denom = np.sum(exp_vals) + 1e-12\n        probs = exp_vals / denom\n        score[feasible] = -np.log(probs + 1e-12)\n\n    # Deterministic noise for tie\u2011breaking\n    score += np.arange(len(bins)) * 1e-8\n\n    return score\n\n",
  "zscore_tightness_aug_58": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = np.clip(bins - item, 0, None)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack > 0\n    if np.any(feasible):\n        s = slack[feasible]\n        max_slack = np.max(s) + 1e-12\n        sigma = np.std(s) + 1e-12\n        # Score relative to the maximum slack, with a larger spread factor\n        score[feasible] = -(s - max_slack) / (sigma * 1.5)\n\n    # Linear deterministic noise\n    score += np.linspace(0, 1e-6, len(bins))\n    # Clip to avoid extreme values\n    score = np.clip(score, -1e5, 0)\n\n    return score\n\n",
  "guard_band_slack_aug_59": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    remaining = capacities - float(item)\n\n    # initialise infeasible bins with -inf\n    scores = np.full_like(capacities, -np.inf, dtype=float)\n\n    feasible = remaining >= 0\n    if np.any(feasible):\n        # reference capacity (largest feasible bin)\n        cap_ref = np.nanmax(capacities[feasible]) + 1e-12\n\n        low  = 0.02 * cap_ref\n        high = 0.35 * cap_ref\n        mid  = 0.5 * (low + high)\n\n        # main score: closer to mid is better, larger slack is slightly penalised\n        scores[feasible] = -np.abs(remaining[feasible] - mid) - 0.2 * remaining[feasible]\n\n        # extra penalties for very small or very large slack\n        scores[(remaining >= 0) & (remaining < low)]  -= cap_ref\n        scores[(remaining > high)]                     -= 0.3 * cap_ref\n\n    # deterministic tie\u2011breaking: small increasing offset\n    scores += 1e-6 * np.arange(len(scores))\n\n    # clip to avoid extreme values\n    scores = np.clip(scores, -1e9, 1e9)\n    return scores\n\n",
  "guard_band_slack_aug_60": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps   = np.asarray(bins, dtype=float)\n    rem    = caps - float(item)\n\n    # start with -inf for infeasible bins\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feas = rem >= 0\n    if np.any(feas):\n        cap_ref = np.nanmax(caps[feas]) + 1e-12\n\n        low  = 0.03 * cap_ref\n        high = 0.40 * cap_ref\n        mid  = 0.5 * (low + high)\n\n        # clip slack to avoid extreme values\n        rem_clip = np.clip(rem, 0, cap_ref)\n\n        # use median slack as a softer reference\n        median_slack = np.median(rem_clip[feas])\n\n        # scoring: closer to median is better, slight penalty for larger slack\n        score[feas] = -np.abs(rem_clip[feas] - median_slack) - 0.05 * rem_clip[feas]\n\n        # additional penalties\n        score[(rem >= 0) & (rem < low)]  -= cap_ref\n        score[(rem > high)]              -= 0.2 * cap_ref\n\n    # deterministic noise for tie\u2011breaking\n    score += 1e-7 * np.arange(len(score))\n    return score\n\n",
  "guard_band_slack_aug_61": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    rem  = caps - float(item)\n\n    n = caps.size\n    scores = np.full(n, -np.inf, dtype=float)\n\n    idx = 0\n    while idx < n:\n        if rem[idx] >= 0:\n            # local feasible capacities up to current index\n            feasible_caps = caps[:idx+1][rem[:idx+1] >= 0]\n            cap_ref = np.nanmax(feasible_caps) + 1e-12 if feasible_caps.size > 0 else 1e-12\n\n            low  = 0.015 * cap_ref\n            high = 0.30 * cap_ref\n            mid  = 0.5 * (low + high)\n\n            scores[idx] = -np.abs(rem[idx] - mid) - 0.15 * rem[idx]\n            if rem[idx] < low:\n                scores[idx] -= cap_ref\n            if rem[idx] > high:\n                scores[idx] -= 0.25 * cap_ref\n        idx += 1\n\n    # deterministic offset for tie\u2011breaking\n    scores += 5e-7 * np.arange(n)\n\n    # clip to prevent overflow\n    scores = np.clip(scores, -1e10, 1e10)\n    return scores\n\n",
  "guard_band_slack_aug_62": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    rem  = caps - float(item)\n\n    scores = np.full_like(caps, -np.inf, dtype=float)\n\n    feas = rem >= 0\n    if np.any(feas):\n        cap_ref = np.nanmax(caps[feas]) + 1e-12\n\n        low  = 0.025 * cap_ref\n        high = 0.38 * cap_ref\n        mid  = 0.5 * (low + high)\n\n        # scale for softmin; ensure no division by zero\n        scale = 0.05 * cap_ref + 1e-12\n\n        # compute soft penalty using log\u2011sum\u2011exp trick\n        diff = (rem[feas] - mid) / scale\n        diff = np.clip(diff, -50, 50)           # avoid overflow in exp\n        soft = -np.log1p(np.exp(diff))\n\n        scores[feas] = soft - 0.08 * rem[feas]\n        scores[(rem >= 0) & (rem < low)]  -= cap_ref\n        scores[(rem > high)]              -= 0.2 * cap_ref\n\n    # deterministic tie\u2011breaking\n    scores += 2e-6 * np.arange(len(scores))\n    return scores\n\n",
  "spread_remaining_capacities_aug_63": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    # Ensure slack is non\u2011negative; clip to avoid negative values\n    slack = np.clip(slack, 0, np.inf)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack > 0\n\n    if np.any(feasible):\n        # Median\u2011based spread metric\n        mu = np.median(slack[feasible]) + 1e-12\n        # Deterministic noise proportional to index\n        noise = np.arange(len(bins)) * 1e-6\n        score[feasible] = (\n            np.abs(slack[feasible] - mu) * 0.9\n            - 0.03 * slack[feasible]\n            + noise[feasible]\n        )\n    return score\n\n",
  "spread_remaining_capacities_aug_64": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    slack = np.clip(slack, 0, np.inf)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack > 0\n\n    if np.any(feasible):\n        # Soft\u2011min: larger slack \u2192 smaller score\n        temp = np.exp(-slack[feasible] / (0.05 + 1e-12))\n        score[feasible] = -np.log(temp + 1e-12)\n    return score\n\n",
  "spread_remaining_capacities_aug_65": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    slack = np.clip(slack, 0, np.inf)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack > 0\n\n    if np.any(feasible):\n        mu = np.median(slack[feasible]) + 1e-12\n        score[feasible] = (\n            np.abs(slack[feasible] - mu) * 0.8\n            - 0.04 * slack[feasible]\n        )\n\n    # Deterministic random noise for tie\u2011breaking\n    rng = np.random.default_rng(123)\n    noise = rng.uniform(-1e-6, 1e-6, size=bins.shape)\n    score += noise\n    return score\n\n",
  "spread_remaining_capacities_aug_66": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    slack = np.clip(slack, 0, np.inf)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack > 0\n\n    if np.any(feasible):\n        total = np.sum(slack[feasible]) + 1e-12\n        ratio = slack[feasible] / total\n        ratio = np.clip(ratio, 0, 1)\n        score[feasible] = ratio * 0.7 - 0.02 * slack[feasible]\n    return score\n\n",
  "temperature_scaled_tightness_aug_67": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    req = float(item)\n    avail = np.asarray(bins, dtype=float)\n    slack = avail - req\n    score = np.full_like(avail, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Standard deviation of slack with a tiny epsilon to avoid division by zero\n        temp = np.std(slack[feasible]) + 1e-12\n        score[feasible] = -slack[feasible] / temp\n\n    # Ensure no values fall outside a reasonable range\n    return np.clip(score, -1e6, 0.0)\n\n",
  "temperature_scaled_tightness_aug_68": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    req = float(item)\n    avail = np.asarray(bins, dtype=float)\n    slack = avail - req\n    score = np.full_like(avail, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Mean of feasible slack, epsilon added\n        temp = np.mean(slack[feasible]) + 1e-12\n        score[feasible] = -slack[feasible] / temp\n\n    # Add a tiny deterministic noise to break ties\n    noise = np.arange(len(avail)) * 1e-6\n    score += noise\n\n    # Clip to keep values bounded\n    return np.clip(score, -1e6, 0.0)\n\n",
  "temperature_scaled_tightness_aug_69": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    req = float(item)\n    avail = np.asarray(bins, dtype=float)\n    slack = avail - req\n    score = np.full_like(avail, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Use the maximum feasible slack as the temperature\n        temp = np.max(slack[feasible]) + 1e-12\n        # Compute raw scores\n        raw = -slack[feasible] / temp\n        # Keep only the top 3 bins with the best (least negative) scores\n        top_k = 3\n        if len(raw) > top_k:\n            idx_top = np.argpartition(raw, -top_k)[-top_k:]\n            mask = np.zeros_like(feasible, dtype=bool)\n            mask[feasible] = False\n            mask[np.where(feasible)[0][idx_top]] = True\n            score[mask] = raw[idx_top]\n        else:\n            score[feasible] = raw\n\n    # Clip to avoid extreme values\n    return np.clip(score, -1e6, 0.0)\n\n",
  "temperature_scaled_tightness_aug_70": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    req = float(item)\n    avail = np.asarray(bins, dtype=float)\n    slack = avail - req\n    score = np.full_like(avail, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Median of feasible slack with epsilon\n        temp = np.median(slack[feasible]) + 1e-12\n        score[feasible] = -slack[feasible] / temp\n\n    # Clip to a safe range\n    return np.clip(score, -1e6, 0.0)\n\n",
  "harmonic_tight_and_not_too_small_aug_71": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    value = float(item)\n\n    # slack must be non\u2011negative\n    slack = np.clip(capacities - value, a_min=0.0, a_max=None)\n\n    # initialise all scores as -inf\n    scores = np.full_like(capacities, -np.inf, dtype=float)\n\n    feasible = slack > 0\n    if np.any(feasible):\n        a = slack[feasible] + 1e-12\n        b = 1.0 / (capacities[feasible] + 1e-12)\n        scores[feasible] = 2.0 / (a + b)\n\n    # deterministic noise for tie\u2011breaking (no random state)\n    noise = np.sin(value * 12345.6789 + capacities) * 1e-6\n    return scores + noise\n\n",
  "harmonic_tight_and_not_too_small_aug_72": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    value = float(item)\n    n = caps.size\n    scores = np.full(n, -np.inf, dtype=float)\n\n    idx = 0\n    while idx < n:\n        slack = caps[idx] - value\n        # only consider bins with slack above a small threshold\n        if slack > 0.2:\n            denom = (slack + 1e-12) * (caps[idx] + 1e-12)\n            scores[idx] = 1.0 / denom\n        idx += 1\n\n    # deterministic noise based on the index\n    noise = (value + np.arange(n)) * 1e-7\n    return scores + noise\n\n",
  "harmonic_tight_and_not_too_small_aug_73": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    spaces = np.asarray(bins, dtype=float)\n    val = float(item)\n\n    # ensure slack is non\u2011negative\n    slack = np.clip(spaces - val, a_min=0.0, a_max=None)\n\n    scores = np.full_like(spaces, -np.inf, dtype=float)\n    feasible = slack > 0\n    if np.any(feasible):\n        # avoid division by zero in the inverse capacity term\n        denom = np.clip(spaces[feasible], a_min=1e-12, a_max=None)\n        scores[feasible] = np.maximum(slack[feasible], 1.0 / denom)\n\n    # deterministic tie\u2011breaking noise\n    noise = np.cos(val * 9876.5432 + spaces) * 1e-6\n    return scores + noise\n\n",
  "small_items_best_large_items_worst_aug_74": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    # Available slack in each bin\n    slack = bins_arr - item_val\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    # Which bins can accommodate the item?\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Reference capacity (largest feasible bin)\n        max_cap = np.max(bins_arr[feasible]) + 1e-12\n\n        # Decide strategy based on item size\n        large = item_val >= 0.5 * max_cap\n        # Small items: best\u2011fit \u2192 minimise slack\n        # Large items: worst\u2011fit \u2192 maximise slack\n        score[feasible] = np.where(\n            large,\n            slack[feasible],          # maximise slack\n            -slack[feasible]          # minimise slack\n        )\n\n        # Small deterministic noise to break ties\n        noise = np.arange(len(score)) * 1e-9\n        score += noise\n\n    return score\n\n",
  "small_items_best_large_items_worst_aug_75": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack = bins_arr - item_val\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Use the median bin as a reference to avoid extreme outliers\n        ref_cap = np.median(bins_arr[feasible]) + 1e-12\n        large = item_val >= 0.6 * ref_cap   # stricter threshold\n\n        # Apply tunable weights\n        weight_big   = 1.3\n        weight_small = 0.7\n        score[feasible] = np.where(\n            large,\n            slack[feasible] * weight_big,\n            -slack[feasible] * weight_small\n        )\n\n        # Clip scores to a reasonable range\n        score = np.clip(score, -1.0, 1.0)\n\n        # Add deterministic noise for tie\u2011breaking\n        noise = np.linspace(-1e-8, 1e-8, len(score))\n        score += noise\n\n    return score\n\n",
  "small_items_best_large_items_worst_aug_76": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack = bins_arr - item_val\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Reference capacity for scaling\n        max_cap = np.max(bins_arr[feasible]) + 1e-12\n        large = item_val >= 0.5 * max_cap\n\n        # Temperature controls softness\n        temp = 0.5\n        # Small items: prefer tight fits (small slack) \u2192 use exp(-slack/temp)\n        # Large items: prefer loose fits (large slack) \u2192 use exp(+slack/temp)\n        exp_factor = np.exp(np.where(large, slack, -slack) / temp)\n        # Avoid overflow with clipping\n        exp_factor = np.clip(exp_factor, 0, 1e12)\n\n        score[feasible] = exp_factor[feasible]\n\n        # Small deterministic noise to avoid exact ties\n        noise = np.arange(len(score)) * 1e-10\n        score += noise\n\n    return score\n\n",
  "small_items_best_large_items_worst_aug_77": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack = bins_arr - item_val\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Use the maximum feasible bin as a reference to keep ratios in [0,1]\n        max_ref = np.max(bins_arr[feasible]) + 1e-12\n        large = item_val >= 0.4 * max_ref\n\n        # Compute ratio of slack to reference\n        ratio = slack / max_ref\n        # Clip ratio to avoid invalid values\n        ratio = np.clip(ratio, 0, 1)\n\n        # Small items: prefer tight fits \u2192 lower ratio is better\n        # Large items: prefer loose fits \u2192 higher ratio is better\n        score[feasible] = np.where(large, ratio[feasible], 1 - ratio[feasible])\n\n        # Add deterministic noise for tie\u2011breaking\n        noise = np.linspace(-5e-9, 5e-9, len(score))\n        score += noise\n\n    return score\n\n",
  "capacity_near_small_integer_multiple_of_item_aug_78": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    weight = float(item)\n    slack = capacities - weight\n    scores = np.full_like(capacities, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if np.any(feasible):\n        k = np.clip(np.round(capacities / max(weight, 1e-12)), 1, 5)\n        target = k * weight\n        scores[feasible] = -np.abs(capacities[feasible] - target[feasible]) - 0.04 * slack[feasible]\n    return scores\n\n",
  "capacity_near_small_integer_multiple_of_item_aug_79": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    wt = float(item)\n    slack = caps - wt\n    scores = np.full_like(caps, -np.inf, dtype=float)\n    feasible = slack >= 0\n    rng = np.random.default_rng(0)\n    if np.any(feasible):\n        k = np.clip(np.round(caps / max(wt, 1e-12)), 1, 5)\n        target = k * wt\n        base = -np.abs(caps[feasible] - target[feasible]) - 0.08 * slack[feasible]\n        noise = rng.uniform(-1e-6, 1e-6, size=feasible.sum())\n        scores[feasible] = base + noise\n    return scores\n\n",
  "capacity_near_small_integer_multiple_of_item_aug_80": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    wt = float(item)\n    slack = caps - wt\n    scores = np.full_like(caps, -np.inf, dtype=float)\n    feasible = slack >= 0\n    rng = np.random.default_rng(42)\n    if np.any(feasible):\n        k = np.clip(np.round(caps / max(wt, 1e-12)), 1, 5)\n        target = k * wt\n        base = -np.square(caps[feasible] - target[feasible]) - 0.06 * slack[feasible]\n        idx = np.argsort(base)[:3]  # pick the three best candidates\n        noise = rng.uniform(-1e-6, 1e-6, size=feasible.sum())\n        base[idx] += noise[idx]\n        scores[feasible] = base\n    return scores\n\n",
  "capacity_near_small_integer_multiple_of_item_aug_81": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    wt = float(item)\n    slack = caps - wt\n    scores = np.full_like(caps, -np.inf, dtype=float)\n    feasible = slack >= 0\n    rng = np.random.default_rng(1)\n    if np.any(feasible):\n        denom = max(wt, 1e-12)\n        k = np.clip(np.round(caps / denom), 1, 5)\n        target = k * wt\n        base = -np.square(caps[feasible] - target[feasible]) - 0.03 * slack[feasible]\n        noise = rng.uniform(-1e-6, 1e-6, size=feasible.sum())\n        scores[feasible] = base + noise\n    return scores\n\n",
  "penalize_too_small_gap_relative_item_aug_82": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    # Vectorised slack computation\n    slack = bins - item\n    # Invert logic: invalid bins become -inf\n    score = -slack\n    score[slack < 0] = -np.inf\n\n    # Small gap penalty (linear)\n    small_gap = (slack >= 0) & (slack < 0.25 * item)\n    penalty = 5.0 * (0.25 * item - slack[small_gap])\n    score[small_gap] -= penalty\n\n    # Deterministic tie\u2011breaking noise\n    rng = np.random.default_rng(42)\n    noise = rng.normal(loc=0.0, scale=1e-6, size=bins.shape)\n    score += noise\n\n    # Clip to avoid extreme values\n    score = np.clip(score, -1e6, 1e6)\n    return score\n\n",
  "penalize_too_small_gap_relative_item_aug_83": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    slack = bins - item\n    # Clip slack to avoid negative values before penalty\n    slack_clipped = np.clip(slack, 0, None)\n\n    # Base score\n    score = -slack_clipped\n    score[slack < 0] = -np.inf\n\n    # Quadratic penalty for gaps < item/4\n    small_gap = slack_clipped < 0.25 * item\n    penalty = 20.0 * np.square(0.25 * item - slack_clipped[small_gap])\n    score[small_gap] -= penalty\n\n    # Add deterministic noise\n    rng = np.random.default_rng(7)\n    noise = rng.normal(scale=5e-7, size=bins.shape)\n    score += noise\n\n    # Clip final scores\n    score = np.clip(score, -5e5, 5e5)\n    return score\n\n",
  "penalize_too_small_gap_relative_item_aug_84": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    slack = bins - item\n    # Ensure slack is non\u2011negative for log1p\n    slack_pos = np.clip(slack, 0, None)\n\n    # Log\u2011based score: larger slack \u2192 smaller score\n    score = -np.log1p(slack_pos + 1e-12)\n\n    # Invalidate bins that cannot fit\n    score[slack < 0] = -np.inf\n\n    # Add tiny noise for deterministic tie\u2011breaking\n    rng = np.random.default_rng(2023)\n    noise = rng.normal(scale=2e-6, size=bins.shape)\n    score += noise\n\n    # Clip to keep values within a safe range\n    score = np.clip(score, -1e4, 1e4)\n    return score\n\n",
  "worst_fit_with_big_gap_penalty_aug_85": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Feasibility mask\n    feasible = slack >= 0\n    # Start with raw slack as the score\n    score = np.where(feasible, slack, -np.inf)\n\n    # Penalize bins with slack above the 75th percentile\n    if np.any(feasible):\n        hi = np.quantile(slack[feasible], 0.75)\n        mask = slack > hi\n        # Penalty factor with epsilon to avoid division by zero\n        penalty = (slack[mask] - hi) / (hi + 1e-12)\n        score[mask] -= penalty * 1.2  # heavier penalty\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(score)) * 1e-6\n    score += noise\n\n    # Clip to avoid extreme values\n    score = np.clip(score, -1e9, 1e9)\n    return score\n\n",
  "worst_fit_with_big_gap_penalty_aug_86": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    feasible = slack >= 0\n    score = np.where(feasible, slack, -np.inf)\n\n    if np.any(feasible):\n        # Use the median of feasible slack as the threshold\n        hi = np.median(slack[feasible])\n        mask = slack > hi\n        penalty = (slack[mask] - hi) / (hi + 1e-12)\n        score[mask] -= penalty * 1.0\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(score)) * 1e-6\n    score += noise\n\n    # Clip to safe bounds\n    score = np.clip(score, -1e9, 1e9)\n    return score\n\n",
  "worst_fit_with_big_gap_penalty_aug_87": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    n = bins.size\n    score = np.full(n, -np.inf, dtype=float)\n\n    # Compute slack using a while loop\n    i = 0\n    while i < n:\n        slack_val = bins[i] - float(item)\n        if slack_val >= 0:\n            # Use squared slack as part of the score\n            score[i] = np.square(slack_val)\n        i += 1\n\n    feasible = score >= 0\n    if np.any(feasible):\n        hi = np.quantile(score[feasible], 0.80)\n        mask = score > hi\n        penalty = (score[mask] - hi) / (hi + 1e-12)\n        score[mask] -= penalty * 1.5\n\n    # Random tie\u2011breaking among the top\u20115 bins\n    if np.any(feasible):\n        top_k = min(5, np.count_nonzero(feasible))\n        top_indices = np.argpartition(score, -top_k)[-top_k:]\n        rand_noise = np.random.uniform(0, 1e-5, size=top_k)\n        score[top_indices] += rand_noise\n\n    # Clip to avoid extreme values\n    score = np.clip(score, -1e9, 1e9)\n    return score\n\n",
  "worst_fit_with_big_gap_penalty_aug_88": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    feasible = slack >= 0\n    score = np.where(feasible, slack, -np.inf)\n\n    if np.any(feasible):\n        # Approximate the 80th percentile by sorting\n        sorted_slack = np.sort(slack[feasible])\n        idx = int(np.floor(0.80 * len(sorted_slack)))\n        hi = sorted_slack[idx] if idx < len(sorted_slack) else sorted_slack[-1]\n        mask = slack > hi\n        penalty = (slack[mask] - hi) / (hi + 1e-12)\n        score[mask] -= penalty * 1.1\n\n    # Softmax weighting: higher slack gets higher weight\n    exp_scores = np.exp(-score / (1.0 + 1e-12))\n    softmax = exp_scores / (np.sum(exp_scores) + 1e-12)\n    score = score - softmax * 0.5\n\n    # Random tie\u2011breaking among the top\u20113 bins\n    if np.any(feasible):\n        top_k = min(3, np.count_nonzero(feasible))\n        top_indices = np.argpartition(score, -top_k)[-top_k:]\n        rand_noise = np.random.uniform(0, 1e-5, size=top_k)\n        score[top_indices] += rand_noise\n\n    # Clip to safe bounds\n    score = np.clip(score, -1e9, 1e9)\n    return score\n\n",
  "rank_best_fit_aug_89": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    slack = capacities - float(item)\n\n    # Higher score for tighter slack; infeasible bins get -inf\n    scores = np.full_like(capacities, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        # Small deterministic noise to break ties\n        noise = 1e-6 * np.arange(capacities.size)\n        s = slack[feasible] + noise[feasible]\n\n        order = np.argsort(s)                     # ascending slack\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n        scores[feasible] = -ranks                # tighter gets higher score\n\n    return scores\n\n",
  "rank_best_fit_aug_90": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    slack = capacities - float(item)\n\n    eps = 1e-12\n    scores = np.full_like(capacities, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        # Add deterministic noise to avoid exact ties\n        noise = 1e-6 * np.arange(capacities.size)\n        s = slack[feasible] + noise[feasible]\n        s = np.clip(s, eps, np.inf)              # prevent division by zero\n        scores[feasible] = -1.0 / s              # tighter slack \u2192 higher score\n\n    return scores\n\n",
  "rank_best_fit_aug_91": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    slack = capacities - float(item)\n\n    scores = np.full_like(capacities, -np.inf, dtype=float)\n    feasible_idx = np.where(slack >= 0)[0]\n    n = feasible_idx.size\n    if n == 0:\n        return scores\n\n    # Deterministic noise to break ties\n    noise = 1e-6 * np.arange(capacities.size)\n    slack_noisy = slack + noise\n\n    # Extract feasible slack values\n    feas_slack = slack_noisy[feasible_idx]\n\n    # In\u2011place selection sort (while loop) to order by ascending slack\n    i = 0\n    while i < n:\n        min_pos = i\n        min_val = feas_slack[i]\n        j = i + 1\n        while j < n:\n            if feas_slack[j] < min_val:\n                min_val = feas_slack[j]\n                min_pos = j\n            j += 1\n        # Swap the minimum element to position i\n        feas_slack[[i, min_pos]] = feas_slack[[min_pos, i]]\n        feasible_idx[[i, min_pos]] = feasible_idx[[min_pos, i]]\n        i += 1\n\n    # Assign scores: tightest (first) gets 0, next gets -1, etc.\n    for pos, idx in enumerate(feasible_idx):\n        scores[idx] = -pos\n\n    return scores\n\n",
  "rank_best_fit_aug_92": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    slack = capacities - float(item)\n\n    eps = 1e-12\n    scale = 1.0\n    scores = np.full_like(capacities, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        # Deterministic noise to break ties before weighting\n        noise = 1e-6 * np.arange(capacities.size)\n        s = slack[feasible] + noise[feasible]\n\n        # Soft\u2011max style weights (tighter slack \u2192 larger weight)\n        w = np.exp(-s / (scale + eps))\n        w = np.clip(w, 0, 1)                       # bound weights\n\n        # Select top\u2011k bins\n        k = 5\n        if k > w.size:\n            k = w.size\n        sorted_idx = np.argsort(-w)[:k]            # indices of top\u2011k weights\n        top_weights = w[sorted_idx]\n\n        # Map back to original indices and assign log\u2011weight scores\n        idxs = np.where(feasible)[0]\n        scores[idxs[sorted_idx]] = np.log(top_weights + eps)\n\n    return scores\n\n",
  "rank_worst_fit_aug_93": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    n = bins.size\n    score = np.full(n, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    idx = np.where(feasible)[0]\n\n    # Rank each feasible bin by counting how many feasible bins have\n    # a larger slack value.  The highest slack receives rank 0.\n    i = 0\n    while i < idx.size:\n        cur = idx[i]\n        higher = np.sum(slack[idx] > slack[cur])\n        rank = higher                      # 0 for the loosest bin\n        # Use a division that never hits zero \u2013 add a tiny epsilon.\n        score[cur] = - (rank + 1) / (n + 1e-12)\n        i += 1\n\n    return score\n\n",
  "rank_worst_fit_aug_94": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    # Ensure no negative values are used for weighting.\n    slack = np.clip(bins - float(item), 0, np.inf)\n\n    n = bins.size\n    score = np.full(n, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        # Weighted combination of slack and its median\n        weighted = 0.6 * s + 0.4 * np.median(s)\n        # Determine ranks (0 for highest weighted value)\n        ranks = np.argsort(-weighted)\n        # Normalise ranks to avoid large negative numbers\n        denom = len(s) + 1e-12\n        score[feasible] = - (ranks + 1) / denom\n        # Deterministic tie\u2011breaking noise\n        noise = np.sin(item) * 1e-6\n        score[feasible] += noise\n\n    return score\n\n",
  "rank_worst_fit_aug_95": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = np.clip(bins - float(item), 0, np.inf)\n\n    # Avoid division by zero in the temperature term\n    max_slack = np.max(slack) + 1e-12\n    exp_term = np.exp(-slack / max_slack)\n    # Clip exponentials to keep them within a reasonable range\n    exp_term = np.clip(exp_term, 1e-12, 1.0)\n\n    score = -exp_term\n\n    # Deterministic noise for ties\n    noise = np.sin(item + np.arange(slack.size)) * 1e-6\n    score += noise\n\n    # Infeasible bins keep the -inf sentinel\n    score[slack < 0] = -np.inf\n\n    return score\n\n",
  "rank_worst_fit_aug_96": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    n = bins.size\n    score = np.full(n, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if feasible.any():\n        median_slack = np.median(slack[feasible])\n        diff = slack[feasible] - median_slack\n        # Normalise by the maximum difference; epsilon guards against zero.\n        max_diff = np.max(diff) + 1e-12\n        score[feasible] = - (diff / max_diff)\n        # Deterministic tie\u2011breaking noise\n        score[feasible] += np.cos(item) * 1e-7\n\n    return score\n\n",
  "best_fit_with_deterministic_jitter_aug_97": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    # Compute slack and clip to avoid negative values\n    slack = np.clip(bins - item, a_min=0.0, a_max=None)\n\n    # Base score: the less slack the better\n    score = -slack\n\n    # Deterministic jitter using a sine wave\n    idx = np.arange(bins.size, dtype=float)\n    jitter = np.sin((idx + 1.0) * (item + 1.234567)) * 1e-6\n    jitter = np.clip(jitter, -1e-6, 1e-6)          # keep jitter bounded\n\n    # Add jitter only to feasible bins\n    score += jitter\n\n    # Mark infeasible bins with -inf\n    score[bins < item] = -np.inf\n\n    return score\n\n",
  "best_fit_with_deterministic_jitter_aug_98": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    n = bins.size\n    score = np.full(n, -np.inf, dtype=float)\n    i = 0\n    while i < n:\n        slack = bins[i] - item\n        if slack >= 0:\n            # Small jitter; epsilon prevents division by zero\n            jitter = np.cos((i + 1) * (item + 0.5678)) * 2e-6\n            jitter /= (np.abs(item) + 1e-12)\n            jitter = np.clip(jitter, -2e-6, 2e-6)\n            score[i] = -slack + jitter\n        i += 1\n\n    # Clip scores to avoid extreme values\n    score = np.clip(score, -1e6, 1e6)\n    return score\n\n",
  "best_fit_with_deterministic_jitter_aug_99": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item\n    slack = np.clip(slack, 0, None)                 # only feasible slack\n\n    # Quadratic penalty: larger slack gets much worse score\n    penalty = slack ** 2\n    score = -penalty\n\n    # Deterministic cosine jitter\n    idx = np.arange(bins.size, dtype=float)\n    jitter = np.cos((idx + 1.0) * (item + 2.71828)) * 1e-5\n    jitter = np.clip(jitter, -1e-5, 1e-5)\n    score += jitter\n\n    # Infeasible bins get -inf\n    score[bins < item] = -np.inf\n\n    return score\n\n",
  "best_fit_with_deterministic_jitter_aug_100": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    rng = np.random.default_rng(seed=42)\n\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item\n    score = -slack\n\n    # Feasible mask\n    feasible = slack >= 0\n\n    # Random noise added only to feasible bins\n    noise = rng.random(bins.size) * 1e-6\n    noise /= (bins.size + 1e-12)                    # epsilon in denominator\n    noise = np.clip(noise, 0, 1e-6)\n\n    score[feasible] += noise[feasible]\n\n    # Infeasible bins\n    score[~feasible] = -np.inf\n\n    # Clip to keep scores within a reasonable range\n    score = np.clip(score, -1e6, 1e6)\n\n    return score\n\n",
  "huber_slack_penalty_aug_101": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    # Slack is never negative \u2013 clip to avoid invalid operations\n    slack = np.clip(bins - item, 0, np.inf)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack > 0\n    if feasible.any():\n        # Mean of feasible slack, with epsilon to avoid division by zero\n        delta = np.mean(slack[feasible]) + 1e-12\n        s = slack[feasible]\n        # Huber penalty, using a safe denominator\n        huber = np.where(\n            s <= delta,\n            -(s ** 2) / (2 * delta + 1e-12),\n            -(s - delta / 2.0)\n        )\n        # Deterministic noise for tie\u2011breaking (index\u2011based)\n        noise = np.arange(len(slack)) * 1e-9\n        score[feasible] = huber + noise[feasible]\n    return score\n\n",
  "huber_slack_penalty_aug_102": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack_arr = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    # Build a list of indices of feasible bins\n    idx = 0\n    feasible_indices = []\n    while idx < slack_arr.size:\n        if slack_arr[idx] >= 0:\n            feasible_indices.append(idx)\n        idx += 1\n\n    if feasible_indices:\n        s = slack_arr[feasible_indices]\n        delta = np.max(s) + 1e-12\n        # Huber penalty with safe denominator\n        huber = np.where(\n            s <= delta,\n            -(s ** 2) / (2 * delta + 1e-12),\n            -(s - delta / 2.0)\n        )\n        # Softmin weighting: larger slack \u2192 lower weight\n        weight = np.exp(-s / (delta + 1e-12))\n        # Convert the weight to a penalty adjustment\n        adjustment = -0.5 * np.log(weight + 1e-12)\n        score[feasible_indices] = huber + adjustment\n    return score\n\n",
  "huber_slack_penalty_aug_103": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    # Clip to keep slack non\u2011negative\n    slack = np.clip(bins - item, 0, np.inf)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        s = slack[feasible]\n        # Sum\u2011based delta to bias towards larger slack values\n        delta = np.sum(s) / (s.size + 1e-12)\n        # Compute huber values via list comprehension\n        huber_vals = [\n            -(x ** 2) / (2 * delta + 1e-12) if x <= delta else -(x - delta / 2.0)\n            for x in s\n        ]\n        noise = np.arange(s.size) * 1e-8\n        score[feasible] = np.array(huber_vals) + noise\n    return score\n\n",
  "huber_slack_penalty_aug_104": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    # Ensure slack stays in a valid range\n    slack = np.clip(bins - item, 0, np.inf)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack > 0\n    if np.any(feasible):\n        s = slack[feasible]\n        # 75th percentile delta to emphasize larger slack values\n        delta = np.percentile(s, 75) + 1e-12\n        # Huber penalty, safe denominator\n        huber = np.where(\n            s <= delta,\n            -(s ** 2) / (2 * delta + 1e-12),\n            -(s - delta / 2.0)\n        )\n        # Linear deterministic noise for tie\u2011breaking\n        noise = np.linspace(-1e-9, 1e-9, s.size)\n        score[feasible] = huber + noise\n    return score\n\n",
  "tight_fit_plus_capacity_skew_control_aug_105": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = np.clip(bins - float(item), 0, None)          # keep only feasible slack\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack > 0\n    if feasible.any():\n        mu = np.mean(bins[feasible]) + 1e-12              # avoid divide\u2011by\u2011zero\n        cap_term = -np.abs(bins - mu)\n\n        # raw score: tightness + small pull toward median\n        raw = -slack + 0.02 * cap_term\n\n        # deterministic tie\u2011breaker: tiny increasing noise\n        noise = np.arange(len(bins)) * 1e-6\n        raw += noise\n\n        # soft\u2011min: convert raw scores to a probability distribution\n        exp_vals = np.exp(-raw - np.min(-raw))           # shift for stability\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n        score[feasible] = -np.log(probs[feasible] + 1e-12)\n\n    return score\n\n",
  "tight_fit_plus_capacity_skew_control_aug_106": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    scores = np.full_like(capacities, -np.inf, dtype=float)\n\n    for idx, cap in enumerate(capacities):\n        slack = cap - float(item)\n        if slack >= 0:\n            mu = np.mean(capacities[capacities >= item]) + 1e-12\n            cap_term = -np.abs(cap - mu)\n            raw = -slack + 0.015 * cap_term\n            scores[idx] = raw\n\n    # Random tie\u2011breaking among the top\u20115 scores\n    top_k = 5\n    if np.isfinite(scores).any():\n        top_indices = np.argpartition(-scores, top_k)[:top_k]\n        rng = np.random.default_rng()\n        chosen = rng.choice(top_indices)\n        mask = np.ones_like(scores, dtype=bool)\n        mask[chosen] = False\n        scores[mask] = -np.inf\n\n    return scores\n\n",
  "tight_fit_plus_capacity_skew_control_aug_107": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Invert logic: compute a score even for infeasible bins (but keep -inf)\n    score = np.array([\n        (-slack[i] + 0.03 * (-np.abs(bins[i] - np.max(bins))) + 1e-6 * i)\n        if slack[i] >= 0 else -np.inf\n        for i in range(len(bins))\n    ], dtype=float)\n\n    return score\n\n",
  "tight_fit_plus_capacity_skew_control_aug_108": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = np.clip(bins - float(item), 0, None)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack > 0\n    if feasible.any():\n        mu = np.mean(bins[feasible]) + 1e-12\n        cap_term = -np.abs(bins - mu)\n        raw = -slack + 0.02 * cap_term\n\n        # deterministic noise for reproducibility\n        noise = np.linspace(0, 1e-5, len(bins))\n        raw += noise\n\n        # softmax to obtain probability\u2011like scores\n        exp_vals = np.exp(raw - np.max(raw))\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n        score[feasible] = probs[feasible]\n\n    return score\n\n",
  "cdf_quantile_tightness_aug_109": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Feasible bins are those with non\u2011negative slack\n    feasible = slack >= 0\n    # Initialise all scores to -inf (unfeasible)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n        # Ascending order of slack gives lower\u2011quantile first\n        order = np.argsort(s)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n\n        denom = max(1.0, order.size - 1.0) + 1e-12\n        q = ranks / denom\n        q = np.clip(q, 0.0, 1.0)\n\n        score[feasible] = -q\n    return score\n\n",
  "cdf_quantile_tightness_aug_110": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Scale slack to tune influence of the quantity\n    slack_scaled = slack * 0.8\n    feasible = slack_scaled >= 0\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack_scaled[feasible]\n        order = np.argsort(s)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n\n        denom = max(1.0, order.size - 1.0) + 1e-12\n        q = ranks / denom\n\n        # Deterministic noise for tie\u2011breaking\n        noise = 1e-6 * np.arange(s.size, dtype=float)\n        q = q + noise\n        q = np.clip(q, 0.0, 1.0)\n\n        # Weight the quantile to adjust relative importance\n        score[feasible] = -q * 0.9\n    return score\n\n",
  "cdf_quantile_tightness_aug_111": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    feasible = slack >= 0\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n        # Small deterministic perturbation to avoid exact ties\n        s = s + 1e-8 * np.arange(s.size, dtype=float)\n\n        alpha = 5.0  # temperature controlling softness\n        exp_vals = np.exp(-alpha * s)\n        softmin = exp_vals / (exp_vals.sum() + 1e-12)\n\n        # Higher softmin means lower slack \u2192 higher priority\n        score[feasible] = -softmin\n        score[feasible] = np.clip(score[feasible], -1.0, 0.0)\n    return score\n\n",
  "cdf_quantile_tightness_aug_112": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    feasible = slack >= 0\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n        # Determine top\u2011k indices (k limited by available feasible bins)\n        k = min(3, s.size)\n        topk_idx = np.argpartition(s, k-1)[:k]\n\n        # Deterministic random selection\n        rng = np.random.default_rng(12345)\n        chosen = rng.choice(topk_idx)\n\n        # Assign scores: 0 for chosen, -1 for others\n        scores = -np.ones_like(s, dtype=float)\n        scores[chosen] = 0.0\n\n        # Add deterministic noise for remaining bins\n        noise = 1e-6 * np.arange(s.size, dtype=float)\n        scores += noise\n\n        # Clip to keep scores within [-1, 0]\n        scores = np.clip(scores, -1.0, 0.0)\n\n        score[feasible] = scores\n    return score\n\n",
  "sigmoid_negative_slack_aug_113": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_f = np.asarray(bins, dtype=float)\n    slack = bins_f - float(item)\n\n    # Negative slack (only for feasible bins)\n    neg_slack = -np.maximum(slack, 0.0)\n\n    # Sigmoid with a small epsilon in the denominator\n    denom = 1.0 + np.exp(-neg_slack) + 1e-12\n    score = 1.0 / denom\n\n    # Small deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=bins_f.shape)\n    score += noise\n\n    # Infeasible bins get -inf\n    score = np.where(slack < 0, -np.inf, score)\n\n    # Clip to a valid probability range\n    score = np.clip(score, 0.0, 1.0)\n    return score\n\n",
  "sigmoid_negative_slack_aug_114": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_f = np.asarray(bins, dtype=float)\n    slack = bins_f - float(item)\n\n    # Mask for feasible bins\n    feasible = slack >= 0\n\n    # Exponential terms with a scaling factor (0.7)\n    exp_vals = np.exp(-0.7 * slack)\n    exp_vals = np.where(feasible, exp_vals, 0.0)\n\n    # Deterministic noise added to the numerator\n    noise = np.random.uniform(-1e-7, 1e-7, size=bins_f.shape)\n    exp_vals += noise\n\n    # Normalise to obtain a soft\u2011min distribution\n    denom = np.sum(exp_vals) + 1e-12\n    score = exp_vals / denom\n\n    # Clip to [0,1] before masking infeasible bins\n    score = np.clip(score, 0.0, 1.0)\n\n    # Infeasible bins get -inf\n    score = np.where(feasible, score, -np.inf)\n    return score\n\n",
  "sigmoid_negative_slack_aug_115": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_f = np.asarray(bins, dtype=float)\n    slack = bins_f - float(item)\n\n    # Keep only positive slack\n    pos_slack = np.maximum(slack, 0.0)\n\n    # Square the slack to emphasise large gaps\n    slack_sq = np.square(pos_slack)\n\n    # Apply a scaling factor (0.4) before the sigmoid\n    neg_scaled = -0.4 * slack_sq\n    denom = 1.0 + np.exp(-neg_scaled) + 1e-12\n    score = 1.0 / denom\n\n    # Small deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(-3e-7, 3e-7, size=bins_f.shape)\n    score += noise\n\n    # Infeasible bins get -inf\n    score = np.where(slack < 0, -np.inf, score)\n\n    # Clip to a valid range\n    score = np.clip(score, 0.0, 1.0)\n    return score\n\n",
  "sigmoid_negative_slack_aug_116": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_f = np.asarray(bins, dtype=float)\n    slack = bins_f - float(item)\n\n    # Initialise all scores as -inf\n    score = np.full_like(bins_f, -np.inf, dtype=float)\n\n    # Compute scores only for feasible bins\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Sigmoid of positive slack\n        denom = 1.0 + np.exp(slack[feasible]) + 1e-12\n        score[feasible] = 1.0 / denom\n\n    # Add deterministic noise before final clipping\n    noise = np.random.uniform(-2e-6, 2e-6, size=bins_f.shape)\n    score += noise\n\n    # Clip to [0,1] (infeasible bins stay -inf)\n    score = np.clip(score, 0.0, 1.0)\n    return score\n\n",
  "log_barrier_best_fit_aug_117": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    eps = 1e-12\n    bins_arr = np.asarray(bins, dtype=float)\n\n    # Slack between capacity and item size\n    slack = bins_arr - float(item)\n\n    # Clip to avoid log of zero or negative values\n    slack_clipped = np.clip(slack, eps, None)\n\n    # Base score: higher when slack is smaller\n    score = -np.log(slack_clipped + eps)\n\n    # Add deterministic noise to break ties in a reproducible way\n    noise = 1e-6 * np.arange(len(bins_arr))\n    score += noise\n\n    # Mark infeasible bins with -inf\n    score = np.where(slack < 0, -np.inf, score)\n\n    return score\n\n",
  "log_barrier_best_fit_aug_118": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    eps = 1e-12\n    bins_arr = np.asarray(bins, dtype=float)\n\n    slack = bins_arr - float(item)\n\n    # Clip to avoid division by zero and log of zero\n    slack_clipped = np.clip(slack, eps, None)\n    bins_clipped = np.clip(bins_arr, eps, None)\n\n    # Component scores\n    log_score   = -np.log(slack_clipped + eps)          # log\u2011barrier\n    ratio_score = -slack_clipped / (bins_clipped + eps)  # negative slack ratio\n\n    # Weighted sum (more emphasis on log\u2011barrier)\n    score = 0.7 * log_score + 0.3 * ratio_score\n\n    # Infeasible bins\n    score = np.where(slack < 0, -np.inf, score)\n\n    return score\n\n",
  "log_barrier_best_fit_aug_119": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    eps = 1e-12\n    bins_arr = np.asarray(bins, dtype=float)\n\n    slack = bins_arr - float(item)\n\n    # Ensure slack is positive for the exponential\n    slack_clipped = np.clip(slack, eps, None)\n\n    # Softmin temperature\n    temp = 0.1\n\n    # Compute softmin probabilities\n    exp_vals = np.exp(-slack_clipped / (temp + eps))\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n\n    # Convert probabilities to scores (higher probability \u2192 higher score)\n    score = -np.log(np.clip(probs, eps, None))\n\n    # Infeasible bins\n    score = np.where(slack < 0, -np.inf, score)\n\n    return score\n\n",
  "log_barrier_best_fit_aug_120": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    eps = 1e-12\n    bins_arr = np.asarray(bins, dtype=float)\n\n    slack = bins_arr - float(item)\n\n    # Bound slack to [eps, 1] to keep log values in a reasonable range\n    slack_clipped = np.clip(slack, eps, 1.0)\n\n    # Base score\n    score = -np.log(slack_clipped + eps)\n\n    # Deterministic noise for reproducible tie\u2011breaking\n    noise = 1e-7 * np.arange(len(bins_arr))\n    score += noise\n\n    # Mark infeasible bins with -inf\n    score = np.where(slack < 0, -np.inf, score)\n\n    return score\n\n",
  "robust_mad_tightness_aug_121": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    slack = capacities - float(item)\n    feasible = slack >= 0\n\n    # Score array: higher is better\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if not feasible.any():\n        return score\n\n    # Robust statistics: median & MAD\n    med = np.median(slack[feasible])\n    mad = np.median(np.abs(slack[feasible] - med)) + 1e-12\n\n    # Z\u2011score with clipping to avoid overflow\n    z = (slack[feasible] - med) / (1.4826 * mad + 1e-12)\n    z = np.clip(z, -10, 10)\n\n    # Soft\u2011min priority: tighter slack \u2192 higher score\n    score[feasible] = np.exp(-z)\n\n    # Deterministic tie\u2011breaker\n    noise = 1e-15 * np.arange(capacities.size).reshape(capacities.shape)\n    score += noise\n\n    return score\n\n",
  "robust_mad_tightness_aug_122": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacity = np.asarray(bins, dtype=float)\n    slack = capacity - float(item)\n    feasible = slack >= 0\n\n    # Base score: 0 for all bins\n    score = np.zeros_like(capacity)\n\n    if not feasible.any():\n        return score\n\n    top_k = 7  # hyper\u2011parameter tuning\n\n    # Indices of feasible bins sorted by increasing slack\n    feasible_idx = np.where(feasible)[0]\n    sorted_idx = feasible_idx[np.argsort(slack[feasible_idx])]\n    chosen = sorted_idx[:top_k]\n\n    # Top\u2011k feasible bins receive the highest priority\n    score[chosen] = 1.0\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-10 * np.arange(capacity.size).reshape(capacity.shape)\n    score += noise\n\n    # Keep scores in [0, 1]\n    score = np.clip(score, 0, 1)\n    return score\n\n",
  "robust_mad_tightness_aug_123": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    spaces = np.asarray(bins, dtype=float)\n    slack = spaces - float(item)\n    feasible = slack >= 0\n\n    # Score array with -inf for infeasible bins\n    score = np.full_like(spaces, -np.inf, dtype=float)\n\n    if not feasible.any():\n        return score\n\n    # Use median and standard deviation as a proxy for MAD\n    med = np.median(slack[feasible])\n    std = np.std(slack[feasible]) + 1e-12\n\n    # Z\u2011score with clipping\n    z = (slack[feasible] - med) / (1.4826 * std + 1e-12)\n    z = np.clip(z, -20, 20)\n\n    # Logistic soft\u2011max: tighter slack \u2192 higher score\n    score[feasible] = 1.0 / (1.0 + np.exp(z))\n\n    # Deterministic noise for stability\n    noise = 1e-12 * np.arange(spaces.size).reshape(spaces.shape)\n    score += noise\n\n    return score\n\n",
  "robust_mad_tightness_aug_124": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    cap = np.asarray(bins, dtype=float)\n    slack = cap - float(item)\n    feasible = slack >= 0\n\n    # If no feasible bins, return -inf everywhere\n    if not feasible.any():\n        return np.full_like(cap, -np.inf, dtype=float)\n\n    med = np.median(slack[feasible])\n    mad = np.median(np.abs(slack[feasible] - med)) + 1e-12\n\n    def compute(val, feas):\n        if feas:\n            z = (val - med) / (1.4826 * mad + 1e-12)\n            z = np.clip(z, -10, 10)\n            return np.exp(-z)\n        return -np.inf\n\n    # List comprehension for explicit control flow\n    score_list = [compute(val, feas) for val, feas in zip(slack, feasible)]\n    score = np.array(score_list, dtype=float)\n\n    # Deterministic noise to break ties\n    noise = 1e-14 * np.arange(cap.size).reshape(cap.shape)\n    score += noise\n\n    return score\n\n",
  "reserve_large_bins_top_decile_aug_125": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    demand = float(item)\n\n    slack = capacities - demand\n    # Ratio of slack to capacity \u2013 safe division with epsilon\n    ratio = slack / (capacities + 1e-12)\n\n    # Base score: tighter fit better\n    score = -slack\n    score = np.where(slack >= 0, score, -np.inf)\n\n    # Clip to avoid extreme values\n    score = np.clip(score, -1e9, 0)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Approximate top decile using percentile\n        q90 = np.percentile(capacities[feasible], 90)\n        big = (capacities >= q90) & feasible\n        # Penalty proportional to excess over q90, modulated by ratio\n        penalty = 0.25 * (capacities[big] - q90) * (1 - ratio[big])\n        score[big] -= penalty\n\n    return score\n\n",
  "reserve_large_bins_top_decile_aug_126": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    demand = float(item)\n\n    slack = capacities - demand\n    ratio = slack / (capacities + 1e-12)\n    ratio = np.clip(ratio, 0, 1)\n\n    score = -slack\n    score = np.where(slack >= 0, score, -np.inf)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Use 85th percentile instead of 90th\n        q85 = np.percentile(capacities[feasible], 85)\n        big = (capacities >= q85) & feasible\n        penalty = 0.4 * (capacities[big] - q85) * (1 - ratio[big])\n        score[big] -= penalty\n\n    score = np.clip(score, -1e9, 0)\n    return score\n\n",
  "reserve_large_bins_top_decile_aug_127": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    demand = float(item)\n\n    slack = capacities - demand\n    noise = np.arange(len(bins), dtype=float) * 1e-6\n\n    score = -slack\n    score = np.where(slack >= 0, score, -np.inf)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        median_val = np.median(capacities[feasible])\n        big = (capacities >= median_val) & feasible\n        # Soft penalty using exponential decay\n        penalty = 0.25 * np.exp(-(capacities[big] - median_val) / (median_val + 1e-12))\n        score[big] -= penalty\n\n    score += noise\n    score = np.clip(score, -1e9, 0)\n    return score\n\n",
  "reserve_large_bins_top_decile_aug_128": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    demand = float(item)\n\n    slack = capacities - demand\n    noise = np.linspace(0, 1e-6, len(bins))\n\n    score = -slack\n    score = np.where(slack >= 0, score, -np.inf)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Approximate 90th percentile by sorting\n        sorted_cap = np.sort(capacities[feasible])\n        idx = int(0.9 * len(sorted_cap))\n        idx = np.clip(idx, 0, len(sorted_cap) - 1)\n        q90 = sorted_cap[idx]\n        big = (capacities >= q90) & feasible\n        penalty = 0.25 * (capacities[big] - q90) / (capacities[big] + 1e-12)\n        score[big] -= penalty\n\n    score += noise\n    score = np.clip(score, -1e9, 0)\n    return score\n\n",
  "capacity_aware_best_fit_aug_129": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    req = float(item)\n\n    slack = capacities - req\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        cap_median = np.median(capacities[feasible]) + 1e-12\n        score[feasible] = (\n            -slack[feasible]\n            - 0.08 * (capacities[feasible] / cap_median)\n        )\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(capacities)) * 1e-9\n    score = np.where(np.isfinite(score), score + noise, score)\n\n    # Clip to avoid extreme values\n    score = np.clip(score, -1e6, 0)\n    return score\n\n",
  "capacity_aware_best_fit_aug_130": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    req = float(item)\n\n    n = caps.size\n    score = np.full(n, -np.inf, dtype=float)\n\n    feasible = caps - req >= 0\n    cap_scale = np.sum(caps[feasible]) + 1e-12  # sum scaling\n\n    idx = 0\n    while idx < n:\n        if feasible[idx]:\n            score[idx] = (\n                -(caps[idx] - req)\n                - 0.07 * (caps[idx] / cap_scale)\n            )\n        idx += 1\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(n) * 1e-9\n    score = np.where(np.isfinite(score), score + noise, score)\n\n    # Clip to safe bounds\n    score = np.clip(score, -1e6, 0)\n    return score\n\n",
  "capacity_aware_best_fit_aug_131": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    req = float(item)\n\n    slack = caps - req\n    feasible = slack >= 0\n\n    score = np.full_like(caps, -np.inf, dtype=float)\n    if np.any(feasible):\n        cap_scale = np.max(caps[feasible]) + 1e-12\n        bias = 0.1 * (caps[feasible] / cap_scale)\n        # Soft\u2011min: negative exponential of slack plus bias\n        score[feasible] = -np.exp(-slack[feasible] - bias)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(caps)) * 1e-9\n    score = np.where(np.isfinite(score), score + noise, score)\n\n    # Clip to prevent overflow\n    score = np.clip(score, -1e6, 0)\n    return score\n\n",
  "capacity_aware_best_fit_aug_132": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    req = float(item)\n\n    slack = caps - req\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        cap_scale = np.max(caps[feasible]) + 1e-12\n        score[feasible] = -(slack[feasible] + 0.05 * (caps[feasible] / cap_scale))\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(caps)) * 1e-9\n    score = np.where(np.isfinite(score), score + noise, score)\n\n    # Clip to avoid invalid operations\n    score = np.clip(score, -1e6, 0)\n    return score\n\n",
  "fill_ratio_then_tightness_aug_133": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    weight = float(item)\n    capacities = np.asarray(bins, dtype=float)\n\n    # Raw slack and feasibility check\n    slack_raw = capacities - weight\n    feasible = slack_raw >= 0\n\n    # Clip slack to avoid negative values\n    slack = np.clip(slack_raw, 0, None)\n\n    # Fill ratio\n    fill = weight / np.maximum(capacities, 1e-12)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(len(capacities))\n\n    # Scoring: higher fill ratio is better, lower slack is better\n    score = 8.0 * fill - slack + noise\n\n    # Infeasible bins receive -inf\n    score[~feasible] = -np.inf\n    return score\n\n",
  "fill_ratio_then_tightness_aug_134": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    weight = float(item)\n    caps = np.asarray(bins, dtype=float)\n\n    slack_raw = caps - weight\n    feasible = slack_raw >= 0\n    slack = np.clip(slack_raw, 0, None)\n\n    fill = weight / np.maximum(caps, 1e-12)\n    # Use squared fill to emphasize larger ratios\n    score = 5.0 * np.square(fill) - slack\n\n    # Clip extreme values to keep the score bounded\n    score = np.clip(score, -1e6, 1e6)\n\n    # Deterministic noise (index\u2011based) for tie\u2011breaking\n    noise = 1e-8 * np.arange(len(caps)) ** 2\n    score += noise\n\n    score[~feasible] = -np.inf\n    return score\n\n",
  "fill_ratio_then_tightness_aug_135": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    weight = float(item)\n    caps = np.asarray(bins, dtype=float)\n\n    scores = [\n        -np.inf if caps[i] < weight else\n        10.0 * (weight / (caps[i] + 1e-12)) - (caps[i] - weight)\n        for i in range(len(caps))\n    ]\n\n    # Keep scores within a reasonable range\n    scores = np.clip(scores, -1e6, 1e6)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(len(caps))\n    return np.array(scores) + noise\n\n",
  "fill_ratio_then_tightness_aug_136": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    weight = float(item)\n    caps = np.asarray(bins, dtype=float)\n\n    slack_raw = caps - weight\n    feasible = slack_raw >= 0\n    slack = np.clip(slack_raw, 0, None)\n\n    fill = weight / np.maximum(caps, 1e-12)\n\n    # Soft\u2011min style scoring: exponential decay with slack\n    score = np.exp(-slack) * fill\n\n    # Deterministic noise (index\u2011based) for tie\u2011breaking\n    noise = 1e-7 * np.arange(len(caps))\n    score += noise\n\n    score[~feasible] = -np.inf\n    return score\n\n",
  "avoid_half_full_deadzone_aug_137": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    # Slack and feasibility mask\n    slack = bins_arr - itm\n    feasible = slack >= 0\n\n    # Approximate fill (clipped to [0,1]) and deterministic noise\n    eps = 1e-12\n    fill = np.clip(np.divide(bins_arr, bins_arr + eps), 0, 1)\n    noise = 1e-6 * np.arange(bins_arr.size)\n\n    # Score: larger is better\n    score = np.where(\n        feasible,\n        -slack + 0.15 * np.abs(fill - 0.5) + noise,\n        -np.inf\n    )\n    return score\n\n",
  "avoid_half_full_deadzone_aug_138": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    slack = bins_arr - itm\n    feasible = slack >= 0\n\n    # Squared fill factor, clipped to [0,1]\n    eps = 1e-12\n    fill = np.clip(bins_arr / (bins_arr + eps), 0, 1)\n    fill_sq = fill ** 2\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-7 * np.arange(bins_arr.size)\n\n    # Construct score array\n    score = np.full(bins_arr.shape, -np.inf, dtype=float)\n    score[feasible] = (\n        -slack[feasible]\n        + 0.2 * np.abs(fill_sq[feasible] - 0.5)\n        + noise[feasible]\n    )\n    return score\n\n",
  "avoid_half_full_deadzone_aug_139": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    slack = bins_arr - itm\n    feasible = slack >= 0\n\n    # Fill factor and raw score\n    eps = 1e-12\n    fill = np.clip(bins_arr / (bins_arr + eps), 0, 1)\n    raw = -slack + 0.1 * np.abs(fill - 0.5)\n\n    # Soft\u2011min (negative log\u2011softmax) to smooth scores\n    soft = -np.log(np.exp(-raw) + eps)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-8 * np.arange(bins_arr.size)\n\n    score = np.where(feasible, soft + noise, -np.inf)\n    return score\n\n",
  "avoid_half_full_deadzone_aug_140": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    slack = bins_arr - itm\n    feasible = slack >= 0\n\n    # Proxy fill approximation, clipped to [0,1]\n    eps = 1e-12\n    fill = np.clip(bins_arr / (bins_arr + itm + eps), 0, 1)\n\n    # Deterministic sinusoidal noise\n    noise = 1e-5 * np.sin(np.arange(bins_arr.size))\n\n    score = np.full(bins_arr.shape, -np.inf, dtype=float)\n    score[feasible] = (\n        -slack[feasible]\n        + 0.05 * np.abs(fill[feasible] - 0.5)\n        + noise[feasible]\n    )\n    return score\n\n",
  "target_complementary_gap_equal_item_aug_141": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    # Residual capacity of each bin\n    residual = bins_arr - itm\n\n    # Base score: prefer slack close to the item\n    base = -np.abs(residual - itm)\n\n    # Infeasible bins get -inf\n    base = np.where(residual < 0, -np.inf, base)\n\n    # Small deterministic noise to break ties\n    noise = 1e-6 * np.arange(len(bins_arr))\n    return base + noise\n\n",
  "target_complementary_gap_equal_item_aug_142": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    # Residual capacity\n    residual = bins_arr - itm\n\n    # Clip residual to avoid negative values in later calculations\n    clipped = np.clip(residual, 0, None)\n\n    # Apply a heavier penalty to the slack difference\n    score = -1.5 * np.abs(clipped - itm)\n\n    # Infeasible bins\n    score = np.where(residual < 0, -np.inf, score)\n\n    # Add a tiny epsilon for numerical stability\n    return score + 1e-12\n\n",
  "target_complementary_gap_equal_item_aug_143": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    # Slack relative to the item\n    slack = arr - itm\n\n    # Ratio of item to bin capacity (avoid div\u2011by\u2011zero)\n    ratio = itm / (arr + 1e-12)\n    ratio = np.clip(ratio, 0, 1)\n\n    # Use the maximum ratio as a reference\n    max_ratio = np.max(ratio)\n    score = -np.abs(max_ratio - ratio)\n\n    # Penalise infeasible bins\n    score = np.where(slack < 0, -np.inf, score)\n    return score\n\n",
  "target_complementary_gap_equal_item_aug_144": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    # Residual capacity\n    residual = arr - itm\n\n    # Proxy ratio (item over bin capacity) with clipping\n    proxy = itm / (arr + 1e-12)\n    proxy = np.clip(proxy, 0, 1)\n\n    # Weighted score using the proxy\n    score = -0.8 * np.abs(residual - itm) * proxy\n\n    # Infeasible bins\n    score = np.where(residual < 0, -np.inf, score)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(len(arr))\n    return score + noise\n\n",
  "adaptive_sigmoid_target_slack_aug_145": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr_bins = np.asarray(bins, dtype=float)\n    arr_item = float(item)\n    slack_arr = arr_bins - arr_item\n    score_arr = np.full_like(arr_bins, -np.inf, dtype=float)\n    feasible_mask = slack_arr >= 0\n    if np.any(feasible_mask):\n        feasible_slack = slack_arr[feasible_mask]\n        target = np.mean(feasible_slack)                     # mean instead of median\n        scale = np.std(feasible_slack) + 1e-9\n        z = (target - slack_arr) / scale\n        z = np.clip(z, -10, 10)                              # bound z to avoid overflow\n        denom = 1.0 + np.exp(-z) + 1e-12                     # epsilon in denominator\n        score_arr[feasible_mask] = 1.0 / denom[feasible_mask]\n        # deterministic tie\u2011breaking noise\n        noise = 1e-6 * np.arange(len(score_arr))\n        score_arr += noise\n    return score_arr\n\n",
  "adaptive_sigmoid_target_slack_aug_146": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bin_caps = np.asarray(bins, dtype=float)\n    size = float(item)\n    n = bin_caps.size\n    scores = np.full(n, -np.inf, dtype=float)\n\n    slack_arr = bin_caps - size\n    feasible = slack_arr >= 0\n    if np.any(feasible):\n        feas_idx = np.nonzero(feasible)[0]\n        feas_slack = slack_arr[feas_idx]\n        target = np.max(feas_slack)                          # max slack as target\n        scale = (np.max(feas_slack) - np.min(feas_slack)) + 1e-9\n        z = (slack_arr[feas_idx] - target) / scale\n        z = np.clip(z, -10, 10)\n        denom = 1.0 + np.exp(z) + 1e-12                      # softmin denominator\n        scores[feas_idx] = 1.0 / denom\n        # deterministic noise\n        noise = 1e-7 * np.arange(n)\n        scores += noise\n    return scores\n\n",
  "adaptive_sigmoid_target_slack_aug_147": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    sz = float(item)\n    slack = caps - sz\n    score = np.full_like(caps, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if np.any(feasible):\n        feas_slack = slack[feasible]\n        target = np.sum(feas_slack) / len(feas_slack)        # mean via sum\n        mad = np.mean(np.abs(feas_slack - target))          # mean absolute deviation\n        scale = mad + 1e-9\n        z = (target - slack) / scale\n        z = np.clip(z, -8, 8)\n        denom = 1.0 + np.exp(-z) + 1e-12\n        score[feasible] = 1.0 / denom\n        # deterministic noise based on fractional part\n        noise = 1e-8 * (slack % 1)\n        score += noise\n    return score\n\n",
  "adaptive_sigmoid_target_slack_aug_148": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    sz = float(item)\n    slack = caps - sz\n    score = np.full_like(caps, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if np.any(feasible):\n        feas_slack = slack[feasible]\n        target = 0.7 * np.mean(feas_slack) + 0.3 * np.max(feas_slack)\n        scale = np.max(feas_slack) - np.min(feas_slack) + 1e-9\n        z = (target - slack) / scale\n        z = np.clip(z, -12, 12)\n        denom = 1.0 + np.exp(-z) + 1e-12\n        score[feasible] = 1.0 / denom\n        # deterministic noise\n        noise = 1e-9 * np.arange(len(score))\n        score += noise\n        # clip final scores to [0, 1]\n        score = np.clip(score, 0.0, 1.0)\n    return score\n\n",
  "kde_rarity_slack_preference_aug_149": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        s = slack[feasible]\n        h_val = np.median(s) + 1e-12            # bandwidth based on median\n        h_val = np.clip(h_val, 1e-12, None)\n        diff_mat = (s[:, None] - s[None, :]) / h_val\n        density = np.sum(np.exp(-0.5 * diff_mat ** 2), axis=1)\n\n        # negative density as raw score\n        raw_score = -density\n\n        # retain only the best 7 feasible bins\n        top_k = 7\n        if len(raw_score) > top_k:\n            idx = np.argpartition(raw_score, -top_k)[-top_k:]\n            mask = np.zeros_like(raw_score, dtype=bool)\n            mask[idx] = True\n            raw_score = np.where(mask, raw_score, -np.inf)\n\n        # deterministic noise for tie\u2011breaking\n        noise = np.arange(len(raw_score)) * 1e-6\n        score[feasible] = raw_score + noise\n    return score\n\n",
  "kde_rarity_slack_preference_aug_150": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        s = slack[feasible]\n        mad = np.median(np.abs(s - np.median(s))) + 1e-12\n        h_val = mad + 1e-12\n        h_val = np.clip(h_val, 1e-12, None)\n        diff_mat = (s[:, None] - s[None, :]) / h_val\n        density = np.max(np.exp(-0.5 * np.square(diff_mat)), axis=1)\n\n        raw_score = -density\n\n        # keep only the best 5 feasible bins\n        top_k = 5\n        if len(raw_score) > top_k:\n            idx = np.argpartition(raw_score, -top_k)[-top_k:]\n            mask = np.zeros_like(raw_score, dtype=bool)\n            mask[idx] = True\n            raw_score = np.where(mask, raw_score, -np.inf)\n\n        # deterministic noise for tie\u2011breaking\n        noise = np.arange(len(raw_score)) * 1e-6\n        score[feasible] = raw_score + noise\n    return score\n\n",
  "variance_reduction_post_slack_aug_151": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    slack = np.clip(slack, 0, np.inf)          # ensure non\u2011negative slack\n    feasible = slack > 0\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        mu = np.median(slack[feasible])\n        # ratio with epsilon to avoid division by zero\n        ratio = slack / (slack + 1e-12)\n        score[feasible] = -np.square(ratio[feasible] - 0.5) - 0.01 * slack[feasible]\n\n    # deterministic tie\u2011breaking noise\n    score += 1e-6 * np.arange(len(bins))\n    return score\n\n",
  "variance_reduction_post_slack_aug_152": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    slack = np.clip(slack, 0, np.inf)\n    feasible = slack > 0\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        mu = np.max(slack[feasible])\n        score[feasible] = -np.square(slack[feasible] - mu) - 0.02 * slack[feasible]\n\n    # add small random noise for tie\u2011breaking\n    score += np.random.uniform(-1e-6, 1e-6, size=len(bins))\n    return score\n\n",
  "variance_reduction_post_slack_aug_153": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    slack = np.clip(slack, 0, np.inf)\n    feasible = slack > 0\n\n    # aggregate using sum (equivalent to mean) with epsilon\n    mu = np.sum(slack[feasible]) / (len(slack[feasible]) + 1e-12)\n\n    # compute soft\u2011min probability\n    exp_vals = np.exp(-slack / (slack + 1e-12))\n    p = exp_vals / (np.sum(exp_vals) + 1e-12)\n    p = np.clip(p, 1e-12, 1 - 1e-12)\n\n    score = -np.square(slack - mu) - 0.01 * slack - np.log(p + 1e-12)\n    score[~feasible] = -np.inf\n\n    # deterministic noise\n    score += 1e-6 * np.arange(len(bins))\n    return score\n\n",
  "variance_reduction_post_slack_aug_154": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    slack = np.clip(slack, 0, np.inf)\n    feasible = slack >= 0\n\n    mu = np.max(slack[feasible]) if np.any(feasible) else 0.0\n    score = -np.square(slack - mu) - 0.5 * slack\n    score[~feasible] = -np.inf\n\n    # keep only the top\u2011k bins with the smallest slack\n    k = min(5, len(bins))\n    topk_idx = np.argpartition(slack, k-1)[:k]\n    mask_topk = np.zeros(len(bins), dtype=bool)\n    mask_topk[topk_idx] = True\n    score[~mask_topk] = -np.inf\n\n    # random noise for tie\u2011breaking\n    score += np.random.uniform(-1e-6, 1e-6, size=len(bins))\n    return score\n\n",
  "heavy_tail_penalty_on_extreme_slack_aug_155": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Feasibility mask\n    feasible = slack >= 0.0\n\n    # Compute z\u2011score only for feasible bins\n    mu = np.mean(slack[feasible]) if feasible.any() else 0.0\n    sd = np.std(slack[feasible]) + 1e-12 if feasible.any() else 1.0\n    z = (slack - mu) / sd\n\n    # Vectorised score: penalise large |z| and large slack\n    score = np.where(\n        feasible,\n        -np.abs(z) ** 3 - 0.02 * slack,\n        -np.inf\n    )\n    return score\n\n",
  "heavy_tail_penalty_on_extreme_slack_aug_156": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    feasible = slack >= 0.0\n\n    # Median instead of mean, different slack weight, deterministic noise\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if feasible.any():\n        s = slack[feasible]\n        mu = np.median(s)\n        sd = np.std(s) + 1e-12\n        z = (s - mu) / sd\n\n        # Deterministic noise based on index\n        noise = ((np.arange(len(s)) % 2) - 0.5) * 1e-4\n\n        # Clip z to avoid extreme values\n        z = np.clip(z, -10.0, 10.0)\n\n        score[feasible] = -np.abs(z) ** 3 - 0.015 * s + noise\n    return score\n\n",
  "heavy_tail_penalty_on_extreme_slack_aug_157": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    feasible = slack >= 0.0\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if feasible.any():\n        s = slack[feasible]\n        # Use maximum instead of mean for the central tendency\n        mu = np.max(s)\n        sd = np.std(s) + 1e-12\n        z = (s - mu) / sd\n\n        # Soft\u2011min style penalty (larger z \u2192 lower score)\n        z = np.clip(z, -10.0, 10.0)\n        soft = -np.exp(-z)\n\n        # Deterministic tie\u2011breaking noise\n        noise = np.sin(item + np.arange(len(s))) * 1e-4\n\n        score[feasible] = soft - 0.02 * s + noise\n    return score\n\n",
  "heavy_tail_penalty_on_extreme_slack_aug_158": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n\n    # Clip negative slack to zero and keep a mask of feasible bins\n    slack = np.clip(bins - float(item), a_min=0.0, a_max=None)\n    feasible = slack > 0.0\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if feasible.any():\n        s = slack[feasible]\n        mu = np.mean(s)\n        sd = np.std(s) + 1e-12\n        z = (s - mu) / sd\n\n        # Temperature\u2011controlled soft\u2011min\n        temp = 5.0\n        soft = -np.exp(-z / temp)\n\n        # Small deterministic noise for reproducibility\n        noise = ((np.arange(len(s)) % 3) - 1) * 5e-5\n\n        score[feasible] = soft - 0.018 * s + noise\n    return score\n\n",
  "piecewise_small_item_spread_large_item_tight_aug_159": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        med_bin = np.median(bins[feasible])\n        small = item <= 0.25 * med_bin\n\n        mu = np.mean(slack[feasible])\n\n        if small:\n            # Avoid division by zero\n            ratio = np.clip(1.0 / (slack[feasible] + 1e-12), 0.0, 1.0)\n            score[feasible] = (\n                np.abs(slack[feasible] - mu) * ratio\n                - 0.02 * slack[feasible]\n            )\n        else:\n            score[feasible] = -slack[feasible]\n\n        # Deterministic tie\u2011breaking noise\n        noise = 1e-5 * np.arange(bins.size)\n        score += noise\n\n        # Clip to avoid extreme values\n        score = np.clip(score, -1e12, 1e12)\n\n    return score\n\n",
  "piecewise_small_item_spread_large_item_tight_aug_160": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        med_bin = np.median(bins[feasible])\n        small = item <= 0.30 * med_bin\n\n        mu = np.median(slack[feasible])\n\n        if small:\n            ratio = np.clip(1.0 / (slack[feasible] + 1e-12), 0.0, 1.0)\n            score[feasible] = (\n                np.abs(slack[feasible] - mu) * ratio\n                - 0.05 * slack[feasible]\n            )\n        else:\n            score[feasible] = -slack[feasible]\n\n        # Deterministic tie\u2011breaking noise\n        noise = 1e-6 * np.arange(bins.size)\n        score += noise\n\n        # Clip to avoid extreme values\n        score = np.clip(score, -1e12, 1e12)\n\n    return score\n\n",
  "piecewise_small_item_spread_large_item_tight_aug_161": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        med_bin = np.median(bins[feasible])\n        small = item <= 0.25 * med_bin\n\n        med_slack = np.median(slack[feasible])\n\n        if small:\n            # Spread bins: larger deviation from median slack is better\n            score[feasible] = np.abs(slack[feasible] - med_slack) + 0.01 * slack[feasible]\n        else:\n            # Soft\u2011min weighting for tight packing\n            max_slack = np.max(slack[feasible]) + 1e-12\n            soft_factor = 1.0 + 0.5 * np.exp(-slack[feasible] / max_slack)\n            score[feasible] = -slack[feasible] * soft_factor\n\n        # Deterministic tie\u2011breaking noise\n        noise = 1e-6 * np.arange(bins.size)\n        score += noise\n\n        # Clip to avoid extreme values\n        score = np.clip(score, -1e12, 1e12)\n\n    return score\n\n",
  "piecewise_small_item_spread_large_item_tight_aug_162": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    # Ensure proper dtype\n    bin_caps = np.asarray(bins, dtype=float)\n    item_weight = float(item)\n\n    n = bin_caps.size\n    score = np.full(n, -np.inf, dtype=float)\n\n    slack = bin_caps - item_weight\n    feasible_indices = np.nonzero(slack >= 0)[0]\n\n    if feasible_indices.size > 0:\n        med_cap = np.median(bin_caps[feasible_indices])\n        small_item = item_weight <= 0.25 * med_cap\n        mean_slack = np.mean(slack[feasible_indices])\n\n        idx = 0\n        while idx < feasible_indices.size:\n            i = feasible_indices[idx]\n            if small_item:\n                # Avoid division by zero\n                ratio = np.clip(1.0 / (slack[i] + 1e-12), 0.0, 1.0)\n                score[i] = np.abs(slack[i] - mean_slack) * ratio - 0.02 * slack[i]\n            else:\n                score[i] = -slack[i]\n            idx += 1\n\n        # Deterministic tie\u2011breaking noise\n        noise = 1e-5 * np.arange(n)\n        score += noise\n\n        # Clip final scores\n        score = np.clip(score, -1e12, 1e12)\n\n    return score\n\n",
  "exponential_overflow_guard_aug_163": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    residual = capacities - float(item)\n\n    # Mask infeasible bins\n    feasible = residual >= 0\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # Median-based scale with safety epsilon\n        scale = np.median(residual[feasible]) + 1e-9\n        # Avoid division by zero\n        denom = scale + 1e-12\n\n        # Compute score for feasible bins\n        exp_term = np.exp(residual[feasible] / denom)\n        noise = np.random.uniform(-1e-6, 1e-6, size=feasible.sum())\n        score[feasible] = -residual[feasible] - exp_term + noise\n\n    return score\n\n",
  "exponential_overflow_guard_aug_164": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bin_capacities = np.asarray(bins, dtype=float)\n    residual = bin_capacities - float(item)\n    feasible = residual >= 0\n\n    score = np.full_like(bin_capacities, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # Max\u2011based scale with epsilon\n        scale = np.max(residual[feasible]) + 1e-9\n        denom = scale + 1e-12\n\n        # Weighted penalty (40% exponential)\n        weight = 0.4\n        penalty = weight * np.exp(residual[feasible] / denom)\n\n        # Raw score with deterministic noise\n        noise = np.random.uniform(-1e-7, 1e-7, size=feasible.sum())\n        raw = -residual[feasible] - penalty + noise\n        score[feasible] = raw\n\n        # Soft top\u2011k selection (k = 3)\n        top_k = 3\n        if feasible.sum() > top_k:\n            top_indices = np.argpartition(score[feasible], -top_k)[-top_k:]\n            mask = np.ones_like(score[feasible], dtype=bool)\n            mask[top_indices] = False\n            score[feasible][mask] = -np.inf\n\n    return score\n\n",
  "exponential_overflow_guard_aug_165": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    size = float(item)\n    slack = capacities - size\n    feasible = slack >= 0\n\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # Scale based on mean of squared slack\n        scale = np.mean(np.square(slack[feasible])) + 1e-9\n        denom = scale + 1e-12\n\n        exp_component = np.exp(slack[feasible] / denom)\n        score[feasible] = -slack[feasible] - exp_component\n\n        # Deterministic tie\u2011breaking noise\n        score[feasible] += slack[feasible] * 1e-9\n\n        # Clip to avoid extreme values\n        score[feasible] = np.clip(score[feasible], -1e6, 1e6)\n\n    return score\n\n",
  "exponential_overflow_guard_aug_166": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    obj = float(item)\n    slack = capacities - obj\n\n    # Clip slack to non\u2011negative values\n    slack = np.clip(slack, 0, None)\n    feasible = slack > 0\n\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        denom = np.sum(slack[feasible]) + 1e-12\n        log_term = np.log1p(slack[feasible] / denom)\n        score[feasible] = -slack[feasible] - log_term\n\n        # Deterministic noise for tie\u2011breaking\n        noise = np.linspace(-1e-8, 1e-8, feasible.sum())\n        score[feasible] += noise\n\n        # Keep only the best 5 feasible bins\n        top_k = 5\n        if feasible.sum() > top_k:\n            top_indices = np.argpartition(score[feasible], -top_k)[-top_k:]\n            mask = np.ones_like(score[feasible], dtype=bool)\n            mask[top_indices] = False\n            score[feasible][mask] = -np.inf\n\n    return score\n\n",
  "triangular_peak_at_quantile_40_aug_167": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    # Boolean mask for feasible bins\n    feasible = slack >= 0\n    # Initialize all scores to a very low value\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # Compute peak and width only on feasible slack\n        slack_feasible = slack[feasible]\n        peak = np.quantile(slack_feasible, 0.40)\n        # Width computed from 10th and 90th percentiles\n        low = np.quantile(slack_feasible, 0.10)\n        high = np.quantile(slack_feasible, 0.90)\n        width = (high - low) + 1e-12          # epsilon to avoid division by zero\n        # Vectorized score calculation\n        score[feasible] = 1.0 - (np.abs(slack_feasible - peak) / width)\n\n    # Clip scores to avoid extreme values\n    return np.clip(score, -1.0, 1.0)\n\n",
  "triangular_peak_at_quantile_40_aug_168": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n\n    if np.any(feasible):\n        s = slack[feasible]\n        # Shift the peak to the 50th percentile and widen the spread\n        peak = np.quantile(s, 0.50)\n        low = np.quantile(s, 0.15)\n        high = np.quantile(s, 0.85)\n        width = (high - low) * 1.2 + 1e-12          # scaling factor + epsilon\n        # Apply a slightly higher weight to the distance component\n        score[feasible] = 1.0 - 0.8 * (np.abs(s - peak) / width)\n\n    return np.clip(score, -1.0, 1.0)\n\n",
  "triangular_peak_at_quantile_40_aug_169": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n\n    if np.any(feasible):\n        s = slack[feasible]\n        peak = np.quantile(s, 0.40)\n        low = np.quantile(s, 0.10)\n        high = np.quantile(s, 0.90)\n        width = (high - low) + 1e-12\n        base_score = 1.0 - (np.abs(s - peak) / width)\n        # Add deterministic noise proportional to bin index\n        noise = 1e-6 * np.arange(len(bins))\n        score[feasible] = base_score + noise[feasible]\n\n    return np.clip(score, -1.0, 1.0)\n\n",
  "triangular_peak_at_quantile_40_aug_170": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n\n    if np.any(feasible):\n        s = slack[feasible]\n        peak = np.mean(s)                           # mean as proxy for median\n        width = np.max(s) - np.min(s) + 1e-12       # max\u2011min spread\n        score[feasible] = 1.0 - (np.abs(s - peak) / width)\n\n    return np.clip(score, -1.0, 1.0)\n\n",
  "cosine_match_bin_slack_profile_aug_171": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    slack = np.clip(capacities - item, 0, None)          # avoid negative slack\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        mu_cap = np.median(capacities[feasible])\n        mu_slack = np.median(slack[feasible])\n\n        vec = np.column_stack((capacities[feasible], slack[feasible]))\n        ref = np.array([mu_cap, mu_slack], dtype=float)\n\n        num = vec @ ref\n        denom = (np.linalg.norm(vec, axis=1) *\n                 (np.linalg.norm(ref) + 1e-12) + 1e-12)\n\n        score[feasible] = num / denom - 0.015 * slack[feasible]\n\n        # deterministic tie\u2011breaking noise\n        score[feasible] += 1e-6 * np.arange(np.count_nonzero(feasible))\n    return score\n\n",
  "cosine_match_bin_slack_profile_aug_172": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - item\n    slack = np.clip(slack, 0, None)\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    idx = np.nonzero(feasible)[0]\n\n    # aggregate once\n    mu_cap = np.sum(caps[feasible]) / np.count_nonzero(feasible)\n    mu_slack = np.sum(slack[feasible]) / np.count_nonzero(feasible)\n    ref = np.array([mu_cap, mu_slack], dtype=float)\n\n    i = 0\n    while i < len(idx):\n        j = idx[i]\n        vec = np.array([caps[j], slack[j]], dtype=float)\n        num = vec @ ref\n        denom = (np.linalg.norm(vec) *\n                 (np.linalg.norm(ref) + 1e-12) + 1e-12)\n        score[j] = num / denom - 0.04 * slack[j]\n        i += 1\n\n    # deterministic tie\u2011breaking by adding small index\u2011based noise\n    score[feasible] += 1e-8 * idx\n    return score\n\n",
  "cosine_match_bin_slack_profile_aug_173": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - item\n    slack = np.clip(slack, 0, None)\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        mu_cap = np.max(caps[feasible])\n        mu_slack = np.max(slack[feasible])\n        ref = np.array([mu_cap, mu_slack], dtype=float)\n\n        vec = np.column_stack((caps[feasible], slack[feasible]))\n        num = vec @ ref\n        denom = (np.linalg.norm(vec, axis=1) *\n                 (np.linalg.norm(ref) + 1e-12) + 1e-12)\n        scores_feas = num / denom - 0.02 * slack[feasible]\n\n        # Randomly keep only one of the top\u20113 scores\n        if len(scores_feas) > 3:\n            top_k = np.argpartition(-scores_feas, 3)[:3]\n            chosen = np.random.choice(top_k)\n            mask = np.ones_like(scores_feas, dtype=bool)\n            mask[chosen] = False\n            scores_feas[mask] = -np.inf\n\n        score[feasible] = scores_feas\n    return score\n\n",
  "cosine_match_bin_slack_profile_aug_174": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - item\n    slack = np.clip(slack, 0, None)\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        mu_cap = np.mean(caps[feasible])\n        mu_slack = np.mean(slack[feasible])\n        ref = np.array([mu_cap, mu_slack], dtype=float)\n\n        vec = np.column_stack((caps[feasible], slack[feasible]))\n        num = vec @ ref\n        denom = (np.linalg.norm(vec, axis=1) *\n                 (np.linalg.norm(ref) + 1e-12) + 1e-12)\n        similarity = num / denom\n\n        # softmax over negative slack (prefers bins with less slack)\n        exp_neg = np.exp(-slack[feasible] * 0.1)\n        softmax = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n        score[feasible] = 0.9 * similarity + 0.1 * softmax\n    return score\n\n",
  "lexicographic_rank_then_capacity_center_aug_175": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack_arr = bins_arr - float(item)\n\n    # Initialise scores with -\u221e for infeasible bins\n    score_arr = np.full_like(bins_arr, -np.inf, dtype=float)\n    feasible_mask = slack_arr >= 0\n\n    if np.any(feasible_mask):\n        # Compute ranks for feasible bins\n        feasible_slack = slack_arr[feasible_mask]\n        sorted_idx = np.argsort(feasible_slack)\n        ranks = np.empty_like(sorted_idx, dtype=float)\n        ranks[sorted_idx] = np.arange(sorted_idx.size, dtype=float)\n\n        # Deterministic noise to break ties\n        noise = 1e-6 * np.arange(sorted_idx.size, dtype=float)\n\n        # Center closeness to the median of feasible bins\n        med_val = np.median(bins_arr[feasible_mask])\n        center = -np.abs(bins_arr[feasible_mask] - med_val)\n        center = np.clip(center, -1, 1)  # keep values bounded\n\n        # Final score: higher is better\n        score_arr[feasible_mask] = -ranks + 0.0005 * center + noise\n\n    return score_arr\n\n",
  "lexicographic_rank_then_capacity_center_aug_176": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack_arr = bins_arr - float(item)\n\n    score_arr = np.full_like(bins_arr, -np.inf, dtype=float)\n    feasible_mask = slack_arr >= 0\n\n    if np.any(feasible_mask):\n        feasible_slack = slack_arr[feasible_mask]\n\n        # Soft\u2011min ranking: lower slack \u2192 higher rank\n        temp = 1.0\n        exp_vals = np.exp(-feasible_slack / (temp + 1e-12))\n        soft_rank = -np.log(exp_vals + 1e-12)          # epsilon for log(0)\n\n        # Normalise ranks to [0, 1]\n        min_r, max_r = np.min(soft_rank), np.max(soft_rank)\n        norm_rank = (soft_rank - min_r) / (max_r - min_r + 1e-12)\n\n        # Center closeness to the median of feasible bins\n        med_val = np.median(bins_arr[feasible_mask])\n        center = -np.abs(bins_arr[feasible_mask] - med_val)\n        center = np.clip(center, -1, 1)\n\n        score_arr[feasible_mask] = -norm_rank + 0.002 * center\n\n    return score_arr\n\n",
  "lexicographic_rank_then_capacity_center_aug_177": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack_arr = bins_arr - float(item)\n\n    score_arr = np.full_like(bins_arr, -np.inf, dtype=float)\n    feasible_mask = slack_arr >= 0\n\n    if np.any(feasible_mask):\n        feasible_slack = slack_arr[feasible_mask]\n        sorted_idx = np.argsort(feasible_slack)\n        ranks = np.empty_like(sorted_idx, dtype=float)\n        ranks[sorted_idx] = np.arange(sorted_idx.size, dtype=float)\n\n        # Top\u2011k selection\n        top_k = 7\n        top_indices = sorted_idx[:top_k]\n\n        # Random tie\u2011breaking among top\u2011k\n        rng = np.random.default_rng(42)\n        chosen = rng.choice(top_indices)\n\n        # Center closeness using mean of feasible bins\n        mean_val = np.mean(bins_arr[feasible_mask])\n        center = -np.abs(bins_arr[feasible_mask] - mean_val)\n        center = np.clip(center, -1, 1)\n\n        # Base score\n        score_arr[feasible_mask] = -ranks + 0.001 * center\n\n        # Give a slight boost to the randomly chosen bin\n        score_arr[feasible_mask][chosen] += 0.01\n\n    return score_arr\n\n",
  "quantized_slack_prefer_round_remainders_aug_178": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    # Slack must never be negative \u2013 clip at zero\n    slack = np.clip(bins - float(item), 0, None)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack > 0\n    if feasible.any():\n        s = slack[feasible]\n        # Dynamic quantum \u2013 use median, add tiny epsilon to avoid div\u2011by\u2011zero\n        q = (np.median(s) / 4.0) + 1e-12\n        k = np.round(slack / q)\n        dist = np.abs(slack - k * q)\n        score[feasible] = -dist[feasible] - 0.08 * slack[feasible]\n        # Small noise to break ties deterministically\n        noise = np.random.uniform(-1e-6, 1e-6, size=score.shape)\n        score += noise\n    return score\n\n",
  "quantized_slack_prefer_round_remainders_aug_179": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    for idx, cap in enumerate(bins):\n        slack_val = cap - float(item)\n        slack_val = np.clip(slack_val, 0, None)\n        if slack_val > 0:\n            # Quantum from the mean of all feasible slacks so far\n            feasible_slack = bins[:idx+1] - float(item)\n            feasible_slack = feasible_slack[feasible_slack >= 0]\n            if feasible_slack.size == 0:\n                continue\n            q = (np.mean(feasible_slack) / 5.0) + 1e-12\n            k = np.round(slack_val / q)\n            dist = np.abs(slack_val - k * q)\n            score[idx] = -dist - 0.1 * slack_val\n    # Soft\u2011min transformation \u2013 add epsilon to denominator\n    exp_scores = np.exp(-score - np.max(-score))\n    denom = np.sum(exp_scores) + 1e-12\n    softmin = exp_scores / denom\n    return softmin\n\n",
  "quantized_slack_prefer_round_remainders_aug_180": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = np.clip(bins - float(item), 0, None)\n    scores = []\n    for s in slack:\n        if s > 0:\n            # Quantum from the maximum slack\n            q = (np.max([s, 1e-12]) / 3.0) + 1e-12\n            k = np.round(s / q)\n            dist = np.abs(s - k * q)\n            scores.append(-dist - 0.06 * s)\n        else:\n            scores.append(-np.inf)\n    scores = np.array(scores, dtype=float)\n    # Randomly keep one of the top\u2011k scores\n    k_top = 5\n    top_indices = np.argpartition(scores, -k_top)[-k_top:]\n    top_scores = scores[top_indices]\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(k_top) * 1e-7\n    top_scores += noise\n    rng = np.random.default_rng()\n    chosen = rng.choice(top_indices)\n    scores[:] = -np.inf\n    scores[chosen] = top_scores[np.where(top_indices == chosen)[0][0]]\n    return scores\n\n",
  "quantized_slack_prefer_round_remainders_aug_181": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    idx = 0\n    n = bins.size\n    while idx < n:\n        slack_val = bins[idx] - float(item)\n        slack_val = np.clip(slack_val, 0, None)\n        if slack_val > 0:\n            # Quantum from the sum of all feasible slacks\n            feasible = bins[:idx+1] - float(item)\n            feasible = feasible[feasible >= 0]\n            q = (np.sum(feasible) / 6.0) + 1e-12\n            k = np.round(slack_val / q)\n            dist = np.abs(slack_val - k * q)\n            score[idx] = -dist - 0.07 * slack_val\n        idx += 1\n    # Normalize with a squared\u2011error denominator\n    denom = np.sum(np.square(score - np.min(score))) + 1e-12\n    norm_score = (score - np.min(score)) / denom\n    return norm_score\n\n",
  "softmin_slack_with_logsumexp_scale_aug_182": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    remaining = bins - float(item)\n\n    scores = np.full_like(bins, -np.inf, dtype=float)\n    feasible = remaining >= 0\n\n    if feasible.any():\n        rem = remaining[feasible]\n        # Scale based on mean slack with a small epsilon\n        scale = (np.mean(rem) + 1e-12) * np.log1p(rem.size)\n        scale = np.clip(scale, 1e-12, None)\n\n        # Core scoring\n        scores[feasible] = -rem / (scale + 1e-12)\n\n        # Deterministic tie\u2011breaking noise\n        noise = np.arange(rem.size, dtype=float) * 1e-8\n        scores[feasible] += noise\n\n    return scores\n\n",
  "softmin_slack_with_logsumexp_scale_aug_183": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    scores = np.full_like(bins, -np.inf, dtype=float)\n    # Feasible only if slack is noticeably positive\n    feasible = slack >= 1e-6\n\n    if feasible.any():\n        s = slack[feasible]\n        # Scale based on maximum slack and an extra multiplier\n        scale = (np.max(s) + 1e-9) * np.log1p(s.size) * 1.5\n        scale = np.clip(scale, 1e-12, None)\n\n        scores[feasible] = -s / (scale + 1e-12)\n\n        # Add deterministic noise to break ties\n        scores[feasible] += np.linspace(-1e-7, 1e-7, num=s.size)\n\n    return scores\n\n",
  "softmin_slack_with_logsumexp_scale_aug_184": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    scores = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n\n    if feasible.any():\n        # Indices of feasible bins\n        idx = np.where(feasible)[0]\n        rem = slack[feasible]\n\n        # Select the k bins with the smallest slack\n        k = min(5, rem.size)\n        topk = np.argpartition(rem, k - 1)[:k]\n        selected = idx[topk]\n\n        # Soft\u2011min weighting\n        scale = np.median(rem) + 1e-12\n        weights = np.exp(-rem[topk] / (scale + 1e-12))\n        # Convert weights to scores (higher is better)\n        scores[selected] = -np.log(weights + 1e-12)\n\n        # Small random perturbation for deterministic tie\u2011breaking\n        scores[selected] += np.random.uniform(-1e-6, 1e-6, size=selected.size)\n\n    return scores\n\n",
  "softmin_slack_with_logsumexp_scale_aug_185": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    scores = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n\n    if feasible.any():\n        rem = slack[feasible]\n        # Scale based on squared mean slack\n        scale = np.square(np.mean(rem)) + 1e-12\n        scale = np.clip(scale, 1e-12, None)\n\n        raw = -rem / (scale + 1e-12)\n        # Clip scores to a safe range to avoid extreme values\n        raw = np.clip(raw, -1.0, 0.0)\n        scores[feasible] = raw\n\n        # Add a tiny normal noise for tie\u2011breaking\n        scores[feasible] += np.random.normal(scale=1e-7, size=feasible.sum())\n\n    return scores\n\n",
  "golden_ratio_dithered_best_fit_aug_186": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    size = float(item)\n    capacities = np.asarray(bins, dtype=float)\n\n    # raw slack (may be negative for infeasible bins)\n    raw_slack = np.array([c - size for c in capacities], dtype=float)\n\n    # clip slack to non\u2011negative for score calculation\n    slack = np.clip(raw_slack, 0, np.inf)\n\n    # base score: higher is better (less remaining space)\n    score = -slack\n\n    # mark infeasible bins\n    score[raw_slack < 0] = -np.inf\n\n    # only add dither if there is at least one feasible bin\n    feasible = raw_slack >= 0\n    if feasible.any():\n        phi = (1.0 + np.sqrt(5.0)) / 2.0\n        idx = np.arange(capacities.size, dtype=float) + 1.0\n        dither = np.mod(idx * phi, 1.0) - 0.5\n        score[feasible] += 1e-6 * dither[feasible]\n\n    return score\n\n",
  "golden_ratio_dithered_best_fit_aug_187": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    itm = float(item)\n    caps = np.asarray(bins, dtype=float)\n    n = caps.size\n\n    # compute slack using a while loop\n    slack_arr = np.empty(n, dtype=float)\n    i = 0\n    while i < n:\n        slack_arr[i] = caps[i] - itm\n        i += 1\n\n    # clip slack for score calculation\n    slack_clipped = np.clip(slack_arr, 0, np.inf)\n    score = -slack_clipped\n\n    # infeasible bins\n    score[slack_arr < 0] = -np.inf\n\n    # deterministic dither\n    phi = (1.0 + np.sqrt(5.0)) / 2.0\n    idx = np.arange(n, dtype=float) + 1.0\n    noise = 5e-7 * (np.mod(idx * phi, 1.0) - 0.5)\n    score += noise\n\n    # soft\u2011min (softmax of the score)\n    temp = 1.0 + 1e-12\n    exp_vals = np.exp(score / temp)\n    probs = exp_vals / np.clip(np.sum(exp_vals), 1e-12, None)\n\n    # return negative log\u2011probabilities as priority scores\n    return -np.log(np.clip(probs, 1e-12, None))\n\n",
  "golden_ratio_dithered_best_fit_aug_188": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    size = float(item)\n    caps = np.asarray(bins, dtype=float)\n    raw_slack = caps - size\n    feasible = raw_slack >= 0\n\n    # initialize all scores to -inf (infeasible)\n    score = np.full(caps.shape, -np.inf, dtype=float)\n\n    if not feasible.any():\n        return score\n\n    # clip slack for safe operations\n    slack = np.clip(raw_slack, 0, np.inf)\n\n    # base priority: best\u2011fit (smaller slack \u2192 higher score)\n    score[feasible] = -slack[feasible]\n\n    # deterministic RNG for tie\u2011breaking\n    seed = hash((size, tuple(caps.tolist())))\n    rng = np.random.default_rng(seed)\n\n    # choose top\u2011k bins with largest slack\n    top_k = min(3, slack.size)\n    idx_top = np.argpartition(-slack, top_k - 1)[:top_k]\n\n    # add deterministic noise to the top\u2011k bins\n    noise = 1e-7 * np.sin(idx_top * np.pi)\n    score[idx_top] += noise\n\n    # small penalty for remaining feasible bins\n    remaining = feasible & (~np.isin(np.arange(caps.size), idx_top))\n    score[remaining] -= 1e-3\n\n    return score\n\n",
  "golden_ratio_dithered_best_fit_aug_189": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    itm = float(item)\n    caps = np.asarray(bins, dtype=float)\n\n    # raw slack\n    raw_slack = caps - itm\n\n    # clip slack to avoid negative values in the score\n    slack = np.clip(raw_slack, 0, np.inf)\n\n    # base score: negative squared slack (stronger penalty for large slack)\n    score = -np.square(slack)\n\n    # mark infeasible bins\n    score[raw_slack < 0] = -np.inf\n\n    # add sinusoidal deterministic dither to feasible bins\n    feasible = raw_slack >= 0\n    if feasible.any():\n        idx = np.arange(caps.size, dtype=float) + 1.0\n        dither = np.sin(idx * np.pi) * 0.5\n        score[feasible] += 1e-7 * dither[feasible]\n\n    return score\n\n",
  "percentile_guard_avoid_tails_aug_190": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    # Clip slack to avoid extreme negative values\n    slack_clipped = np.clip(slack, 0, 1e12)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n\n    if np.any(feasible):\n        # 15th and 85th percentiles\n        lo = np.percentile(slack[feasible], 15)\n        hi = np.percentile(slack[feasible], 85)\n        mid = 0.5 * (lo + hi)\n\n        # Base score: distance from mid and a small penalty for slack\n        base = -np.abs(slack_clipped[feasible] - mid) - 0.025 * slack_clipped[feasible]\n        score[feasible] = base\n\n        # Penalize slacks outside the central band\n        left_mask = (slack[feasible] < lo)\n        right_mask = (slack[feasible] > hi)\n        score[feasible][left_mask] -= (lo - slack_clipped[feasible][left_mask])\n        score[feasible][right_mask] -= (slack_clipped[feasible][right_mask] - hi)\n\n        # Add deterministic tie-breaking noise\n        noise = 1e-6 * np.arange(len(bins))\n        score += noise\n\n    return score\n\n",
  "percentile_guard_avoid_tails_aug_191": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    n = bins.size\n    score = np.full(n, -np.inf, dtype=float)\n\n    i = 0\n    while i < n:\n        slack = bins[i] - item\n        if slack >= 0:\n            # Simple heuristic: negative slack distance from a custom mid\n            lo = 0.9 * slack\n            hi = 1.1 * slack\n            mid = 0.5 * (lo + hi)\n            base = -np.abs(slack - mid) - 0.03 * slack\n            score[i] = base\n\n            # Deterministic noise for tie-breaking\n            score[i] += 1e-7 * i\n        else:\n            score[i] = -np.inf\n        i += 1\n\n    return score\n\n",
  "percentile_guard_avoid_tails_aug_192": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    feasible = slack >= 0\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n        # Use median instead of mean for mid-point\n        mid = np.median(s)\n        lo = np.percentile(s, 10)\n        hi = np.percentile(s, 90)\n\n        # Raw score\n        raw = -np.abs(s - mid) - 0.02 * s\n        # Softmin transformation\n        exp_neg = np.exp(-raw)\n        denom = np.sum(exp_neg) + 1e-12  # epsilon to avoid division by zero\n        soft = -np.log(exp_neg / denom)\n        score[feasible] = soft\n\n        # Penalize slacks outside [lo, hi]\n        left = s < lo\n        right = s > hi\n        score[feasible][left] -= (lo - s[left])\n        score[feasible][right] -= (s[right] - hi)\n\n    return score\n\n",
  "percentile_guard_avoid_tails_aug_193": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    feasible = slack >= 0\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n        mean = np.mean(s)\n        std = np.std(s)\n\n        # Approximate lo and hi using mean \u00b1 0.5*std\n        lo = np.clip(mean - 0.5 * std, 0, np.inf)\n        hi = mean + 0.5 * std\n\n        mid = 0.5 * (lo + hi)\n\n        base = -np.abs(s - mid) - 0.03 * s\n        score[feasible] = base\n\n        left = s < lo\n        right = s > hi\n        score[feasible][left] -= (lo - s[left])\n        score[feasible][right] -= (s[right] - hi)\n\n        # Add deterministic noise for tie-breaking\n        noise = 1e-6 * np.arange(len(bins))\n        score += noise\n\n    return score\n\n",
  "entropy_flatten_slack_histogram_aug_194": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Initialize all scores to -inf\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if not feasible.any():\n        return score\n\n    s = slack[feasible]\n    lo, hi = np.min(s), np.max(s)\n\n    # If all feasible slacks are identical, no rarity information\n    if hi - lo < 1e-12:\n        score[feasible] = 0.0\n        return score\n\n    nb = 10\n    edges = np.linspace(lo, hi, nb + 1)\n    idx = np.digitize(s, edges, right=True) - 1\n    idx = np.clip(idx, 0, nb - 1)\n\n    # Count occurrences per bin and compute rarity\n    counts = np.bincount(idx, minlength=nb).astype(float)\n    rarity = 1.0 / (counts[idx] + 1e-12)\n\n    # Final score: rarity minus a small penalty for slack\n    score[feasible] = rarity - 0.02 * s\n    return score\n\n",
  "entropy_flatten_slack_histogram_aug_195": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if not feasible.any():\n        return score\n\n    s = slack[feasible]\n    lo, hi = np.min(s), np.max(s)\n\n    if hi - lo < 1e-12:\n        score[feasible] = 0.0\n        return score\n\n    nb = 12\n    edges = np.linspace(lo, hi, nb + 1)\n    idx = np.digitize(s, edges, right=True) - 1\n    idx = np.clip(idx, 0, nb - 1)\n\n    counts = np.bincount(idx, minlength=nb).astype(float)\n    rarity = 1.0 / (counts[idx] + 1e-12)\n\n    # Soft\u2011min over slack with a temperature\n    temp = 0.5\n    softmin = np.exp(-s / (temp + 1e-12))\n    softmin /= np.sum(softmin) + 1e-12\n\n    base = rarity * softmin\n\n    # Deterministic noise for tie\u2011breaking\n    rng = np.random.default_rng(seed=42)\n    noise = rng.uniform(-1e-4, 1e-4, size=base.shape)\n\n    score[feasible] = base + noise\n    return score\n\n",
  "entropy_flatten_slack_histogram_aug_196": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if not feasible.any():\n        return score\n\n    s = slack[feasible]\n    lo, hi = np.min(s), np.max(s)\n\n    if hi - lo < 1e-12:\n        score[feasible] = 0.0\n        return score\n\n    nb = 8\n    edges = np.linspace(lo, hi, nb + 1)\n    idx = np.digitize(s, edges, right=True) - 1\n    idx = np.clip(idx, 0, nb - 1)\n\n    # Compute median slack per bin\n    medians = np.empty(nb, dtype=float)\n    for k in range(nb):\n        mask = idx == k\n        medians[k] = np.median(s[mask]) if np.any(mask) else hi\n\n    rarity = 1.0 / (medians[idx] + 1e-12)\n\n    score[feasible] = rarity - 0.01 * s\n    return score\n\n",
  "entropy_flatten_slack_histogram_aug_197": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if not feasible.any():\n        return score\n\n    s = slack[feasible]\n    lo, hi = np.min(s), np.max(s)\n\n    if hi - lo < 1e-12:\n        score[feasible] = 0.0\n        return score\n\n    nb = 10\n    edges = np.linspace(lo, hi, nb + 1)\n    idx = np.digitize(s, edges, right=True) - 1\n    idx = np.clip(idx, 0, nb - 1)\n\n    counts = np.bincount(idx, minlength=nb).astype(float)\n    rarity = 1.0 / (counts[idx] + 1e-12)\n\n    base = rarity - 0.01 * s\n\n    # Randomly perturb the top\u2011k scores\n    top_k = 5\n    rng = np.random.default_rng(seed=123)\n    if base.size > top_k:\n        top_indices = np.argpartition(-base, top_k - 1)[:top_k]\n        perturb = rng.normal(0, 1e-3, size=base.shape)\n        base[top_indices] += perturb[top_indices]\n\n    score[feasible] = base\n    return score\n\n",
  "tukey_biweight_tightness_aug_198": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack_space = bins - float(item)\n    feasible_mask = slack_space >= 0\n    scores = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible_mask):\n        s = slack_space[feasible_mask]\n        med = np.median(s)\n        mad = np.median(np.abs(s - med)) + 1e-12\n        c = 4.685\n        u = (s - med) / (c * 1.4826 * mad + 1e-12)\n        w = (1 - u**2)\n        w[np.abs(u) >= 1] = 0.0\n        w = np.clip(w**2, 0, 1)\n        scores[feasible_mask] = w - 0.025 * s\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(len(bins), dtype=float) * 1e-6\n    return scores + noise\n\n",
  "tukey_biweight_tightness_aug_199": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    scores = np.full_like(bins, -np.inf, dtype=float)\n\n    idx = np.where(slack >= 0)[0]\n    i = 0\n    while i < len(idx):\n        k = idx[i]\n        s = slack[k]\n        med = s                     # single element median\n        mad = 1e-12\n        c = 4.0\n        u = (s - med) / (c * 1.4826 * mad + 1e-12)\n        w = np.exp(-u**2)\n        w = np.clip(w, 0, 1)\n        scores[k] = w - 0.015 * s\n        i += 1\n\n    # Randomly keep one of the top\u20113 bins (deterministic seed)\n    top_k = 3\n    if np.any(scores > -np.inf):\n        top_idx = np.argpartition(-scores, top_k)[:top_k]\n        rng = np.random.default_rng(seed=0)\n        chosen = rng.choice(top_idx)\n        mask = np.ones_like(scores, dtype=bool)\n        mask[chosen] = False\n        scores[mask] = -np.inf\n\n    return scores\n\n",
  "tukey_biweight_tightness_aug_200": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    feasible = slack >= 0\n    scores = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n        med = np.mean(s)                        # use mean instead of median\n        mad = np.median(np.abs(s - med)) + 1e-12\n        c = 5.0\n        u = (s - med) / (c * 1.4826 * mad + 1e-12)\n        w = 1 / (1 + np.exp(u**2))              # soft\u2011min style\n        w = np.clip(w, 0, 1)\n        scores[feasible] = w - 0.02 * s\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(bins), dtype=float) * 1e-7\n    return scores + noise\n\n",
  "tukey_biweight_tightness_aug_201": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    scores = []\n    for s in slack:\n        if s < 0:\n            scores.append(-np.inf)\n        else:\n            med = s                          # single element median\n            mad = 1e-12\n            c = 3.5\n            u = (s - med) / (c * 1.4826 * mad + 1e-12)\n            # soft\u2011min like logistic weighting\n            w = np.exp(-u**2) / (1 + np.exp(-u**2))\n            w = np.clip(w, 0, 1)\n            scores.append(w - 0.03 * s)\n\n    scores = np.array(scores, dtype=float)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(bins), dtype=float) * 1e-7\n    return scores + noise\n\n",
  "cauchy_target_slack_aug_202": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    n = bins.size\n    res = np.full(n, -np.inf, dtype=float)\n\n    slack = bins - float(item)\n    feasible = slack >= 0\n    if not feasible.any():\n        return res\n\n    feasible_slack = slack[feasible]\n    target = np.median(feasible_slack)\n    scale = np.std(feasible_slack) + 1e-12\n\n    for idx in np.where(feasible)[0]:\n        s = slack[idx]\n        z = (s - target) / scale\n        # safe denominator with epsilon\n        res[idx] = 1.0 / (1.0 + z * z + 1e-12) - 0.02 * s\n\n    # deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(n)\n    res += noise\n\n    # clip to keep values in a reasonable range\n    res = np.clip(res, -1.0, 1.0)\n    return res\n\n",
  "cauchy_target_slack_aug_203": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    mask = slack >= 0\n    res = np.full_like(bins, -np.inf, dtype=float)\n\n    if not mask.any():\n        return res\n\n    feasible = slack[mask]\n    target = np.mean(feasible)\n    scale = np.std(feasible) + 1e-12\n    z = (feasible - target) / scale\n\n    # softmax\u2011style score with a small penalty\n    scores = np.exp(-z * z) - 0.005 * feasible\n    res[mask] = scores\n\n    # deterministic tie\u2011breaking noise\n    res += 1e-6 * np.arange(bins.size)\n\n    # clip only the feasible part to preserve -inf for infeasible bins\n    res[mask] = np.clip(res[mask], -10.0, 10.0)\n    return res\n\n",
  "cauchy_target_slack_aug_204": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    res = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible_idx = [i for i, s in enumerate(slack) if s >= 0]\n    if not feasible_idx:\n        return res\n\n    feasible_slack = slack[feasible_idx]\n    target = np.median(feasible_slack)\n    scale = np.std(feasible_slack) + 1e-12\n\n    for i in feasible_idx:\n        s = slack[i]\n        z = (s - target) / scale\n        res[i] = 1.0 / (1.0 + z * z + 1e-12) - 0.02 * s\n\n    # deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(bins.size)\n    res += noise\n\n    # clip to keep values within a reasonable range\n    res = np.clip(res, -1.0, 1.0)\n    return res\n\n",
  "cauchy_target_slack_aug_205": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    n = bins.size\n    slack = bins - float(item)\n    res = np.full(n, -np.inf, dtype=float)\n\n    # gather indices of feasible bins using a while loop\n    idx = 0\n    feasible_indices = []\n    while idx < n:\n        if slack[idx] >= 0:\n            feasible_indices.append(idx)\n        idx += 1\n\n    if not feasible_indices:\n        return res\n\n    feasible_slack = slack[feasible_indices]\n    k = len(feasible_slack) // 2\n    target = np.partition(feasible_slack, k)[k]\n    scale = np.std(feasible_slack) * 0.5 + 1e-12\n\n    for i in feasible_indices:\n        s = slack[i]\n        z = (s - target) / scale\n        res[i] = 1.0 / (1.0 + z * z + 1e-12) - 0.01 * s + 0.001 * s\n\n    # deterministic tie\u2011breaking noise\n    res += 1e-6 * np.arange(n)\n\n    # clip to keep values bounded\n    res = np.clip(res, -5.0, 5.0)\n    return res\n\n",
  "borda_rank_slack_and_capacity_aug_206": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if feasible.any():\n        # Rank bins by increasing slack (smaller slack gets lower rank)\n        s = slack[feasible]\n        rank_slack = np.argsort(np.argsort(s))\n\n        # Rank bins by distance from median capacity\n        b = bins[feasible]\n        median_cap = np.median(b)\n        rank_mid = np.argsort(np.argsort(np.abs(b - median_cap)))\n\n        # Combine ranks with weighted sum (slack weight 1, mid weight 0.7)\n        score[feasible] = -(rank_slack + 0.7 * rank_mid).astype(float)\n\n    # Add deterministic noise for stable tie breaking\n    noise = np.arange(len(score)) * 1e-6\n    score += noise\n\n    # Clip to avoid extreme values\n    return np.clip(score, -1e9, 1e9)\n\n",
  "borda_rank_slack_and_capacity_aug_207": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        b = bins[feasible]\n        median_cap = np.median(b)\n\n        # Ranks\n        rank_slack = np.argsort(np.argsort(s))\n        rank_mid   = np.argsort(np.argsort(np.abs(b - median_cap)))\n\n        # Exponential weighting (softmin)\n        w_slack = np.exp(-rank_slack.astype(float))\n        w_mid   = np.exp(-rank_mid.astype(float))\n\n        # Normalised combined score\n        denom = np.sum(w_slack) + 0.5 * np.sum(w_mid) + 1e-12\n        score[feasible] = -(w_slack + 0.5 * w_mid) / denom\n\n    # Deterministic noise for tie\u2011breaking\n    score += np.arange(len(score)) * 5e-7\n\n    # Clip to prevent overflow\n    return np.clip(score, -1e9, 1e9)\n\n",
  "borda_rank_slack_and_capacity_aug_208": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if not feasible.any():\n        return score\n\n    # Pre\u2011compute median of feasible bins\n    med = np.percentile(bins[feasible], 50)\n\n    for idx in range(len(bins)):\n        if not feasible[idx]:\n            continue\n\n        # Rank by slack (count of smaller slack among feasible)\n        rank_slack = np.sum((slack[feasible] < slack[idx]).astype(int))\n\n        # Rank by distance to median\n        rank_mid = np.sum((np.abs(bins[feasible] - med) < np.abs(bins[idx] - med)).astype(int))\n\n        score[idx] = -(rank_slack + 0.5 * rank_mid)\n\n    # Noise for deterministic tie\u2011breaking\n    score += np.arange(len(score)) * 2e-6\n\n    # Ensure numerical stability\n    return np.clip(score, -1e9, 1e9)\n\n",
  "borda_rank_slack_and_capacity_aug_209": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if feasible.any():\n        # Compute ranks using np.where to avoid explicit loops\n        rank_slack = np.where(\n            feasible,\n            np.argsort(np.argsort(slack)),\n            np.iinfo(np.int32).max\n        )\n        median_cap = np.median(bins[feasible])\n        rank_mid = np.where(\n            feasible,\n            np.argsort(np.argsort(np.abs(bins - median_cap))),\n            np.iinfo(np.int32).max\n        )\n\n        # Combine with weighted sum and normalise\n        denom = np.sum(rank_slack[feasible]) + 0.4 * np.sum(rank_mid[feasible]) + 1e-12\n        score[feasible] = -(0.6 * rank_slack[feasible] + 0.4 * rank_mid[feasible]) / denom\n\n    # Add deterministic noise\n    score += np.arange(len(score)) * 3e-6\n\n    # Clip to prevent overflow\n    return np.clip(score, -1e9, 1e9)\n\n",
  "capacity_outlier_penalty_plus_tightness_aug_210": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bin_caps = np.asarray(bins, dtype=float)\n    item_size = float(item)\n    score = np.full_like(bin_caps, -np.inf, dtype=float)\n\n    # Iterate over bins explicitly (syntactic rewrite)\n    for idx, cap in enumerate(bin_caps):\n        slack = cap - item_size\n        if slack >= 0:  # feasible bin\n            # Statistics computed on all feasible bins\n            feas_caps = bin_caps[bin_caps >= item_size]\n            mu = np.median(feas_caps)\n            sd = np.std(feas_caps) + 1e-12          # epsilon to avoid division by zero\n            out = np.abs(cap - mu) / sd\n            # deterministic tie\u2011breaker using index\n            score[idx] = -slack - 0.12 * out + 1e-9 * idx\n    return score\n\n",
  "capacity_outlier_penalty_plus_tightness_aug_211": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    size = float(item)\n    slack = caps - size\n    feasible = slack >= 0\n\n    score = np.full_like(caps, -np.inf, dtype=float)\n    if feasible.any():\n        feas_caps = caps[feasible]\n        mu = np.median(feas_caps)\n        # use mean absolute deviation instead of std\n        sd = np.mean(np.abs(feas_caps - mu)) + 1e-12\n        out = np.abs(caps - mu) / sd\n        out = np.clip(out, 0, 5)                    # bound outliers\n        # deterministic noise for tie\u2011breaking\n        score[feasible] = -slack[feasible] - 0.2 * out + 1e-9 * np.arange(len(caps))\n    return score\n\n",
  "capacity_outlier_penalty_plus_tightness_aug_212": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    size = float(item)\n    slack = caps - size\n    feasible = slack >= 0\n\n    score = np.full_like(caps, -np.inf, dtype=float)\n    if feasible.any():\n        feas_caps = caps[feasible]\n        mu = np.median(feas_caps)\n        # use mean absolute deviation as proxy for spread\n        sd = np.mean(np.abs(feas_caps - mu)) + 1e-12\n        out = np.abs(caps - mu) / sd\n        # lighter penalty and deterministic noise\n        score[feasible] = -slack[feasible] - 0.05 * out + 1e-9 * np.arange(len(caps))\n    return score\n\n",
  "capacity_outlier_penalty_plus_tightness_aug_213": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    size = float(item)\n    slack = caps - size\n    feasible = slack >= 0\n\n    score = np.full_like(caps, -np.inf, dtype=float)\n    if feasible.any():\n        feas_caps = caps[feasible]\n        mu = np.median(feas_caps)\n        sd = np.mean(np.abs(feas_caps - mu)) + 1e-12\n\n        out = np.abs(caps - mu) / sd\n\n        # stable softmax of negative slack (softmin)\n        neg_slack = -slack[feasible]\n        max_val = np.max(neg_slack)\n        exp_vals = np.exp(neg_slack - max_val)          # shift for numerical stability\n        soft = exp_vals / (np.sum(exp_vals) + 1e-12)     # epsilon in denominator\n\n        # combine soft preference with outlier penalty\n        score[feasible] = soft - 0.1 * out[feasible] + 1e-9 * np.arange(len(caps))\n    return score\n\n",
  "avoid_ultra_tight_bottom_decile_slack_aug_214": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    size = float(item)\n\n    # remaining capacity in each bin\n    remaining = capacities - size\n\n    # higher remaining \u2192 higher score; infeasible \u2192 -inf\n    score = -remaining + np.where(remaining < 0, -np.inf, 0)\n\n    # mask of feasible bins\n    feasible_mask = remaining >= 0\n    if np.any(feasible_mask):\n        # 10th percentile of remaining among feasible bins\n        p10 = np.quantile(remaining[feasible_mask], 0.10)\n\n        # bins that are in the bottom decile\n        tight_mask = feasible_mask & (remaining <= p10)\n\n        # penalty for ultra\u2011tight bins\n        penalty = (p10 - remaining[tight_mask] + 1e-12) * 0.5\n        score[tight_mask] -= penalty\n\n    return score\n\n",
  "avoid_ultra_tight_bottom_decile_slack_aug_215": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    sz = float(item)\n\n    slack = caps - sz\n    score = -slack\n    score[slack < 0] = -np.inf\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # use a slightly looser threshold (15th percentile)\n        p10 = np.quantile(slack[feasible], 0.15)\n        ultra_mask = feasible & (slack <= p10)\n        penalty = (p10 - slack[ultra_mask] + 1e-12) * 0.8\n        score[ultra_mask] -= penalty\n\n    # deterministic noise for tie\u2011breaking\n    rng = np.random.default_rng(12345)\n    noise = rng.normal(scale=1e-6, size=score.shape)\n    score += noise\n\n    # keep values within a safe range\n    score = np.clip(score, -1e9, 1e9)\n\n    return score\n\n",
  "avoid_ultra_tight_bottom_decile_slack_aug_216": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    sz = float(item)\n\n    slack = caps - sz\n    score = -slack\n    score[slack < 0] = -np.inf\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # use the median as the \u201ctight\u201d threshold\n        median_slack = np.median(slack[feasible])\n\n        tight_mask = feasible & (slack <= median_slack)\n\n        # soft penalty using exponential weighting\n        temp = 10.0 + 1e-12  # temperature, avoid division by zero\n        penalty = np.exp(-(median_slack - slack[tight_mask]) / temp) * 0.3\n        score[tight_mask] -= penalty\n\n    return score\n\n",
  "avoid_ultra_tight_bottom_decile_slack_aug_217": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    sz = float(item)\n\n    # compute slack using a list comprehension\n    slack_list = [c - sz for c in caps]\n    slack = np.array(slack_list, dtype=float)\n\n    # base score (higher slack \u2192 higher score)\n    score = np.array([-s for s in slack], dtype=float)\n\n    # mark infeasible bins\n    for i, s in enumerate(slack):\n        if s < 0:\n            score[i] = -np.inf\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # 10th percentile with clipping to avoid negatives\n        p10 = np.quantile(slack[feasible], 0.10)\n        p10 = np.clip(p10, 0, None)\n\n        tight_mask = feasible & (slack <= p10)\n        penalty = (p10 - slack[tight_mask] + 1e-12) * 0.6\n        score[tight_mask] -= penalty\n\n    # clip scores to keep them within a reasonable range\n    score = np.clip(score, -1e6, 1e6)\n\n    return score\n\n",
  "softplus_barrier_target_fraction_20_aug_218": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    # Slack and feasibility\n    slack_arr = bins_arr - item_val\n    feasible = slack_arr >= 0\n\n    # Initialise all scores to -inf\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # Target slack is 20\u202f% of bin capacity\n        target = 0.20 * np.maximum(bins_arr, 1e-12)\n\n        # Softplus penalty centred on the target\n        k = 8.0\n        x = k * (np.abs(slack_arr - target) / np.maximum(bins_arr, 1e-12))\n        softplus = np.log1p(np.exp(x))\n\n        # Deterministic noise for stable tie\u2011breaking\n        noise = np.arange(bins_arr.size, dtype=float) * 1e-6\n\n        # Final score: lower is better\n        score[feasible] = -softplus[feasible] - 0.01 * slack_arr[feasible] + noise[feasible]\n\n    return score\n\n",
  "softplus_barrier_target_fraction_20_aug_219": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack_arr = bins_arr - item_val\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    # Invert feasibility: handle infeasible bins first\n    for idx, slack in enumerate(slack_arr):\n        if slack < 0:          # infeasible\n            continue\n        # New target: 15\u202f% of capacity\n        target = 0.15 * np.maximum(bins_arr[idx], 1e-12)\n        k = 6.0\n        x = k * (np.abs(slack - target) / np.maximum(bins_arr[idx], 1e-12))\n        softplus = np.log1p(np.exp(x))\n        score[idx] = -softplus - 0.01 * slack\n\n    return score\n\n",
  "softplus_barrier_target_fraction_20_aug_220": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    rng = np.random.default_rng(42)  # deterministic RNG for reproducibility\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack_arr = bins_arr - item_val\n    feasible = slack_arr >= 0\n\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        target = 0.20 * np.maximum(bins_arr, 1e-12)\n        k = 8.0\n        x = k * (np.abs(slack_arr - target) / np.maximum(bins_arr, 1e-12))\n        softplus = np.log1p(np.exp(x))\n        score[feasible] = -softplus[feasible] - 0.02 * slack_arr[feasible]\n\n        # Randomly pick among the best top\u20115 scores\n        top_k = 5\n        best_indices = np.argpartition(score, -top_k)[-top_k:]\n        chosen = rng.choice(best_indices, size=top_k, replace=False)\n        mask = np.full_like(score, False, dtype=bool)\n        mask[chosen] = True\n        score[~mask] = -np.inf\n\n    return score\n\n",
  "softplus_barrier_target_fraction_20_aug_221": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack_arr = bins_arr - item_val\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    if np.any(slack_arr >= 0):\n        target = 0.25 * np.maximum(bins_arr, 1e-12)\n        k = 10.0\n        # Approximate exp(x) with a second\u2011order Taylor expansion\n        x = k * (np.abs(slack_arr - target) / np.maximum(bins_arr, 1e-12))\n        exp_approx = 1.0 + x + 0.5 * x**2\n        # Softplus approximation: log(1 + exp(x)) \u2248 log(1 + exp_approx)\n        softplus = np.log1p(exp_approx)\n        softplus = np.clip(softplus, 0, 20)  # keep within reasonable bounds\n\n        score[slack_arr >= 0] = -softplus[slack_arr >= 0] - 0.01 * slack_arr[slack_arr >= 0]\n\n    return score\n\n",
  "logit_fill_target_70_aug_222": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    size = float(item)\n    remaining = capacities - size\n    scores = np.full_like(capacities, -np.inf, dtype=float)\n    feasible = remaining >= 0\n    if np.any(feasible):\n        fill_ratio = size / np.maximum(capacities, 1e-12)\n        target = 0.65\n        z = -(np.abs(fill_ratio - target)) * 10.0\n        logistic = 1.0 / (1.0 + np.exp(-z[feasible]))\n        penalty = 0.02 * remaining[feasible]\n        scores[feasible] = np.clip(logistic - penalty, -10.0, 10.0)\n        noise = 1e-6 * np.arange(capacities.size)\n        scores[feasible] += noise[feasible]\n        scores[feasible] = np.clip(scores[feasible], -10.0, 10.0)\n\n",
  "minimize_fractional_slack_squared_aug_223": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Avoid division by zero and keep fractions in a safe range\n    frac = slack / np.maximum(bins, 1e-12)\n    frac = np.clip(frac, 0.0, 1.0)\n\n    # Square the fraction (tightness) and add a tiny noise\n    score = -np.square(frac)\n    noise = 1e-7 * np.arange(len(bins), dtype=float)\n    score += noise\n\n    # Infeasible bins receive -inf\n    score = np.where(slack < 0, -np.inf, score)\n    return score\n\n",
  "minimize_fractional_slack_squared_aug_224": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Compute the fraction of remaining capacity\n    frac = slack / np.maximum(bins, 1e-12)\n    frac = np.clip(frac, 0.0, 1.0)\n\n    # Apply a tunable weight mix between slack and fill\u2011ratio\n    score = -(0.6 * np.square(frac) + 0.4 * np.square(1.0 - frac))\n\n    # Small deterministic noise to break ties\n    score += 5e-8 * np.arange(len(bins), dtype=float)\n\n    # Mark infeasible bins\n    score = np.where(slack < 0, -np.inf, score)\n    return score\n\n",
  "minimize_fractional_slack_squared_aug_225": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Fraction of slack relative to bin size\n    frac = slack / np.maximum(bins, 1e-12)\n    frac = np.clip(frac, 0.0, 1.0)\n\n    # Soft\u2011min: larger slack \u2192 higher probability (negative score)\n    score = -np.exp(-10.0 * np.square(frac))\n\n    # Infeasible bins are set to -inf\n    score = np.where(slack < 0, -np.inf, score)\n    return score\n\n",
  "minimize_fractional_slack_squared_aug_226": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Compute raw scores using a list comprehension\n    raw_scores = [\n        -( ((b - item) / max(b, 1e-12)) ** 2 ) if b >= item else -np.inf\n        for b in bins\n    ]\n\n    # Convert to an array, clip to a safe range, and add deterministic noise\n    score = np.array(raw_scores, dtype=float)\n    score = np.clip(score, -1.0, 0.0)\n    score += 2e-7 * np.arange(len(bins), dtype=float)\n    return score\n\n",
  "sawtooth_modulo_item_multiple_bias_aug_227": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    eps = 1e-12\n\n    # Clip bins to avoid overflow and compute slack\n    clipped_bins = np.clip(bins, 0, 1e9)\n    slack = clipped_bins - item\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n\n    if feasible.any() and item > eps:\n        # Use floor to avoid rounding errors\n        k = np.floor((slack[feasible] + eps) / (item + eps))\n        dist = np.abs(slack[feasible] - k * item)\n        dist = np.clip(dist, 0, 1e6)\n\n        # Weight slack more heavily\n        score[feasible] = -dist - 0.10 * np.clip(slack[feasible], 0, 1e6)\n\n        # Deterministic noise for tie\u2011breaking\n        noise = np.arange(len(slack)) * 1e-8\n        score += noise\n\n    return score\n\n",
  "sawtooth_modulo_item_multiple_bias_aug_228": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    eps = 1e-12\n\n    slack = bins - item\n    feasible = slack >= 0\n    # Clip slack to avoid overflow\n    slack = np.clip(slack, 0, 1e9)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if feasible.any() and item > eps:\n        # Compute k and distance using list comprehension\n        k_list = [np.round((s + eps) / (item + eps)) for s in slack[feasible]]\n        dist_list = [abs(s - k * item) for s, k in zip(slack[feasible], k_list)]\n        dist_list = [min(d, 1e6) for d in dist_list]\n\n        # Assign scores\n        score[feasible] = [-d - 0.20 * min(s, 1e6)\n                           for d, s in zip(dist_list, slack[feasible])]\n\n        # Add deterministic noise\n        noise = np.sin(np.arange(len(slack))) * 1e-7\n        score += noise\n\n    return score\n\n",
  "sawtooth_modulo_item_multiple_bias_aug_229": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    eps = 1e-12\n\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n\n    if feasible.any() and item > eps:\n        k = np.round((slack[feasible] + eps) / (item + eps))\n        dist = np.abs(slack[feasible] - k * item)\n        dist = np.clip(dist, 0, 1e6)\n\n        # Soften the penalty with tanh\n        score[feasible] = -np.tanh(dist + 0.05 * slack[feasible])\n\n        # Deterministic noise from a fixed RNG seed\n        rng = np.random.default_rng(42)\n        noise = rng.normal(0, 1e-8, size=slack.shape)\n        score += noise\n\n    return score\n\n",
  "sawtooth_modulo_item_multiple_bias_aug_230": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    eps = 1e-12\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    for idx, b in enumerate(bins):\n        slack = b - item\n        if slack >= 0 and item > eps:\n            k = np.round((slack + eps) / (item + eps))\n            dist = abs(slack - k * item)\n            dist = np.clip(dist, 0, 1e6)\n\n            score[idx] = -dist - 0.08 * np.clip(slack, 0, 1e6)\n\n            # Deterministic noise\n            score[idx] += (idx % 2) * 1e-9\n\n    return score\n\n",
  "prefer_power_of_two_fraction_remainder_aug_231": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    piece = float(item)\n    remaining = capacities - piece\n    remaining = np.clip(remaining, 0, None)  # avoid negative fractions\n    score = np.full_like(capacities, -np.inf, dtype=float)\n    is_feasible = remaining >= 0\n    if np.any(is_feasible):\n        denom = np.maximum(capacities[is_feasible], 1e-12)\n        frac = remaining[is_feasible] / denom\n        targets = np.array([0.5, 0.25, 0.125, 0.0625, 0.03125], dtype=float)\n        d = np.min(np.abs(frac[:, None] - targets[None, :]), axis=1)\n        # slightly altered weight for slack\n        score[is_feasible] = -d - 0.025 * remaining[is_feasible]\n    return score\n\n",
  "prefer_power_of_two_fraction_remainder_aug_232": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    piece = float(item)\n    remaining = capacities - piece\n    remaining = np.clip(remaining, 0, None)\n    score = np.full_like(capacities, -np.inf, dtype=float)\n    mask = remaining >= 0\n    if np.any(mask):\n        denom = np.maximum(capacities[mask], 1e-12)\n        frac = remaining[mask] / denom\n        targets = np.array([0.5, 0.25, 0.125, 0.0625, 0.03125], dtype=float)\n        diff = np.abs(frac[:, None] - targets[None, :])\n        # use mean instead of min for aggregation\n        d = np.mean(diff, axis=1)\n        # deterministic noise for tie\u2011breaking\n        noise = 1e-6 * np.arange(len(capacities))\n        score[mask] = -d - 0.02 * remaining[mask] + noise[mask]\n    return score\n\n",
  "prefer_power_of_two_fraction_remainder_aug_233": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    piece = float(item)\n    remaining = capacities - piece\n    remaining = np.clip(remaining, 0, None)\n    score = np.full_like(capacities, -np.inf, dtype=float)\n    targets = np.array([0.5, 0.25, 0.125, 0.0625, 0.03125], dtype=float)\n\n    for idx, cap in enumerate(capacities):\n        if remaining[idx] < 0:\n            continue\n        denom = max(cap, 1e-12)\n        frac = remaining[idx] / denom\n        diff = np.abs(frac - targets)\n        # sum of squared differences as alternative aggregation\n        d = np.sum(diff ** 2)\n        score[idx] = -d - 0.015 * remaining[idx]\n\n    # clip final scores to keep them within a reasonable range\n    score = np.clip(score, -5, 0)\n    return score\n\n",
  "prefer_power_of_two_fraction_remainder_aug_234": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    piece = float(item)\n    remaining = capacities - piece\n    remaining = np.clip(remaining, 0, None)\n    score = np.full_like(capacities, -np.inf, dtype=float)\n    mask = remaining >= 0\n    if np.any(mask):\n        denom = np.maximum(capacities[mask], 1e-12)\n        frac = remaining[mask] / denom\n        targets = np.array([0.5, 0.25, 0.125, 0.0625, 0.03125], dtype=float)\n        d = np.min(np.abs(frac[:, None] - targets[None, :]), axis=1)\n        # softmin weighting via log of exponential\n        weight = np.exp(-d - 0.02 * remaining[mask])\n        score[mask] = np.log(weight + 1e-12)  # higher (less negative) is better\n        # deterministic random noise for tie\u2011breaking\n        rng = np.random.default_rng(42)\n        noise = rng.normal(0, 1e-6, size=mask.sum())\n        score[mask] += noise\n    return score\n\n",
  "two_sided_guard_band_slack_aug_235": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacity_left = np.asarray(bins, dtype=float)\n    item_size = float(item)\n\n    slack_space = capacity_left - item_size\n    score_arr = np.full_like(capacity_left, -np.inf, dtype=float)\n\n    feasible_mask = slack_space >= 0\n    if feasible_mask.any():\n        s = slack_space[feasible_mask]\n        hi = np.quantile(s, 0.75)\n        lo = 0.25 * item_size\n        center = 0.5 * (lo + hi)\n        center = np.clip(center, 0, np.max(capacity_left))\n\n        # Avoid division by zero \u2013 add epsilon to the denominator\n        ratio = slack_space / (item_size + 1e-12)\n        ratio = np.clip(ratio, 0, 1)\n\n        # Core scoring: penalty for distance from the centre plus a ratio bonus\n        score_arr[feasible_mask] = (\n            -np.abs(slack_space[feasible_mask] - center)\n            - 0.3 * (1 - ratio[feasible_mask])\n        )\n\n        # Deterministic noise for tie\u2011breaking\n        noise = 1e-6 * np.arange(len(capacity_left))\n        score_arr += noise\n\n    return score_arr\n\n",
  "two_sided_guard_band_slack_aug_236": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    slack = caps - itm\n    scores = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        lo = 0.15 * itm\n        hi = np.median(s)          # proxy for a high percentile\n        center = 0.5 * (lo + hi)\n        center = np.clip(center, 0, np.max(caps))\n\n        # Stronger penalty for distance from the centre\n        scores[feasible] = -1.5 * np.abs(slack[feasible] - center)\n\n        # Deterministic random noise (fixed seed for reproducibility)\n        rng = np.random.default_rng(42)\n        noise = 1e-8 * rng.random(len(caps))\n        scores += noise\n\n    return scores\n\n",
  "two_sided_guard_band_slack_aug_237": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    slack = bins_arr - itm\n    scores = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        lo = 0.2 * itm\n        hi = np.quantile(s, 0.8)\n        center = 0.5 * (lo + hi)\n        center = np.clip(center, 0, np.max(bins_arr))\n\n        # Squared distance penalty\n        scores[feasible] = -np.square(slack[feasible] - center)\n\n        # Quadratic deterministic noise\n        noise = 1e-7 * np.arange(len(bins_arr))**2\n        scores += noise\n\n        # Deterministic top\u2011k selection (k = 3)\n        top_k = 3\n        rng = np.random.default_rng(999)\n        perm = rng.permutation(len(bins_arr))\n        top_indices = perm[:top_k]\n        mask = np.ones_like(scores, dtype=bool)\n        mask[top_indices] = True\n        scores[~mask] = -np.inf\n\n    return scores\n\n",
  "two_sided_guard_band_slack_aug_238": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    cap = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    slack = cap - itm\n    scores = np.full_like(cap, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        lo = 0.2 * itm\n        hi = np.percentile(s, 80) + 1e-12  # proxy with epsilon\n        center = 0.5 * (lo + hi)\n        center = np.clip(center, 0, np.max(cap))\n\n        diff = np.abs(slack - center)\n        # Denominator includes epsilon to avoid division by zero\n        scores[feasible] = -diff / (1 + diff + 1e-12)\n\n        # Sinusoidal deterministic noise for tie\u2011breaking\n        noise = 1e-9 * np.sin(np.arange(len(cap)))\n        scores += noise\n\n    return scores\n\n",
  "harmonic_slack_capped_aug_239": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack = bins_arr - float(item)\n    eps = 1e-12\n    raw = 1.0 / (slack + eps)\n    raw = np.where(slack < 0, -np.inf, raw)\n    finite_mask = np.isfinite(raw)\n    if finite_mask.any():\n        cap = np.quantile(raw[finite_mask], 0.95)\n        raw[finite_mask] = np.clip(raw[finite_mask], None, cap)\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(raw.size) * 1e-9\n    return raw + noise\n\n",
  "harmonic_slack_capped_aug_240": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack = bins_arr - float(item)\n    eps = 1e-8\n    inv = 1.0 / (slack + eps)\n    inv = np.where(slack < 0, -np.inf, inv)\n    # softmin\u2011style scaling \u2013 higher values still mean better priority\n    raw = np.exp(inv * 0.8)\n    cap = np.quantile(raw[np.isfinite(raw)], 0.97)\n    raw = np.clip(raw, None, cap)\n    # deterministic noise\n    noise = np.linspace(0, 1e-8, raw.size)\n    return raw + noise\n\n",
  "harmonic_slack_capped_aug_241": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    rng = np.random.default_rng(42)\n    bins_arr = np.asarray(bins, dtype=float)\n    slack = bins_arr - float(item)\n    eps = 1e-12\n    raw = 1.0 / (slack ** 2 + eps)\n    raw = np.where(slack < 0, -np.inf, raw)\n    finite_mask = np.isfinite(raw)\n    if finite_mask.any():\n        cap = np.median(raw[finite_mask])\n        raw[finite_mask] = np.minimum(raw[finite_mask], cap)\n    # random tie\u2011breaking among the top 7 priorities\n    top_k = 7\n    indices = np.argsort(-raw)[:top_k]\n    noise = rng.uniform(-1e-9, 1e-9, raw.size)\n    raw[indices] += noise[indices]\n    return raw\n\n",
  "harmonic_slack_capped_aug_242": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack = bins_arr - float(item)\n    eps = 1e-12\n    raw = np.where(slack < 0, -np.inf, 1.0 / np.sqrt(slack + eps))\n    finite_mask = np.isfinite(raw)\n    if finite_mask.any():\n        cap = np.mean(raw[finite_mask]) * 2.0  # scaling factor\n        raw[finite_mask] = np.clip(raw[finite_mask], None, cap)\n    # deterministic noise for tie\u2011breaking\n    noise = np.linspace(0, 1e-10, raw.size)\n    return raw + noise\n\n",
  "sqrt_tightness_smooth_aug_243": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n\n    # Clip slack to avoid extreme values and add a tiny epsilon for numerical stability\n    slack = np.clip(capacities - float(item), 0.0, 1e6)\n\n    # Base score: higher when slack is smaller (smooth best\u2011fit)\n    score = -np.sqrt(slack + 1e-12)\n\n    # Deterministic noise for tie\u2011breaking (index\u2011based)\n    noise = 1e-6 * np.arange(len(capacities))\n    score += noise\n\n    # Infeasible bins receive -inf\n    score[capacities < item] = -np.inf\n    return score\n\n",
  "sqrt_tightness_smooth_aug_244": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - float(item)\n\n    # Apply a weight to the slack before scoring\n    weighted_slack = 0.8 * np.maximum(slack, 0.0)\n\n    # Compute score with a small epsilon inside sqrt\n    score = -np.sqrt(weighted_slack + 1e-12)\n\n    # Adjust the infeasibility threshold slightly\n    score[slack < -1e-8] = -np.inf\n    return score\n\n",
  "sqrt_tightness_smooth_aug_245": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - float(item)\n\n    # Clip slack to prevent overflow in the exponential\n    clipped = np.clip(slack, -1e2, 1e2)\n\n    # Softmin: lower slack \u2192 higher score\n    exp_neg = np.exp(-clipped / (1.0 + 1e-12))\n    score = -exp_neg\n\n    # Infeasible bins\n    score[slack < 0] = -np.inf\n    return score\n\n",
  "sqrt_tightness_smooth_aug_246": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    cap = np.asarray(bins, dtype=float)\n    slack = np.clip(cap - float(item), 0.0, 1e6)\n\n    # Weighted sqrt with a scaling factor\n    score = -0.9 * np.sqrt(slack + 1e-12)\n\n    # Sinusoidal deterministic perturbation for diversity\n    perturb = 0.05 * np.sin(np.arange(len(cap)))\n    score += perturb\n\n    # Mark infeasible bins\n    score[cap < item] = -np.inf\n    return score\n\n",
  "dynamic_alpha_tightness_by_bin_cv_aug_247": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    rem  = caps - float(item)                     # remaining capacity\n    s    = np.full_like(caps, -np.inf, dtype=float)\n\n    ok   = rem >= 0.0\n    if ok.any():\n        # coefficient of variation, clipped to [0,1]\n        cv   = np.std(caps[ok]) / (np.mean(caps[ok]) + 1e-12)\n        p    = 1.0 + 2.0 * np.clip(cv, 0.0, 1.0)\n\n        # compute score only for feasible bins\n        s[ok] = -np.power(rem[ok], p)\n\n    # deterministic noise to break ties\n    s += 1e-6 * np.arange(len(caps))\n    return s\n\n",
  "dynamic_alpha_tightness_by_bin_cv_aug_248": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    rem  = caps - float(item)\n    s    = np.full_like(caps, -np.inf, dtype=float)\n\n    ok   = rem >= 0.0\n    if ok.any():\n        # use median instead of mean for robustness\n        cv   = np.std(caps[ok]) / (np.median(caps[ok]) + 1e-12)\n        p    = 1.0 + 3.0 * np.clip(cv, 0.0, 1.0)\n\n        # softmin transformation\n        s[ok] = -np.exp(-np.power(rem[ok], p))\n\n    # deterministic noise for tie\u2011breaking\n    s += 1e-8 * np.arange(len(caps))\n    return s\n\n",
  "dynamic_alpha_tightness_by_bin_cv_aug_249": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    rem  = caps - float(item)\n    s    = np.full_like(caps, -np.inf, dtype=float)\n\n    ok   = rem >= 0.0\n    if ok.any():\n        cv   = np.std(caps[ok]) / (np.mean(caps[ok]) + 1e-12)\n        p    = 1.0 + 2.0 * np.clip(cv, 0.0, 1.0)\n        base = -np.power(rem, p)\n\n        # pick top\u2011k feasible bins for random noise\n        rng   = np.random.default_rng(12345)\n        top_k = 5\n        feasible_idx = np.where(ok)[0]\n        if feasible_idx.size > 0:\n            # sort by score (higher is better)\n            sorted_idx = feasible_idx[np.argsort(base[feasible_idx])[::-1]]\n            top_idx    = sorted_idx[:top_k]\n            noise      = rng.standard_normal(top_k) * 1e-6\n            base[top_idx] += noise\n\n        s = base\n\n    return s\n\n",
  "dynamic_alpha_tightness_by_bin_cv_aug_250": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    rem  = caps - float(item)\n    s    = np.full_like(caps, -np.inf, dtype=float)\n\n    ok   = rem >= 0.0\n    if ok.any():\n        # approximate standard deviation using squared deviations\n        mean_cap = np.mean(caps[ok]) + 1e-12\n        std_approx = np.sqrt(np.mean(np.square(caps[ok] - mean_cap)))\n        cv = std_approx / (mean_cap + 1e-12)\n        p  = 1.0 + 2.0 * np.clip(cv, 0.0, 1.0)\n\n        # use squared slack in the exponent\n        s[ok] = -(np.square(rem[ok]) ** p)\n\n    # tiny deterministic noise for tie\u2011breaking\n    s += 1e-9 * np.arange(len(caps))\n    return s\n\n",
  "middle_capacity_preference_with_tightness_aug_251": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    slack = capacities - float(item)\n    score = np.full_like(capacities, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if np.any(feasible):\n        feasible_caps = capacities[feasible]\n        med = np.median(feasible_caps)\n        # weighted penalty with epsilon to avoid division by zero\n        penalty = 0.25 * slack[feasible] / (1.0 + 1e-12)\n        score[feasible] = -np.abs(feasible_caps - med) - penalty\n    return score\n\n",
  "middle_capacity_preference_with_tightness_aug_252": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - float(item)\n    score = np.full_like(caps, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if np.any(feasible):\n        f_caps = caps[feasible]\n        mean_cap = np.mean(f_caps)\n        penalty = 0.35 * slack[feasible] / (1.0 + 1e-12)\n        # deterministic noise based on index to break ties\n        noise = 1e-6 * np.arange(len(caps))\n        score[feasible] = -np.abs(f_caps - mean_cap) - penalty + noise[feasible]\n    return score\n\n",
  "middle_capacity_preference_with_tightness_aug_253": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacity = np.asarray(bins, dtype=float)\n    slack = capacity - float(item)\n    score = np.full_like(capacity, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if np.any(feasible):\n        f_cap = capacity[feasible]\n        med = np.median(f_cap)\n        penalty = 0.2 * slack[feasible] / (1.0 + 1e-12)\n        max_slack = np.max(slack[feasible])\n        penalty += 0.1 * max_slack / (1.0 + 1e-12)\n        raw = -np.abs(f_cap - med) - penalty\n        # deterministic noise\n        noise = 1e-7 * np.arange(len(capacity))\n        score[feasible] = raw + noise[feasible]\n    return score\n\n",
  "middle_capacity_preference_with_tightness_aug_254": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bin_caps = np.asarray(bins, dtype=float)\n    n = len(bin_caps)\n    score = np.full(n, -np.inf, dtype=float)\n\n    # Compute median of feasible bins once\n    feasible_mask = bin_caps >= float(item)\n    med = np.median(bin_caps[feasible_mask]) if np.any(feasible_mask) else 0.0\n\n    i = 0\n    while i < n:\n        cap = bin_caps[i]\n        slack = cap - float(item)\n        if slack >= 0:\n            penalty = 0.25 * slack / (1.0 + 1e-12)\n            raw = -np.abs(cap - med) - penalty\n            # softmin-inspired transformation (kept as raw for ranking)\n            score[i] = raw + 1e-6 * i  # deterministic tie\u2011breaker\n        i += 1\n    return score\n\n",
  "reserve_bottom_quartile_for_small_items_aug_255": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    size = float(item)\n\n    # Compute slack space for each bin\n    slack_space = capacities - size\n    score_arr = np.full_like(capacities, -np.inf, dtype=float)\n\n    # Identify feasible bins\n    feasible_mask = slack_space >= 0\n    if np.any(feasible_mask):\n        # Base score: negative slack (best fit)\n        base_scores = -slack_space[feasible_mask]\n        score_arr[feasible_mask] = base_scores\n\n        # Small\u2011item rule\n        feasible_caps = capacities[feasible_mask]\n        q25 = np.quantile(feasible_caps, 0.25)\n        max_cap = np.max(feasible_caps) + 1e-12\n        small_flag = size <= 0.12 * max_cap\n\n        if small_flag:\n            small_bins_mask = feasible_mask & (capacities <= q25)\n            penalty = 0.5 * (q25 - capacities[small_bins_mask])\n            score_arr[small_bins_mask] -= penalty\n\n        # Deterministic tie\u2011breaking noise\n        noise = np.arange(len(capacities)) * 1e-6\n        score_arr += noise\n\n    return score_arr\n\n",
  "reserve_bottom_quartile_for_small_items_aug_256": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    slack = caps - itm\n    scores = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Weighted slack penalty (more aggressive)\n        scores[feasible] = -0.8 * slack[feasible]\n\n        # Estimate 25th percentile via sorted slice\n        half = int(np.ceil(np.sum(feasible) / 2))\n        sorted_caps = np.sort(caps[feasible])\n        q25 = sorted_caps[half - 1] if half > 0 else 0.0\n\n        max_cap = np.max(sorted_caps) + 1e-12\n        small = itm <= 0.2 * max_cap\n\n        if small:\n            small_bins = feasible & (caps <= q25)\n            penalty = 0.7 * np.clip(q25 - caps[small_bins], 0, None)\n            scores[small_bins] -= penalty\n\n    return scores\n\n",
  "reserve_bottom_quartile_for_small_items_aug_257": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    slack = caps - itm\n    scores = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        scores[feasible] = -slack[feasible]\n\n        max_cap = np.max(caps[feasible]) + 1e-12\n        small = itm <= 0.15 * max_cap\n        if small:\n            q25 = np.quantile(caps[feasible], 0.25)\n            small_bins = feasible & (caps <= q25)\n            scores[small_bins] -= 0.6 * (q25 - caps[small_bins])\n\n        # Keep only the top\u2011k bins (k=5)\n        k = 5\n        if np.sum(feasible) > k:\n            topk_idx = np.argpartition(scores, -k)[-k:]\n            mask_topk = np.zeros_like(scores, dtype=bool)\n            mask_topk[topk_idx] = True\n            scores[~mask_topk] = -np.inf\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(len(caps)) * 1e-7\n    scores += noise\n    return scores\n\n",
  "reserve_bottom_quartile_for_small_items_aug_258": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    scores = np.full_like(caps, -np.inf, dtype=float)\n\n    # Loop\u2011based implementation with inverted logic\n    for idx, cap in enumerate(caps):\n        slack = cap - itm\n        if slack < 0:\n            continue\n\n        # Weighted slack penalty\n        scores[idx] = -0.6 * slack\n\n        # Small\u2011item rule\n        cap_ref = np.max(caps) + 1e-12\n        if itm <= 0.18 * cap_ref:\n            q25 = np.quantile(caps, 0.25)\n            if cap <= q25:\n                penalty = 0.4 * np.clip(q25 - cap, 0, None)\n                scores[idx] -= penalty\n\n    # Clip to avoid extreme values\n    scores = np.clip(scores, -1e9, 1e9)\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(len(caps)) * 1e-6\n    scores += noise\n\n    return scores\n\n",
  "quadrant_rule_high_fill_or_low_waste_aug_259": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    remaining = capacities - float(item)\n    score = np.full_like(capacities, -np.inf, dtype=float)\n    feasible = remaining >= 0\n    if np.any(feasible):\n        fill_rate = float(item) / np.maximum(capacities, 1e-12)\n        p25 = np.quantile(remaining[feasible], 0.25)\n        good = (fill_rate >= 0.90) | (remaining <= p25)\n        score[feasible] = -remaining[feasible]\n        score[feasible & good] += 0.3\n        rng = np.random.default_rng(42)\n        noise = rng.normal(loc=0.0, scale=1e-6, size=capacities.shape)\n        score += noise\n        score = np.clip(score, -np.inf, 0.0)\n    return score\n\n",
  "quadrant_rule_high_fill_or_low_waste_aug_260": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    remaining = capacities - float(item)\n    score = np.full_like(capacities, -np.inf, dtype=float)\n    feasible = remaining >= 0\n    if np.any(feasible):\n        fill_rate = float(item) / np.maximum(capacities, 1e-12)\n        p30 = np.quantile(remaining[feasible], 0.30)\n        good = (fill_rate >= 0.85) | (remaining <= p30)\n        score[feasible] = -remaining[feasible]\n        score[feasible & good] += 0.4\n        rng = np.random.default_rng(123)\n        noise = rng.normal(loc=0.0, scale=5e-7, size=capacities.shape)\n        score += noise\n        score = np.clip(score, -1.0, 0.0)\n    return score\n\n",
  "quadrant_rule_high_fill_or_low_waste_aug_261": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    remaining = capacities - float(item)\n    score = np.full_like(capacities, -np.inf, dtype=float)\n    feasible = remaining >= 0\n    if np.any(feasible):\n        fill_rate = float(item) / np.maximum(capacities, 1e-12)\n        med = np.median(remaining[feasible])\n        good = (fill_rate >= 0.88) | (remaining <= med)\n        baseline = -np.exp(-remaining[feasible])\n        score[feasible] = baseline\n        score[feasible & good] += 0.15\n        noise = np.arange(capacities.size, dtype=float) * 1e-7\n        score += noise\n        score = np.clip(score, -np.inf, 0.0)\n    return score\n\n",
  "quadrant_rule_high_fill_or_low_waste_aug_262": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    remaining = capacities - float(item)\n    score = np.full_like(capacities, -np.inf, dtype=float)\n    feasible = remaining >= 0\n    if np.any(feasible):\n        fill_rate = float(item) / np.maximum(capacities, 1e-12)\n        idx = int(np.floor(0.25 * feasible.sum()))\n        sorted_rem = np.sort(remaining[feasible])\n        p25_approx = sorted_rem[idx] if idx < sorted_rem.size else sorted_rem[-1]\n        good = (fill_rate >= 0.80) | (remaining <= p25_approx)\n        mean_slack = np.mean(remaining[feasible])\n        score[feasible] = -remaining[feasible] + 0.05 * mean_slack\n        score[feasible & good] += 0.2\n        rng = np.random.default_rng(7)\n        noise = rng.uniform(-1e-6, 1e-6, size=capacities.shape)\n        score += noise\n        score = np.clip(score, -np.inf, 0.0)\n    return score\n\n",
  "projected_pairing_probability_exp_aug_263": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item\n    feasible = slack >= 0\n\n    # initialise with a very low score for infeasible bins\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # avoid division by zero and use a small epsilon\n        scale = max(item, 1e-9) + 1e-12\n        sim = np.exp(-((slack[feasible] - item) / scale) ** 2)\n        # stronger slack penalty than the original\n        score[feasible] = sim - 0.05 * slack[feasible]\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(len(bins))\n    score += noise\n\n    # bound the scores to avoid extreme values\n    score = np.clip(score, -10.0, 10.0)\n    return score\n\n",
  "projected_pairing_probability_exp_aug_264": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    idx = 0\n    while idx < len(bins):\n        s = slack[idx]\n        if s >= 0:\n            # epsilon added to the scale denominator\n            scale = max(item, 1e-9) + 1e-12\n            sim = np.exp(-((s - item) / scale) ** 2)\n            # modified weight for the slack penalty\n            score[idx] = sim - 0.04 * s + 1e-6 * idx\n        idx += 1\n\n    # clip to keep scores within a reasonable range\n    score = np.clip(score, -8.0, 8.0)\n    return score\n\n",
  "projected_pairing_probability_exp_aug_265": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    # ensure slack is non\u2011negative\n    slack = np.maximum(bins - item, 0.0)\n\n    # median\u2011based scaling factor with epsilon\n    scale = np.clip(np.median(np.maximum(bins, 0.0)), 1e-9, None) + 1e-12\n    if scale < 1e-9:\n        scale = 1e-9 + 1e-12\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    for i, s in enumerate(slack):\n        if s >= 0:\n            soft = np.exp(-s / scale)\n            score[i] = soft - 0.02 * s + 1e-7 * (len(bins) - i)\n\n    # keep the scores bounded\n    score = np.clip(score, -5.0, 5.0)\n    return score\n\n",
  "projected_pairing_probability_exp_aug_266": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item\n    feasible = slack >= 0\n\n    base = np.full_like(bins, -np.inf, dtype=float)\n    if np.any(feasible):\n        scale = max(item, 1e-9) + 1e-12\n        sim = np.exp(-((slack[feasible] - item) / scale) ** 2)\n        base[feasible] = sim - 0.03 * slack[feasible]\n\n    # replace -inf with a large negative number for stable exp\n    base = np.where(np.isneginf(base), -1e9, base)\n\n    # softmax normalisation with epsilon to avoid division by zero\n    max_val = np.max(base)\n    exp_vals = np.exp(base - max_val)\n    denom = np.sum(exp_vals) + 1e-12\n    score = exp_vals / denom\n\n    # deterministic noise for reproducible tie\u2011breaking\n    noise = 1e-8 * np.arange(len(bins))\n    score += noise\n\n    # clip to a valid probability range\n    score = np.clip(score, 0.0, 1.0)\n    return score\n\n",
  "temperature_scaled_boltzmann_tightness_aug_267": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n\n    # Remaining capacity in each bin\n    rem = arr - float(item)\n\n    # Start with a sentinel value\n    pr = np.full_like(arr, -np.inf, dtype=float)\n\n    # Feasible bins (slack >= 0)\n    feas = rem >= 0\n    if np.any(feas):\n        # Slack values for feasible bins\n        s = rem[feas]\n\n        # IQR based temperature with a tiny epsilon\n        q1, q3 = np.quantile(s, 0.25), np.quantile(s, 0.75)\n        T = (q3 - q1) + 1e-8\n        T = np.clip(T, 1e-12, None)\n\n        # Exponential score, clipped to avoid overflow\n        exp_term = np.exp(np.clip(-s / T, -700, 700))\n        pr[feas] = exp_term\n\n        # Deterministic tie\u2011breaking noise\n        pr[feas] += 1e-6 * np.arange(np.count_nonzero(feas))\n\n    return pr\n\n",
  "temperature_scaled_boltzmann_tightness_aug_268": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n    slack = arr - float(item)\n    score = np.full_like(arr, -np.inf, dtype=float)\n\n    feas = slack >= 0\n    if np.any(feas):\n        s = slack[feas]\n\n        # Use the median slack as a scaling factor\n        median_val = np.median(s)\n        T = median_val + 1e-7\n        T = np.clip(T, 1e-12, None)\n\n        # Soft\u2011min style score\n        exp_term = np.exp(np.clip(s / T, -700, 700))\n        softmin = 1 / (1 + exp_term)\n\n        # Deterministic noise for tie\u2011breaking\n        noise = 1e-6 * np.arange(np.count_nonzero(feas))\n        score[feas] = softmin + noise\n\n    return score\n\n",
  "temperature_scaled_boltzmann_tightness_aug_269": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n    slack = arr - float(item)\n\n    score = np.full_like(arr, -np.inf, dtype=float)\n    mask = slack >= 0\n\n    if np.any(mask):\n        s = slack[mask]\n\n        # Avoid division by zero\n        eps = 1e-12\n        inv = 1.0 / np.clip(s + eps, eps, None)\n\n        # Scale by the median slack\n        med = np.median(s) + eps\n        med = np.clip(med, eps, None)\n\n        score[mask] = inv / med\n\n        # Deterministic noise for tie\u2011breaking\n        score[mask] += 1e-7 * np.arange(np.count_nonzero(mask))\n\n    return score\n\n",
  "minimize_relative_slack_to_item_target_20pct_aug_270": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    # Compute slack, clip negative values to zero\n    slack = np.clip(bins - item, 0, None)\n\n    # Initialize scores with negative infinity\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    # Feasible bins mask\n    feasible = slack > 0\n\n    # Avoid division by zero\n    denom = item + 1e-12\n    if feasible.any() and item > 1e-12:\n        rel = slack[feasible] / denom\n        # Adjusted target slack ratio and penalty\n        target = 0.25\n        penalty = 0.03\n        base = -np.abs(rel - target) - penalty * slack[feasible]\n\n        # Deterministic tie\u2011breaking noise\n        noise = 1e-6 * np.arange(len(bins))\n        score[feasible] = base + noise[feasible]\n\n    return score\n\n",
  "minimize_relative_slack_to_item_target_20pct_aug_271": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    # Compute slack and clip negative values\n    slack = np.clip(bins - item, 0, None)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    # Invert logic: early return if no feasible bin or item too small\n    if not (slack > 0).any() or item <= 1e-12:\n        return score\n\n    # Iterate over indices with a while loop\n    idx = 0\n    n = len(bins)\n    target = 0.15  # adjusted relative slack target\n    penalty = 0.025\n\n    while idx < n:\n        if slack[idx] > 0:\n            rel = slack[idx] / (item + 1e-12)\n            score[idx] = -np.abs(rel - target) - penalty * slack[idx]\n            # Deterministic noise based on index\n            score[idx] += 1e-7 * idx\n        idx += 1\n\n    return score\n\n",
  "minimize_relative_slack_to_item_target_20pct_aug_272": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    # Compute slack and clip negative values\n    slack = np.clip(bins - item, 0, None)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack > 0\n    if not feasible.any() or item <= 1e-12:\n        return score\n\n    # Median slack of feasible bins\n    median_slack = np.median(slack[feasible]) if feasible.any() else 0.0\n    denom = item + 1e-12\n\n    # Compute scores relative to median slack\n    rel = (slack[feasible] - median_slack) / denom\n    target = 0.20\n    penalty = 0.025\n    base = -np.abs(rel - target) - penalty * slack[feasible]\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(len(bins))\n    score[feasible] = base + noise[feasible]\n\n    return score\n\n",
  "percentile_rank_slack_then_penalize_edges_aug_273": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    # Mask of bins that can accommodate the item\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Assign ranks (0 for tightest, 1 for most slack)\n        ranks = np.empty_like(slack, dtype=float)\n        order = np.argsort(slack[feasible])\n        ranks[feasible] = np.linspace(0.0, 1.0, num=order.size)\n\n        # Edge penalty: discourages bins at the extremes\n        edge = np.minimum(ranks, 1.0 - ranks)\n        edge = np.clip(edge, 0, 0.5)\n\n        # Final score: lower is better\n        score[feasible] = -(ranks + 0.2 * (0.5 - edge))\n\n    return score\n\n",
  "percentile_rank_slack_then_penalize_edges_aug_274": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    eps = 1e-12\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        n = feasible.sum()\n        # Rank from 0 (tightest) to 1 (most slack)\n        r = np.arange(n, dtype=float) / (n - 1 + eps)\n        edge = np.minimum(r, 1.0 - r)\n        edge = np.clip(edge, 0, 0.5)\n\n        # Small deterministic noise to break ties\n        rng = np.random.default_rng(42)\n        noise = 1e-6 * rng.random(r.shape)\n\n        # Adjusted weight for the edge penalty\n        score[feasible] = -(r + 0.4 * (0.5 - edge) + noise)\n\n    return score\n\n",
  "percentile_rank_slack_then_penalize_edges_aug_275": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        n = feasible.sum()\n        r = np.linspace(0.0, 1.0, num=n)\n        edge = np.minimum(r, 1.0 - r)\n\n        # Exponential proxy to mimic the original penalty shape\n        penalty = np.exp(-5.0 * (0.5 - edge))\n        penalty = np.clip(penalty, 0, 1)\n\n        score[feasible] = -(r + 0.2 * penalty)\n\n    return score\n\n",
  "percentile_rank_slack_then_penalize_edges_aug_276": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible_indices = np.where(slack >= 0)[0]\n    if feasible_indices.size:\n        remaining = feasible_indices.copy()\n        rank = 0\n        total = feasible_indices.size\n        while remaining.size:\n            # Pick the feasible bin with the smallest slack\n            idx = remaining[np.argmin(slack[remaining])]\n            r = rank / (total - 1 + 1e-12)\n            edge = np.minimum(r, 1.0 - r)\n            edge = np.clip(edge, 0, 0.5)\n            score[idx] = -(r + 0.2 * (0.5 - edge))\n\n            # Remove the chosen index and increment rank\n            remaining = remaining[remaining != idx]\n            rank += 1\n\n    return score\n\n",
  "l1_target_vector_bin_and_slack_aug_277": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n\n    # Slack is the remaining capacity after placing the item\n    slack = arr - float(item)\n\n    # Feasibility mask\n    mask = slack >= 0\n    score = np.full_like(arr, -np.inf, dtype=float)\n\n    if np.any(mask):\n        # Extract feasible values\n        f_bins = arr[mask]\n        f_slack = np.clip(slack[mask], 0, None)  # enforce non\u2011negative\n\n        # Compute means with a tiny epsilon in the denominator\n        n = f_bins.size\n        mean_bins = np.sum(f_bins) / (n + 1e-12)\n        mean_slack = np.sum(f_slack) / (n + 1e-12)\n\n        # L1 distance to the mean state\n        dist = np.abs(f_bins - mean_bins) + np.abs(f_slack - mean_slack)\n        score[mask] = -dist\n\n    return score\n\n",
  "l1_target_vector_bin_and_slack_aug_278": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n    slack = arr - float(item)\n    mask = slack >= 0\n    score = np.full_like(arr, -np.inf, dtype=float)\n\n    if np.any(mask):\n        f_bins = arr[mask]\n        f_slack = slack[mask]\n\n        # Tunable weights\n        w_bin, w_slack = 0.6, 0.4\n        median_b = np.median(f_bins)\n        median_s = np.median(f_slack)\n\n        # Weighted distance, normalised by the sum of weights\n        raw = w_bin * np.abs(f_bins - median_b) + w_slack * np.abs(f_slack - median_s)\n        dist = raw / (w_bin + w_slack + 1e-12)\n\n        # Clip to avoid extreme values\n        dist = np.clip(dist, 0, 1e6)\n        score[mask] = -dist\n\n    return score\n\n",
  "l1_target_vector_bin_and_slack_aug_279": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n    slack = arr - float(item)\n    mask = slack >= 0\n    score = np.full_like(arr, -np.inf, dtype=float)\n\n    if np.any(mask):\n        f_bins = arr[mask]\n        f_slack = slack[mask]\n\n        # Mean with epsilon\u2011protected denominator\n        mean_b = np.sum(f_bins) / (f_bins.size + 1e-12)\n        mean_s = np.sum(f_slack) / (f_slack.size + 1e-12)\n\n        # Deterministic noise (seeded RNG)\n        rng = np.random.default_rng(seed=42)\n        noise = rng.normal(scale=1e-4, size=f_bins.size)\n\n        dist = np.abs(f_bins - mean_b) + np.abs(f_slack - mean_s) + noise\n        dist = np.clip(dist, 0, 1e6)\n        score[mask] = -dist\n\n    return score\n\n",
  "l1_target_vector_bin_and_slack_aug_280": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    arr = np.asarray(bins, dtype=float)\n    slack = arr - float(item)\n    mask = slack >= 0\n    score = np.full_like(arr, -np.inf, dtype=float)\n\n    if np.any(mask):\n        f_bins = arr[mask]\n        f_slack = slack[mask]\n\n        # Mean values for distance calculation\n        mean_b = np.sum(f_bins) / (f_bins.size + 1e-12)\n        mean_s = np.sum(f_slack) / (f_slack.size + 1e-12)\n\n        dist = np.abs(f_bins - mean_b) + np.abs(f_slack - mean_s)\n        dist = np.clip(dist, 0, 1e6)\n\n        # Top\u2011k selection (k = 5 or fewer if not enough bins)\n        top_k = min(5, dist.size)\n        idx_sorted = np.argsort(dist)\n        top_idx = idx_sorted[:top_k]\n\n        # Random tie\u2011breaking noise\n        rng = np.random.default_rng(seed=7)\n        noise = rng.uniform(0, 1e-4, size=top_k)\n        dist[top_idx] += noise\n\n        # Assign scores only for the chosen top\u2011k bins\n        score[mask] = -np.inf\n        score[mask][top_idx] = -dist[top_idx]\n\n    return score\n\n",
  "bimodal_preference_tight_or_roomy_aug_281": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack = bins_arr - float(item)\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    indices = np.where(slack >= 0)[0]\n    if indices.size:\n        s = slack[indices]\n        p20, p80 = np.percentile(s, [30, 70])          # different percentile cut\u2011offs\n        max_s = np.max(s)\n        median_s = np.median(s)\n        std_s = np.std(s)\n\n        i = 0\n        while i < indices.size:\n            idx = indices[i]\n            val = slack[idx]\n            if val <= p20:\n                sc = 1.0 - (val / (p20 + 1e-12))\n            elif val >= p80:\n                sc = 0.5 + (val - p80) / (max_s - p80 + 1e-12)\n            else:\n                sc = -0.5 - np.abs(val - median_s) / (std_s + 1e-12)\n            # deterministic noise for tie\u2011breaking\n            sc += 1e-8 * idx\n            score[idx] = np.clip(sc, -1.0, 1.0)\n            i += 1\n\n    return score\n\n",
  "inverse_capacity_weighted_tightness_aug_282": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    cap = np.asarray(bins, dtype=float)\n    rem = cap - float(item)\n    # Clip negative slack to zero \u2013 this keeps the array safe for later ops\n    rem = np.clip(rem, 0, None)\n    scores = np.full_like(cap, -np.inf, dtype=float)\n    can_fit = rem >= 0\n    if np.any(can_fit):\n        # Inverse capacity with a tiny epsilon to avoid division by zero\n        inv_cap = 1.0 / (cap[can_fit] + 1e-12)\n        max_inv = np.max(inv_cap)\n        # Parameter tuning: use weight 4.0 instead of 5.0\n        scores[can_fit] = -rem[can_fit] * (1.0 + 4.0 * (1.0 - inv_cap / max_inv))\n        # Deterministic noise for tie\u2011breaking\n        noise = 1e-8 * np.arange(cap.size)\n        scores += noise\n    # Clip scores to a reasonable range to avoid overflow\n    scores = np.clip(scores, -1e10, 0)\n    return scores\n\n",
  "inverse_capacity_weighted_tightness_aug_283": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bin_caps = np.asarray(bins, dtype=float)\n    n = bin_caps.size\n    score_arr = np.full(n, -np.inf, dtype=float)\n    i = 0\n    rng = np.random.default_rng(seed=42)  # deterministic random noise\n    while i < n:\n        cap = bin_caps[i]\n        remaining = cap - float(item)\n        if remaining >= 0:\n            inv_cap = 1.0 / (cap + 1e-12)\n            max_inv = 1.0 / (np.max(bin_caps) + 1e-12)\n            # Parameter tuning: weight 3.5 instead of 5.0\n            base_score = -remaining * (1.0 + 3.5 * (1.0 - inv_cap / max_inv))\n            # Random noise for tie\u2011breaking\n            noise = rng.uniform(-1e-8, 1e-8)\n            score_arr[i] = base_score + noise\n        i += 1\n    # Clip scores to avoid extreme values\n    score_arr = np.clip(score_arr, -1e10, 0)\n    return score_arr\n\n",
  "inverse_capacity_weighted_tightness_aug_284": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    cap = np.asarray(bins, dtype=float)\n    rem = cap - float(item)\n    # Clip negative slack to zero for safety\n    rem = np.clip(rem, 0, None)\n    scores = np.full_like(cap, -np.inf, dtype=float)\n    feasible = rem >= 0\n    if np.any(feasible):\n        # Proxy approximation for inverse capacity using safe division\n        inv_cap = np.divide(1.0, cap + 1e-12, out=np.zeros_like(cap), where=cap > 0)\n        # Use median instead of max for scaling\n        med_inv = np.median(inv_cap[feasible])\n        # Parameter tuning: weight 4.2 instead of 5.0\n        scores[feasible] = -rem[feasible] * (1.0 + 4.2 * (1.0 - inv_cap[feasible] / (med_inv + 1e-12)))\n        # Deterministic noise for tie\u2011breaking\n        noise = 1e-9 * np.linspace(1, cap.size, cap.size)\n        scores += noise\n    # Clip to a safe range\n    scores = np.clip(scores, -1e9, 0)\n    return scores\n\n",
  "inverse_capacity_weighted_tightness_aug_285": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    # Original slack before clipping \u2013 used to identify infeasible bins\n    slack_orig = caps - float(item)\n    # Clip negative slack to zero for safe downstream calculations\n    slack = np.clip(slack_orig, 0, None)\n    # Inverse capacity with safe division\n    inv_caps = np.divide(1.0, caps + 1e-12, out=np.zeros_like(caps), where=caps > 0)\n    max_inv = np.max(inv_caps)\n    # Parameter tuning: weight 6.0 instead of 5.0\n    base = -slack * (1.0 + 6.0 * (1.0 - inv_caps / (max_inv + 1e-12)))\n    # Deterministic noise for tie\u2011breaking\n    noise = 5e-9 * np.arange(caps.size)\n    scores = base + noise\n    # Mark truly infeasible bins with -inf\n    scores = np.where(slack_orig >= 0, scores, -np.inf)\n    # Final clipping to avoid overflow\n    scores = np.clip(scores, -1e12, 0)\n    return scores\n\n",
  "gini_like_balance_proxy_aug_286": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    weight = float(item)\n\n    slack = capacities - weight\n    feasible_mask = slack >= 0\n\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if np.any(feasible_mask):\n        s = slack[feasible_mask]\n        med = np.median(s)\n        q1, q3 = np.quantile(s, 0.25), np.quantile(s, 0.75)\n        iqr = (q3 - q1) + 1e-12          # epsilon to avoid division by zero\n        z = np.abs(s - med) / iqr\n        z = np.clip(z, 0, 1)              # bound to avoid extreme values\n        # deterministic tie\u2011breaker\n        noise = 1e-9 * np.arange(capacities.size)\n        score[feasible_mask] = -z - 0.02 * s + noise\n\n    return score\n\n",
  "gini_like_balance_proxy_aug_287": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    w = float(item)\n\n    slack = caps - w\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feas = slack >= 0\n    if np.any(feas):\n        s = slack[feas]\n        mean_slack = np.mean(s)\n        std_slack = np.std(s) + 1e-12   # epsilon\n        z = np.abs(s - mean_slack) / std_slack\n        z = np.clip(z, 0, 1)             # bound values\n        # deterministic noise for tie\u2011breaking\n        noise = 1e-9 * np.arange(caps.size)\n        score[feas] = -z - 0.015 * s + noise\n\n    return score\n\n",
  "gini_like_balance_proxy_aug_288": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    w = float(item)\n\n    slacks = caps - w\n    scores = np.full_like(caps, -np.inf, dtype=float)\n    iqr_eps = 1e-12\n\n    for idx, slack in enumerate(slacks):\n        if slack < 0:\n            continue\n\n        feas_slack = slacks[slacks >= 0]\n        med = np.median(feas_slack)\n        q1 = np.quantile(feas_slack, 0.25)\n        q3 = np.quantile(feas_slack, 0.75)\n        iqr = (q3 - q1) + iqr_eps\n\n        z = np.abs(slack - med) / iqr\n        z = np.clip(z, 0, 1)\n\n        # deterministic noise\n        scores[idx] = -z - 0.02 * slack + 1e-8 * idx\n\n    return scores\n\n",
  "minimize_slack_times_capacity_deviation_aug_289": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Determine feasible bins\n    feasible = slack >= 0\n\n    # Base score array\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if feasible.any():\n        # Median of the feasible bins (with epsilon)\n        medb = np.median(bins[feasible]) + 1e-12\n\n        # Relative deviation with deterministic noise\n        dev = np.abs(bins[feasible] - medb) / (medb + 1e-12)\n        dev += 1e-8 * np.arange(len(dev))          # deterministic tie\u2011breaker\n        dev = np.clip(dev, 0, 1)                    # keep dev in a sane range\n\n        # Compute priority scores\n        score[feasible] = -slack[feasible] * (1.0 + 0.6 * dev)\n\n    return score\n\n",
  "minimize_slack_times_capacity_deviation_aug_290": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    n = bins.size\n    score = np.full(n, -np.inf, dtype=float)\n\n    # Manual loop to collect feasible indices\n    feasible_indices = []\n    i = 0\n    while i < n:\n        if bins[i] - item >= 0:\n            feasible_indices.append(i)\n        i += 1\n\n    if feasible_indices:\n        feas_bins = bins[feasible_indices]\n        # Use the mean instead of the median\n        medb = np.mean(feas_bins) + 1e-12\n        dev = np.abs(feas_bins - medb) / (medb + 1e-12)\n        dev = np.clip(dev, 0, 1)\n        slack = feas_bins - item\n        score[feasible_indices] = -slack * (1.0 + 0.4 * dev)\n\n    return score\n\n",
  "minimize_slack_times_capacity_deviation_aug_291": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    feasible_mask = bins >= item\n    feasible_bins = bins[feasible_mask]\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if feasible_bins.size:\n        # Median of feasible bins\n        medb = np.median(feasible_bins) + 1e-12\n\n        # Deviation as a summed absolute difference\n        dev = np.sum(np.abs(feasible_bins - medb)) / (medb + 1e-12)\n        dev = np.clip(dev, 0, 2)   # allow a larger range\n\n        slack = feasible_bins - item\n        # Add deterministic noise to the final score\n        noise = 1e-7 * np.arange(feasible_bins.size)\n        score[feasible_mask] = -slack * (1.0 + 0.7 * dev) + noise\n\n    return score\n\n",
  "minimize_slack_times_capacity_deviation_aug_292": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Feasibility mask\n    feasible = slack >= 0\n\n    # Base score array\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if feasible.any():\n        # Median of the feasible bins (with epsilon)\n        medb = np.median(bins[feasible]) + 1e-12\n\n        # Relative deviation, clipped and with deterministic noise\n        dev = np.abs(bins[feasible] - medb) / (medb + 1e-12)\n        dev = np.clip(dev, 0, 1)\n        dev += 2e-8 * np.arange(len(dev))\n\n        # Compute priority scores with a lighter weight\n        score[feasible] = -slack[feasible] * (1.0 + 0.3 * dev)\n\n    return score\n\n",
  "softmaxed_best_fit_temperature_by_scale_aug_293": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    free_space = bins - float(item)          # renamed slack \u2192 free_space\n    scores = np.full_like(bins, -np.inf, dtype=float)\n\n    # Feasible bins are those with non\u2011negative free space\n    feasible = free_space >= 0\n    if np.any(feasible):\n        fs = free_space[feasible]\n        # Scaling factor: mean of free space plus tiny epsilon\n        scale = np.mean(fs) + 1e-12\n        # Compute log\u2011scores: -free_space / scale\n        raw = -fs / scale\n        # Add deterministic noise to break ties\n        noise = 1e-6 * np.arange(fs.size)\n        raw += noise\n        # Clip to avoid extreme values\n        raw = np.clip(raw, -1e6, 0)\n        scores[feasible] = raw\n    return scores\n\n",
  "softmaxed_best_fit_temperature_by_scale_aug_294": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    scores = np.full_like(bins, -np.inf, dtype=float)\n\n    # Pre\u2011compute the scaling factor using all bins\n    free_space = bins - float(item)\n    scale = (np.mean(free_space[free_space >= 0]) + 1e-12)\n\n    idx = 0\n    while idx < bins.size:\n        if free_space[idx] >= 0:\n            # Log\u2011score for this bin\n            scores[idx] = -free_space[idx] / scale\n        idx += 1\n\n    # Clip scores to avoid numerical issues\n    scores = np.clip(scores, -1e6, 0)\n    return scores\n\n",
  "softmaxed_best_fit_temperature_by_scale_aug_295": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    free_space = bins - float(item)\n    scores = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = free_space >= 0\n    if np.any(feasible):\n        fs = free_space[feasible]\n        scale = np.mean(fs) + 1e-12\n        # Compute softmin probabilities\n        exp_vals = np.exp(-fs / scale)\n        log_sum = np.log(np.sum(exp_vals) + 1e-12)\n        # Log\u2011probabilities (negative log\u2011softmin)\n        log_probs = -np.log(exp_vals + 1e-12) - log_sum\n        # Randomly choose among top\u2011k (k=3) to break ties\n        top_k = 3\n        top_idx = np.argpartition(log_probs, -top_k)[-top_k:]\n        chosen = np.random.choice(top_idx)\n        chosen_log_prob = log_probs[chosen]\n        # Assign chosen score, others get -inf\n        scores[feasible] = -np.inf\n        scores[feasible][chosen] = chosen_log_prob\n\n    return scores\n\n",
  "softmaxed_best_fit_temperature_by_scale_aug_296": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    free_space = bins - float(item)\n    scores = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = free_space >= 0\n    if np.any(feasible):\n        fs = free_space[feasible]\n        # Use median instead of mean for scaling\n        scale = np.median(fs) + 1e-12\n        raw = -fs / scale\n        # Add deterministic noise\n        noise = 5e-7 * np.sin(np.arange(fs.size))\n        raw += noise\n        # Clip to keep values bounded\n        raw = np.clip(raw, -1e6, 0)\n        scores[feasible] = raw\n\n    return scores\n\n",
  "huber_loss_around_target_slack_aug_297": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    # Compute non\u2011negative slack and clip to avoid negative values\n    slack = np.clip(bins_arr - float(item), 0, None)\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    feasible = slack > 0\n    if np.any(feasible):\n        s = slack[feasible]\n        target = np.median(s)\n        delta = np.std(s) + 1e-9\n        diff = s - target\n        huber = np.where(\n            np.abs(diff) <= delta,\n            0.5 * diff ** 2,\n            delta * (np.abs(diff) - 0.5 * delta)\n        )\n        # Slightly heavier penalty on slack to favour tighter packing\n        score[feasible] = -huber - 0.02 * s\n        # Deterministic tie\u2011breaking noise\n        score[feasible] += 1e-8 * np.arange(np.count_nonzero(feasible))\n    return score\n\n",
  "huber_loss_around_target_slack_aug_298": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    n = bins_arr.size\n    score = np.full(n, -np.inf, dtype=float)\n    slack = bins_arr - float(item)\n\n    # Target is the mean of non\u2011negative slack\n    non_neg = slack >= 0\n    target = np.mean(slack[non_neg]) if np.any(non_neg) else 0.0\n\n    idx = 0\n    while idx < n:\n        if slack[idx] >= 0:\n            diff = slack[idx] - target\n            penalty = np.abs(diff)\n            score[idx] = -penalty - 0.01 * slack[idx]\n            # Deterministic noise for tie\u2011breaking\n            score[idx] += 1e-7 * idx\n        idx += 1\n    return score\n\n",
  "huber_loss_around_target_slack_aug_299": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack = np.clip(bins_arr - float(item), 0, None)\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    feasible = slack > 0\n    if np.any(feasible):\n        target = np.max(slack[feasible])\n        diff = slack[feasible] - target\n        penalty = np.abs(diff)\n        score[feasible] = -penalty - 0.015 * slack[feasible]\n        # Deterministic tie\u2011breaking using index\n        score[feasible] += 1e-9 * np.arange(np.count_nonzero(feasible))\n    return score\n\n",
  "huber_loss_around_target_slack_aug_300": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    slack = np.clip(bins_arr - float(item), 0, None)\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    feasible = slack > 0\n    if np.any(feasible):\n        target = np.mean(slack[feasible])\n        diff = slack[feasible] - target\n        penalty = diff ** 2  # squared deviation\n        score[feasible] = -penalty - 0.005 * slack[feasible]\n        # Small deterministic noise for tie\u2011breaking\n        score[feasible] += 1e-10 * np.arange(np.count_nonzero(feasible))\n    return score\n\n",
  "winsorized_best_fit_aug_301": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # feasibility mask\n    feasible = slack >= 0\n\n    # Winsorised upper bound of slack (95th percentile)\n    cap = np.quantile(slack[feasible] + 1e-12, 0.95) if feasible.any() else 0.0\n\n    # Clamp slack to the cap\n    capped_slack = np.minimum(slack, cap)\n\n    # Score: negative clamped slack for feasible bins, -inf otherwise\n    score = np.where(feasible, -capped_slack, -np.inf)\n\n    # Keep score within a reasonable range\n    score = np.clip(score, -1e6, 0.0)\n    return score\n\n",
  "winsorized_best_fit_aug_302": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Feasibility mask\n    feasible = slack >= 0\n\n    # Weighted score: 80\u202f% slack, 20\u202f% item size\n    weight = -0.8 * slack / (1.0 + 1e-12) + 0.2 * float(item)\n\n    # Add deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=bins.shape)\n    weight += noise\n\n    # Infeasible bins receive -inf\n    score = np.where(feasible, weight, -np.inf)\n\n    # Clip to avoid extreme values\n    score = np.clip(score, -1e6, 1e6)\n    return score\n\n",
  "winsorized_best_fit_aug_303": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Feasibility mask\n    feasible = slack >= 0\n\n    # 90th percentile as an approximate cap\n    cap = np.percentile(slack[feasible], 90) if feasible.any() else 0.0\n\n    # Clamp slack to the cap\n    capped = np.minimum(slack, cap)\n\n    # Soft\u2011min: -log(exp(-capped) + \u03b5)\n    soft = -np.log(np.exp(-capped) + 1e-12)\n\n    # Final score: feasible bins get the soft score, others -inf\n    score = np.where(feasible, soft, -np.inf)\n\n    # Clip to a safe range\n    score = np.clip(score, -1e6, 1e6)\n    return score\n\n",
  "winsorized_best_fit_aug_304": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Feasibility mask\n    feasible = slack >= 0\n\n    # Approximate cap: median of the largest 5 feasible slacks\n    if feasible.any():\n        sorted_slack = np.sort(slack[feasible])\n        top5 = sorted_slack[-5:] if sorted_slack.size >= 5 else sorted_slack\n        cap = np.median(top5)\n    else:\n        cap = 0.0\n\n    capped = np.minimum(slack, cap)\n\n    # Random noise for the top\u2011k smallest slacks (most feasible)\n    noise = np.zeros_like(bins)\n    if feasible.any():\n        # indices of the k bins with the smallest slack\n        topk_idx = np.argsort(slack)[:5]\n        noise[topk_idx] = np.random.uniform(-1e-6, 1e-6, size=topk_idx.size)\n\n    # Score: negative capped slack plus noise for top\u2011k\n    score = -capped + noise\n    score = np.where(feasible, score, -np.inf)\n\n    # Clip to a bounded interval\n    score = np.clip(score, -1e6, 1e6)\n    return score\n\n",
  "maximize_post_fill_margin_from_quarters_aug_305": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacity = np.asarray(bins, dtype=float)\n    size = float(item)\n    remain = capacity - size\n    score = np.full_like(capacity, -np.inf, dtype=float)\n\n    feasible = remain >= 0\n    if not feasible.any():\n        return score\n\n    # Avoid division by zero and clip to valid range\n    fill_ratio = size / np.clip(capacity, 1e-12, None)\n    anchors = np.array([0.25, 0.5, 0.75])\n    diff = np.abs(fill_ratio[feasible][:, None] - anchors[None, :])\n    min_diff = np.min(diff, axis=1)\n\n    slack_penalty = 0.08 * remain[feasible]\n    score[feasible] = min_diff - slack_penalty\n\n    # Deterministic noise to break ties\n    noise = 1e-8 * np.arange(len(score))\n    return score + noise\n\n",
  "maximize_post_fill_margin_from_quarters_aug_306": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    cap = np.asarray(bins, dtype=float)\n    size = float(item)\n    n = cap.size\n    score = np.full(n, -np.inf, dtype=float)\n\n    idx = 0\n    while idx < n:\n        slack = cap[idx] - size\n        if slack >= 0:\n            fill = size / np.clip(cap[idx], 1e-12, None)\n            anchors = np.array([0.25, 0.5, 0.75])\n            diff = np.abs(fill - anchors)\n            min_diff = np.min(diff)\n            score[idx] = min_diff - 0.06 * slack\n            score[idx] += 1e-9 * idx  # deterministic noise\n        idx += 1\n\n    return score\n\n",
  "maximize_post_fill_margin_from_quarters_aug_307": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacity = np.asarray(bins, dtype=float)\n    size = float(item)\n    slack = capacity - size\n    score = np.full_like(capacity, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if feasible.any():\n        fill = size / np.clip(capacity, 1e-12, None)\n        anchors = np.array([0.25, 0.5, 0.75])\n        diff = np.abs(fill[feasible][:, None] - anchors[None, :])\n        min_diff = np.min(diff, axis=1)\n        cost = min_diff - 0.07 * slack[feasible]\n        beta = 10.0\n        softmin = np.exp(-beta * cost)\n        score[feasible] = softmin\n        noise = 1e-10 * np.arange(len(score))\n        score += noise\n\n    return score\n\n",
  "maximize_post_fill_margin_from_quarters_aug_308": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    sz = float(item)\n    n = caps.size\n    score = np.full(n, -np.inf, dtype=float)\n    anchors = np.array([0.25, 0.5, 0.75])\n\n    for i in range(n):\n        slack = caps[i] - sz\n        if slack >= 0:\n            fill = sz / np.clip(caps[i], 1e-12, None)\n            diff = np.abs(fill - anchors)\n            max_diff = np.max(diff)\n            val = max_diff - 0.05 * slack\n            score[i] = np.exp(5.0 * val)\n            score[i] += 1e-7 * i  # deterministic noise\n\n    return score\n\n",
  "knee_point_preference_on_sorted_slacks_aug_309": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return score\n\n    s = slack[feasible]\n    ss = np.sort(s)\n    n = ss.size\n    if n <= 2:\n        score[feasible] = -s\n        return score\n\n    x = np.linspace(0.0, 1.0, n)\n    denom = ss[-1] - ss[0] + 1e-12\n    y = (ss - ss[0]) / denom\n    knee = np.argmax(np.abs(y - x))\n    target = ss[knee]\n    raw = -np.abs(s - target) - 0.015 * s\n    noise = np.random.uniform(-1e-6, 1e-6, size=feasible.sum())\n    score[feasible] = np.clip(raw + noise, -1e6, 0.0)\n    return score\n\n",
  "knee_point_preference_on_sorted_slacks_aug_310": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    idx = np.where(feasible)[0]\n    if idx.size == 0:\n        return score\n\n    s = slack[feasible]\n    ss = np.sort(s)\n    n = ss.size\n    if n <= 3:\n        median = np.median(ss)\n        for i, ind in enumerate(idx):\n            score[ind] = -np.abs(s[i] - median) - 0.02 * s[i]\n        return score\n\n    x = np.linspace(0.0, 1.0, n)\n    denom = ss[-1] - ss[0] + 1e-12\n    y = (ss - ss[0]) / denom\n    diff_sq = (y - x) ** 2\n    knee = np.argmax(diff_sq)\n    target = ss[knee]\n    i = 0\n    while i < idx.size:\n        val = -np.abs(s[i] - target) - 0.02 * s[i]\n        noise = np.random.uniform(-5e-7, 5e-7)\n        score[idx[i]] = np.clip(val + noise, -1e6, 0.0)\n        i += 1\n    return score\n\n",
  "knee_point_preference_on_sorted_slacks_aug_311": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return score\n\n    s = slack[feasible]\n    ss = np.sort(s)\n    n = ss.size\n    if n <= 2:\n        score[feasible] = -s\n        return score\n\n    median = np.median(ss)\n    std = np.std(ss)\n    target = median + 0.5 * std\n\n    # Randomly pick a candidate close to the proxy target\n    mask = np.abs(ss - target) <= 0.1 * target\n    candidates = ss[mask]\n    if candidates.size == 0:\n        target = median\n    else:\n        np.random.seed(0)  # deterministic choice\n        chosen = np.random.choice(candidates, size=1)[0]\n        target = chosen\n\n    raw = -np.abs(s - target) - 0.015 * s\n    noise = np.random.uniform(-2e-6, 2e-6, size=feasible.sum())\n    score[feasible] = np.clip(raw + noise, -1e6, 0.0)\n    return score\n\n",
  "minimize_second_order_slack_difference_aug_312": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    # Rename variables\n    weight = float(item)\n    capacities = np.asarray(bins, dtype=float)\n\n    # Compute slack and feasibility\n    slack_raw = capacities - weight\n    feasible = slack_raw >= 0\n    slack = np.clip(slack_raw, 0, None)          # avoid negative values\n\n    # Initialize scores\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if feasible.any():\n        s = slack[feasible]\n        mu = np.mean(s) + 1e-12                  # epsilon to avoid exact zero division\n\n        # Deterministic tie\u2011breaking noise\n        noise = 1e-6 * np.arange(len(capacities))\n\n        # Higher is better: penalty for deviation from mean slack\n        score[feasible] = -(np.square(s - mu)) - 0.02 * s + noise[feasible]\n\n    return score\n\n",
  "minimize_second_order_slack_difference_aug_313": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    weight = float(item)\n    capacities = np.asarray(bins, dtype=float)\n\n    slack_raw = capacities - weight\n    feasible = slack_raw >= 0\n    slack = np.clip(slack_raw, 0, None)\n\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if feasible.any():\n        s = slack[feasible]\n        # Use the median of the smallest 7 feasible slacks (or fewer if not enough)\n        k = min(7, len(s))\n        smallest = np.partition(s, k-1)[:k]\n        mu = np.median(smallest) + 1e-12\n\n        # Deterministic noise from a fixed RNG\n        rng = np.random.default_rng(1234)\n        noise = rng.normal(size=len(capacities)) * 1e-8\n\n        score[feasible] = -(s - mu)**2 - 0.05 * s + noise[feasible]\n\n    return score\n\n",
  "minimize_second_order_slack_difference_aug_314": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    weight = float(item)\n    capacities = np.asarray(bins, dtype=float)\n\n    slack_raw = capacities - weight\n    feasible = slack_raw >= 0\n    slack = np.clip(slack_raw, 0, None)\n\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if feasible.any():\n        s = slack[feasible]\n        mu = np.max(s) + 1e-12                       # proxy for mean slack\n\n        # Deterministic tie\u2011breaking noise\n        noise = 1e-5 * np.sin(np.arange(len(capacities)))\n\n        score[feasible] = -(np.square(s - mu)) - 0.10 * s + noise[feasible]\n\n        # Clip to avoid extreme negative values\n        score = np.clip(score, -1e6, 0)\n\n    return score\n\n",
  "minimize_second_order_slack_difference_aug_315": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    weight = float(item)\n    capacities = np.asarray(bins, dtype=float)\n\n    slack_raw = capacities - weight\n    feasible = slack_raw >= 0\n    slack = np.clip(slack_raw, 0, None)\n\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if feasible.any():\n        s = slack[feasible]\n        # Select top\u2011k bins with the largest slack\n        k = min(5, len(s))\n        top_indices = np.argpartition(-slack, k-1)[:k]\n        mu = np.mean(s[top_indices]) + 1e-12\n\n        # Deterministic noise (reverse order)\n        noise = 1e-6 * np.arange(len(capacities))[::-1]\n\n        score[feasible] = -(np.square(s - mu)) - 0.08 * s + noise[feasible]\n\n    return score\n\n",
  "quantile_band_pass_then_best_fit_aug_316": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    weight = float(item)\n\n    # Remaining capacity in each bin\n    remaining = capacities - weight\n    remaining = np.clip(remaining, 0, None)          # prevent negative values\n\n    can_fit = remaining >= 0\n    priority_score = np.full_like(capacities, -1e12, dtype=float)\n\n    if can_fit.any():\n        # 30th and 70th percentiles of the remaining capacities\n        p30, p70 = np.percentile(remaining[can_fit], [30, 70])\n\n        # Bins whose slack lies in the desired band\n        in_band = can_fit & (remaining >= p30) & (remaining <= p70)\n\n        # Base score: best\u2011fit (smaller slack \u2192 higher score)\n        priority_score[can_fit] = -remaining[can_fit]\n        # Bonus for being in the band\n        priority_score[in_band] += 0.2\n\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.sin(np.arange(len(capacities)) * 0.1)\n    priority_score += noise\n\n    # Clip to avoid extreme values\n    priority_score = np.clip(priority_score, -1e12, 0)\n    return priority_score\n\n",
  "quantile_band_pass_then_best_fit_aug_317": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    weight = float(item)\n\n    remaining = capacities - weight\n    remaining = np.clip(remaining, 0, None)\n\n    can_fit = remaining >= 0\n    priority_score = np.full_like(capacities, -1e12, dtype=float)\n\n    if can_fit.any():\n        # 25th and 75th percentiles\n        p25, p75 = np.percentile(remaining[can_fit], [25, 75])\n\n        in_band = can_fit & (remaining >= p25) & (remaining <= p75)\n\n        priority_score[can_fit] = -remaining[can_fit]\n        # Increased bonus\n        priority_score[in_band] += 0.3\n\n    # Deterministic noise using a safe ratio (epsilon added)\n    ratio = remaining / (remaining + 1e-12)\n    noise = 1e-6 * np.cos(np.arange(len(capacities)) * ratio)\n    priority_score += noise\n\n    # Clip to keep values bounded\n    priority_score = np.clip(priority_score, -1e12, 0)\n    return priority_score\n\n",
  "quantile_band_pass_then_best_fit_aug_318": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    weight = float(item)\n\n    remaining = capacities - weight\n    remaining = np.clip(remaining, 0, None)\n\n    can_fit = remaining >= 0\n    priority_score = np.full_like(capacities, -1e12, dtype=float)\n\n    if can_fit.any():\n        # Approximate 30th and 70th percentiles via sorted indices\n        sorted_idx = np.argsort(remaining[can_fit])\n        n = len(sorted_idx)\n        p30_idx = sorted_idx[int(0.30 * n)]\n        p70_idx = sorted_idx[int(0.70 * n)]\n        p30 = remaining[can_fit][p30_idx]\n        p70 = remaining[can_fit][p70_idx]\n\n        in_band = can_fit & (remaining >= p30) & (remaining <= p70)\n\n        # Softmin: higher score for smaller remaining\n        base = np.exp(-remaining)\n        priority_score[can_fit] = base[can_fit]\n        priority_score[in_band] += 0.25\n\n    # Deterministic noise using a safe ratio\n    ratio = remaining / (remaining + 1e-12)\n    noise = 1e-6 * np.sin(np.arange(len(capacities)) * ratio)\n    priority_score += noise\n\n    # Clip to a probability\u2011like range\n    priority_score = np.clip(priority_score, 0, 1)\n    return priority_score\n\n",
  "quantile_band_pass_then_best_fit_aug_319": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    weight = float(item)\n\n    remaining = capacities - weight\n    remaining = np.clip(remaining, 0, None)\n\n    can_fit = remaining >= 0\n    priority_score = np.full_like(capacities, -1e12, dtype=float)\n\n    if can_fit.any():\n        # Sort remaining values and pick indices for 30% and 70%\n        sorted_vals = np.sort(remaining[can_fit])\n        n = len(sorted_vals)\n        p30 = sorted_vals[int(0.30 * n)]\n        p70 = sorted_vals[int(0.70 * n)]\n\n        in_band = can_fit & (remaining >= p30) & (remaining <= p70)\n\n        # Base score: negative remaining (best\u2011fit)\n        priority_score[can_fit] = -remaining[can_fit]\n        # Reduce score for bins outside the band\n        priority_score[~in_band & can_fit] *= 0.5\n\n    # Deterministic noise using a safe ratio\n    ratio = remaining / (remaining + 1e-12)\n    noise = 1e-6 * np.cos(np.arange(len(capacities)) * ratio)\n    priority_score += noise\n\n    # Clip to keep scores bounded\n    priority_score = np.clip(priority_score, -1e12, 0)\n    return priority_score\n\n",
  "prefer_geometric_mean_slack_aug_320": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Feasible bins are those with non\u2011negative slack\n    feasible = slack >= 0\n\n    # Compute the geometric mean for feasible bins only\n    s = slack[feasible] + 1e-12\n    gm = np.exp(np.mean(np.log(s)))\n\n    # Base score: negative absolute difference plus a small slack penalty\n    base = -np.abs(slack[feasible] - gm) - 0.02 * slack[feasible]\n\n    # Deterministic noise for tie\u2011breaking (index\u2011based)\n    noise = 1e-9 * np.arange(len(bins))\n\n    # Assemble final scores\n    score = np.full_like(bins, -np.inf, dtype=float)\n    score[feasible] = base + noise[feasible]\n    return score\n\n",
  "rank_by_slack_then_penalize_high_capacity_aug_321": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        s = slack[feasible]\n        # deterministic noise to break ties\n        noise = 1e-9 * np.arange(s.size)\n        s_noisy = s + noise\n\n        order = np.argsort(s_noisy)          # smallest slack first\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n\n        b = bins[feasible]\n        denom = max(b.size - 1, 1) + 1e-12\n        cap_rank = np.argsort(np.argsort(b)).astype(float) / denom\n\n        score[feasible] = -ranks - 0.3 * cap_rank\n        score[feasible] = np.clip(score[feasible], -1e6, 0)\n\n    return score\n\n",
  "rank_by_slack_then_penalize_high_capacity_aug_322": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        s = slack[feasible]\n        noise = 1e-7 * np.arange(s.size)\n        s_noisy = s + noise\n\n        order = np.argsort(s_noisy)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n\n        b = bins[feasible]\n        denom = max(b.size - 1, 1) + 1e-12\n        cap_rank = np.argsort(np.argsort(b)).astype(float) / denom\n\n        base_score = -ranks - 0.3 * cap_rank\n\n        top_k = 3\n        if base_score.size <= top_k:\n            chosen_idx = np.argmin(base_score)\n        else:\n            idx_partition = np.argpartition(base_score, top_k - 1)[:top_k]\n            seed = int((item * 1e6) % 2**32) ^ int(np.sum(bins * 1e6) % 2**32)\n            rng = np.random.default_rng(seed)\n            chosen_idx = rng.choice(idx_partition)\n\n        chosen_global = np.where(feasible)[0][chosen_idx]\n        score[chosen_global] = base_score[chosen_idx]\n\n    return score\n\n",
  "rank_by_slack_then_penalize_high_capacity_aug_323": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        s = slack[feasible]\n        noise = 1e-8 * np.arange(s.size)\n        s_noisy = s + noise\n\n        order = np.argsort(-s_noisy)          # largest slack first\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n\n        b = bins[feasible]\n        denom = max(b.size - 1, 1) + 1e-12\n        cap_rank = 1.0 - (np.argsort(np.argsort(b)).astype(float) / denom)\n\n        score[feasible] = -ranks - 0.4 * cap_rank\n        score[feasible] = np.clip(score[feasible], -1e6, 0)\n\n    return score\n\n",
  "slope_limited_linear_penalty_aug_324": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    EPS = 1e-12\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return score\n\n    s = slack[feasible]\n    thr = np.quantile(s, 0.60)\n\n    # Piecewise penalty, then normalise with a tiny epsilon\n    penal = np.where(\n        s <= thr,\n        s,\n        thr + 0.15 * (s - thr)\n    )\n    penal = np.clip(penal, 0, np.inf)\n    penal = penal / (1 + EPS)                     # avoid division by zero\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(bins)) * 1e-6\n    score[feasible] = -(penal + noise[feasible])\n    return score\n\n",
  "slope_limited_linear_penalty_aug_325": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    EPS = 1e-12\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return score\n\n    s = slack[feasible]\n    thr = np.median(s)\n\n    penal = np.where(\n        s <= thr,\n        s,\n        thr + 0.25 * (s - thr)\n    )\n    penal = np.clip(penal, 0, np.inf)\n\n    # Softmin transformation\n    temperature = 0.5\n    soft = np.exp(-penal / (temperature + EPS))\n    soft = soft / (soft.sum() + EPS)\n\n    # Convert to a higher\u2011score for lower penalty\n    score[feasible] = -np.log(soft + EPS)\n\n    # Deterministic stochastic noise (seeded RNG)\n    rng = np.random.default_rng(0)\n    noise = rng.uniform(-1e-6, 1e-6, size=len(bins))\n    score[feasible] += noise[feasible]\n    return score\n\n",
  "slope_limited_linear_penalty_aug_326": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    EPS = 1e-12\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return score\n\n    s = slack[feasible]\n    thr = np.quantile(s, 0.55)\n\n    penal = np.where(\n        s <= thr,\n        s,\n        thr + 0.15 * (s - thr)\n    )\n    penal = np.clip(penal, 0, np.inf)\n    penal = penal / (1 + EPS)                     # avoid division by zero\n\n    # Choose one of the k best bins\n    k = 5\n    idx_feasible = np.where(feasible)[0]\n    if len(penal) <= k:\n        chosen = np.argmin(penal)\n    else:\n        topk = np.argpartition(penal, k-1)[:k]\n        rng = np.random.default_rng(42)\n        chosen = topk[rng.integers(0, k)]\n\n    chosen_idx = idx_feasible[chosen]\n    chosen_penal = penal[chosen]\n    score[chosen_idx] = -chosen_penal\n\n    # Deterministic noise\n    noise = np.arange(len(bins)) * 1e-7\n    score += noise\n    return score\n\n",
  "slope_limited_linear_penalty_aug_327": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    EPS = 1e-12\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return score\n\n    s = slack[feasible]\n    thr = np.mean(s) * 0.6                    # proxy for 60\u2011th percentile\n\n    penal = np.where(\n        s <= thr,\n        s,\n        thr + 0.25 * (s - thr)\n    )\n    penal = np.clip(penal, 0, np.inf)\n    penal = penal / (1 + EPS)                 # avoid division by zero\n\n    # Emphasise the largest slack\n    max_slack = np.max(s)\n    penal = np.maximum(penal, max_slack * 0.1)\n\n    score[feasible] = -penal\n\n    # Deterministic stochastic noise\n    rng = np.random.default_rng(7)\n    noise = rng.uniform(-1e-6, 1e-6, size=len(bins))\n    score += noise\n    return score\n\n",
  "prefer_slack_near_item_iqr_scaled_aug_328": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n\n    # initialise with -inf for infeasible bins\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n\n    if np.any(feasible):\n        s = slack[feasible]\n        # IQR with epsilon to avoid division by zero\n        q1, q3 = np.quantile(s, 0.25), np.quantile(s, 0.75)\n        iqr = (q3 - q1) + 1e-12\n\n        # small deterministic noise for tie\u2011breaking\n        noise = np.random.rand(feasible.sum()) * 1e-6\n\n        score[feasible] = (\n            -np.abs(s - item) / iqr\n            - 0.01 * s\n            + noise\n        )\n\n    # clip to a safe range\n    return np.clip(score, -1e6, 0.0)\n\n",
  "prefer_slack_near_item_iqr_scaled_aug_329": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    eps = 1e-12\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n\n    if np.any(feasible):\n        s = slack[feasible]\n        mean_slack = np.mean(s) + eps\n\n        raw = np.abs(s - item) / mean_slack + 0.02 * s\n\n        # deterministic noise to break ties\n        noise = np.arange(len(raw)) * 1e-7\n        raw_noisy = raw + noise\n\n        # soft\u2011min transformation\n        softmin = -np.log(np.exp(-raw_noisy) + eps)\n        softmin = np.clip(softmin, -1e5, 0.0)\n\n        score[feasible] = softmin\n\n    return score\n\n",
  "prefer_slack_near_item_iqr_scaled_aug_330": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    eps = 1e-12\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    # list comprehension to collect feasible indices\n    feasible_indices = [i for i, s in enumerate(slack) if s >= 0]\n\n    if feasible_indices:\n        s_vals = slack[feasible_indices]\n        # proxy IQR: (max - min)/2\n        approx_iqr = (np.max(s_vals) - np.min(s_vals)) / 2.0 + eps\n\n        for idx in feasible_indices:\n            s = slack[idx]\n            score[idx] = -abs(s - item) / approx_iqr - 0.015 * s\n\n        # small random noise for tie\u2011breaking\n        noise = np.random.rand(len(feasible_indices)) * 1e-6\n        for idx, n in zip(feasible_indices, noise):\n            score[idx] += n\n\n    # clip to a safe range\n    score = np.clip(score, -1e6, 0.0)\n    return score\n\n",
  "minimize_slack_times_log_capacity_aug_331": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Clip slack to keep only feasible bins; infeasible bins will receive -inf later\n    slack_clip = np.clip(slack, 0, np.inf)\n\n    # Weight factor using log of capacity (stable with a small epsilon)\n    w = np.log(np.clip(bins, 1e-12, None) + 1.0)\n\n    # Base score for feasible bins\n    base = -slack_clip * w\n\n    # Small deterministic noise to break ties in a reproducible way\n    noise = 1e-9 * np.arange(len(bins), dtype=float)\n\n    # Assemble final score array\n    score = np.full_like(bins, -np.inf, dtype=float)\n    mask = slack > 0\n    score[mask] = base[mask] + noise[mask]\n    return score\n\n",
  "minimize_slack_times_log_capacity_aug_332": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    feasible = slack >= 0\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if feasible.any():\n        # Tuned weight: log(capacity) divided by capacity (stable with epsilon)\n        w = np.log(np.clip(bins[feasible], 1e-12, None) + 1.0) / (bins[feasible] + 1e-12)\n\n        # Raw penalty and softmin transformation\n        raw = -slack[feasible] * w\n        softmin = -np.log(np.exp(-raw) + 1e-12)\n\n        score[feasible] = softmin\n    return score\n\n",
  "minimize_slack_times_log_capacity_aug_333": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    feasible = slack >= 0\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if feasible.any():\n        w = np.log(np.clip(bins[feasible], 1e-12, None) + 1.0)\n        base = -slack[feasible] * w\n\n        # Random noise for tie\u2011breaking (fixed seed for reproducibility)\n        rng = np.random.default_rng(seed=42)\n        noise = rng.uniform(low=-1e-6, high=1e-6, size=base.shape)\n\n        score[feasible] = base + noise\n    return score\n\n",
  "minimize_slack_times_log_capacity_aug_334": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    feasible = slack >= 0\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if feasible.any():\n        # Approximate log with log1p for numerical stability\n        w = np.log1p(np.clip(bins[feasible], 0, None))\n\n        # Mean of slack and weight as the scoring metric\n        mean_term = np.mean([slack[feasible], w], axis=0)\n        score[feasible] = -mean_term\n    return score\n\n",
  "prefer_small_bin_if_multiple_feasible_else_roomy_aug_335": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    # Slack must be non\u2011negative; clip to avoid negative values\n    slack = np.clip(bins - item, 0, None)\n\n    # Base score array\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    # Determine which bins can accommodate the item\n    feasible = slack >= 0\n    k = int(np.sum(feasible))\n    if k > 0:\n        # Different weighting regimes\n        if k >= 4:\n            score[feasible] = -bins[feasible] - 0.2 * slack[feasible]\n        else:\n            score[feasible] = slack[feasible] - 0.1 * bins[feasible]\n\n        # Small deterministic noise for tie\u2011breaking\n        noise = np.sin(item * bins[feasible]) * 1e-6\n        score[feasible] += noise\n\n    return score\n\n",
  "prefer_small_bin_if_multiple_feasible_else_roomy_aug_336": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = np.clip(bins - item, 0, None)\n    feasible = slack > 0\n    k = int(np.sum(feasible))\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if k > 0:\n        idxs = np.where(feasible)[0]\n        # Handle fewer than 4 feasible bins first\n        if k < 4:\n            scores = [\n                slack[i] - 0.07 * bins[i] + np.cos(item + bins[i]) * 1e-6\n                for i in idxs\n            ]\n        else:\n            scores = [\n                -bins[i] - 0.13 * slack[i] + np.sin(item * bins[i]) * 1e-6\n                for i in idxs\n            ]\n        score[idxs] = scores\n\n    return score\n\n",
  "prefer_small_bin_if_multiple_feasible_else_roomy_aug_337": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    eps = 1e-12\n    slack = np.clip(bins - item, 0, None)\n    feasible = slack > 0\n    k = int(np.sum(feasible))\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if k > 0:\n        # Proxy weight using sqrt of bins (avoids division)\n        proxy = np.sqrt(bins + eps)\n        soft = -proxy - 0.1 * slack\n        score[feasible] = soft[feasible]\n\n        # Deterministic tie\u2011breaking noise\n        noise = np.sin(item * bins[feasible]) * 1e-6\n        score[feasible] += noise\n\n    return score\n\n",
  "prefer_small_bin_if_multiple_feasible_else_roomy_aug_338": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = np.clip(bins - item, 0, None)\n    feasible_idx = np.where(slack > 0)[0]\n    k = len(feasible_idx)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if k > 0:\n        # Median slack reference\n        median_slack = np.median(slack[feasible_idx])\n\n        # Scoring loop\n        for idx in feasible_idx:\n            if k <= 3:\n                score[idx] = slack[idx] - 0.08 * bins[idx]\n            else:\n                score[idx] = -bins[idx] - 0.12 * slack[idx]\n\n        # Random tie\u2011breaking among the top 5 feasible bins\n        rng = np.random.default_rng(42)\n        top_k = min(5, k)\n        top_indices = rng.choice(feasible_idx, size=top_k, replace=False)\n        noise = rng.uniform(-1e-6, 1e-6, size=top_k)\n        score[top_indices] += noise\n\n    # Clip extreme values to maintain numerical stability\n    score = np.clip(score, -1e6, 1e6)\n    return score\n\n",
  "piecewise_penalize_mid_slack_interval_aug_339": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    # Residual capacity (slack) \u2013 clip negative values to 0\n    slack = np.clip(bins - float(item), 0, None)\n    # Base score: larger slack \u2192 lower score (negative)\n    score = -slack\n    # Identify feasible bins (slack > 0)\n    feasible = slack > 0\n    if np.any(feasible):\n        # Mid\u2011interval bounds (40th & 60th percentiles)\n        p40, p60 = np.quantile(slack[feasible], [0.4, 0.6])\n        # Mid\u2011interval mask\n        mid = feasible & (slack >= p40) & (slack <= p60)\n        # Apply penalty to mid\u2011interval bins\n        penalty = 0.4 * (p60 - p40 + 1e-12)\n        score[mid] -= penalty\n    # Deterministic noise for tie breaking (depends on item)\n    noise = (np.sin(item) + np.cos(item)) * 1e-6\n    return score + noise\n\n",
  "piecewise_penalize_mid_slack_interval_aug_340": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    scores = []\n    for cap in bins:\n        slack = cap - float(item)\n        if slack >= 0:\n            # Softmin score: higher for larger slack\n            score = np.exp(-slack)\n        else:\n            score = -np.inf\n        scores.append(score)\n    scores = np.array(scores, dtype=float)\n    # Identify feasible indices\n    feas_idx = np.where(scores > -np.inf)[0]\n    if feas_idx.size:\n        feas_slack = bins[feas_idx] - float(item)\n        p40, p60 = np.quantile(feas_slack, [0.4, 0.6])\n        mid_mask = (feas_slack >= p40) & (feas_slack <= p60)\n        penalty = 0.2 * (p60 - p40 + 1e-12)\n        scores[feas_idx[mid_mask]] -= penalty\n    # Add deterministic noise\n    noise = np.cos(item) * 1e-6\n    return scores + noise\n\n",
  "piecewise_penalize_mid_slack_interval_aug_341": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    # Compute slack for all bins\n    slack = bins - float(item)\n    # Base score: negative slack\n    score = -slack\n    # Feasible bins\n    feasible = slack > 0\n    if np.any(feasible):\n        # Use median and interquartile range as bounds\n        median = np.median(slack[feasible])\n        iqr = np.percentile(slack[feasible], 75) - np.percentile(slack[feasible], 25)\n        p_low = median - 0.5 * iqr\n        p_high = median + 0.5 * iqr\n        mid = feasible & (slack >= p_low) & (slack <= p_high)\n        penalty = 0.5 * (p_high - p_low + 1e-12)\n        score[mid] -= penalty\n    # Add deterministic noise using sin\n    noise = np.sin(item) * 1e-6\n    return score + noise\n\n",
  "piecewise_penalize_mid_slack_interval_aug_342": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = np.clip(bins - float(item), 0, None)\n    # Base score: negative slack\n    score = -slack\n    # Feasible indices\n    feas = slack > 0\n    if np.any(feas):\n        # Compute 40th and 60th percentiles on feasible slack\n        p40, p60 = np.quantile(slack[feas], [0.4, 0.6])\n        mid = feas & (slack >= p40) & (slack <= p60)\n        penalty = 0.3 * (p60 - p40 + 1e-12)\n        score[mid] -= penalty\n    # Clip score to avoid overly negative values\n    score = np.clip(score, -1e6, 0)\n    # Deterministic noise via sin of half the item\n    noise = np.sin(item / 2.0) * 1e-6\n    return score + noise\n\n",
  "max_margin_from_feasible_min_slack_aug_343": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    # Slack is the remaining capacity after placing the item\n    slack = bins_arr - item_val\n    # Only positive slack is considered feasible\n    slack = np.clip(slack, 0.0, None)\n\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n    feasible = slack > 0\n\n    if np.any(feasible):\n        s = slack[feasible]\n        # Use the mean slack of all feasible bins as a reference\n        avg_slack = np.mean(s + 1e-12)\n        # Margin is how far a bin's slack deviates from a slightly enlarged mean\n        margin = np.abs(s - (avg_slack + 0.1 * (np.max(s) - avg_slack + 1e-12)))\n        # Deterministic noise to break ties (index\u2011based)\n        noise = 1e-6 * np.arange(len(bins_arr))\n        score[feasible] = -margin - 0.02 * s + noise[feasible]\n\n    return score\n\n",
  "max_margin_from_feasible_min_slack_aug_344": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    # Determine indices of bins that can accommodate the item\n    feasible_indices = [i for i, cap in enumerate(bins_arr) if cap - item_val >= 0]\n    if not feasible_indices:\n        return score\n\n    slacks = bins_arr[feasible_indices] - item_val\n    # Use median slack as reference instead of minimum\n    median_slack = np.median(slacks + 1e-12)\n    max_slack = np.max(slacks + 1e-12)\n\n    for i in feasible_indices:\n        slack = bins_arr[i] - item_val\n        # Margin relative to a slightly enlarged median\n        margin = np.abs(slack - (median_slack + 0.08 * (max_slack - median_slack + 1e-12)))\n        score[i] = -margin - 0.015 * slack\n\n    return score\n\n",
  "max_margin_from_feasible_min_slack_aug_345": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack = bins_arr - item_val\n    slack = np.clip(slack, 0.0, None)          # only non\u2011negative slack\n    feasible = slack > 0\n\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n        # Avoid division by zero by adding epsilon to the denominator\n        denom = np.max(s) + 1e-12\n        # Soft\u2011min weight: larger slack \u2192 smaller weight\n        weights = np.exp(-s / denom)\n        # Deterministic noise for stable tie\u2011breaking\n        noise = 1e-7 * np.arange(len(bins_arr))\n        score[feasible] = -np.log(weights + 1e-12) - 0.01 * s + noise[feasible]\n\n    return score\n\n",
  "max_margin_from_feasible_min_slack_aug_346": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins_arr = np.asarray(bins, dtype=float)\n    item_val = float(item)\n\n    slack = bins_arr - item_val\n    slack = np.clip(slack, 0.0, None)          # only positive slack\n    feasible = slack > 0\n\n    score = np.full_like(bins_arr, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n        # Approximate the minimum slack via partition (O(n))\n        min_slack = np.partition(s, 0)[0]\n        # Use the maximum of the top\u20113 slacks as a proxy for the range\n        top_k = min(3, len(s))\n        max_slack = np.partition(s, -top_k)[-top_k].max()\n        # Compute margin with a slightly increased range factor\n        margin = np.abs(s - (min_slack + 0.07 * (max_slack - min_slack + 1e-12)))\n        score[feasible] = -margin - 0.02 * s\n\n    return score\n\n",
  "prefer_slack_near_capacity_percentile_35_aug_347": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item                     # remaining capacity\n    feasible = slack >= 0.0                 # only bins that can hold the item\n\n    # Default score array (infeasible bins stay -inf)\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if feasible.any():\n        # 35th\u2011percentile of the capacities that can fit the item\n        target = np.quantile(bins[feasible], 0.35)\n\n        # Base score: absolute deviation from 20\u202f% of the target minus a small\n        # penalty proportional to the slack.  The 0.2 factor is a tunable weight.\n        base = -np.abs(slack[feasible] - 0.2 * target) - 0.01 * slack[feasible]\n\n        # Deterministic tie\u2011breaking noise (increasing with index)\n        noise = np.arange(len(bins), dtype=float) * 1e-6\n\n        score[feasible] = base + noise[feasible]\n\n    # Clip the scores to keep them within a reasonable range\n    score = np.clip(score, -1e6, 0.0)\n    return score\n\n",
  "prefer_slack_near_capacity_percentile_35_aug_348": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item\n    feasible = slack >= 0.0\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if feasible.any():\n        # Median of the capacities that can accept the item\n        target = np.median(bins[feasible])\n\n        # Soft\u2011min: lower ratio -> higher score\n        ratio = slack[feasible] / (target + 1e-12)   # epsilon to avoid div\u2011by\u2011zero\n        softmin = -np.log(np.exp(-ratio) + 1e-12)    # soft\u2011min approximation\n\n        score[feasible] = softmin\n\n        # Random tie\u2011breaking among the top\u20113 bins\n        rng = np.random.default_rng(42)\n        top_k = 3\n        top_indices = np.argpartition(score[feasible], -top_k)[-top_k:]\n        random_offsets = rng.random(top_k) * 1e-4\n        score[feasible][top_indices] += random_offsets\n\n    # Ensure scores stay bounded\n    score = np.clip(score, -1e6, 0.0)\n    return score\n\n",
  "prefer_slack_near_capacity_percentile_35_aug_349": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n\n    slack = bins - item\n    feasible = slack >= 0.0\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n\n    if feasible.any():\n        # Mean of the capacities that can fit the item\n        target = np.mean(bins[feasible])\n\n        # Ratio of slack to bin capacity (prevent div\u2011by\u2011zero with epsilon)\n        ratio = slack[feasible] / (bins[feasible] + 1e-12)\n\n        # Score: negative log of (1 + ratio) to reward larger slack ratios\n        base_score = -np.log1p(ratio + 1e-12)\n\n        # Use squared slack to penalize bins that are just barely feasible\n        penalty = -0.05 * np.square(slack[feasible])\n\n        # Combine with small deterministic noise\n        noise = np.arange(len(bins), dtype=float) * 1e-7\n        score[feasible] = base_score + penalty + noise[feasible]\n\n    # Clip to avoid extreme values\n    score = np.clip(score, -1e6, 0.0)\n    return score\n\n",
  "minimize_lognormalized_slack_aug_350": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Clip slack at zero and add a tiny epsilon to avoid log(0)\n    slack_pos = np.clip(slack, 0, None) + 1e-12\n    # Base score: negative log\u20111\u2011p of the positive slack\n    base_score = -np.log1p(slack_pos)\n\n    # Deterministic tie\u2011breaking noise (scaled by bin index)\n    noise = np.arange(len(bins), dtype=float) * 1e-6\n    score = base_score + noise\n\n    # Mark bins that cannot hold the item with -inf\n    score = np.where(slack >= 0, score, -np.inf)\n    return score\n\n",
  "minimize_lognormalized_slack_aug_351": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Positive slack only, clipped to avoid negative values\n    slack_pos = np.clip(slack, 0, None)\n\n    # Base penalty: negative log\u20111\u2011p of the positive slack\n    base = -np.log1p(slack_pos + 1e-12)\n\n    # Median\u2011based adjustment: tighter bins get a small boost\n    median_slack = np.median(slack_pos + 1e-12)\n    adjustment = 0.2 * (median_slack / (slack_pos + 1e-12))\n\n    # Combine components and add a tiny noise for deterministic tie\u2011breaking\n    noise = np.arange(len(bins), dtype=float) * 5e-7\n    score = base + adjustment + noise\n\n    # Invalidate bins that cannot accommodate the item\n    score = np.where(slack >= 0, score, -np.inf)\n    return score\n\n",
  "minimize_lognormalized_slack_aug_352": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Positive slack only; clip to avoid negative values\n    slack_pos = np.clip(slack, 0, None)\n\n    # Base score: negative log\u20111\u2011p of the positive slack\n    base_score = -np.log1p(slack_pos + 1e-12)\n\n    # Reciprocal weighting: tighter bins get a larger multiplier\n    reciprocal = 1.0 / (slack_pos + 1e-12)\n    weighted = base_score * reciprocal\n\n    # Add a small deterministic noise for tie\u2011breaking\n    noise = np.arange(len(bins), dtype=float) * 2e-7\n    score = weighted + noise\n\n    # Mark bins that cannot hold the item with -inf\n    score = np.where(slack >= 0, score, -np.inf)\n    return score\n\n",
  "prefer_slack_near_mean_capacity_minus_item_aug_353": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    weight = float(item)\n\n    # Slack is the remaining capacity after placing the item\n    slack = capacities - weight\n    slack = np.clip(slack, 0.0, np.inf)          # prevent negative values\n\n    # Identify feasible bins\n    feasible = slack >= 0.0\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # Use the median of feasible capacities as the reference\n        median_cap = np.median(capacities[feasible])\n        target = max(median_cap - weight, 0.0)\n\n        # Deterministic noise to break ties\n        noise = np.arange(capacities.size, dtype=float) * 1e-6\n\n        # Score: closer to target is better; larger slack is slightly penalised\n        score[feasible] = (\n            -np.abs(slack[feasible] - target)\n            - 0.02 * slack[feasible]\n            + noise[feasible]\n        )\n\n    return score\n\n",
  "prefer_slack_near_mean_capacity_minus_item_aug_354": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    weight = float(item)\n\n    slack = capacities - weight\n    slack = np.clip(slack, 0.0, np.inf)\n\n    feasible = slack >= 0.0\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # Mean with epsilon to guard against empty slices\n        mean_cap = np.mean(capacities[feasible] + 1e-12)\n        target = max(mean_cap - weight, 0.0)\n\n        rng = np.random.default_rng(42)  # deterministic seed for reproducibility\n        noise = rng.uniform(-1e-6, 1e-6, size=feasible.sum())\n\n        # Quadratic penalty on slack\n        sq_slack = np.square(slack[feasible])\n        score[feasible] = (\n            -sq_slack\n            - 0.02 * slack[feasible]\n            + noise\n        )\n\n    return score\n\n",
  "prefer_slack_near_mean_capacity_minus_item_aug_355": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    weight = float(item)\n\n    slack = capacities - weight\n    slack = np.clip(slack, 0.0, np.inf)\n\n    feasible = slack >= 0.0\n    score = np.full_like(capacities, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        max_cap = np.max(capacities[feasible])\n        target = max(max_cap - weight, 0.0)\n\n        # Sinusoidal deterministic noise based on bin index\n        noise = np.sin(np.arange(capacities.size, dtype=float)) * 1e-7\n\n        score[feasible] = (\n            -np.abs(slack[feasible] - target)\n            - 0.005 * slack[feasible]\n            + noise[feasible]\n        )\n\n    return score\n\n",
  "asymmetric_penalty_small_slack_over_big_slack_aug_356": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = np.clip(bins - float(item), 0.0, np.inf)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack > 0.0\n    if np.any(feasible):\n        s = slack[feasible]\n        cap = np.max(bins[feasible]) + 1e-12\n        sliver = 0.04 * cap                       # reduced sliver size\n        penalty = np.where(\n            s < sliver,\n            4.0 * (sliver - s) / (sliver + 1e-12),  # penalty for slivers\n            0.25 * s                                # penalty for normal slack\n        )\n        penalty = np.clip(penalty, 0.0, 10.0)       # bound penalty\n        score[feasible] = -penalty\n    return score\n\n",
  "asymmetric_penalty_small_slack_over_big_slack_aug_357": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0.0\n    if np.any(feasible):\n        s = slack[feasible]\n        cap = np.max(bins[feasible]) + 1e-12\n        sliver = 0.06 * cap                       # larger sliver to penalise slivers more\n        penalty = np.where(\n            s < sliver,\n            6.0 * (sliver - s) / (sliver + 1e-12),  # steeper sliver penalty\n            0.15 * s                                # lighter slack penalty\n        )\n        penalty = np.clip(penalty, 0.0, 12.0)\n\n        # deterministic noise for tie\u2011breaking\n        noise = 1e-6 * np.arange(len(bins))\n        score[feasible] = -penalty + noise[feasible]\n    return score\n\n",
  "asymmetric_penalty_small_slack_over_big_slack_aug_358": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = np.clip(bins - float(item), 0.0, np.inf)\n\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack > 0.0\n    if np.any(feasible):\n        s = slack[feasible]\n        cap = np.max(bins[feasible]) + 1e-12\n        sliver = 0.05 * cap\n        penalty = np.where(\n            s < sliver,\n            5.0 * (sliver - s) / (sliver + 1e-12),\n            0.2 * s\n        )\n        penalty = np.clip(penalty, 0.0, 15.0)\n\n        # Soft\u2011min weighting and logarithmic score\n        temperature = 0.02 + 1e-12\n        weights = np.exp(-penalty / temperature)\n        soft_score = -np.log(weights + 1e-12)\n        score[feasible] = soft_score\n    return score\n\n",
  "median_absolute_deviation_capacity_centering_aug_359": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - float(item)\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feas = slack >= 0\n    if np.any(feas):\n        c_feas = caps[feas]\n\n        # Use the mean as the central tendency and a robust MAD estimate.\n        center = np.mean(c_feas)\n        mad = np.mean(np.abs(c_feas - center)) + 1e-12\n\n        # Standardised distance, clipped to avoid extreme values.\n        z = np.abs(c_feas - center) / (1.4826 * mad)\n        z = np.clip(z, 0, 10)\n\n        # Score combines distance and slack with a heavier slack penalty.\n        score[feas] = -z - 0.2 * slack[feas]\n\n        # Deterministic tie\u2011breaking noise.\n        noise = np.arange(c_feas.size, dtype=float) * 1e-9\n        score[feas] += noise\n\n    return score\n\n",
  "median_absolute_deviation_capacity_centering_aug_360": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - float(item)\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feas = slack >= 0\n    if np.any(feas):\n        c_feas = caps[feas]\n\n        # Median centre and robust MAD.\n        center = np.median(c_feas)\n        mad = np.median(np.abs(c_feas - center)) + 1e-12\n\n        z = np.abs(c_feas - center) / (1.4826 * mad)\n\n        # Soft\u2011min style: larger distance \u2192 smaller score.\n        score[feas] = -np.exp(z) - 0.5 * slack[feas]\n\n        # Deterministic small noise using a fixed RNG seed.\n        rng = np.random.default_rng(42)\n        noise = rng.uniform(-1e-9, 1e-9, size=c_feas.size)\n        score[feas] += noise\n\n        # Clip to keep values within a reasonable range.\n        score[feas] = np.clip(score[feas], -1e6, 0)\n\n    return score\n\n",
  "median_absolute_deviation_capacity_centering_aug_361": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    slack = caps - float(item)\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feas = slack >= 0\n    if np.any(feas):\n        c_feas = caps[feas]\n\n        center = np.mean(c_feas)\n        mad = np.std(c_feas) + 1e-12\n\n        z = np.abs(c_feas - center) / (1.4826 * mad)\n        score[feas] = -z - 0.3 * slack[feas]\n\n        # Deterministic tie\u2011breaking noise using a sine pattern.\n        indices = np.arange(c_feas.size, dtype=float)\n        noise = 1e-8 * np.sin(indices)\n        score[feas] += noise\n\n        # Ensure scores stay within a sane range.\n        score[feas] = np.clip(score[feas], -5.0, 0.0)\n\n    return score\n\n",
  "prefer_slack_near_triangular_median_iqr_aug_362": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Feasibility mask\n    feasible = slack >= 0\n    scores = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n\n        # Center at mean and width as full range\n        center = np.mean(s)\n        width  = (np.max(s) - np.min(s)) + 1e-12\n\n        # Raw score\n        raw = 1.0 - np.abs(s - center) / width - 0.02 * s\n\n        # Deterministic tie\u2011breaking noise\n        rng = np.random.default_rng(42)\n        noise = rng.normal(scale=1e-5, size=s.shape)\n\n        scores[feasible] = raw + noise\n\n    # Clip to keep scores bounded\n    scores = np.where(feasible, np.clip(scores, a_min=None, a_max=1.0), -np.inf)\n    return scores\n\n",
  "prefer_slack_near_triangular_median_iqr_aug_363": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    feasible = slack >= 0\n    scores = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n\n        # Center between Q1 and Q3\n        q1, q3 = np.quantile(s, [0.25, 0.75])\n        center = (q1 + q3) / 2\n        width  = (q3 - q1) / 2 + 1e-12\n\n        # Raw score with a larger slack penalty\n        raw = 1.0 - np.abs(s - center) / width - 0.03 * s\n\n        # Randomly scale the top\u2011k scores for diversity\n        top_k = 5\n        rng = np.random.default_rng(123)\n        if raw.size > 0:\n            idx = np.argpartition(-raw, top_k - 1)[:top_k]\n            scaling = rng.uniform(0.95, 1.05, size=idx.shape)\n            raw[idx] *= scaling\n\n        scores[feasible] = raw\n\n    # Clip scores to a wide but safe range\n    scores = np.where(feasible, np.clip(scores, a_min=-1e10, a_max=1.2), -np.inf)\n    return scores\n\n",
  "prefer_slack_near_triangular_median_iqr_aug_364": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n\n    # Invert the feasibility test\n    infeasible = slack < 0\n    feasible   = ~infeasible\n\n    scores = np.full_like(bins, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = slack[feasible]\n\n        # Median center and IQR\u2011based width\n        med   = np.median(s)\n        q1, q3 = np.quantile(s, [0.25, 0.75])\n        width = (q3 - q1) + 1e-12\n\n        # Raw score\n        raw = 1.0 - np.abs(s - med) / width - 0.02 * s\n\n        # Deterministic noise using a sine function\n        noise = np.sin(bins[feasible] * 1000) * 1e-6\n\n        scores[feasible] = raw + noise\n\n    # Clip final scores to avoid overflow\n    scores = np.where(feasible, np.clip(scores, a_min=-1e10, a_max=1.0), -np.inf)\n    return scores\n\n",
  "prefer_high_fill_and_low_capacity_aug_365": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    cap = np.asarray(bins, dtype=float)\n    itm = float(item)\n    slack = cap - itm\n    # Initialise score array with negative infinity\n    score = np.full_like(cap, -np.inf, dtype=float)\n    # Feasible bins where slack >= 0\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Fill ratio\n        fill = itm / np.maximum(cap[feasible], 1e-12)\n        # Normalised capacity relative to largest feasible bin\n        cap_norm = cap[feasible] / (np.max(cap[feasible]) + 1e-12)\n        # Weighted score with altered coefficients\n        score[feasible] = 2.2 * fill - 0.75 * cap_norm - 0.07 * slack[feasible]\n        # Add deterministic noise for tie breaking\n        noise = np.arange(len(cap)) * 1e-6\n        score += noise\n    # Clamp scores to avoid extreme values\n    return np.clip(score, -1e3, 1e3)\n\n",
  "prefer_high_fill_and_low_capacity_aug_366": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacity = np.asarray(bins, dtype=float)\n    value = float(item)\n    result = np.full_like(capacity, -np.inf, dtype=float)\n    for idx, cap in enumerate(capacity):\n        slack = cap - value\n        if slack < 0:  # infeasible\n            continue\n        # Compute fill ratio\n        fill = value / np.maximum(cap, 1e-12)\n        # Normalised capacity using max of all bins\n        cap_norm = cap / (np.max(capacity) + 1e-12)\n        # Different weighting scheme\n        result[idx] = 3.0 * fill - 0.5 * cap_norm - 0.12 * slack\n    # Clip to prevent overflow\n    return np.clip(result, -1e4, 1e4)\n\n",
  "prefer_high_fill_and_low_capacity_aug_367": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    val = float(item)\n    # Compute scores using list comprehension for feasible bins\n    scores = [\n        2.5 * (val / np.maximum(cap, 1e-12))\n        - 0.7 * (cap / (np.median(caps) + 1e-12))\n        - 0.02 * (cap - val)\n        + (i * 1e-6)  # deterministic tie-breaking noise\n        if cap >= val else -np.inf\n        for i, cap in enumerate(caps)\n    ]\n    # Convert to array and clip\n    arr = np.array(scores, dtype=float)\n    return np.clip(arr, -5e2, 5e2)\n\n",
  "minimize_slack_to_capacity_ratio_then_exact_bonus_aug_368": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    residual = capacities - float(item)\n    score = np.full(capacities.shape, -np.inf, dtype=float)\n    feasible = residual >= 0\n    if np.any(feasible):\n        denom = np.maximum(capacities[feasible], 1e-12)\n        frac = residual[feasible] / denom\n        score[feasible] = -frac\n        tol = 1e-9\n        near = (np.abs(residual) <= tol) & feasible\n        score[near] += 10.0\n    noise = np.arange(capacities.size, dtype=float) * 1e-6\n    score += noise\n    score = np.clip(score, -1.0, 10.0)\n    return score\n\n",
  "minimize_slack_to_capacity_ratio_then_exact_bonus_aug_369": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    rem = caps - float(item)\n    score = np.full(caps.shape, -np.inf, dtype=float)\n    feasible = rem >= 0\n    if np.any(feasible):\n        denom = np.maximum(caps[feasible], 1e-12)\n        frac = rem[feasible] / denom\n        score[feasible] = -0.8 * frac\n        tol = 1e-8\n        near = feasible & (np.abs(rem) <= tol)\n        score[near] += 2.0\n    score = np.clip(score, -1.0, 5.0)\n    return score\n\n",
  "minimize_slack_to_capacity_ratio_then_exact_bonus_aug_370": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    capacities = np.asarray(bins, dtype=float)\n    residual = capacities - float(item)\n    score = np.full(capacities.shape, -np.inf, dtype=float)\n    feasible = residual >= 0\n    if np.any(feasible):\n        denom = np.maximum(capacities[feasible], 1e-12)\n        frac = residual[feasible] / denom\n        alpha = 10.0\n        softmin = np.exp(-alpha * frac)\n        score[feasible] = softmin\n        tol = 5e-10\n        near = feasible & (np.abs(residual) <= tol)\n        score[near] += 1e-3\n    noise = np.arange(capacities.size, dtype=float) * 1e-7\n    score += noise\n    score = np.clip(score, 0.0, 1.0)\n    return score\n\n",
  "prefer_capacity_near_item_plus_median_slack_aug_371": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    # Slack of each bin relative to the item\n    slack = caps - itm\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    # Feasible bins are those with non\u2011negative slack\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Use the median slack of the feasible bins as a proxy for typical slack\n        med_slack = np.median(slack[feasible])\n        target_cap = itm + med_slack\n\n        # Soft\u2011min style scoring: larger values are better\n        raw = -np.abs(caps[feasible] - target_cap) - 0.05 * slack[feasible]\n        # Convert to a log\u2011probability to avoid large negative numbers\n        score[feasible] = -np.log(np.exp(raw) + 1e-12)\n\n        # Add a deterministic noise to break ties in a reproducible way\n        noise = np.random.default_rng().uniform(-1e-6, 1e-6, size=caps.shape)\n        score += noise\n\n    return score\n\n",
  "prefer_capacity_near_item_plus_median_slack_aug_372": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    slack = caps - itm\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Mean slack replaces median for a smoother estimate\n        mean_slack = np.mean(slack[feasible])\n        target_cap = itm + mean_slack\n\n        # Adjusted weighting factors\n        base = -0.1 * np.abs(caps[feasible] - target_cap) - 0.02 * slack[feasible]\n\n        # Randomly pick top\u2011k bins to receive finite scores\n        top_k = 5\n        idx_feasible = np.flatnonzero(feasible)\n        if len(idx_feasible) > top_k:\n            # Use a deterministic top\u2011k selection: choose the k bins with largest base score\n            top_idx = np.argpartition(-base, top_k - 1)[:top_k]\n            chosen = idx_feasible[top_idx]\n        else:\n            chosen = idx_feasible\n\n        # Assign perturbed scores to chosen bins\n        rng = np.random.default_rng()\n        score[chosen] = base[np.isin(idx_feasible, chosen)] + rng.uniform(-1e-6, 1e-6, size=len(chosen))\n\n    return score\n\n",
  "prefer_capacity_near_item_plus_median_slack_aug_373": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    caps = np.asarray(bins, dtype=float)\n    itm = float(item)\n\n    slack = caps - itm\n    score = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = slack >= 0\n    if np.any(feasible):\n        # Use the maximum feasible slack (with epsilon to avoid divide\u2011by\u2011zero)\n        max_slack = np.max(slack[feasible]) + 1e-12\n        target_cap = itm + max_slack\n\n        # Larger weights for slack to penalize over\u2011capacity bins more\n        raw = -np.abs(caps[feasible] - target_cap) - 0.1 * slack[feasible]\n        score[feasible] = raw\n\n        # Deterministic tie\u2011breaker using a small linear ramp\n        ramp = 1e-6 * np.arange(len(caps))\n        score += ramp\n\n        # Ensure scores stay within a reasonable numeric range\n        score = np.clip(score, -1e6, 1e6)\n\n    return score\n\n",
  "iqr_normalized_best_fit_aug_374": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    # Rename variables for clarity\n    avail = np.asarray(bins, dtype=float)\n\n    # Compute free space and clip to avoid negative values\n    free = np.clip(avail - float(item), 0, None)\n\n    # Identify feasible bins\n    feasible = free > 0\n\n    # Initialise the priority array with -inf\n    prio = np.full_like(avail, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # Compute IQR on the feasible free space\n        s = free[feasible]\n        q1 = np.percentile(s, 25)\n        q3 = np.percentile(s, 75)\n        iqr = (q3 - q1) + 1e-12          # epsilon to avoid division by zero\n\n        # Compute scores only for feasible bins\n        prio[feasible] = -free[feasible] / iqr\n\n    return prio\n\n",
  "iqr_normalized_best_fit_aug_375": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    # Convert to float array\n    avail = np.asarray(bins, dtype=float)\n\n    # Compute free space\n    free = avail - float(item)\n\n    # Feasibility mask\n    feasible = free >= 0\n\n    # Initialise score array\n    score = np.full_like(avail, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = free[feasible]\n\n        # Compute IQR and clip to avoid zero division\n        q1, q3 = np.quantile(s, [0.25, 0.75])\n        iqr = np.clip((q3 - q1) + 1e-12, 1e-12, None)\n\n        # Weight factor for slack (tunable hyperparameter)\n        weight = 0.7\n\n        # Base score (higher is better)\n        base = - (s / iqr) * weight\n\n        # Deterministic tie\u2011breaking noise (small, monotonic)\n        noise = np.arange(len(avail)) * 1e-8\n\n        score[feasible] = base + noise[feasible]\n\n    return score\n\n",
  "iqr_normalized_best_fit_aug_376": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    # Ensure numpy array\n    avail = np.asarray(bins, dtype=float)\n\n    # Free space\n    free = avail - float(item)\n\n    # Feasible bins\n    feasible = free >= 0\n\n    # Score array\n    score = np.full_like(avail, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        s = free[feasible]\n\n        # Proxy IQR: max\u2011min difference (tuned hyperparameter)\n        iqr = np.max(s) - np.min(s) + 1e-12\n        iqr = np.clip(iqr, 1e-12, None)\n\n        # Softmin scaling factor (tau)\n        tau = iqr\n\n        # Compute a softmin\u2011style score\n        soft = np.exp(-s / tau)\n        score[feasible] = -soft\n\n        # Deterministic noise for tie\u2011breaking\n        noise = (np.arange(len(avail)) % 2) * 1e-8\n        score[feasible] += noise[feasible]\n\n    return score\n\n"
}
