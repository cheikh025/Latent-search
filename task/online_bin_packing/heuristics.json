{
  "best_fit_negative_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Best-Fit: prefer smallest nonnegative slack.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -slack\n    score[slack < 0] = -np.inf\n    return score\n",
  "best_fit_inverse_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Best-Fit with inverse slack (strong pull to tight fits).\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    eps = 1e-12\n    score = 1.0 / (slack + eps)\n    score[slack < 0] = -np.inf\n    return score\n",
  "best_fit_quadratic_penalty": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Best-Fit with quadratic penalty on leftover space.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -(slack ** 2)\n    score[slack < 0] = -np.inf\n    return score\n",
  "best_fit_exponential_decay": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Best-Fit via exp(-slack) (smooth, scale-robust).\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.exp(-np.maximum(slack, 0.0))\n    score[slack < 0] = -np.inf\n    return score\n",
  "worst_fit_positive_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Worst-Fit: prefer largest slack among feasible bins.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = slack\n    score[slack < 0] = -np.inf\n    return score\n",
  "worst_fit_sqrt_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Worst-Fit with diminishing returns via sqrt(slack).\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.sqrt(np.maximum(slack, 0.0))\n    score[slack < 0] = -np.inf\n    return score\n",
  "almost_worst_fit_second_best": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Almost-Worst-Fit flavor: de-emphasize the emptiest bin.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = slack.copy()\n    score[slack < 0] = -np.inf\n    if np.isfinite(score).any():\n        j = int(np.nanargmax(score))\n        score[j] = score[j] - (np.nanstd(score[np.isfinite(score)]) + 1e-9)\n    return score\n",
  "minimize_waste_with_sliver_guard": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Best-Fit, but avoid leaving tiny unusable slivers.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -slack\n    score[slack < 0] = -np.inf\n    finite = np.isfinite(score)\n    if finite.any():\n        cap_ref = np.nanmax(bins[finite]) + 1e-12\n        sliver = 0.05 * cap_ref\n        score[(slack >= 0) & (slack < sliver)] -= 0.5 * cap_ref\n    return score\n",
  "mid_slack_target_fraction": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Prefer leaving remainder near 15% of bin capacity.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    target = 0.15 * np.maximum(bins, 1e-12)\n    score = -np.abs(slack - target)\n    score[slack < 0] = -np.inf\n    return score\n",
  "tight_fit_then_balance": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Tight fits first; among them, balance post-slack around median.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    feasible = slack >= 0\n    score = np.full_like(bins, -np.inf, dtype=float)\n    if feasible.any():\n        primary = -slack\n        med = np.median(slack[feasible])\n        secondary = -np.abs(slack - med)\n        score[feasible] = primary[feasible] + 0.05 * secondary[feasible]\n    return score\n",
  "capacity_normalized_best_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Best-Fit using slack fraction (slack/bin).\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    frac = slack / np.maximum(bins, 1e-12)\n    score = -frac\n    score[slack < 0] = -np.inf\n    return score\n",
  "prefer_exact_fit_bonus": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Best-Fit with a huge bonus for exact (or near-exact) fits.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = -slack\n    score[slack < 0] = -np.inf\n    tol = 1e-9\n    score[np.abs(slack) <= tol] += 1e6\n    return score\n",
  "large_item_roomy_small_item_tight": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Large items -> roomy bins; small items -> tight bins.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        cap_ref = np.nanmax(bins[feasible]) + 1e-12\n        big = item >= 0.6 * cap_ref\n        score[feasible] = (slack[feasible] if big else -slack[feasible])\n    return score\n",
  "quantile_target_slack_25": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Target slack near the 25th percentile of feasible slacks.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        target = np.quantile(slack[feasible], 0.25)\n        score[feasible] = -np.abs(slack[feasible] - target)\n    return score\n",
  "zscore_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Prefer tighter-than-average feasible bins via slack z-score.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        mu = np.mean(s)\n        sd = np.std(s) + 1e-12\n        score[feasible] = -(s - mu) / sd\n    return score\n",
  "guard_band_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Prefer slack in a middle band; avoid tiny or huge remainders.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        cap_ref = np.nanmax(bins[feasible]) + 1e-12\n        low, high = 0.02 * cap_ref, 0.35 * cap_ref\n        mid = 0.5 * (low + high)\n        score[feasible] = -np.abs(slack[feasible] - mid) - 0.1 * slack[feasible]\n        score[(slack >= 0) & (slack < low)] -= cap_ref\n        score[(slack > high)] -= 0.25 * cap_ref\n    return score\n",
  "spread_remaining_capacities": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Encourage spread in post-slacks to reduce later dead-ends.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        mu = np.mean(slack[feasible])\n        score[feasible] = np.abs(slack[feasible] - mu) - 0.05 * slack[feasible]\n    return score\n",
  "temperature_scaled_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Tight-fit score scaled by slack std (acts like a temperature).\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        temp = np.std(slack[feasible]) + 1e-9\n        score[feasible] = -slack[feasible] / temp\n    return score\n",
  "harmonic_tight_and_not_too_small": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Combine tightness and avoiding very small bins.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        a = slack[feasible] + 1e-12\n        b = 1.0 / (bins[feasible] + 1e-12)\n        score[feasible] = 2.0 / (a + b)\n    return score\n",
  "small_items_best_large_items_worst": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Small items: best-fit; large items: worst-fit.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        cap_ref = np.nanmax(bins[feasible]) + 1e-12\n        large = item >= 0.5 * cap_ref\n        score[feasible] = (slack[feasible] if large else -slack[feasible])\n    return score\n",
  "capacity_near_small_integer_multiple_of_item": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Prefer bins whose capacity is close to k*item for small k.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        k = np.clip(np.round(bins / max(item, 1e-12)), 1, 5)\n        target = k * item\n        score[feasible] = -np.abs(bins[feasible] - target[feasible]) - 0.05 * slack[feasible]\n    return score\n",
  "penalize_too_small_gap_relative_item": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Best-fit, but penalize leaving gaps smaller than item/4.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = -slack\n    score[slack < 0] = -np.inf\n    small_gap = (slack >= 0) & (slack < 0.25 * item)\n    score[small_gap] -= 10.0 * (0.25 * item - slack[small_gap])\n    return score\n",
  "worst_fit_with_big_gap_penalty": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Worst-fit, but penalize overly large gaps above 80th percentile.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = slack\n    score[slack < 0] = -np.inf\n    feasible = slack >= 0\n    if feasible.any():\n        hi = np.quantile(slack[feasible], 0.80)\n        too_big = slack > hi\n        score[too_big] -= (slack[too_big] - hi)\n    return score\n",
  "rank_best_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Rank feasible bins by slack (tightest gets highest).\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        order = np.argsort(s)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n        score[feasible] = -ranks\n    return score\n",
  "rank_worst_fit": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Rank feasible bins by slack descending (loosest gets highest).\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        order = np.argsort(-s)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n        score[feasible] = -ranks\n    return score\n",
  "best_fit_with_deterministic_jitter": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Best-fit with deterministic tiny jitter to break ties.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    item = float(item)\n    slack = bins - item\n    score = -slack\n    score[slack < 0] = -np.inf\n    feasible = slack >= 0\n    if feasible.any():\n        idx = np.arange(bins.size, dtype=float)\n        jitter = np.sin((idx + 1.0) * (item + 1.234567)) * 1e-6\n        score[feasible] += jitter[feasible]\n    return score\n",
  "huber_slack_penalty": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Huber-style penalty on slack (quadratic near 0, linear far).\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        delta = np.median(slack[feasible]) + 1e-12\n        s = slack[feasible]\n        huber = np.where(s <= delta, -(s**2)/(2*delta), -(s - delta/2))\n        score[feasible] = huber\n    return score\n",
  "tight_fit_plus_capacity_skew_control": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Tight fit plus gentle pull toward mean capacity (reduces skew).\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        mu = np.mean(bins[feasible])\n        cap_term = -np.abs(bins - mu)\n        score[feasible] = -slack[feasible] + 0.01 * cap_term[feasible]\n    return score\n",
  "cdf_quantile_tightness": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Use empirical CDF of slack; prefer lower-quantile slack.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    score = np.full_like(bins, -np.inf, dtype=float)\n    feasible = slack >= 0\n    if feasible.any():\n        s = slack[feasible]\n        order = np.argsort(s)\n        ranks = np.empty_like(order, dtype=float)\n        ranks[order] = np.arange(order.size, dtype=float)\n        q = ranks / max(1.0, order.size - 1.0)\n        score[feasible] = -q\n    return score\n",
  "sigmoid_negative_slack": "import numpy as np\n\ndef priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Higher is better. Bounded score: sigmoid(-slack) for stability across scales.\"\"\"\n    bins = np.asarray(bins, dtype=float)\n    slack = bins - float(item)\n    z = -np.maximum(slack, 0.0)\n    score = 1.0 / (1.0 + np.exp(-z))\n    score[slack < 0] = -np.inf\n    return score\n"
}
