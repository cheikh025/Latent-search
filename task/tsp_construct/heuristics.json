{
  "adaptive_nn_dest_bias": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Nearest + increasing pull to destination as remaining nodes shrink.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    alpha = 0.25 + 1.75 * progress\n    score = d_cur + alpha * d_dest\n\n    return int(unv[int(np.argmin(score))])\n",
  "farthest_early_nearest_late": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Farthest exploration early, greedy tightening late.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    if progress < 0.5:\n        k = max(1, int(np.ceil(0.10 * n_rem)))\n        far_idx = np.argsort(-d_cur)[:k]\n        pick = far_idx[int(np.argmin(d_dest[far_idx]))]\n        return int(unv[int(pick)])\n\n    score = d_cur + 0.75 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "mean_proximity_to_remaining": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Close step + prefer nodes central to remaining set (low mean-to-unvisited).\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    beta = 1.5 * (1.0 - progress) + 0.1\n    score = d_cur + beta * mean_to_unv\n\n    return int(unv[int(np.argmin(score))])\n",
  "outlier_sweep_then_cluster": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Hit outliers early; prefer cluster-friendly picks late.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    m_norm = mean_to_unv / (np.mean(mean_to_unv) + 1e-12)\n\n    if progress < 0.6:\n        score = -m_norm + 0.35 * d_norm\n        return int(unv[int(np.argmin(score))])\n\n    score = d_norm + 0.75 * m_norm\n    return int(unv[int(np.argmin(score))])\n",
  "variance_anchor": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prefer nodes with low variance of distances to remaining (stable anchor).\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    var_to_unv = D.var(axis=1)\n\n    score = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.60 * (var_to_unv / (np.mean(var_to_unv) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "entropy_seeker": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prefer candidates with high distance-profile entropy (more future options).\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    row_sum = D.sum(axis=1) + 1e-12\n    P = D / row_sum[:, None]\n    entropy = -(P * np.log(P + 1e-12)).sum(axis=1)\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    e_norm = entropy / (np.mean(entropy) + 1e-12)\n\n    score = d_norm - 0.85 * e_norm\n    return int(unv[int(np.argmin(score))])\n",
  "regret_gap_guard": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prefer nodes with big (2nd-best - best) neighbor gap to avoid late pain.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    two = np.partition(D, 1, axis=1)[:, :2]\n    regret = two[:, 1] - two[:, 0]\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    r_norm = regret / (np.mean(regret) + 1e-12)\n\n    score = d_norm - 0.70 * r_norm\n    return int(unv[int(np.argmin(score))])\n",
  "two_step_best_next": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"One-step lookahead: current→cand + cand→nearest-other.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    best_next = D.min(axis=1)\n\n    score = d_cur + best_next\n    return int(unv[int(np.argmin(score))])\n",
  "two_step_balanced_with_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Lookahead + destination hint.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    best_next = D.min(axis=1)\n\n    score = d_cur + best_next + 0.35 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "minimax_centrality": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Close step + minimize max distance to remaining (worst-case guard).\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, 0.0)\n    max_to_unv = D.max(axis=1)\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    m_norm = max_to_unv / (np.mean(max_to_unv) + 1e-12)\n\n    score = d_norm + 0.85 * m_norm\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_slack_min": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize triangle slack vs direct current→destination (keep it straight).\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    slack = np.abs(d_cur + d_dest - d_cd)\n    score = slack + 0.05 * d_cur\n\n    return int(unv[int(np.argmin(score))])\n",
  "cosine_alignment_to_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prefer smallest implied angle toward destination (via law of cosines).\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    a = float(distance_matrix[current_node, destination_node])\n    b = distance_matrix[current_node, unv]\n    c = distance_matrix[unv, destination_node]\n\n    denom = 2.0 * a * (b + 1e-12) + 1e-12\n    cos_theta = (a * a + b * b - c * c) / denom\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n\n    score = (-cos_theta) + 0.03 * (b / (np.mean(b) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "augmented_savings": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Maximize detour savings vs direct-to-destination; avoid drifting from remaining.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    savings = d_cd - (d_cur + d_dest)\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    s_norm = savings / (np.mean(np.abs(savings)) + 1e-12)\n    m_norm = mean_to_unv / (np.mean(mean_to_unv) + 1e-12)\n\n    score = (-s_norm) + 0.55 * m_norm\n    return int(unv[int(np.argmin(score))])\n",
  "median_step_match": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prefer step length near median; mild destination nudge.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    med = float(np.median(d_cur))\n    score = np.abs(d_cur - med) + 0.10 * d_dest\n\n    return int(unv[int(np.argmin(score))])\n",
  "percentile_band_random": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Pick from mid-distance band; deterministic random among best-to-destination.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    lo = np.percentile(d_cur, 30)\n    hi = np.percentile(d_cur, 70)\n    band_mask = (d_cur >= lo) & (d_cur <= hi)\n\n    cand = unv[band_mask] if np.any(band_mask) else unv\n    d_dest_c = distance_matrix[cand, destination_node]\n\n    seed = (int(current_node) * 73856093) ^ (int(destination_node) * 19349663) ^ (int(unv.size) * 83492791)\n    rng = np.random.default_rng(seed % (2**32))\n\n    k = min(int(cand.size), 5)\n    best_k = np.argsort(d_dest_c)[:k]\n    pick = int(rng.integers(0, k))\n\n    return int(cand[int(best_k[pick])])\n",
  "softmin_temperature_sample": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Softmin sampling; temperature cools as remaining shrinks.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    frac = n_rem / max(1, n_total)\n\n    score = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.35 * (d_dest / (np.mean(d_dest) + 1e-12)) + 0.35 * (mean_to_unv / (np.mean(mean_to_unv) + 1e-12))\n\n    temp = (0.15 + 1.85 * frac) * (np.std(score) + 1e-12)\n\n    w = np.exp(-(score - score.min()) / (temp + 1e-12))\n    w = w / (w.sum() + 1e-12)\n\n    seed = (int(current_node) * 2654435761) ^ (int(destination_node) * 2246822519) ^ (int(n_rem) * 3266489917)\n    rng = np.random.default_rng(seed % (2**32))\n\n    pick = int(rng.choice(np.arange(unv.size), p=w))\n    return int(unv[pick])\n",
  "rank_geometric_choice": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Rank by blended score, then geometric-biased pick (more greedy late).\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    blended = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.55 * (d_dest / (np.mean(d_dest) + 1e-12))\n    order = np.argsort(blended)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    p = float(np.clip(0.15 + 0.70 * progress, 0.05, 0.95))\n\n    ranks = np.arange(order.size, dtype=float)\n    w = (1.0 - p) ** ranks * p\n    w = w / (w.sum() + 1e-12)\n\n    seed = (int(current_node) * 1597334677) ^ (int(destination_node) * 3812015801) ^ (int(n_rem) * 9586897)\n    rng = np.random.default_rng(seed % (2**32))\n\n    pick_rank = int(rng.choice(np.arange(order.size), p=w))\n    return int(unv[int(order[pick_rank])])\n",
  "k_nearest_switch": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Use k-th nearest (k>1 early, k=1 late); tie-break by destination.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    k = 3 if progress < 0.33 else (2 if progress < 0.66 else 1)\n    k = min(k, int(unv.size))\n\n    order = np.argsort(d_cur)\n    kth = order[k - 1]\n\n    kth_val = d_cur[kth]\n    tie = np.where(np.isclose(d_cur, kth_val))[0]\n    if tie.size > 1:\n        kth = tie[int(np.argmin(d_dest[tie]))]\n\n    return int(unv[int(kth)])\n",
  "isolation_priority": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Visit isolated nodes earlier (large nearest-neighbor distance within remaining).\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    isolation = D.min(axis=1)\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    iso_norm = isolation / (np.mean(isolation) + 1e-12)\n\n    score = d_norm - 0.90 * iso_norm\n    return int(unv[int(np.argmin(score))])\n",
  "destination_pulse": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Alternate mode: destination-aligned vs cluster-aligned based on state parity.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    mode = (int(current_node) + int(destination_node) + int(unv.size)) & 1\n\n    if mode == 0:\n        score = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.95 * (d_dest / (np.mean(d_dest) + 1e-12))\n    else:\n        score = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.95 * (mean_to_unv / (np.mean(mean_to_unv) + 1e-12))\n\n    return int(unv[int(np.argmin(score))])\n",
  "hash_jitter_tiebreak": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Blended greedy score + tiny deterministic jitter to break symmetry.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    base = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.35 * (d_dest / (np.mean(d_dest) + 1e-12))\n\n    jitter = np.sin(unv * 12.9898 + current_node * 78.233 + destination_node * 37.719)\n    jitter = jitter / (np.max(np.abs(jitter)) + 1e-12)\n\n    score = base + 0.02 * jitter\n    return int(unv[int(np.argmin(score))])\n",
  "edge_length_equalizer": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prefer edge length close to a blended 'typical' length (avoid tiny/huge jumps).\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    avg_cur = float(np.mean(d_cur))\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    avg_cand = D.mean(axis=1)\n\n    target = 0.55 * avg_cur + 0.45 * avg_cand\n    score = np.abs(d_cur - target)\n\n    return int(unv[int(np.argmin(score))])\n",
  "normalized_multiobjective": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Normalize and blend: step + destination + mean-to-remaining.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    def norm(x):\n        x = x.astype(float)\n        mn = float(x.min())\n        mx = float(x.max())\n        return (x - mn) / (mx - mn + 1e-12)\n\n    s1 = norm(d_cur)\n    s2 = norm(d_dest)\n    s3 = norm(mean_to_unv)\n\n    score = 0.55 * s1 + 0.25 * s2 + 0.20 * s3\n    return int(unv[int(np.argmin(score))])\n",
  "bottleneck_edge_prevent": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Penalize candidates with large 10th-percentile distance to remaining (few close options).\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    q = np.percentile(D, 10, axis=1)\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    q_norm = q / (np.mean(q) + 1e-12)\n\n    score = d_norm + 0.80 * q_norm\n    return int(unv[int(np.argmin(score))])\n",
  "two_ring_corridor": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Keep a smooth radial progression: match candidate's dest-distance to current's.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    r0 = float(distance_matrix[current_node, destination_node])\n    r = distance_matrix[unv, destination_node]\n    d_cur = distance_matrix[current_node, unv]\n\n    score = np.abs(r - r0) + 0.10 * d_cur\n    return int(unv[int(np.argmin(score))])\n",
  "antipodal_then_smooth": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Early: antipodal to destination; late: radial smoothing.\"\"\"\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    a = float(distance_matrix[current_node, destination_node])\n    b = distance_matrix[current_node, unv]\n    c = distance_matrix[unv, destination_node]\n\n    denom = 2.0 * a * (b + 1e-12) + 1e-12\n    cos_theta = (a * a + b * b - c * c) / denom\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    if progress < 0.5:\n        score = cos_theta + 0.08 * (b / (np.mean(b) + 1e-12))\n        return int(unv[int(np.argmin(score))])\n\n    r0 = a\n    score = np.abs(c - r0) + 0.08 * b\n    return int(unv[int(np.argmin(score))])\n"
}
