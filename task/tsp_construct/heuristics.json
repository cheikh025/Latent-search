{
  "adaptive_nn_dest_bias": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    alpha = 0.25 + 1.75 * progress\n    score = d_cur + alpha * d_dest\n\n    return int(unv[int(np.argmin(score))])\n",
  "farthest_early_nearest_late": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    if progress < 0.5:\n        k = max(1, int(np.ceil(0.10 * n_rem)))\n        far_idx = np.argsort(-d_cur)[:k]\n        pick = far_idx[int(np.argmin(d_dest[far_idx]))]\n        return int(unv[int(pick)])\n\n    score = d_cur + 0.75 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "mean_proximity_to_remaining": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    beta = 1.5 * (1.0 - progress) + 0.1\n    score = d_cur + beta * mean_to_unv\n\n    return int(unv[int(np.argmin(score))])\n",
  "outlier_sweep_then_cluster": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    m_norm = mean_to_unv / (np.mean(mean_to_unv) + 1e-12)\n\n    if progress < 0.6:\n        score = -m_norm + 0.35 * d_norm\n        return int(unv[int(np.argmin(score))])\n\n    score = d_norm + 0.75 * m_norm\n    return int(unv[int(np.argmin(score))])\n",
  "variance_anchor": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    var_to_unv = D.var(axis=1)\n\n    score = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.60 * (var_to_unv / (np.mean(var_to_unv) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "entropy_seeker": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    row_sum = D.sum(axis=1) + 1e-12\n    P = D / row_sum[:, None]\n    entropy = -(P * np.log(P + 1e-12)).sum(axis=1)\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    e_norm = entropy / (np.mean(entropy) + 1e-12)\n\n    score = d_norm - 0.85 * e_norm\n    return int(unv[int(np.argmin(score))])\n",
  "regret_gap_guard": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    two = np.partition(D, 1, axis=1)[:, :2]\n    regret = two[:, 1] - two[:, 0]\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    r_norm = regret / (np.mean(regret) + 1e-12)\n\n    score = d_norm - 0.70 * r_norm\n    return int(unv[int(np.argmin(score))])\n",
  "two_step_best_next": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    best_next = D.min(axis=1)\n\n    score = d_cur + best_next\n    return int(unv[int(np.argmin(score))])\n",
  "two_step_balanced_with_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    best_next = D.min(axis=1)\n\n    score = d_cur + best_next + 0.35 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "minimax_centrality": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, 0.0)\n    max_to_unv = D.max(axis=1)\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    m_norm = max_to_unv / (np.mean(max_to_unv) + 1e-12)\n\n    score = d_norm + 0.85 * m_norm\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_slack_min": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    slack = np.abs(d_cur + d_dest - d_cd)\n    score = slack + 0.05 * d_cur\n\n    return int(unv[int(np.argmin(score))])\n",
  "cosine_alignment_to_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    a = float(distance_matrix[current_node, destination_node])\n    b = distance_matrix[current_node, unv]\n    c = distance_matrix[unv, destination_node]\n\n    denom = 2.0 * a * (b + 1e-12) + 1e-12\n    cos_theta = (a * a + b * b - c * c) / denom\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n\n    score = (-cos_theta) + 0.03 * (b / (np.mean(b) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "augmented_savings": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    savings = d_cd - (d_cur + d_dest)\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    s_norm = savings / (np.mean(np.abs(savings)) + 1e-12)\n    m_norm = mean_to_unv / (np.mean(mean_to_unv) + 1e-12)\n\n    score = (-s_norm) + 0.55 * m_norm\n    return int(unv[int(np.argmin(score))])\n",
  "median_step_match": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    med = float(np.median(d_cur))\n    score = np.abs(d_cur - med) + 0.10 * d_dest\n\n    return int(unv[int(np.argmin(score))])\n",
  "percentile_band_random": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    lo = np.percentile(d_cur, 30)\n    hi = np.percentile(d_cur, 70)\n    band_mask = (d_cur >= lo) & (d_cur <= hi)\n\n    cand = unv[band_mask] if np.any(band_mask) else unv\n    d_dest_c = distance_matrix[cand, destination_node]\n\n    seed = (int(current_node) * 73856093) ^ (int(destination_node) * 19349663) ^ (int(unv.size) * 83492791)\n    rng = np.random.default_rng(seed % (2**32))\n\n    k = min(int(cand.size), 5)\n    best_k = np.argsort(d_dest_c)[:k]\n    pick = int(rng.integers(0, k))\n\n    return int(cand[int(best_k[pick])])\n",
  "softmin_temperature_sample": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    frac = n_rem / max(1, n_total)\n\n    score = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.35 * (d_dest / (np.mean(d_dest) + 1e-12)) + 0.35 * (mean_to_unv / (np.mean(mean_to_unv) + 1e-12))\n\n    temp = (0.15 + 1.85 * frac) * (np.std(score) + 1e-12)\n\n    w = np.exp(-(score - score.min()) / (temp + 1e-12))\n    w = w / (w.sum() + 1e-12)\n\n    seed = (int(current_node) * 2654435761) ^ (int(destination_node) * 2246822519) ^ (int(n_rem) * 3266489917)\n    rng = np.random.default_rng(seed % (2**32))\n\n    pick = int(rng.choice(np.arange(unv.size), p=w))\n    return int(unv[pick])\n",
  "rank_geometric_choice": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    blended = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.55 * (d_dest / (np.mean(d_dest) + 1e-12))\n    order = np.argsort(blended)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    p = float(np.clip(0.15 + 0.70 * progress, 0.05, 0.95))\n\n    ranks = np.arange(order.size, dtype=float)\n    w = (1.0 - p) ** ranks * p\n    w = w / (w.sum() + 1e-12)\n\n    seed = (int(current_node) * 1597334677) ^ (int(destination_node) * 3812015801) ^ (int(n_rem) * 9586897)\n    rng = np.random.default_rng(seed % (2**32))\n\n    pick_rank = int(rng.choice(np.arange(order.size), p=w))\n    return int(unv[int(order[pick_rank])])\n",
  "k_nearest_switch": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    k = 3 if progress < 0.33 else (2 if progress < 0.66 else 1)\n    k = min(k, int(unv.size))\n\n    order = np.argsort(d_cur)\n    kth = order[k - 1]\n\n    kth_val = d_cur[kth]\n    tie = np.where(np.isclose(d_cur, kth_val))[0]\n    if tie.size > 1:\n        kth = tie[int(np.argmin(d_dest[tie]))]\n\n    return int(unv[int(kth)])\n",
  "isolation_priority": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    isolation = D.min(axis=1)\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    iso_norm = isolation / (np.mean(isolation) + 1e-12)\n\n    score = d_norm - 0.90 * iso_norm\n    return int(unv[int(np.argmin(score))])\n",
  "destination_pulse": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    mode = (int(current_node) + int(destination_node) + int(unv.size)) & 1\n\n    if mode == 0:\n        score = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.95 * (d_dest / (np.mean(d_dest) + 1e-12))\n    else:\n        score = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.95 * (mean_to_unv / (np.mean(mean_to_unv) + 1e-12))\n\n    return int(unv[int(np.argmin(score))])\n",
  "hash_jitter_tiebreak": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    base = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.35 * (d_dest / (np.mean(d_dest) + 1e-12))\n\n    jitter = np.sin(unv * 12.9898 + current_node * 78.233 + destination_node * 37.719)\n    jitter = jitter / (np.max(np.abs(jitter)) + 1e-12)\n\n    score = base + 0.02 * jitter\n    return int(unv[int(np.argmin(score))])\n",
  "edge_length_equalizer": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    avg_cur = float(np.mean(d_cur))\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    avg_cand = D.mean(axis=1)\n\n    target = 0.55 * avg_cur + 0.45 * avg_cand\n    score = np.abs(d_cur - target)\n\n    return int(unv[int(np.argmin(score))])\n",
  "normalized_multiobjective": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n\n    def norm(x):\n        x = x.astype(float)\n        mn = float(x.min())\n        mx = float(x.max())\n        return (x - mn) / (mx - mn + 1e-12)\n\n    s1 = norm(d_cur)\n    s2 = norm(d_dest)\n    s3 = norm(mean_to_unv)\n\n    score = 0.55 * s1 + 0.25 * s2 + 0.20 * s3\n    return int(unv[int(np.argmin(score))])\n",
  "bottleneck_edge_prevent": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    q = np.percentile(D, 10, axis=1)\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    q_norm = q / (np.mean(q) + 1e-12)\n\n    score = d_norm + 0.80 * q_norm\n    return int(unv[int(np.argmin(score))])\n",
  "two_ring_corridor": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    r0 = float(distance_matrix[current_node, destination_node])\n    r = distance_matrix[unv, destination_node]\n    d_cur = distance_matrix[current_node, unv]\n\n    score = np.abs(r - r0) + 0.10 * d_cur\n    return int(unv[int(np.argmin(score))])\n",
  "antipodal_then_smooth": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    a = float(distance_matrix[current_node, destination_node])\n    b = distance_matrix[current_node, unv]\n    c = distance_matrix[unv, destination_node]\n\n    denom = 2.0 * a * (b + 1e-12) + 1e-12\n    cos_theta = (a * a + b * b - c * c) / denom\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    if progress < 0.5:\n        score = cos_theta + 0.08 * (b / (np.mean(b) + 1e-12))\n        return int(unv[int(np.argmin(score))])\n\n    r0 = a\n    score = np.abs(c - r0) + 0.08 * b\n    return int(unv[int(np.argmin(score))])\n",
  "regret_weighted_earliness": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    # For each candidate, find two smallest edges to remaining (best/second-best).\n    part = np.partition(D, 1, axis=1)\n    best = part[:, 0]\n    second = part[:, 1]\n    regret = second - best\n\n    d_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    r_norm = regret / (np.mean(regret) + 1e-12)\n\n    # High regret => serve earlier => subtract regret.\n    score = d_norm - 0.90 * r_norm\n    return int(unv[int(np.argmin(score))])\n",
  "trimmed_candidate_set_future_pull": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    n_rem = int(unv.size)\n    k = int(max(2, min(n_rem, np.ceil(0.18 * n_rem))))\n    cand_idx = np.argsort(d_cur)[:k]\n\n    cand = unv[cand_idx]\n    Dc = distance_matrix[np.ix_(cand, unv)]\n\n    # Harmonic mean of distances to remaining (smaller is better).\n    hm = float(Dc.shape[1]) / (np.sum(1.0 / (Dc + 1e-12), axis=1) + 1e-12)\n\n    score = (d_cur[cand_idx] / (np.mean(d_cur[cand_idx]) + 1e-12)) + 0.85 * (hm / (np.mean(hm) + 1e-12))\n    return int(cand[int(np.argmin(score))])\n",
  "triangle_slack_to_destination": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    # Slack >= 0 by triangle inequality in metric-ish cases; still usable generally.\n    slack = (d_cur + d_dest) - d_cd\n\n    s_norm = slack / (np.mean(slack) + 1e-12)\n    c_norm = d_cur / (np.mean(d_cur) + 1e-12)\n\n    # Prefer small slack (destination-consistent), but keep steps short too.\n    score = 0.70 * c_norm + 0.90 * s_norm\n    return int(unv[int(np.argmin(score))])\n",
  "mst_edge_proxy_step": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    attach_cost = D.min(axis=1)  # cheapest edge to connect candidate into remaining\n\n    a_norm = attach_cost / (np.mean(attach_cost) + 1e-12)\n    c_norm = d_cur / (np.mean(d_cur) + 1e-12)\n\n    # Move cheaply now, and also choose nodes that are easy to connect later.\n    score = c_norm + 0.95 * a_norm\n    return int(unv[int(np.argmin(score))])\n",
  "bridge_balance_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    n = int(unv.size)\n    k = int(max(2, min(n - 1, np.ceil(0.12 * n))))\n\n    near = np.partition(D, k - 1, axis=1)[:, :k].mean(axis=1)\n    far = np.partition(D, n - k - 1, axis=1)[:, -k:].mean(axis=1)\n\n    ratio = near / (far + 1e-12)  # closer to 1 => balanced\n    balance = np.abs(ratio - 1.0)\n\n    b_norm = balance / (np.mean(balance) + 1e-12)\n    c_norm = d_cur / (np.mean(d_cur) + 1e-12)\n\n    score = c_norm + 0.80 * b_norm\n    return int(unv[int(np.argmin(score))])\n",
  "median_radial_progress": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    radial = d_dest - d_cur\n    target = float(np.median(radial))\n\n    # Preference: stay near the typical radial change while keeping steps modest.\n    score = np.abs(radial - target) + 0.25 * (d_cur / (np.mean(d_cur) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "hash_jittered_softmin": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    base = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.65 * (d_dest / (np.mean(d_dest) + 1e-12))\n\n    # Hash-like jitter in [0,1): stable across runs, varies with state and candidate id.\n    seed = (int(current_node) * 1315423911) ^ (int(destination_node) * 2654435761) ^ (int(unv.size) * 97531)\n    x = (unv.astype(np.int64) ^ np.int64(seed)) & np.int64(0xFFFFFFFF)\n    jitter = ((x * np.int64(1103515245) + np.int64(12345)) & np.int64(0x7FFFFFFF)).astype(np.float64)\n    jitter = (jitter / (2.0**31))\n\n    # Temperature adapts to remaining size: more exploration early.\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    temp = 0.55 - 0.45 * progress\n\n    score = base + temp * (jitter - 0.5)\n    return int(unv[int(np.argmin(score))])\n",
  "k_nearest_density_schedule": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    k = int(max(2, min(n_rem - 1, np.ceil(0.10 * n_rem))))\n    knn = np.partition(D, k - 1, axis=1)[:, :k].mean(axis=1)\n\n    # Larger knn mean => sparser neighborhood.\n    c_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    knn_norm = knn / (np.mean(knn) + 1e-12)\n\n    # Early: prefer sparse (subtract), late: prefer dense (add).\n    w = 1.10 * (0.5 - progress)\n    score = c_norm + w * knn_norm\n    return int(unv[int(np.argmin(score))])\n",
  "ranked_destination_gate": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    # Destination rank among remaining (0 = closest to destination).\n    order = np.argsort(d_dest)\n    rank = np.empty_like(order)\n    rank[order] = np.arange(order.size)\n    rank = rank.astype(np.float64)\n    rank_norm = rank / (np.mean(rank) + 1e-12)\n\n    c_norm = d_cur / (np.mean(d_cur) + 1e-12)\n\n    # Early allow wandering (small penalty), late enforce destination-closeness (big penalty).\n    gate = 0.20 + 1.60 * progress\n    score = c_norm + gate * rank_norm\n    return int(unv[int(np.argmin(score))])\n",
  "two_step_to_destination_minplus": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    n = int(unv.size)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_to_dest = distance_matrix[unv, destination_node]\n\n    if n == 1:\n        return int(unv[0])\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    # For each candidate i, compute min_j (D[i,j] + d_to_dest[j]).\n    future = np.min(D + d_to_dest[None, :], axis=1)\n\n    score = d_cur + 0.95 * future\n    return int(unv[int(np.argmin(score))])\n",
  "perimeter_first_closure": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_all = D.mean(axis=1)  # larger => more 'peripheral'\n\n    if progress < 0.55:\n        score = (d_cur / (np.mean(d_cur) + 1e-12)) - 0.95 * (mean_to_all / (np.mean(mean_to_all) + 1e-12))\n        return int(unv[int(np.argmin(score))])\n\n    score = d_cur + 0.85 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "destination_rank_bandit": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    n = int(unv.size)\n    band = int(max(2, min(n, np.ceil(0.20 * n))))\n    best_to_dest_idx = np.argsort(d_dest)[:band]\n\n    cand = unv[best_to_dest_idx]\n    dc = d_cur[best_to_dest_idx]\n    dd = d_dest[best_to_dest_idx]\n\n    # Within band, prefer short step but also keep destination very close.\n    score = (dc / (np.mean(dc) + 1e-12)) + 1.10 * (dd / (np.mean(dd) + 1e-12))\n    return int(cand[int(np.argmin(score))])\n",
  "inverse_square_potential_field": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    # Repulsion: sum 1/(d^2) to all others (bigger => crowded area).\n    repulse = np.sum(1.0 / (D * D + 1e-9), axis=1)\n\n    c_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    a_norm = d_dest / (np.mean(d_dest) + 1e-12)\n    r_norm = repulse / (np.mean(repulse) + 1e-12)\n\n    # Prefer short move + destination attraction, and avoid very crowded zones early.\n    score = c_norm + 0.75 * a_norm + 0.35 * r_norm\n    return int(unv[int(np.argmin(score))])\n",
  "cheapest_insertion_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    insertion_cost = (d_cur + d_dest) - d_cd\n\n    # Add a mild preference to keep future connections easy.\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    attach = D.min(axis=1)\n\n    ins_norm = insertion_cost / (np.mean(np.abs(insertion_cost)) + 1e-12)\n    att_norm = attach / (np.mean(attach) + 1e-12)\n\n    score = ins_norm + 0.35 * att_norm\n    return int(unv[int(np.argmin(score))])\n",
  "local_two_opt_risk": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    # Compare to swapping via best other node j: cur->j + j->dest.\n    alt = distance_matrix[current_node, unv] + distance_matrix[unv, destination_node]\n    best_alt = float(np.min(alt))\n\n    risk = (d_cur + d_dest) - best_alt\n\n    c_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    r_norm = risk / (np.mean(np.abs(risk)) + 1e-12)\n\n    score = 0.65 * c_norm + 0.90 * r_norm\n    return int(unv[int(np.argmin(score))])\n",
  "min_sum_of_two_closest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    two = np.partition(D, 1, axis=1)[:, :2]\n    sum2 = two.sum(axis=1)\n\n    c_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    s_norm = sum2 / (np.mean(sum2) + 1e-12)\n\n    score = c_norm + 0.90 * s_norm\n    return int(unv[int(np.argmin(score))])\n",
  "destination_overshoot_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    r0 = float(distance_matrix[current_node, destination_node])\n    r = distance_matrix[unv, destination_node]\n    d_cur = distance_matrix[current_node, unv]\n\n    overshoot = np.maximum(0.0, r - r0)\n\n    o_norm = overshoot / (np.mean(overshoot) + 1e-12)\n    c_norm = d_cur / (np.mean(d_cur) + 1e-12)\n\n    # Strongly avoid moves that increase distance-to-destination; still keep steps short.\n    score = c_norm + 1.25 * o_norm\n    return int(unv[int(np.argmin(score))])\n",
  "quantile_target_edge": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    # Early aim higher quantile (longer hops), late aim lower quantile (short hops).\n    q = 0.75 - 0.55 * progress\n    target = float(np.quantile(d_cur, q))\n\n    score = np.abs(d_cur - target)\n    return int(unv[int(np.argmin(score))])\n",
  "destination_cone_filter": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    a = float(distance_matrix[current_node, destination_node])\n    b = distance_matrix[current_node, unv]\n    c = distance_matrix[unv, destination_node]\n\n    denom = 2.0 * a * (b + 1e-12) + 1e-12\n    cos_theta = (a * a + b * b - c * c) / denom\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n\n    # Cone threshold tightens over time.\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    thr = 0.05 + 0.85 * progress  # late -> require strong alignment\n\n    aligned = np.where(cos_theta >= thr)[0]\n\n    if aligned.size > 0:\n        idx = aligned\n        score = (b[idx] / (np.mean(b[idx]) + 1e-12)) + 0.70 * (c[idx] / (np.mean(c[idx]) + 1e-12))\n        return int(unv[int(idx[int(np.argmin(score))])])\n\n    # Fallback: smallest triangle slack.\n    slack = (b + c) - a\n    score = slack + 0.10 * b\n    return int(unv[int(np.argmin(score))])\n",
  "barycentric_pull_then_clip": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    d_cur = distance_matrix[current_node, unv]\n\n    # Rank-based centrality: average rank of distances to others (lower rank => more central).\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    ranks = np.argsort(np.argsort(D, axis=1), axis=1).astype(np.float64)\n    central_rank = ranks.mean(axis=1)\n\n    # Clip to a near set to avoid huge moves.\n    n = int(unv.size)\n    k = int(max(2, min(n, np.ceil(0.25 * n))))\n    near_idx = np.argsort(d_cur)[:k]\n\n    c = unv[near_idx]\n    cr = central_rank[near_idx]\n    dc = d_cur[near_idx]\n\n    score = (dc / (np.mean(dc) + 1e-12)) + 0.80 * (cr / (np.mean(cr) + 1e-12))\n    return int(c[int(np.argmin(score))])\n",
  "destination_differential_greedy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    r0 = float(distance_matrix[current_node, destination_node])\n    step = distance_matrix[current_node, unv]\n    r1 = distance_matrix[unv, destination_node]\n\n    gain = r0 - r1  # positive => progress toward destination\n    eff = step / (gain + 1e-12)  # smaller is better\n\n    # Prefer positive gain; if all negative, fall back to shortest step.\n    if np.all(gain <= 1e-12):\n        return int(unv[int(np.argmin(step))])\n\n    eff = np.where(gain > 1e-12, eff, np.inf)\n    return int(unv[int(np.argmin(eff))])\n",
  "softmax_sampling_deterministic": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    base = (d_cur / (np.mean(d_cur) + 1e-12)) + 0.85 * (d_dest / (np.mean(d_dest) + 1e-12))\n\n    # Gumbel-like deterministic noise in (0,1)\n    seed = (int(current_node) * 1000003) ^ (int(destination_node) * 9176) ^ (int(unv.size) * 6151)\n    x = (unv.astype(np.int64) ^ np.int64(seed)) & np.int64(0xFFFFFFFF)\n    u = ((x * np.int64(1664525) + np.int64(1013904223)) & np.int64(0xFFFFFFFF)).astype(np.float64) / (2.0**32)\n    u = np.clip(u, 1e-12, 1.0 - 1e-12)\n    g = -np.log(-np.log(u))\n\n    # Temperature increases early, decreases late.\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    tau = 0.85 - 0.65 * progress\n\n    score = base - tau * g\n    return int(unv[int(np.argmin(score))])\n",
  "min_cycle_closure_risk": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    # Proxy: discourage candidates that are simultaneously close to current and destination (may create short loops).\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    loopiness = 1.0 / (d_cur + 1e-12) + 1.0 / (d_dest + 1e-12)\n\n    c_norm = d_cur / (np.mean(d_cur) + 1e-12)\n    l_norm = loopiness / (np.mean(loopiness) + 1e-12)\n\n    score = c_norm + 0.55 * l_norm\n    return int(unv[int(np.argmin(score))])\n",
  "min_geometric_mean_step_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n    rem = distance_matrix[unv, destination_node]\n\n    score = np.sqrt((step + 1e-12) * (rem + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "min_l1_rank_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n    dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    central = D.mean(axis=1)\n\n    r_step = np.argsort(np.argsort(step)).astype(np.float64)\n    r_dest = np.argsort(np.argsort(dest)).astype(np.float64)\n    r_cent = np.argsort(np.argsort(central)).astype(np.float64)\n\n    score = r_step + 0.9 * r_dest + 0.6 * r_cent\n    return int(unv[int(np.argmin(score))])\n",
  "max_margin_to_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    part = np.partition(D, 2, axis=1)\n    d1, d3 = part[:, 0], part[:, 2]\n    margin = d3 - d1\n\n    s_norm = step / (np.mean(step) + 1e-12)\n    m_norm = margin / (np.mean(margin) + 1e-12)\n\n    # Larger margin => serve earlier.\n    score = s_norm - 0.80 * m_norm\n    return int(unv[int(np.argmin(score))])\n",
  "min_destination_curvature": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    cd = float(distance_matrix[current_node, destination_node])\n    step = distance_matrix[current_node, unv]\n    rem = distance_matrix[unv, destination_node]\n\n    curvature = (step + rem) / (cd + 1e-12)\n    score = curvature + 0.05 * (step / (np.mean(step) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "min_quantile_attach_cost": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    q75 = np.percentile(D, 75, axis=1)\n\n    s_norm = step / (np.mean(step) + 1e-12)\n    q_norm = q75 / (np.mean(q75) + 1e-12)\n\n    score = s_norm + 0.70 * q_norm\n    return int(unv[int(np.argmin(score))])\n",
  "destination_monotone_filter": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    r0 = float(distance_matrix[current_node, destination_node])\n    r = distance_matrix[unv, destination_node]\n    step = distance_matrix[current_node, unv]\n\n    ok = np.where(r <= r0 + 1e-12)[0]\n    if ok.size > 0:\n        idx = ok\n        score = step[idx] + 0.55 * r[idx]\n        return int(unv[int(idx[int(np.argmin(score))])])\n\n    # fallback: minimal triangle slack\n    slack = (step + r) - r0\n    score = slack + 0.10 * step\n    return int(unv[int(np.argmin(score))])\n",
  "centrality_then_isolation_switch": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    central = D.mean(axis=1)\n    isolation = D.min(axis=1)\n\n    s_norm = step / (np.mean(step) + 1e-12)\n    c_norm = central / (np.mean(central) + 1e-12)\n    i_norm = isolation / (np.mean(isolation) + 1e-12)\n\n    if progress < 0.55:\n        score = s_norm + 0.85 * c_norm\n    else:\n        score = s_norm - 0.85 * i_norm\n\n    return int(unv[int(np.argmin(score))])\n",
  "destination_rank_smoothing": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    order = np.argsort(d_dest)\n    rank = np.empty_like(order)\n    rank[order] = np.arange(order.size)\n    rank = rank.astype(np.float64)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    # Sigmoid center shifts with progress.\n    x = (rank / max(1.0, float(n_rem)))\n    center = 0.65 - 0.45 * progress\n    steep = 10.0\n    penalty = 1.0 / (1.0 + np.exp(-steep * (x - center)))\n\n    score = (step / (np.mean(step) + 1e-12)) + 1.10 * penalty\n    return int(unv[int(np.argmin(score))])\n",
  "min_destination_hinge_loss": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    r0 = float(distance_matrix[current_node, destination_node])\n    r = distance_matrix[unv, destination_node]\n    step = distance_matrix[current_node, unv]\n\n    margin = 0.05 * (np.mean(r) + 1e-12)\n    hinge = np.maximum(0.0, r - (r0 + margin))\n\n    score = (step / (np.mean(step) + 1e-12)) + 1.00 * (hinge / (np.mean(hinge) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "trimmed_mean_centrality": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    n = int(unv.size)\n    if n <= 6:\n        central = D.mean(axis=1)\n    else:\n        lo = int(np.floor(0.15 * n))\n        hi = int(np.ceil(0.85 * n))\n        sorted_row = np.sort(D, axis=1)\n        central = sorted_row[:, lo:hi].mean(axis=1)\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.85 * (central / (np.mean(central) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "kcore_proxy_degree": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    # Radius = median of all pairwise distances in remaining.\n    radius = float(np.median(D[np.isfinite(D)]))\n    deg = np.sum(D <= radius, axis=1).astype(np.float64)\n\n    # Target medium degree ~ median.\n    target = float(np.median(deg))\n    score = np.abs(deg - target) / (np.mean(np.abs(deg - target)) + 1e-12) + 0.35 * (step / (np.mean(step) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "destination_aligned_pair_min": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    n = int(unv.size)\n    if n == 1:\n        return int(unv[0])\n\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    # For each i, allow j only if d_dest[j] <= d_dest[i] (toward destination).\n    allow = (d_dest[None, :] <= d_dest[:, None])\n    masked = np.where(allow, D, np.inf)\n    future = np.min(masked, axis=1)\n\n    score = step + 0.95 * future\n    return int(unv[int(np.argmin(score))])\n",
  "local_spread_minimizer": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    n = int(unv.size)\n    k = int(max(3, min(n - 1, np.ceil(0.12 * n))))\n    knn = np.partition(D, k - 1, axis=1)[:, :k]\n    spread = knn.std(axis=1)\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.80 * (spread / (np.mean(spread) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "destination_ring_quantized": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    r0 = float(distance_matrix[current_node, destination_node])\n    r = distance_matrix[unv, destination_node]\n    step = distance_matrix[current_node, unv]\n\n    # Ring width based on IQR of remaining destination distances.\n    iqr = float(np.subtract(*np.percentile(r, [75, 25]))) + 1e-12\n    w = 0.35 * iqr\n\n    ring0 = np.floor(r0 / w)\n    ring = np.floor(r / w)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    # Early: stay in same ring; late: prefer smaller ring index.\n    if progress < 0.55:\n        penalty = np.abs(ring - ring0)\n    else:\n        penalty = ring\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.85 * (penalty / (np.mean(penalty) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "min_destination_pareto_front": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n    dest = distance_matrix[unv, destination_node]\n\n    # Identify non-dominated points (min step and min dest).\n    idx = np.argsort(step)\n    best_dest = np.inf\n    nd = []\n    for i in idx:\n        if dest[i] < best_dest - 1e-12:\n            nd.append(i)\n            best_dest = dest[i]\n\n    nd = np.array(nd, dtype=int)\n    if nd.size == 1:\n        return int(unv[int(nd[0])])\n\n    # Tie-break by mean distance to remaining (prefer smaller = more central).\n    D = distance_matrix[np.ix_(unv, unv)]\n    central = D.mean(axis=1)\n\n    s = step[nd] / (np.mean(step[nd]) + 1e-12)\n    c = central[nd] / (np.mean(central[nd]) + 1e-12)\n    d = dest[nd] / (np.mean(dest[nd]) + 1e-12)\n\n    score = 0.55 * s + 0.55 * d + 0.35 * c\n    return int(unv[int(nd[int(np.argmin(score))])])\n",
  "max_future_min_progress": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    n = int(unv.size)\n    if n == 1:\n        return int(unv[0])\n\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    k = int(max(2, min(n - 1, np.ceil(0.10 * n))))\n    knn_idx = np.argpartition(D, k - 1, axis=1)[:, :k]\n\n    # For each i, consider its k-nearest neighbors; compute minimum progress advantage.\n    adv = np.empty(n, dtype=np.float64)\n    for i in range(n):\n        neigh = knn_idx[i]\n        adv[i] = np.min(d_dest[i] - d_dest[neigh])\n\n    # Larger adv (less negative / more positive) is better; convert to minimization.\n    a_norm = adv / (np.mean(np.abs(adv)) + 1e-12)\n    s_norm = step / (np.mean(step) + 1e-12)\n\n    score = s_norm - 0.75 * a_norm\n    return int(unv[int(np.argmin(score))])\n",
  "closest_to_median_pairwise": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    med = np.median(D, axis=1)\n    mad = np.median(np.abs(D - med[:, None]), axis=1)\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.90 * (mad / (np.mean(mad) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "anti_hub_preference": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    # Small radius = 25th percentile of finite distances.\n    finite = D[np.isfinite(D)]\n    r = float(np.percentile(finite, 25)) + 1e-12\n    degree = np.sum(D <= r, axis=1).astype(np.float64)\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.75 * (degree / (np.mean(degree) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "max_gap_in_destination_ranks": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_dest = distance_matrix[unv, destination_node]\n    step = distance_matrix[current_node, unv]\n\n    order = np.argsort(d_dest)\n    sd = d_dest[order]\n    gaps = np.diff(sd)\n    if gaps.size == 0:\n        return int(unv[int(np.argmin(step))])\n\n    cut = int(np.argmax(gaps))\n    # Candidate set: around the boundary (two on each side).\n    lo = max(0, cut - 1)\n    hi = min(order.size - 1, cut + 2)\n    band_idx = order[lo:hi+1]\n\n    score = (step[band_idx] / (np.mean(step[band_idx]) + 1e-12)) + 0.85 * (d_dest[band_idx] / (np.mean(d_dest[band_idx]) + 1e-12))\n    return int(unv[int(band_idx[int(np.argmin(score))])])\n",
  "min_expected_next_step": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    exp_next = D.mean(axis=1)\n\n    score = step + 0.70 * exp_next\n    return int(unv[int(np.argmin(score))])\n",
  "min_worst_kNN": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    n = int(unv.size)\n    k = int(max(2, min(n - 1, np.ceil(0.10 * n))))\n    knn = np.partition(D, k - 1, axis=1)[:, :k]\n    radius = knn.max(axis=1)\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.95 * (radius / (np.mean(radius) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "destination_hysteresis": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    r0 = float(distance_matrix[current_node, destination_node])\n    # Threshold derived from remaining dest-distance distribution.\n    thr = float(np.percentile(d_dest, 35))\n\n    if r0 <= thr + 1e-12:\n        score = step + 1.15 * d_dest\n    else:\n        D = distance_matrix[np.ix_(unv, unv)]\n        central = D.mean(axis=1)\n        score = (step / (np.mean(step) + 1e-12)) + 0.90 * (central / (np.mean(central) + 1e-12))\n\n    return int(unv[int(np.argmin(score))])\n",
  "min_span_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, 0.0)\n    mx = D.max(axis=1)\n    mn = np.where(D == 0.0, np.inf, D).min(axis=1)\n    span = mx - mn\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.85 * (span / (np.mean(span) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "quantile_balanced_step": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    finite = D[np.isfinite(D)]\n    if finite.size == 0:\n        return int(unv[int(np.argmin(step))])\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    q = 0.35 + 0.40 * (1.0 - progress)  # early higher\n    target = float(np.quantile(finite, q))\n\n    score = np.abs(step - target)\n    return int(unv[int(np.argmin(score))])\n",
  "min_logsumexp_future": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n\n    # Temperature on remaining size.\n    n = int(unv.size)\n    tau = 0.35 + 0.25 * (n / max(1, int(distance_matrix.shape[0])))\n\n    x = -D / (tau + 1e-12)\n    m = np.max(x, axis=1)\n    lse = m + np.log(np.sum(np.exp(x - m[:, None]), axis=1) + 1e-12)\n    softmin = -tau * lse\n\n    score = step + 0.55 * softmin\n    return int(unv[int(np.argmin(score))])\n",
  "min_destination_betweenness_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    # For each candidate i, count how many j satisfy d(j,i)+d(i,dest) <= (1+eps)*d(j,dest)\n    d_i_dest = distance_matrix[unv, destination_node]\n    Dji = distance_matrix[np.ix_(unv, unv)]  # j->i\n    d_j_dest = d_i_dest.copy()\n\n    eps = 0.08\n    # Broadcast: for each i (col), compare for all j (row)\n    on_path = (Dji + d_i_dest[None, :]) <= (1.0 + eps) * d_j_dest[:, None] + 1e-12\n    count = on_path.sum(axis=0).astype(np.float64)  # per i\n\n    # Prefer higher count (more 'bridge' to destination)\n    c_norm = count / (np.mean(count) + 1e-12)\n    s_norm = step / (np.mean(step) + 1e-12)\n\n    score = s_norm - 0.75 * c_norm\n    return int(unv[int(np.argmin(score))])\n",
  "min_detour_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    cd = float(distance_matrix[current_node, destination_node])\n    step = distance_matrix[current_node, unv]\n    rem = distance_matrix[unv, destination_node]\n\n    ratio = (step + rem) / (cd + 1e-12)\n    score = ratio + 0.05 * (step / (np.mean(step) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "max_interiority_score": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    med = np.median(D, axis=1)\n    interior = np.sum(D <= med[:, None], axis=1).astype(np.float64)\n\n    # Prefer higher interiority; still keep step short.\n    i_norm = interior / (np.mean(interior) + 1e-12)\n    s_norm = step / (np.mean(step) + 1e-12)\n\n    score = s_norm - 0.70 * i_norm\n    return int(unv[int(np.argmin(score))])\n",
  "min_border_crossing": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    # Current's profile vs remaining\n    cur_prof = distance_matrix[current_node, unv]\n    qcur = float(np.quantile(cur_prof, 0.35))\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    q = np.quantile(D, 0.35, axis=1)\n\n    step = distance_matrix[current_node, unv]\n    score = np.abs(q - qcur) + 0.20 * (step / (np.mean(step) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "destination_late_commitment": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    isolation = D.min(axis=1)\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    # Smooth step function\n    pivot = 1.0 / (1.0 + np.exp(-12.0 * (progress - 0.65)))\n\n    score = (1.0 - pivot) * (step - 0.85 * isolation) + pivot * (step + 1.05 * d_dest)\n    return int(unv[int(np.argmin(score))])\n",
  "max_spacing_then_fill": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    if progress < 0.45:\n        # Choose among top-farthest 15% and pick the one most central to remaining.\n        k = int(max(1, np.ceil(0.15 * n_rem)))\n        far = np.argsort(-step)[:k]\n        D = distance_matrix[np.ix_(unv, unv)]\n        central = D.mean(axis=1)\n        cand = far\n        score = central[cand] + 0.10 * step[cand]\n        return int(unv[int(cand[int(np.argmin(score))])])\n\n    return int(unv[int(np.argmin(step))])\n",
  "min_two_hop_diameter": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    Dij = distance_matrix[np.ix_(unv, unv)]\n    # For each i, compute max over j of min(Dij[i,j], d_dest[j])\n    cap = np.maximum.reduce(np.minimum(Dij, d_dest[None, :]), axis=1)\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.85 * (cap / (np.mean(cap) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "entropy_of_ranks": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    ranks = np.argsort(np.argsort(D, axis=1), axis=1).astype(np.float64)\n\n    # Normalize ranks to a pseudo-probability distribution per row.\n    row_sum = ranks.sum(axis=1) + 1e-12\n    P = ranks / row_sum[:, None]\n    ent = -(P * np.log(P + 1e-12)).sum(axis=1)\n\n    score = (step / (np.mean(step) + 1e-12)) - 0.85 * (ent / (np.mean(ent) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "destination_anchor_then_wander": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    if progress < 0.40:\n        k = int(max(2, min(n_rem, np.ceil(0.18 * n_rem))))\n        idx = np.argsort(d_dest)[:k]\n        score = step[idx] + 0.95 * d_dest[idx]\n        return int(unv[int(idx[int(np.argmin(score))])])\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    bottleneck = np.percentile(D, 20, axis=1)\n    score = (step / (np.mean(step) + 1e-12)) + 0.80 * (bottleneck / (np.mean(bottleneck) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "min_variance_of_knn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    n = int(unv.size)\n    k = int(max(3, min(n - 1, np.ceil(0.12 * n))))\n    knn = np.partition(D, k - 1, axis=1)[:, :k]\n    v = knn.var(axis=1)\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.85 * (v / (np.mean(v) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "min_regret_over_two_hops": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    n = int(unv.size)\n    if n == 1:\n        return int(unv[0])\n\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    Dij = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(Dij, np.inf)\n\n    twohop = Dij + d_dest[None, :]\n    part = np.partition(twohop, 1, axis=1)\n    best = part[:, 0]\n    second = part[:, 1]\n    regret = second - best\n\n    s_norm = step / (np.mean(step) + 1e-12)\n    r_norm = regret / (np.mean(regret) + 1e-12)\n\n    score = s_norm - 0.85 * r_norm\n    return int(unv[int(np.argmin(score))])\n",
  "destination_time_window": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    d_dest = distance_matrix[unv, destination_node]\n    step = distance_matrix[current_node, unv]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    # Target dest-distance slides from high quantile to low quantile.\n    hi = float(np.quantile(d_dest, 0.80))\n    lo = float(np.quantile(d_dest, 0.20))\n    target = (1.0 - progress) * hi + progress * lo\n\n    width = (0.55 - 0.40 * progress) * (hi - lo + 1e-12)\n    penalty = np.maximum(0.0, np.abs(d_dest - target) - width)\n\n    score = (step / (np.mean(step) + 1e-12)) + 1.05 * (penalty / (np.mean(penalty) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "nearest_neighbor_with_blacklist_radius": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    # Micro radius = 15th percentile of remaining pairwise distances.\n    finite = D[np.isfinite(D)]\n    r = float(np.percentile(finite, 15)) + 1e-12\n    crowd = np.sum(D <= r, axis=1).astype(np.float64)\n\n    # Allow some crowding early, avoid late.\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    limit = (1.0 - progress) * np.percentile(crowd, 80) + progress * np.percentile(crowd, 40)\n\n    mask = crowd <= limit + 1e-12\n    if np.any(mask):\n        idx = np.where(mask)[0]\n        return int(unv[int(idx[int(np.argmin(step[idx]))])])\n\n    return int(unv[int(np.argmin(step))])\n",
  "destination_funnel_kbest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    k = int(max(2, min(n_rem, np.ceil((0.30 - 0.22 * progress) * n_rem))))\n    idx = np.argsort(step)[:k]\n\n    pick = idx[int(np.argmin(d_dest[idx]))]\n    return int(unv[int(pick)])\n",
  "destination_divergence_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    r0 = float(distance_matrix[current_node, destination_node])\n    r = distance_matrix[unv, destination_node]\n    step = distance_matrix[current_node, unv]\n\n    gain = r0 - r\n    best_gain = float(np.max(gain))\n    divergence = (best_gain - gain)\n\n    # Prefer big gain, small step.\n    score = (step / (np.mean(step) + 1e-12)) + 0.95 * (divergence / (np.mean(divergence) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "min_congestion_cost": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    scale = float(np.median(D[np.isfinite(D)])) + 1e-12\n    density = np.sum(np.exp(-D / scale), axis=1)\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.80 * (density / (np.mean(density) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "max_coverage_jump": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n\n    # Coverage radius = 30th percentile of pairwise distances.\n    finite = D[np.isfinite(D)]\n    rad = float(np.percentile(finite, 30)) + 1e-12\n    cover = np.sum(D <= rad, axis=1).astype(np.float64)\n\n    # Prefer higher cover (serve cluster core), but keep step bounded.\n    c_norm = cover / (np.mean(cover) + 1e-12)\n    s_norm = step / (np.mean(step) + 1e-12)\n\n    score = s_norm - 0.75 * c_norm\n    return int(unv[int(np.argmin(score))])\n",
  "robust_minimax_two_quantiles": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, 0.0)\n\n    q80 = np.percentile(D, 80, axis=1)\n    mx = D.max(axis=1)\n    tail = 0.65 * q80 + 0.35 * mx\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.95 * (tail / (np.mean(tail) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "min_cross_cluster_pull": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)].copy()\n    np.fill_diagonal(D, np.inf)\n    nn = D.min(axis=1)\n\n    # Higher nn => boundary / sparse.\n    n_norm = nn / (np.mean(nn) + 1e-12)\n    s_norm = step / (np.mean(step) + 1e-12)\n\n    score = s_norm - 0.85 * n_norm\n    return int(unv[int(np.argmin(score))])\n",
  "destination_biased_kmedian": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    med = np.median(D, axis=1)\n\n    score = (step / (np.mean(step) + 1e-12)) + 0.75 * (med / (np.mean(med) + 1e-12)) + 0.55 * (d_dest / (np.mean(d_dest) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "max_distance_dispersion": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    mu = D.mean(axis=1) + 1e-12\n    sigma = D.std(axis=1)\n    disp = sigma / mu\n\n    score = (step / (np.mean(step) + 1e-12)) - 0.75 * (disp / (np.mean(disp) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "min_geodesic_deviation": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    n = int(unv.size)\n    step = distance_matrix[current_node, unv]\n\n    if n < 3:\n        return int(unv[int(np.argmin(step))])\n\n    # Current profile to remaining\n    pc = step\n    pc = pc - pc.mean()\n    pc_norm = np.sqrt(np.sum(pc * pc)) + 1e-12\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    corr = np.empty(n, dtype=np.float64)\n\n    for i in range(n):\n        pi = D[i] - D[i].mean()\n        denom = (np.sqrt(np.sum(pi * pi)) + 1e-12) * pc_norm\n        corr[i] = float(np.sum(pi * pc) / denom)\n\n    # Prefer high correlation; keep step short.\n    score = (step / (np.mean(step) + 1e-12)) + 0.35 * ((1.0 - corr) / (np.mean(1.0 - corr) + 1e-12))\n    return int(unv[int(np.argmin(score))])\n",
  "destination_intercept_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    r0 = float(distance_matrix[current_node, destination_node])\n    step = distance_matrix[current_node, unv]\n    r = distance_matrix[unv, destination_node]\n\n    gain = np.maximum(1e-12, r0 - r)\n    ratio = step / gain\n\n    # If no positive gain, fall back to shortest step.\n    if np.all(r0 - r <= 1e-12):\n        return int(unv[int(np.argmin(step))])\n\n    ratio = np.where(r0 - r > 1e-12, ratio, np.inf)\n    return int(unv[int(np.argmin(ratio))])\n",
  "late_stage_endgame_lock": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    n = int(unv.size)\n\n    step = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n\n    if n <= 6:\n        # Evaluate choosing i now and then best (i->j + j->dest).\n        D = distance_matrix[np.ix_(unv, unv)].copy()\n        np.fill_diagonal(D, np.inf)\n        future = np.min(D + d_dest[None, :], axis=1)\n        score = step + future\n        return int(unv[int(np.argmin(score))])\n\n    # Otherwise simple: step + moderate destination pull.\n    score = step + 0.85 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "edge_contrast_balancer": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n\n    unv = unvisited_nodes.astype(int)\n    step = distance_matrix[current_node, unv]\n\n    D = distance_matrix[np.ix_(unv, unv)]\n    med = np.median(D, axis=1)\n\n    score = np.abs(step - med) / (np.mean(np.abs(step - med)) + 1e-12)\n    return int(unv[int(np.argmin(score))])\n"
}
