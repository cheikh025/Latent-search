{
  "nn_dest_bias_p025_to175": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.25 + 1.75 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p010_to120": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + 1.10 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p000_to080": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.80 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p030_to130": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.30 + 1.00 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p050_to150": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.50 + 1.00 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p020_to090": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.20 + 0.70 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p015_to060": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.15 + 0.45 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_quadratic_02_to14": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.20 + 1.20 * (progress * progress)\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_sqrt_01_to12": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + 1.10 * np.sqrt(max(0.0, progress))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_clipped_00_to10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = float(np.clip(1.00 * progress, 0.0, 1.0))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_inverse_rem_02": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    alpha = 0.20 + 2.0 / max(2.0, float(n_rem))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_inverse_rem_05": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_rem = int(unv.size)\n    alpha = 0.50 + 3.0 / max(3.0, float(n_rem))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_progress_steep": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + 2.00 * (progress ** 3)\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_progress_midboost": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.20 + 1.20 * (4.0 * progress * (1.0 - progress))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_piecewise_lowhigh": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.25 if progress < 0.5 else 1.25\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_piecewise_ramp": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + (1.40 if progress > 0.7 else 0.60)\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_logistic": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + 1.40 * (1.0 / (1.0 + np.exp(-10.0 * (progress - 0.5))))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_small_eps": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.05 + 1.00 * progress\n    score = d_cur + alpha * (d_dest + 1e-9)\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_strong_endgame": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + 2.50 * (progress ** 2)\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "cl_nn_k05_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.05 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    pick = idx[int(np.argmin(d_dest))]\n    return int(unv[int(pick)])\n",
  "cl_nn_k10_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    pick = idx[int(np.argmin(d_dest))]\n    return int(unv[int(pick)])\n",
  "cl_nn_k15_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    pick = idx[int(np.argmin(d_dest))]\n    return int(unv[int(pick)])\n",
  "cl_nn_k20_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    pick = idx[int(np.argmin(d_dest))]\n    return int(unv[int(pick)])\n",
  "cl_nn_k05_linear": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.05 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = 0.7 * d_cur[idx] + 0.3 * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k10_linear": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = 0.6 * d_cur[idx] + 0.4 * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k15_linear": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = 0.5 * d_cur[idx] + 0.5 * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k20_linear": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = 0.4 * d_cur[idx] + 0.6 * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k05_meanrem": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.05 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    D = distance_matrix[np.ix_(cand, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur[idx] + 0.25 * mean_to_unv\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k10_meanrem": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    D = distance_matrix[np.ix_(cand, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur[idx] + 0.20 * mean_to_unv\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k15_meanrem": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    D = distance_matrix[np.ix_(cand, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur[idx] + 0.15 * mean_to_unv\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k20_meanrem": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    D = distance_matrix[np.ix_(cand, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur[idx] + 0.10 * mean_to_unv\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k05_mindest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.05 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    score = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k10_mindest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    score = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k15_mindest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    score = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k20_mindest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    score = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k10_progress_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur_all = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur_all)[:k]\n    cand = unv[idx]\n    d_cur = d_cur_all[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = (1.0 - progress) * d_cur + progress * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k15_progress_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur_all = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(d_cur_all)[:k]\n    cand = unv[idx]\n    d_cur = d_cur_all[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = (1.0 - progress) * d_cur + progress * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k20_progress_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur_all = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur_all)[:k]\n    cand = unv[idx]\n    d_cur = d_cur_all[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = (1.0 - progress) * d_cur + progress * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "far_then_nn_40": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.40:\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_then_nn_50": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_then_nn_60": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.60:\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far10pct_then_nn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    if n_rem > int(0.90 * distance_matrix.shape[0]):\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far20pct_then_nn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    if n_rem > int(0.80 * distance_matrix.shape[0]):\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far30pct_then_nn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    if n_rem > int(0.70 * distance_matrix.shape[0]):\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_k05_then_nn_dest_tie": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        k = max(1, int(np.ceil(0.05 * n_rem)))\n        far_idx = np.argsort(-d_cur)[:k]\n        cand = unv[far_idx]\n        d_dest = distance_matrix[cand, destination_node]\n        return int(cand[int(np.argmin(d_dest))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_k10_then_nn_dest_tie": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        k = max(1, int(np.ceil(0.10 * n_rem)))\n        far_idx = np.argsort(-d_cur)[:k]\n        cand = unv[far_idx]\n        d_dest = distance_matrix[cand, destination_node]\n        return int(cand[int(np.argmin(d_dest))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_k15_then_nn_dest_tie": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        k = max(1, int(np.ceil(0.15 * n_rem)))\n        far_idx = np.argsort(-d_cur)[:k]\n        cand = unv[far_idx]\n        d_dest = distance_matrix[cand, destination_node]\n        return int(cand[int(np.argmin(d_dest))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_k20_then_nn_dest_tie": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        k = max(1, int(np.ceil(0.20 * n_rem)))\n        far_idx = np.argsort(-d_cur)[:k]\n        cand = unv[far_idx]\n        d_dest = distance_matrix[cand, destination_node]\n        return int(cand[int(np.argmin(d_dest))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_then_nn_weighted_to_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        return int(unv[int(np.argmax(d_cur - 0.25 * d_dest))])\n    return int(unv[int(np.argmin(d_cur + 0.50 * d_dest))])\n",
  "near_then_far_endgame": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.85:\n        return int(unv[int(np.argmin(d_cur))])\n    return int(unv[int(np.argmax(d_cur))])\n",
  "far_then_nn_endgame_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    score = d_cur + 0.75 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "far_then_nn_endgame_mean": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur + 0.20 * mean_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "far_then_nn_endgame_median": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    D = distance_matrix[np.ix_(unv, unv)]\n    med_to_unv = np.median(D, axis=1)\n    score = d_cur + 0.15 * med_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "far_then_nn_endgame_min2": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    D = distance_matrix[np.ix_(unv, unv)]\n    part = np.partition(D, 1, axis=1)\n    mean2 = (part[:, 0] + part[:, 1]) / 2.0\n    score = d_cur + 0.10 * mean2\n    return int(unv[int(np.argmin(score))])\n",
  "far_then_nn_endgame_min3": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    D = distance_matrix[np.ix_(unv, unv)]\n    part = np.partition(D, 2, axis=1)\n    mean3 = (part[:, 0] + part[:, 1] + part[:, 2]) / 3.0\n    score = d_cur + 0.08 * mean3\n    return int(unv[int(np.argmin(score))])\n",
  "far_then_nn_endgame_dest_strong": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    score = d_cur + 1.25 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean_remaining_beta030": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur + 0.30 * mean_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean_remaining_beta020": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur + 0.20 * mean_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean_remaining_beta010": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur + 0.10 * mean_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_median_remaining_beta020": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    med_to_unv = np.median(D, axis=1)\n    score = d_cur + 0.20 * med_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_median_remaining_beta010": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    med_to_unv = np.median(D, axis=1)\n    score = d_cur + 0.10 * med_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_min_remaining_beta050": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    min_to_unv = D.min(axis=1)\n    score = d_cur + 0.50 * min_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_min_remaining_beta025": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    min_to_unv = D.min(axis=1)\n    score = d_cur + 0.25 * min_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_min_remaining_beta010": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    min_to_unv = D.min(axis=1)\n    score = d_cur + 0.10 * min_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean2_remaining_beta020": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    part = np.partition(D, 1, axis=1)\n    mean2 = (part[:, 0] + part[:, 1]) / 2.0\n    score = d_cur + 0.20 * mean2\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean3_remaining_beta015": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    part = np.partition(D, 2, axis=1)\n    mean3 = (part[:, 0] + part[:, 1] + part[:, 2]) / 3.0\n    score = d_cur + 0.15 * mean3\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean5_remaining_beta010": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    k = 5 if unv.size >= 5 else int(unv.size)\n    part = np.partition(D, k-1, axis=1)[:, :k]\n    meank = part.mean(axis=1)\n    score = d_cur + 0.10 * meank\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean10_remaining_beta008": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    k = 10 if unv.size >= 10 else int(unv.size)\n    part = np.partition(D, k-1, axis=1)[:, :k]\n    meank = part.mean(axis=1)\n    score = d_cur + 0.08 * meank\n    return int(unv[int(np.argmin(score))])\n",
  "stat_max_remaining_beta005": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    max_to_unv = D.max(axis=1)\n    score = d_cur + 0.05 * max_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_var_remaining_beta010": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    var_to_unv = D.var(axis=1)\n    score = d_cur + 0.10 * np.sqrt(var_to_unv + 1e-9)\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean_remaining_progress_beta": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    beta = 0.30 * (1.0 - progress) + 0.05\n    score = d_cur + beta * mean_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_median_remaining_progress_beta": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    med_to_unv = np.median(D, axis=1)\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    beta = 0.25 * (1.0 - progress) + 0.05\n    score = d_cur + beta * med_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_min2_remaining_progress_beta": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    part = np.partition(D, 1, axis=1)\n    mean2 = (part[:, 0] + part[:, 1]) / 2.0\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    beta = 0.18 * (1.0 - progress) + 0.03\n    score = d_cur + beta * mean2\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_plain": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_weight_12": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = 1.0 * d_cur + 1.2 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_weight_08": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = 1.0 * d_cur + 0.8 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_progress_weight": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    w = 0.6 + 0.9 * progress\n    score = d_cur + w * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_ratio_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest + 0.2 * (d_dest / (d_cur + 1e-9))\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_diff_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest + 0.1 * np.abs(d_cur - d_dest)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_softmin_cur": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = np.log1p(d_cur) + d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_softmin_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + np.log1p(d_dest)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_squared_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + 0.05 * (d_dest ** 2)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_squared_cur": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = 0.05 * (d_cur ** 2) + d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_harmonic": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest - 0.3 * (d_cur * d_dest) / (d_cur + d_dest + 1e-9)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_progress_quadratic": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    w = 0.5 + 1.5 * (progress ** 2)\n    score = d_cur + w * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_progress_sqrt": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    w = 0.6 + 1.0 * np.sqrt(max(0.0, progress))\n    score = d_cur + w * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_piecewise_w": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    w = 0.7 if progress < 0.5 else 1.3\n    score = d_cur + w * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_log_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest + 0.1 * np.log1p(d_dest / (d_cur + 1e-9))\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_dest_minus_cur": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest + 0.05 * (d_dest - d_cur)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_cur_minus_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest + 0.05 * (d_cur - d_dest)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_dest_clip": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    d_dest2 = np.clip(d_dest, 0.0, float(np.percentile(d_dest, 90)))\n    score = d_cur + d_dest2\n    return int(unv[int(np.argmin(score))])\n",
  "rand_uniform_seeded": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 101) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(unv[int(rng.integers(0, unv.size))])\n",
  "rand_uniform_progress_bias_near": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 131) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    temp = 1.5 - 1.2 * progress\n    w = np.exp(-d_cur / (np.mean(d_cur) * max(1e-9, temp)))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_uniform_progress_bias_far": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 137) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    temp = 0.8 + 1.2 * (1.0 - progress)\n    w = np.exp(d_cur / (np.mean(d_cur) * max(1e-9, temp)))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_softmax_triangle": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(unv.size) * 97) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest\n    s = score - score.min()\n    w = np.exp(-s / (np.mean(s) + 1e-9))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_topk_nearest_uniform_k10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(n_rem) * 1031 + int(k)) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(cand[int(rng.integers(0, cand.size))])\n",
  "rand_topk_nearest_uniform_k20": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(n_rem) * 1033 + int(k)) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(cand[int(rng.integers(0, cand.size))])\n",
  "rand_topk_farthest_uniform_k10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(-d_cur)[:k]\n    cand = unv[idx]\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(n_rem) * 911 + int(k)) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(cand[int(rng.integers(0, cand.size))])\n",
  "rand_topk_triangle_bestof2": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 179) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    i1 = int(rng.integers(0, unv.size))\n    i2 = int(rng.integers(0, unv.size))\n    c1 = int(unv[i1]); c2 = int(unv[i2])\n    s1 = distance_matrix[current_node, c1] + distance_matrix[c1, destination_node]\n    s2 = distance_matrix[current_node, c2] + distance_matrix[c2, destination_node]\n    return int(c1 if s1 <= s2 else c2)\n",
  "rand_topk_triangle_bestof3": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 181) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    idx = rng.integers(0, unv.size, size=3)\n    cand = unv[idx].astype(int)\n    s = distance_matrix[current_node, cand] + distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(s))])\n",
  "rand_eps_greedy_nn_eps20": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 191) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    eps = 0.20\n    if float(rng.random()) < eps:\n        return int(unv[int(rng.integers(0, unv.size))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "rand_eps_greedy_nn_eps10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 193) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    eps = 0.10\n    if float(rng.random()) < eps:\n        return int(unv[int(rng.integers(0, unv.size))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "rand_eps_greedy_triangle_eps15": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(unv.size) * 197) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    tri = distance_matrix[current_node, unv] + distance_matrix[unv, destination_node]\n    eps = 0.15\n    if float(rng.random()) < eps:\n        return int(unv[int(rng.integers(0, unv.size))])\n    return int(unv[int(np.argmin(tri))])\n",
  "rand_rank_weighted_nn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 211) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    order = np.argsort(d_cur)\n    ranks = np.empty_like(order)\n    ranks[order] = np.arange(order.size)\n    w = 1.0 / (1.0 + ranks.astype(float))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_rank_weighted_triangle": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 223) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    tri = distance_matrix[current_node, unv] + distance_matrix[unv, destination_node]\n    order = np.argsort(tri)\n    ranks = np.empty_like(order)\n    ranks[order] = np.arange(order.size)\n    w = 1.0 / (1.0 + ranks.astype(float))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_two_bucket_near_far": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    near = unv[np.argsort(d_cur)[:k]]\n    far = unv[np.argsort(-d_cur)[:k]]\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(n_rem) * 233) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    choose_near = float(rng.random()) < 0.7\n    bucket = near if choose_near else far\n    return int(bucket[int(rng.integers(0, bucket.size))])\n",
  "rand_progress_switch_bucket": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    k = max(1, int(np.ceil(0.12 * n_rem)))\n    near = unv[np.argsort(d_cur)[:k]]\n    far = unv[np.argsort(-d_cur)[:k]]\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(n_rem) * 239) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    p_near = 0.3 + 0.6 * progress\n    bucket = near if float(rng.random()) < p_near else far\n    return int(bucket[int(rng.integers(0, bucket.size))])\n",
  "rand_weighted_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 241) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_dest = distance_matrix[unv, destination_node]\n    s = d_dest - d_dest.min()\n    w = np.exp(-s / (np.mean(s) + 1e-9))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_weighted_cur_plus_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(unv.size) * 251) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    score = distance_matrix[current_node, unv] + 0.8 * distance_matrix[unv, destination_node]\n    s = score - score.min()\n    w = np.exp(-s / (np.mean(s) + 1e-9))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_best_of5_triangle": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 257) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    m = min(5, int(unv.size))\n    idx = rng.integers(0, unv.size, size=m)\n    cand = unv[idx].astype(int)\n    tri = distance_matrix[current_node, cand] + distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(tri))])\n",
  "rand_best_of7_nn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(unv.size) * 263) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    m = min(7, int(unv.size))\n    idx = rng.integers(0, unv.size, size=m)\n    cand = unv[idx].astype(int)\n    d = distance_matrix[current_node, cand]\n    return int(cand[int(np.argmin(d))])\n",
  "savings_max_plain": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_weighted_dest_12": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + 1.2 * d_dest)\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_weighted_dest_08": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + 0.8 * d_dest)\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_progress_weight": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    w = 0.7 + 0.8 * progress\n    savings = d_cd - (d_cur + w * d_dest)\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_penalize_long_cur": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest) - 0.15 * d_cur\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_penalize_long_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest) - 0.15 * d_dest\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_argmax_normalized": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    denom = d_cur + d_dest + 1e-9\n    savings = (d_cd - denom) / denom\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_argmax_ratio_to_direct": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node]) + 1e-9\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    path = d_cur + d_dest\n    savings = d_cd / (path + 1e-9)\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_topk_then_nn_k10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(-savings)[:k]\n    cand = unv[idx]\n    d_c = distance_matrix[current_node, cand]\n    return int(cand[int(np.argmin(d_c))])\n",
  "savings_topk_then_dest_k10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(-savings)[:k]\n    cand = unv[idx]\n    d_d = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(d_d))])\n",
  "savings_topk_then_triangle_k15": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(-savings)[:k]\n    cand = unv[idx]\n    tri = distance_matrix[current_node, cand] + distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(tri))])\n",
  "savings_progress_switch_topk": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    frac = 0.25 if progress < 0.5 else 0.10\n    k = max(1, int(np.ceil(frac * n_rem)))\n    idx = np.argsort(-savings)[:k]\n    cand = unv[idx]\n    tri = distance_matrix[current_node, cand] + distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(tri))])\n",
  "savings_regret2_insertion_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    path = d_cur + d_dest\n    # regret proxy: prefer nodes where best path is much better than 2nd best\n    order = np.argsort(path)\n    best = path[order[0]]\n    second = path[order[1]] if order.size > 1 else best\n    # choose node if it produces the largest direct-edge reduction among the two best candidates\n    cand = unv[order[:min(5, order.size)]]\n    savings = d_cd - (distance_matrix[current_node, cand] + distance_matrix[cand, destination_node])\n    # amplify if regret is high\n    score = savings + 0.05 * (second - best)\n    return int(cand[int(np.argmax(score))])\n",
  "savings_softmax_pick_seeded": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 271) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    s = savings - savings.max()\n    w = np.exp(s / (np.std(savings) + 1e-9))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "savings_max_with_mean_remaining_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = savings - 0.05 * mean_to_unv\n    return int(unv[int(np.argmax(score))])\n",
  "savings_max_with_min_remaining_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    D = distance_matrix[np.ix_(unv, unv)]\n    min_to_unv = D.min(axis=1)\n    score = savings - 0.08 * min_to_unv\n    return int(unv[int(np.argmax(score))])\n",
  "savings_max_clipped_outliers": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    path = d_cur + d_dest\n    hi = float(np.percentile(path, 90))\n    path2 = np.minimum(path, hi)\n    savings = d_cd - path2\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_endgame_dest_bias": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    bias = 0.0 if progress < 0.7 else 0.25\n    savings = d_cd - (d_cur + d_dest) - bias * d_dest\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_endgame_nn_fallback": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    if unv.size <= 5:\n        return int(unv[int(np.argmin(d_cur))])\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    return int(unv[int(np.argmax(savings))])\n"
}






