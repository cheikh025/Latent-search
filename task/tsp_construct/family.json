{
  "nn_dest_bias_p025_to175": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.25 + 1.75 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p010_to120": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + 1.10 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p000_to080": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.80 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p030_to130": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.30 + 1.00 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p050_to150": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.50 + 1.00 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p020_to090": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.20 + 0.70 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_p015_to060": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.15 + 0.45 * progress\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_quadratic_02_to14": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.20 + 1.20 * (progress * progress)\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_sqrt_01_to12": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + 1.10 * np.sqrt(max(0.0, progress))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_clipped_00_to10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = float(np.clip(1.00 * progress, 0.0, 1.0))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_inverse_rem_02": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    alpha = 0.20 + 2.0 / max(2.0, float(n_rem))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_inverse_rem_05": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_rem = int(unv.size)\n    alpha = 0.50 + 3.0 / max(3.0, float(n_rem))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_progress_steep": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + 2.00 * (progress ** 3)\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_progress_midboost": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.20 + 1.20 * (4.0 * progress * (1.0 - progress))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_piecewise_lowhigh": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.25 if progress < 0.5 else 1.25\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_piecewise_ramp": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + (1.40 if progress > 0.7 else 0.60)\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_logistic": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + 1.40 * (1.0 / (1.0 + np.exp(-10.0 * (progress - 0.5))))\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_small_eps": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.05 + 1.00 * progress\n    score = d_cur + alpha * (d_dest + 1e-9)\n    return int(unv[int(np.argmin(score))])\n",
  "nn_dest_bias_strong_endgame": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    alpha = 0.10 + 2.50 * (progress ** 2)\n    score = d_cur + alpha * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "cl_nn_k05_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.05 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    pick = idx[int(np.argmin(d_dest))]\n    return int(unv[int(pick)])\n",
  "cl_nn_k10_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    pick = idx[int(np.argmin(d_dest))]\n    return int(unv[int(pick)])\n",
  "cl_nn_k15_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    pick = idx[int(np.argmin(d_dest))]\n    return int(unv[int(pick)])\n",
  "cl_nn_k20_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    pick = idx[int(np.argmin(d_dest))]\n    return int(unv[int(pick)])\n",
  "cl_nn_k05_linear": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.05 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = 0.7 * d_cur[idx] + 0.3 * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k10_linear": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = 0.6 * d_cur[idx] + 0.4 * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k15_linear": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = 0.5 * d_cur[idx] + 0.5 * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k20_linear": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = 0.4 * d_cur[idx] + 0.6 * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k05_meanrem": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.05 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    D = distance_matrix[np.ix_(cand, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur[idx] + 0.25 * mean_to_unv\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k10_meanrem": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    D = distance_matrix[np.ix_(cand, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur[idx] + 0.20 * mean_to_unv\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k15_meanrem": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    D = distance_matrix[np.ix_(cand, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur[idx] + 0.15 * mean_to_unv\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k20_meanrem": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    D = distance_matrix[np.ix_(cand, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur[idx] + 0.10 * mean_to_unv\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k05_mindest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.05 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    score = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k10_mindest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    score = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k15_mindest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    score = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k20_mindest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    score = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k10_progress_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur_all = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur_all)[:k]\n    cand = unv[idx]\n    d_cur = d_cur_all[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = (1.0 - progress) * d_cur + progress * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k15_progress_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur_all = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(d_cur_all)[:k]\n    cand = unv[idx]\n    d_cur = d_cur_all[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = (1.0 - progress) * d_cur + progress * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "cl_nn_k20_progress_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur_all = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur_all)[:k]\n    cand = unv[idx]\n    d_cur = d_cur_all[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    score = (1.0 - progress) * d_cur + progress * d_dest\n    return int(cand[int(np.argmin(score))])\n",
  "far_then_nn_40": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.40:\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_then_nn_50": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_then_nn_60": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.60:\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far10pct_then_nn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    if n_rem > int(0.90 * distance_matrix.shape[0]):\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far20pct_then_nn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    if n_rem > int(0.80 * distance_matrix.shape[0]):\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far30pct_then_nn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    if n_rem > int(0.70 * distance_matrix.shape[0]):\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_k05_then_nn_dest_tie": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        k = max(1, int(np.ceil(0.05 * n_rem)))\n        far_idx = np.argsort(-d_cur)[:k]\n        cand = unv[far_idx]\n        d_dest = distance_matrix[cand, destination_node]\n        return int(cand[int(np.argmin(d_dest))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_k10_then_nn_dest_tie": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        k = max(1, int(np.ceil(0.10 * n_rem)))\n        far_idx = np.argsort(-d_cur)[:k]\n        cand = unv[far_idx]\n        d_dest = distance_matrix[cand, destination_node]\n        return int(cand[int(np.argmin(d_dest))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_k15_then_nn_dest_tie": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        k = max(1, int(np.ceil(0.15 * n_rem)))\n        far_idx = np.argsort(-d_cur)[:k]\n        cand = unv[far_idx]\n        d_dest = distance_matrix[cand, destination_node]\n        return int(cand[int(np.argmin(d_dest))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_k20_then_nn_dest_tie": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        k = max(1, int(np.ceil(0.20 * n_rem)))\n        far_idx = np.argsort(-d_cur)[:k]\n        cand = unv[far_idx]\n        d_dest = distance_matrix[cand, destination_node]\n        return int(cand[int(np.argmin(d_dest))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "far_then_nn_weighted_to_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.50:\n        return int(unv[int(np.argmax(d_cur - 0.25 * d_dest))])\n    return int(unv[int(np.argmin(d_cur + 0.50 * d_dest))])\n",
  "near_then_far_endgame": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.85:\n        return int(unv[int(np.argmin(d_cur))])\n    return int(unv[int(np.argmax(d_cur))])\n",
  "far_then_nn_endgame_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    score = d_cur + 0.75 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "far_then_nn_endgame_mean": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur + 0.20 * mean_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "far_then_nn_endgame_median": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    D = distance_matrix[np.ix_(unv, unv)]\n    med_to_unv = np.median(D, axis=1)\n    score = d_cur + 0.15 * med_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "far_then_nn_endgame_min2": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    D = distance_matrix[np.ix_(unv, unv)]\n    part = np.partition(D, 1, axis=1)\n    mean2 = (part[:, 0] + part[:, 1]) / 2.0\n    score = d_cur + 0.10 * mean2\n    return int(unv[int(np.argmin(score))])\n",
  "far_then_nn_endgame_min3": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    D = distance_matrix[np.ix_(unv, unv)]\n    part = np.partition(D, 2, axis=1)\n    mean3 = (part[:, 0] + part[:, 1] + part[:, 2]) / 3.0\n    score = d_cur + 0.08 * mean3\n    return int(unv[int(np.argmin(score))])\n",
  "far_then_nn_endgame_dest_strong": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    if progress < 0.55:\n        return int(unv[int(np.argmax(d_cur))])\n    score = d_cur + 1.25 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean_remaining_beta030": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur + 0.30 * mean_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean_remaining_beta020": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur + 0.20 * mean_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean_remaining_beta010": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = d_cur + 0.10 * mean_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_median_remaining_beta020": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    med_to_unv = np.median(D, axis=1)\n    score = d_cur + 0.20 * med_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_median_remaining_beta010": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    med_to_unv = np.median(D, axis=1)\n    score = d_cur + 0.10 * med_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_min_remaining_beta050": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    min_to_unv = D.min(axis=1)\n    score = d_cur + 0.50 * min_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_min_remaining_beta025": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    min_to_unv = D.min(axis=1)\n    score = d_cur + 0.25 * min_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_min_remaining_beta010": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    min_to_unv = D.min(axis=1)\n    score = d_cur + 0.10 * min_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean2_remaining_beta020": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    part = np.partition(D, 1, axis=1)\n    mean2 = (part[:, 0] + part[:, 1]) / 2.0\n    score = d_cur + 0.20 * mean2\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean3_remaining_beta015": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    part = np.partition(D, 2, axis=1)\n    mean3 = (part[:, 0] + part[:, 1] + part[:, 2]) / 3.0\n    score = d_cur + 0.15 * mean3\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean5_remaining_beta010": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    k = 5 if unv.size >= 5 else int(unv.size)\n    part = np.partition(D, k-1, axis=1)[:, :k]\n    meank = part.mean(axis=1)\n    score = d_cur + 0.10 * meank\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean10_remaining_beta008": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    k = 10 if unv.size >= 10 else int(unv.size)\n    part = np.partition(D, k-1, axis=1)[:, :k]\n    meank = part.mean(axis=1)\n    score = d_cur + 0.08 * meank\n    return int(unv[int(np.argmin(score))])\n",
  "stat_max_remaining_beta005": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    max_to_unv = D.max(axis=1)\n    score = d_cur + 0.05 * max_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_var_remaining_beta010": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    var_to_unv = D.var(axis=1)\n    score = d_cur + 0.10 * np.sqrt(var_to_unv + 1e-9)\n    return int(unv[int(np.argmin(score))])\n",
  "stat_mean_remaining_progress_beta": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    beta = 0.30 * (1.0 - progress) + 0.05\n    score = d_cur + beta * mean_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_median_remaining_progress_beta": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    med_to_unv = np.median(D, axis=1)\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    beta = 0.25 * (1.0 - progress) + 0.05\n    score = d_cur + beta * med_to_unv\n    return int(unv[int(np.argmin(score))])\n",
  "stat_min2_remaining_progress_beta": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    part = np.partition(D, 1, axis=1)\n    mean2 = (part[:, 0] + part[:, 1]) / 2.0\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    beta = 0.18 * (1.0 - progress) + 0.03\n    score = d_cur + beta * mean2\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_plain": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_weight_12": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = 1.0 * d_cur + 1.2 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_weight_08": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = 1.0 * d_cur + 0.8 * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_progress_weight": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    w = 0.6 + 0.9 * progress\n    score = d_cur + w * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_ratio_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest + 0.2 * (d_dest / (d_cur + 1e-9))\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_diff_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest + 0.1 * np.abs(d_cur - d_dest)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_softmin_cur": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = np.log1p(d_cur) + d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_softmin_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + np.log1p(d_dest)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_squared_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + 0.05 * (d_dest ** 2)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_squared_cur": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = 0.05 * (d_cur ** 2) + d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_harmonic": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest - 0.3 * (d_cur * d_dest) / (d_cur + d_dest + 1e-9)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_progress_quadratic": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    w = 0.5 + 1.5 * (progress ** 2)\n    score = d_cur + w * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_progress_sqrt": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    w = 0.6 + 1.0 * np.sqrt(max(0.0, progress))\n    score = d_cur + w * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_piecewise_w": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    w = 0.7 if progress < 0.5 else 1.3\n    score = d_cur + w * d_dest\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_log_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest + 0.1 * np.log1p(d_dest / (d_cur + 1e-9))\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_dest_minus_cur": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest + 0.05 * (d_dest - d_cur)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_cur_minus_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest + 0.05 * (d_cur - d_dest)\n    return int(unv[int(np.argmin(score))])\n",
  "triangle_dest_clip": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    d_dest2 = np.clip(d_dest, 0.0, float(np.percentile(d_dest, 90)))\n    score = d_cur + d_dest2\n    return int(unv[int(np.argmin(score))])\n",
  "rand_uniform_seeded": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 101) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(unv[int(rng.integers(0, unv.size))])\n",
  "rand_uniform_progress_bias_near": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 131) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    temp = 1.5 - 1.2 * progress\n    w = np.exp(-d_cur / (np.mean(d_cur) * max(1e-9, temp)))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_uniform_progress_bias_far": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 137) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    temp = 0.8 + 1.2 * (1.0 - progress)\n    w = np.exp(d_cur / (np.mean(d_cur) * max(1e-9, temp)))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_softmax_triangle": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(unv.size) * 97) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    score = d_cur + d_dest\n    s = score - score.min()\n    w = np.exp(-s / (np.mean(s) + 1e-9))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_topk_nearest_uniform_k10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(n_rem) * 1031 + int(k)) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(cand[int(rng.integers(0, cand.size))])\n",
  "rand_topk_nearest_uniform_k20": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.20 * n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(n_rem) * 1033 + int(k)) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(cand[int(rng.integers(0, cand.size))])\n",
  "rand_topk_farthest_uniform_k10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(-d_cur)[:k]\n    cand = unv[idx]\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(n_rem) * 911 + int(k)) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(cand[int(rng.integers(0, cand.size))])\n",
  "rand_topk_triangle_bestof2": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 179) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    i1 = int(rng.integers(0, unv.size))\n    i2 = int(rng.integers(0, unv.size))\n    c1 = int(unv[i1]); c2 = int(unv[i2])\n    s1 = distance_matrix[current_node, c1] + distance_matrix[c1, destination_node]\n    s2 = distance_matrix[current_node, c2] + distance_matrix[c2, destination_node]\n    return int(c1 if s1 <= s2 else c2)\n",
  "rand_topk_triangle_bestof3": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 181) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    idx = rng.integers(0, unv.size, size=3)\n    cand = unv[idx].astype(int)\n    s = distance_matrix[current_node, cand] + distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(s))])\n",
  "rand_eps_greedy_nn_eps20": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 191) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    eps = 0.20\n    if float(rng.random()) < eps:\n        return int(unv[int(rng.integers(0, unv.size))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "rand_eps_greedy_nn_eps10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 193) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    eps = 0.10\n    if float(rng.random()) < eps:\n        return int(unv[int(rng.integers(0, unv.size))])\n    return int(unv[int(np.argmin(d_cur))])\n",
  "rand_eps_greedy_triangle_eps15": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(unv.size) * 197) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    tri = distance_matrix[current_node, unv] + distance_matrix[unv, destination_node]\n    eps = 0.15\n    if float(rng.random()) < eps:\n        return int(unv[int(rng.integers(0, unv.size))])\n    return int(unv[int(np.argmin(tri))])\n",
  "rand_rank_weighted_nn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 211) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cur = distance_matrix[current_node, unv]\n    order = np.argsort(d_cur)\n    ranks = np.empty_like(order)\n    ranks[order] = np.arange(order.size)\n    w = 1.0 / (1.0 + ranks.astype(float))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_rank_weighted_triangle": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 223) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    tri = distance_matrix[current_node, unv] + distance_matrix[unv, destination_node]\n    order = np.argsort(tri)\n    ranks = np.empty_like(order)\n    ranks[order] = np.arange(order.size)\n    w = 1.0 / (1.0 + ranks.astype(float))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_two_bucket_near_far": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    near = unv[np.argsort(d_cur)[:k]]\n    far = unv[np.argsort(-d_cur)[:k]]\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(n_rem) * 233) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    choose_near = float(rng.random()) < 0.7\n    bucket = near if choose_near else far\n    return int(bucket[int(rng.integers(0, bucket.size))])\n",
  "rand_progress_switch_bucket": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    k = max(1, int(np.ceil(0.12 * n_rem)))\n    near = unv[np.argsort(d_cur)[:k]]\n    far = unv[np.argsort(-d_cur)[:k]]\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(n_rem) * 239) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    p_near = 0.3 + 0.6 * progress\n    bucket = near if float(rng.random()) < p_near else far\n    return int(bucket[int(rng.integers(0, bucket.size))])\n",
  "rand_weighted_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 241) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_dest = distance_matrix[unv, destination_node]\n    s = d_dest - d_dest.min()\n    w = np.exp(-s / (np.mean(s) + 1e-9))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_weighted_cur_plus_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(unv.size) * 251) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    score = distance_matrix[current_node, unv] + 0.8 * distance_matrix[unv, destination_node]\n    s = score - score.min()\n    w = np.exp(-s / (np.mean(s) + 1e-9))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "rand_best_of5_triangle": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 257) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    m = min(5, int(unv.size))\n    idx = rng.integers(0, unv.size, size=m)\n    cand = unv[idx].astype(int)\n    tri = distance_matrix[current_node, cand] + distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(tri))])\n",
  "rand_best_of7_nn": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 99991 + int(destination_node) * 1009 + int(unv.size) * 263) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    m = min(7, int(unv.size))\n    idx = rng.integers(0, unv.size, size=m)\n    cand = unv[idx].astype(int)\n    d = distance_matrix[current_node, cand]\n    return int(cand[int(np.argmin(d))])\n",
  "savings_max_plain": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_weighted_dest_12": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + 1.2 * d_dest)\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_weighted_dest_08": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + 0.8 * d_dest)\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_progress_weight": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    w = 0.7 + 0.8 * progress\n    savings = d_cd - (d_cur + w * d_dest)\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_penalize_long_cur": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest) - 0.15 * d_cur\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_penalize_long_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest) - 0.15 * d_dest\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_argmax_normalized": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    denom = d_cur + d_dest + 1e-9\n    savings = (d_cd - denom) / denom\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_argmax_ratio_to_direct": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node]) + 1e-9\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    path = d_cur + d_dest\n    savings = d_cd / (path + 1e-9)\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_topk_then_nn_k10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(-savings)[:k]\n    cand = unv[idx]\n    d_c = distance_matrix[current_node, cand]\n    return int(cand[int(np.argmin(d_c))])\n",
  "savings_topk_then_dest_k10": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.10 * n_rem)))\n    idx = np.argsort(-savings)[:k]\n    cand = unv[idx]\n    d_d = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(d_d))])\n",
  "savings_topk_then_triangle_k15": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.15 * n_rem)))\n    idx = np.argsort(-savings)[:k]\n    cand = unv[idx]\n    tri = distance_matrix[current_node, cand] + distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(tri))])\n",
  "savings_progress_switch_topk": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    frac = 0.25 if progress < 0.5 else 0.10\n    k = max(1, int(np.ceil(frac * n_rem)))\n    idx = np.argsort(-savings)[:k]\n    cand = unv[idx]\n    tri = distance_matrix[current_node, cand] + distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(tri))])\n",
  "savings_regret2_insertion_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    path = d_cur + d_dest\n    # regret proxy: prefer nodes where best path is much better than 2nd best\n    order = np.argsort(path)\n    best = path[order[0]]\n    second = path[order[1]] if order.size > 1 else best\n    # choose node if it produces the largest direct-edge reduction among the two best candidates\n    cand = unv[order[:min(5, order.size)]]\n    savings = d_cd - (distance_matrix[current_node, cand] + distance_matrix[cand, destination_node])\n    # amplify if regret is high\n    score = savings + 0.05 * (second - best)\n    return int(cand[int(np.argmax(score))])\n",
  "savings_softmax_pick_seeded": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = (int(current_node) * 1000003 + int(destination_node) * 10007 + int(unv.size) * 271) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    s = savings - savings.max()\n    w = np.exp(s / (np.std(savings) + 1e-9))\n    w = w / (w.sum() + 1e-12)\n    return int(unv[int(rng.choice(unv.size, p=w))])\n",
  "savings_max_with_mean_remaining_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    D = distance_matrix[np.ix_(unv, unv)]\n    mean_to_unv = D.mean(axis=1)\n    score = savings - 0.05 * mean_to_unv\n    return int(unv[int(np.argmax(score))])\n",
  "savings_max_with_min_remaining_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    D = distance_matrix[np.ix_(unv, unv)]\n    min_to_unv = D.min(axis=1)\n    score = savings - 0.08 * min_to_unv\n    return int(unv[int(np.argmax(score))])\n",
  "savings_max_clipped_outliers": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    path = d_cur + d_dest\n    hi = float(np.percentile(path, 90))\n    path2 = np.minimum(path, hi)\n    savings = d_cd - path2\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_endgame_dest_bias": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_total = int(distance_matrix.shape[0])\n    n_rem = int(unv.size)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    bias = 0.0 if progress < 0.7 else 0.25\n    savings = d_cd - (d_cur + d_dest) - bias * d_dest\n    return int(unv[int(np.argmax(savings))])\n",
  "savings_max_endgame_nn_fallback": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    if unv.size <= 5:\n        return int(unv[int(np.argmin(d_cur))])\n    d_cd = float(distance_matrix[current_node, destination_node])\n    d_dest = distance_matrix[unv, destination_node]\n    savings = d_cd - (d_cur + d_dest)\n    return int(unv[int(np.argmax(savings))])\n",
  "nn_dest_harmonic_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv] + 1e-6\n    d_dest = distance_matrix[unv, destination_node] + 1e-6\n    # Structural change: Harmonic mean pulls towards nodes that are close to BOTH\n    score = 2.0 * (d_cur * d_dest) / (d_cur + d_dest)\n    return int(unv[int(np.argmin(score))])",
  "nn_dest_geo_mean_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Geometric mean penalizes extremes more than arithmetic sum\n    score = np.sqrt(d_cur * d_dest)\n    return int(unv[int(np.argmin(score))])",
  "nn_dest_log_sum_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Log-space mixing compresses large distances\n    score = np.log1p(d_cur) + 0.5 * np.log1p(d_dest)\n    return int(unv[int(np.argmin(score))])",
  "nn_dest_div_rem_bias": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_rem = int(unv.size)\n    # Structural change: Bias strength depends inversely on swarm size\n    bias = d_dest / (n_rem + 1.0)\n    score = d_cur + bias\n    return int(unv[int(np.argmin(score))])",
  "nn_dest_mul_rem_bias": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_rem = int(unv.size)\n    # Structural change: Bias increases as nodes reduce (endgame panic)\n    factor = 1.0 + np.log1p(1.0 / (n_rem + 1))\n    score = d_cur + factor * d_dest\n    return int(unv[int(np.argmin(score))])",
  "nn_dest_sigmoid_adaptive": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_tot = distance_matrix.shape[0]\n    progress = 1.0 - (unv.size / n_tot)\n    # Structural change: Sigmoid activation for bias transition\n    w = 1.0 / (1.0 + np.exp(-10.0 * (progress - 0.5)))\n    score = d_cur + w * d_dest\n    return int(unv[int(np.argmin(score))])",
  "nn_dest_std_scaled": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Normalize dest influence by local spread\n    scale = np.std(d_cur) + 1e-9\n    score = d_cur + 0.5 * (d_dest / scale)\n    return int(unv[int(np.argmin(score))])",
  "cl_dynamic_sqrt_k": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    # Structural change: K is sub-linear (sqrt) relative to remaining nodes\n    k = max(1, int(np.sqrt(n_rem)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(d_dest))])",
  "cl_filter_far_sort_near": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    k = max(1, int(np.ceil(0.5 * n_rem)))\n    # Structural change: Keep the FARTHEST half, then pick the nearest among them\n    # Logic: avoid local minima by forcing a jump\n    idx = np.argsort(d_cur)[-k:]\n    cand = unv[idx]\n    d_cur_cand = distance_matrix[current_node, cand]\n    return int(cand[int(np.argmin(d_cur_cand))])",
  "cl_filter_near_sort_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    k = max(1, int(unv.size // 3))\n    # Structural change: Shortlist by NN, optimize for Dest\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(d_dest))])",
  "cl_median_split_greedy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_dest = distance_matrix[unv, destination_node]\n    med = np.median(d_dest)\n    # Structural change: Hard filtering by median destination distance\n    mask = d_dest <= med\n    cand = unv[mask]\n    d_cur = distance_matrix[current_node, cand]\n    return int(cand[int(np.argmin(d_cur))])",
  "cl_quartile_exclude_worst": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    # Structural change: Exclude the worst 25%, greedy on rest\n    q75 = np.percentile(d_cur, 75)\n    mask = d_cur <= q75\n    cand = unv[mask]\n    d_cur_cand = distance_matrix[current_node, cand]\n    return int(cand[int(np.argmin(d_cur_cand))])",
  "stat_zscore_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    # Structural change: Z-score normalization logic\n    mean = np.mean(d_cur)\n    std = np.std(d_cur) + 1e-9\n    z = (d_cur - mean) / std\n    # Penalize outliers heavily\n    score = d_cur + 0.5 * std * (z**2)\n    return int(unv[int(np.argmin(score))])",
  "stat_range_bias": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    # Structural change: Use Range (Max - Min) as a proxy for sparsity\n    rng = D.max(axis=1) - D.min(axis=1)\n    score = d_cur + 0.2 * rng\n    return int(unv[int(np.argmin(score))])",
  "stat_skew_proxy_bias": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    # Structural change: Use (Mean - Median) as proxy for distribution skew\n    skew_proxy = np.mean(D, axis=1) - np.median(D, axis=1)\n    score = d_cur + 0.5 * skew_proxy\n    return int(unv[int(np.argmin(score))])",
  "stat_centrality_inverse": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    # Structural change: Inverse centrality (1 / sum_dist)\n    centrality = np.sum(D, axis=1) + 1e-6\n    score = d_cur * centrality\n    return int(unv[int(np.argmin(score))])",
  "stat_min_max_avg_mix": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    # Structural change: Average of the Extremes\n    extremes = 0.5 * (np.min(D, axis=1) + np.max(D, axis=1))\n    score = d_cur + 0.15 * extremes\n    return int(unv[int(np.argmin(score))])",
  "phase_early_explore": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_tot = distance_matrix.shape[0]\n    # Structural change: Logic flip based on phase\n    if unv.size > 0.8 * n_tot:\n        # Go to farthest (explore)\n        return int(unv[int(np.argmax(d_cur))])\n    return int(unv[int(np.argmin(d_cur))])",
  "phase_oscillator_sin": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_rem = unv.size\n    # Structural change: Sinusoidal weight oscillation\n    w = 0.5 + 0.5 * np.sin(n_rem / 2.0)\n    score = (1-w)*d_cur + w*d_dest\n    return int(unv[int(np.argmin(score))])",
  "phase_decay_explore": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n_tot = distance_matrix.shape[0]\n    ratio = unv.size / n_tot\n    # Structural change: Exponential decay of destination influence\n    w = np.exp(-5.0 * (1.0 - ratio))\n    score = d_cur + w * d_dest\n    return int(unv[int(np.argmin(score))])",
  "phase_local_density_switch": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    local_density = np.mean(d_cur)\n    # Structural change: If sparse (high mean dist), aim for dest. If dense, aim for NN.\n    if local_density > np.median(distance_matrix):\n        score = distance_matrix[unv, destination_node]\n    else:\n        score = d_cur\n    return int(unv[int(np.argmin(score))])",
  "phase_stagnation_jump": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    # Structural change: If options are too similar (low variance), force a jump to dest\n    if np.std(d_cur) < 0.1 * np.mean(d_cur):\n        return int(unv[int(np.argmin(distance_matrix[unv, destination_node]))])\n    return int(unv[int(np.argmin(d_cur))])",
  "triangle_perimeter_min": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    base = float(distance_matrix[current_node, destination_node])\n    # Structural change: Minimize full triangle perimeter\n    score = d_cur + d_dest + base\n    return int(unv[int(np.argmin(score))])",
  "triangle_area_proxy_product": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Area proxy (base * height ~ d1 * d2)\n    score = d_cur * d_dest\n    return int(unv[int(np.argmin(score))])",
  "triangle_ratio_d1_d2": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Minimize ratio (Prefer close to me, far from dest)\n    score = d_cur / (d_dest + 1e-6)\n    return int(unv[int(np.argmin(score))])",
  "triangle_abs_diff": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Minimize isosceles deviation\n    score = np.abs(d_cur - d_dest)\n    return int(unv[int(np.argmin(score))])",
  "triangle_cosine_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    base = float(distance_matrix[current_node, destination_node])\n    # Structural change: Law of cosines proxy (numerator)\n    score = (d_cur**2 + d_dest**2 - base**2)\n    return int(unv[int(np.argmin(score))])",
  "triangle_weighted_sq_prod": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Asymmetric polynomial\n    score = (d_cur ** 2) * d_dest\n    return int(unv[int(np.argmin(score))])",
  "triangle_min_max_convex": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Convex combo of min and max edges\n    score = np.minimum(d_cur, d_dest) + 0.5 * np.maximum(d_cur, d_dest)\n    return int(unv[int(np.argmin(score))])",
  "savings_ratio_logic": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    base = float(distance_matrix[current_node, destination_node]) + 1e-9\n    path = distance_matrix[current_node, unv] + distance_matrix[unv, destination_node]\n    # Structural change: Ratio savings instead of additive difference\n    score = base / (path + 1e-9)\n    return int(unv[int(np.argmax(score))])",
  "savings_global_regret": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    # Structural change: Regret vs global minimum available\n    global_min = np.min(d_cur)\n    regret = d_cur - global_min\n    # Pick node with lowest immediate cost + penalty\n    score = d_cur + 0.5 * regret\n    return int(unv[int(np.argmin(score))])",
  "savings_second_best_gap": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    if unv.size < 2: return int(unv[int(np.argmin(d_cur))])\n    # Structural change: Consider gap to 2nd best\n    sorted_idx = np.argsort(d_cur)\n    best = d_cur[sorted_idx[0]]\n    second = d_cur[sorted_idx[1]]\n    gap = second - best\n    # If gap is huge, DEFINITELY take best. If small, maybe look at dest?\n    score = d_cur - 2.0 * gap\n    return int(unv[int(np.argmin(score))])",
  "savings_clarke_proxy_inv": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    base = float(distance_matrix[current_node, destination_node])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Inverse savings\n    savings = (d_cur + d_dest) - base\n    return int(unv[int(np.argmin(savings))])",
  "savings_plus_rem_min": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    min_rem = np.min(D, axis=1)\n    # Structural change: Savings logic augmented by next-step potential\n    score = d_cur + min_rem\n    return int(unv[int(np.argmin(score))])",
  "rand_noise_injection_linear": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    seed = int(d_cur.sum() * 1000) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    # Structural change: Additive uniform noise\n    noisy_score = d_cur + rng.uniform(0, np.mean(d_cur), size=d_cur.shape)\n    return int(unv[int(np.argmin(noisy_score))])",
  "rand_noise_injection_mult": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    seed = int(d_cur.sum() * 1000) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    # Structural change: Multiplicative noise\n    noisy_score = d_cur * rng.uniform(0.8, 1.2, size=d_cur.shape)\n    return int(unv[int(np.argmin(noisy_score))])",
  "rand_prob_accept_greedy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    seed = int(d_cur.sum() * 1000) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    idx = np.argsort(d_cur)\n    # Structural change: Probabilistic acceptance of best\n    if unv.size > 1 and rng.random() < 0.2:\n        return int(unv[idx[1]])\n    return int(unv[idx[0]])",
  "rand_boltzmann_weighted": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    seed = int(d_cur.sum() * 1000) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    # Structural change: Boltzmann distribution\n    T = np.std(d_cur) + 1e-9\n    p = np.exp(-d_cur / T)\n    p /= p.sum()\n    return int(unv[int(rng.choice(unv.size, p=p))])",
  "rand_sample_3_tournament": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    seed = int(current_node * 100) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    k = min(3, unv.size)\n    # Structural change: Random tournament (pick random 3, take best of those)\n    indices = rng.choice(unv.size, k, replace=False)\n    subset = unv[indices]\n    d_cur = distance_matrix[current_node, subset]\n    return int(subset[int(np.argmin(d_cur))])",
  "rand_scramble_top_k": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    k = min(5, unv.size)\n    seed = int(current_node * 100) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    # Structural change: Get top K, then pick uniformly random from them\n    top_k_idx = np.argsort(d_cur)[:k]\n    choice = rng.integers(0, k)\n    return int(unv[top_k_idx[choice]])",
  "rand_noise_decay_time": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    seed = int(unv.size * 100) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    # Structural change: Noise decreases as nodes are visited (Simulated Annealing proxy)\n    n_tot = distance_matrix.shape[0]\n    temp = unv.size / n_tot\n    noisy_score = d_cur + temp * rng.uniform(0, np.mean(d_cur), size=d_cur.shape)\n    return int(unv[int(np.argmin(noisy_score))])",
  "rand_noise_increase_panic": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    seed = int(unv.size * 100) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    # Structural change: Noise INCREASES near end (Endgame Panic)\n    n_tot = distance_matrix.shape[0]\n    progress = 1.0 - (unv.size / n_tot)\n    noisy_score = d_cur + progress * rng.uniform(0, np.mean(d_cur), size=d_cur.shape)\n    return int(unv[int(np.argmin(noisy_score))])",
  "far_then_nn_inverse": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    # Structural change: Inverse distance weighting (prefers near, but soft)\n    score = 1.0 / (d_cur + 1e-6)\n    return int(unv[int(np.argmax(score))])",
  "cl_dynamic_log_k": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    n_rem = int(unv.size)\n    # Structural change: Logarithmic K scaling\n    k = max(1, int(np.log2(n_rem + 2)))\n    idx = np.argsort(d_cur)[:k]\n    cand = unv[idx]\n    d_dest = distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(d_dest))])",
  "phase_mid_game_switch": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    n_tot = distance_matrix.shape[0]\n    progress = 1.0 - (unv.size / n_tot)\n    # Structural change: Only behave differently in the middle 50%\n    if 0.25 < progress < 0.75:\n        score = distance_matrix[unv, destination_node]\n    else:\n        score = distance_matrix[current_node, unv]\n    return int(unv[int(np.argmin(score))])",
  "stat_entropy_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    # Structural change: Entropy proxy (sum of log distances)\n    entropy_proxy = np.sum(np.log1p(D), axis=1)\n    score = d_cur + 0.1 * entropy_proxy\n    return int(unv[int(np.argmin(score))])",
  "cl_exclude_outliers": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    mean = np.mean(d_cur)\n    # Structural change: Filter out anything > 2x mean\n    mask = d_cur < 2.0 * mean\n    cand = unv[mask] if np.any(mask) else unv\n    d_c = distance_matrix[current_node, cand]\n    return int(cand[int(np.argmin(d_c))])",
  "nn_dest_adaptive_min": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Take min of (cur, dest) instead of sum\n    score = np.minimum(d_cur, d_dest)\n    return int(unv[int(np.argmin(score))])",
  "nn_dest_adaptive_max": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Structural change: Minimax (Minimize the maximum leg)\n    score = np.maximum(d_cur, d_dest)\n    return int(unv[int(np.argmin(score))])",
  "savings_weighted_regret": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    base = float(distance_matrix[current_node, destination_node])\n    # Structural change: Double penalty for base edge\n    score = (d_cur + d_dest) - 2.0 * base\n    return int(unv[int(np.argmin(score))])",
  "momentum_consistency_plain": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    # Infer previous step: min distance entering current_node (excluding self)\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    # Momentum: Try to keep the same step size (maintain velocity)\n    diff = np.abs(d_cur - prev_est)\n    score = d_cur + diff\n    return int(unv[int(np.argmin(score))])",
  "momentum_consistency_weight_05": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    unv_int = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv_int]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    diff = np.abs(d_cur - prev_est)\n    score = d_cur + 0.5 * diff\n    return int(unv_int[int(np.argmin(score))])",
  "momentum_consistency_weight_20": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    diff = np.abs(d_cur - prev_est)\n    # Strong preference for rhythm\n    score = d_cur + 2.0 * diff\n    return int(unv[int(np.argmin(score))])",
  "momentum_alternator_short_long": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else 0.0\n    # Logic: If previous was short, go long. If previous was long, go short.\n    # We maximize difference from previous step.\n    diff = np.abs(d_cur - prev_est)\n    # We still want to minimize d_cur, but maximize diff (so subtract diff)\n    score = d_cur - 0.5 * diff\n    return int(unv[int(np.argmin(score))])",
  "momentum_accelerator_decay": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.max(d_cur)\n    # Logic: Decay velocity. Prefer steps smaller than previous.\n    target = prev_est * 0.8\n    diff = np.abs(d_cur - target)\n    score = d_cur + diff\n    return int(unv[int(np.argmin(score))])",
  "momentum_cosine_fwd_proj": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    base = float(distance_matrix[current_node, destination_node]) + 1e-9\n    # Logic: Maximize Cosine Similarity to the direct path vector\n    # Law of Cosines numerator proxy: (a^2 + b^2 - c^2)\n    # We want to minimize the deviation angle.\n    cos_sim_proxy = (d_cur**2 + base**2 - d_dest**2) / (2 * d_cur * base + 1e-9)\n    # Prefer high cosine (close to 1.0) -> minimizing negative cosine\n    score = d_cur - 5.0 * cos_sim_proxy\n    return int(unv[int(np.argmin(score))])",
  "momentum_angle_penalty_sharp": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    base = float(distance_matrix[current_node, destination_node])\n    # Logic: Penalize deviation from straight line (Triangle Inequality Slack)\n    deviation = (d_cur + d_dest) - base\n    # Strong penalty for 'sharp' triangles (large deviations)\n    score = d_cur + 2.5 * deviation\n    return int(unv[int(np.argmin(score))])",
  "momentum_angle_penalty_soft": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    base = float(distance_matrix[current_node, destination_node])\n    # Logic: Softer penalty for deviation\n    deviation = (d_cur + d_dest) - base\n    score = d_cur + 0.8 * deviation\n    return int(unv[int(np.argmin(score))])",
  "momentum_centrifugal_outward": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    # Logic: Prefer nodes that are 'moving away' from the pack (High average distance to others)\n    avg_dist_to_others = np.mean(D, axis=1)\n    # We want high avg_dist (outward momentum) -> subtract it\n    score = d_cur - 0.3 * avg_dist_to_others\n    return int(unv[int(np.argmin(score))])",
  "momentum_centripetal_inward": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    D = distance_matrix[np.ix_(unv, unv)]\n    # Logic: Prefer nodes spiraling inward (Low average distance to others)\n    avg_dist_to_others = np.mean(D, axis=1)\n    score = d_cur + 0.3 * avg_dist_to_others\n    return int(unv[int(np.argmin(score))])",
  "momentum_hybrid_angle_rhythm": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    rhythm_diff = np.abs(d_cur - prev_est)\n    d_dest = distance_matrix[unv, destination_node]\n    base = float(distance_matrix[current_node, destination_node])\n    angle_dev = (d_cur + d_dest) - base\n    # Complex mix: Rhythm + Straightness\n    score = d_cur + 0.5 * rhythm_diff + 0.5 * angle_dev\n    return int(unv[int(np.argmin(score))])",
  "momentum_target_median_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    # Variation: Use Median of incoming edges as a more robust proxy for 'typical' entry speed\n    prev_est = np.median(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    diff = np.abs(d_cur - prev_est)\n    score = d_cur + diff\n    return int(unv[int(np.argmin(score))])",
  "momentum_golden_ratio_expand": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    # Variation: Target a Golden Ratio expansion (Phi ~ 1.618)\n    target = prev_est * 1.618\n    diff = np.abs(d_cur - target)\n    score = d_cur + diff\n    return int(unv[int(np.argmin(score))])",
  "momentum_golden_ratio_compress": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    # Variation: Target a Golden Ratio compression (phi ~ 0.618)\n    target = prev_est * 0.618\n    diff = np.abs(d_cur - target)\n    score = d_cur + diff\n    return int(unv[int(np.argmin(score))])",
  "momentum_log_ratio_smooth": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else 1.0\n    # Variation: Minimize Log-Ratio (Scale Invariant Momentum)\n    # Prefers d_cur / prev_est == 1.0 regardless of magnitude\n    ratio_diff = np.abs(np.log((d_cur + 1e-9) / (prev_est + 1e-9)))\n    score = d_cur * (1.0 + ratio_diff)\n    return int(unv[int(np.argmin(score))])",
  "momentum_progress_ramp_up": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    n_tot = distance_matrix.shape[0]\n    progress = 1.0 - (unv.size / n_tot)\n    # Variation: Target velocity increases with progress\n    target = prev_est * (1.0 + 0.5 * progress)\n    score = d_cur + np.abs(d_cur - target)\n    return int(unv[int(np.argmin(score))])",
  "momentum_progress_brake": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    n_tot = distance_matrix.shape[0]\n    progress = 1.0 - (unv.size / n_tot)\n    # Variation: Target velocity decreases with progress (Braking)\n    target = prev_est * (1.0 - 0.5 * progress)\n    score = d_cur + np.abs(d_cur - target)\n    return int(unv[int(np.argmin(score))])",
  "momentum_zigzag_bias": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    base = float(distance_matrix[current_node, destination_node])\n    # Variation: Zig-Zag Logic\n    # Maximize the triangular deviation (preferring nodes OFF the direct line)\n    deviation = (d_cur + d_dest) - base\n    # Subtract deviation to maximize it (while minimizing d_cur)\n    score = d_cur - 0.2 * deviation\n    return int(unv[int(np.argmin(score))])",
  "momentum_flow_alignment": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Variation: Flow Alignment (Product of current step and remaining dist)\n    # Proxies 'conserving energy' over the path\n    flow = d_cur * d_dest\n    # Minimize the change in flow\n    prev_flow = np.mean(distance_matrix[:, current_node]) * float(distance_matrix[current_node, destination_node])\n    score = np.abs(flow - prev_flow)\n    return int(unv[int(np.argmin(score))])",
  "momentum_stop_and_go": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    avg_len = np.mean(d_cur)\n    # Variation: Stop-and-Go\n    # If previous was fast (long), force slow (short). If slow, allow fast.\n    if prev_est > avg_len:\n        # Force short\n        score = d_cur\n    else:\n        # Force long (invert standard greedy)\n        score = -d_cur\n    return int(unv[int(np.argmin(score))])",
  "momentum_adaptive_inertia": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    # Variation: Inertia weight depends on how extreme the previous step was\n    global_mean = np.mean(distance_matrix[distance_matrix > 0])\n    inertia_w = np.abs(prev_est - global_mean) / global_mean\n    diff = np.abs(d_cur - prev_est)\n    score = d_cur + inertia_w * diff\n    return int(unv[int(np.argmin(score))])",
  "momentum_angular_relaxation": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    base = float(distance_matrix[current_node, destination_node])\n    deviation = (d_cur + d_dest) - base\n    # Variation: Relaxed Angular Constraint\n    # Only penalize deviation if it exceeds a threshold (Hinge Loss)\n    threshold = 0.2 * base\n    penalty = np.maximum(0.0, deviation - threshold)\n    score = d_cur + 5.0 * penalty\n    return int(unv[int(np.argmin(score))])",
  "momentum_target_harmonic": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    # Variation: Harmonic Mean Target\n    # Target is harmonic mean of Previous and Average available\n    avg_avail = np.mean(d_cur)\n    target = 2.0 * (prev_est * avg_avail) / (prev_est + avg_avail + 1e-9)\n    diff = np.abs(d_cur - target)\n    score = d_cur + diff\n    return int(unv[int(np.argmin(score))])",
  "momentum_outlier_snap": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    # Variation: Snap to grid\n    # Penalize non-integer multiples of previous step (Rhythmic Steps)\n    ratio = d_cur / (prev_est + 1e-9)\n    grid_penalty = np.abs(ratio - np.round(ratio))\n    score = d_cur + prev_est * grid_penalty\n    return int(unv[int(np.argmin(score))])",
  "momentum_velocity_cap": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    col = distance_matrix[:, current_node]\n    prev_est = np.min(col[col > 1e-6]) if np.any(col > 1e-6) else np.mean(d_cur)\n    # Variation: Velocity Cap\n    # Hard penalty if step > 1.5x previous\n    penalty = np.maximum(0.0, d_cur - 1.5 * prev_est)\n    score = d_cur + 10.0 * penalty\n    return int(unv[int(np.argmin(score))])",
  "momentum_lookahead_consistency": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0: return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    d_cur = distance_matrix[current_node, unv]\n    # Variation: Lookahead Consistency\n    # Pick node where the *next* step out is consistent with *this* step in\n    D = distance_matrix[np.ix_(unv, unv)]\n    np.fill_diagonal(D, np.inf)\n    min_next = np.min(D, axis=1)\n    diff_future = np.abs(d_cur - min_next)\n    score = d_cur + 0.5 * diff_future\n    return int(unv[int(np.argmin(score))])",
  "subtle_rank_sum": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n = int(unv.size)\n    o1 = np.argsort(d_cur)\n    r1 = np.empty(n, dtype=np.int64)\n    r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(d_dest)\n    r2 = np.empty(n, dtype=np.int64)\n    r2[o2] = np.arange(n, dtype=np.int64)\n    score = (r1 + r2).astype(np.float64)\n    return int(unv[int(np.argmin(score))])\n",
  "subtle_rank_lex_cur": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n = int(unv.size)\n    o1 = np.argsort(d_cur)\n    r1 = np.empty(n, dtype=np.int64)\n    r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(d_dest)\n    r2 = np.empty(n, dtype=np.int64)\n    r2[o2] = np.arange(n, dtype=np.int64)\n    score = (r1 * (n + 1) + r2).astype(np.float64)\n    return int(unv[int(np.argmin(score))])\n",
  "subtle_rank_lex_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n = int(unv.size)\n    o1 = np.argsort(d_cur)\n    r1 = np.empty(n, dtype=np.int64)\n    r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(d_dest)\n    r2 = np.empty(n, dtype=np.int64)\n    r2[o2] = np.arange(n, dtype=np.int64)\n    score = (r2 * (n + 1) + r1).astype(np.float64)\n    return int(unv[int(np.argmin(score))])\n",
  "subtle_rank_borda_2_1": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n = int(unv.size)\n    o1 = np.argsort(d_cur)\n    r1 = np.empty(n, dtype=np.int64)\n    r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(d_dest)\n    r2 = np.empty(n, dtype=np.int64)\n    r2[o2] = np.arange(n, dtype=np.int64)\n    score = (2*r1 + r2).astype(np.float64)\n    return int(unv[int(np.argmin(score))])\n",
  "subtle_rank_borda_1_2": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n = int(unv.size)\n    o1 = np.argsort(d_cur)\n    r1 = np.empty(n, dtype=np.int64)\n    r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(d_dest)\n    r2 = np.empty(n, dtype=np.int64)\n    r2[o2] = np.arange(n, dtype=np.int64)\n    score = (r1 + 2*r2).astype(np.float64)\n    return int(unv[int(np.argmin(score))])\n",
  "subtle_rank_product": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n = int(unv.size)\n    o1 = np.argsort(d_cur)\n    r1 = np.empty(n, dtype=np.int64)\n    r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(d_dest)\n    r2 = np.empty(n, dtype=np.int64)\n    r2[o2] = np.arange(n, dtype=np.int64)\n    score = ((r1 + 1) * (r2 + 1)).astype(np.float64)\n    return int(unv[int(np.argmin(score))])\n",
  "subtle_rank_minmax": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n = int(unv.size)\n    o1 = np.argsort(d_cur)\n    r1 = np.empty(n, dtype=np.int64)\n    r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(d_dest)\n    r2 = np.empty(n, dtype=np.int64)\n    r2[o2] = np.arange(n, dtype=np.int64)\n    score = np.maximum(r1, r2).astype(np.float64)\n    return int(unv[int(np.argmin(score))])\n",
  "subtle_rank_sum_logd": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n = int(unv.size)\n    d1 = np.log1p(d_cur); d2 = np.log1p(d_dest)\n    o1 = np.argsort(d1); r1 = np.empty(n, dtype=np.int64); r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(d2); r2 = np.empty(n, dtype=np.int64); r2[o2] = np.arange(n, dtype=np.int64)\n    score = (r1 + r2).astype(np.float64)\n    return int(unv[int(np.argmin(score))])\n",
  "subtle_rank_sum_sqrtd": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n = int(unv.size)\n    d1 = np.sqrt(d_cur); d2 = np.sqrt(d_dest)\n    o1 = np.argsort(d1); r1 = np.empty(n, dtype=np.int64); r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(d2); r2 = np.empty(n, dtype=np.int64); r2[o2] = np.arange(n, dtype=np.int64)\n    score = (r1 + r2).astype(np.float64)\n    return int(unv[int(np.argmin(score))])\n",
  "subtle_rank_sum_zscore_step": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    n = int(unv.size)\n    d1 = (d_cur - np.mean(d_cur)) / (np.std(d_cur) + 1e-9)\n    d2 = (d_dest - np.mean(d_dest)) / (np.std(d_dest) + 1e-9)\n    o1 = np.argsort(d1); r1 = np.empty(n, dtype=np.int64); r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(d2); r2 = np.empty(n, dtype=np.int64); r2[o2] = np.arange(n, dtype=np.int64)\n    score = (r1 + r2).astype(np.float64)\n    return int(unv[int(np.argmin(score))])\n",
  "subtle_pareto_sum": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    order = np.argsort(d_cur)\n    keep = np.zeros(int(unv.size), dtype=bool)\n    best = np.inf\n    for i in order:\n        if d_dest[i] < best:\n            keep[i] = True\n            best = d_dest[i]\n    cand = unv[keep]\n    dcur_c = d_cur[keep]\n    ddst_c = d_dest[keep]\n    if cand.size == 0:\n        cand = unv\n        dcur_c = d_cur\n        ddst_c = d_dest\n    score = dcur_c + ddst_c\n    return int(cand[int(np.argmin(score))])\n",
  "subtle_pareto_max": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    order = np.argsort(d_cur)\n    keep = np.zeros(int(unv.size), dtype=bool)\n    best = np.inf\n    for i in order:\n        if d_dest[i] < best:\n            keep[i] = True\n            best = d_dest[i]\n    cand = unv[keep]\n    dcur_c = d_cur[keep]\n    ddst_c = d_dest[keep]\n    if cand.size == 0:\n        cand = unv\n        dcur_c = d_cur\n        ddst_c = d_dest\n    score = np.maximum(dcur_c, ddst_c)\n    return int(cand[int(np.argmin(score))])\n",
  "subtle_pareto_product": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    order = np.argsort(d_cur)\n    keep = np.zeros(int(unv.size), dtype=bool)\n    best = np.inf\n    for i in order:\n        if d_dest[i] < best:\n            keep[i] = True\n            best = d_dest[i]\n    cand = unv[keep]\n    dcur_c = d_cur[keep]\n    ddst_c = d_dest[keep]\n    if cand.size == 0:\n        cand = unv\n        dcur_c = d_cur\n        ddst_c = d_dest\n    score = dcur_c * (ddst_c + 1e-9)\n    return int(cand[int(np.argmin(score))])\n",
  "subtle_pareto_detour_excess": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    order = np.argsort(d_cur)\n    keep = np.zeros(int(unv.size), dtype=bool)\n    best = np.inf\n    for i in order:\n        if d_dest[i] < best:\n            keep[i] = True\n            best = d_dest[i]\n    cand = unv[keep]\n    dcur_c = d_cur[keep]\n    ddst_c = d_dest[keep]\n    if cand.size == 0:\n        cand = unv\n        dcur_c = d_cur\n        ddst_c = d_dest\n    d_direct = float(distance_matrix[current_node, destination_node])\n    score = dcur_c + ddst_c - d_direct\n    return int(cand[int(np.argmin(score))])\n",
  "subtle_pareto_lex_cur": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    order = np.argsort(d_cur)\n    keep = np.zeros(int(unv.size), dtype=bool)\n    best = np.inf\n    for i in order:\n        if d_dest[i] < best:\n            keep[i] = True\n            best = d_dest[i]\n    cand = unv[keep]\n    dcur_c = d_cur[keep]\n    ddst_c = d_dest[keep]\n    if cand.size == 0:\n        cand = unv\n        dcur_c = d_cur\n        ddst_c = d_dest\n    n = int(cand.size)\n    o1 = np.argsort(dcur_c)\n    r1 = np.empty(n, dtype=np.int64)\n    r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(ddst_c)\n    r2 = np.empty(n, dtype=np.int64)\n    r2[o2] = np.arange(n, dtype=np.int64)\n    score = (r1 * (n + 1) + r2).astype(np.float64)\n    return int(cand[int(np.argmin(score))])\n",
  "subtle_pareto_lex_dest": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    order = np.argsort(d_cur)\n    keep = np.zeros(int(unv.size), dtype=bool)\n    best = np.inf\n    for i in order:\n        if d_dest[i] < best:\n            keep[i] = True\n            best = d_dest[i]\n    cand = unv[keep]\n    dcur_c = d_cur[keep]\n    ddst_c = d_dest[keep]\n    if cand.size == 0:\n        cand = unv\n        dcur_c = d_cur\n        ddst_c = d_dest\n    n = int(cand.size)\n    o1 = np.argsort(ddst_c)\n    r1 = np.empty(n, dtype=np.int64)\n    r1[o1] = np.arange(n, dtype=np.int64)\n    o2 = np.argsort(dcur_c)\n    r2 = np.empty(n, dtype=np.int64)\n    r2[o2] = np.arange(n, dtype=np.int64)\n    score = (r1 * (n + 1) + r2).astype(np.float64)\n    return int(cand[int(np.argmin(score))])\n",
  "subtle_pareto_eps_sum": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    order = np.argsort(d_cur)\n    keep = np.zeros(int(unv.size), dtype=bool)\n    best = np.inf\n    eps = float(np.median(d_dest) * 0.01 + 1e-12)\n    for i in order:\n        if d_dest[i] <= best + eps:\n            keep[i] = True\n            best = min(best, float(d_dest[i]))\n    cand = unv[keep]\n    dcur_c = d_cur[keep]; ddst_c = d_dest[keep]\n    if cand.size == 0:\n        cand = unv; dcur_c = d_cur; ddst_c = d_dest\n    score = dcur_c + ddst_c\n    return int(cand[int(np.argmin(score))])\n",
  "subtle_pareto_eps_max": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    order = np.argsort(d_cur)\n    keep = np.zeros(int(unv.size), dtype=bool)\n    best = np.inf\n    eps = float(np.median(d_dest) * 0.01 + 1e-12)\n    for i in order:\n        if d_dest[i] <= best + eps:\n            keep[i] = True\n            best = min(best, float(d_dest[i]))\n    cand = unv[keep]\n    dcur_c = d_cur[keep]; ddst_c = d_dest[keep]\n    if cand.size == 0:\n        cand = unv; dcur_c = d_cur; ddst_c = d_dest\n    score = np.maximum(dcur_c, ddst_c)\n    return int(cand[int(np.argmin(score))])\n",
  "subtle_pareto_front2_sum": "import numpy as np\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return int(destination_node)\n    unv = unvisited_nodes.astype(int)\n    if unv.size == 1:\n        return int(unv[0])\n    d_cur = distance_matrix[current_node, unv]\n    d_dest = distance_matrix[unv, destination_node]\n    # Keep first two Pareto layers (slightly more exploratory)\n    order = np.argsort(d_cur)\n    best = np.inf\n    layer1 = np.zeros(int(unv.size), dtype=bool)\n    for i in order:\n        if d_dest[i] < best:\n            layer1[i] = True\n            best = float(d_dest[i])\n    # second layer: Pareto front after removing layer1\n    rem = np.where(~layer1)[0]\n    if rem.size == 0:\n        cand = unv[layer1]\n    else:\n        dcur_r = d_cur[rem]\n        ddst_r = d_dest[rem]\n        o = rem[np.argsort(dcur_r)]\n        best2 = np.inf\n        layer2 = np.zeros(int(unv.size), dtype=bool)\n        for j in o:\n            if d_dest[j] < best2:\n                layer2[j] = True\n                best2 = float(d_dest[j])\n        mask = layer1 | layer2\n        cand = unv[mask]\n    if cand.size == 0:\n        cand = unv\n    score = distance_matrix[current_node, cand] + distance_matrix[cand, destination_node]\n    return int(cand[int(np.argmin(score))])\n"
}






