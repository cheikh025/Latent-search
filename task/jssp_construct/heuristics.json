{
  "shortest_processing_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Shortest Processing Time (SPT): Select operation with minimum processing time.\"\"\"\n    if not feasible_operations:\n        return None\n    return min(feasible_operations, key=lambda x: x[2])\n",
  "longest_processing_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Longest Processing Time (LPT): Select operation with maximum processing time.\"\"\"\n    if not feasible_operations:\n        return None\n    return max(feasible_operations, key=lambda x: x[2])\n",
  "earliest_idle_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation for the machine that will be idle soonest.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    return min(feasible_operations, key=lambda x: machine_status[x[1]])\n",
  "latest_idle_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation for the busiest machine to keep it occupied.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    return max(feasible_operations, key=lambda x: machine_status[x[1]])\n",
  "earliest_available_job": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation from the job that becomes available earliest.\"\"\"\n    if not feasible_operations:\n        return None\n    job_status = current_status['job_status']\n    return min(feasible_operations, key=lambda x: job_status[x[0]])\n",
  "balanced_machine_load": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Balance machine workload: prefer operations on less-loaded machines.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    return min(feasible_operations, key=lambda x: (machine_status[x[1]], x[2]))\n",
  "weighted_spt_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Weighted combination: 60% processing time + 40% machine availability.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    mach_times = np.array([machine_status[op[1]] for op in feasible_operations], dtype=float)\n    \n    proc_norm = proc_times / (np.mean(proc_times) + 1e-9)\n    mach_norm = mach_times / (np.mean(mach_times) + 1e-9)\n    \n    scores = 0.6 * proc_norm + 0.4 * mach_norm\n    return feasible_operations[int(np.argmin(scores))]\n",
  "job_machine_balance": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Balance both job and machine availability times.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    scores = [machine_status[op[1]] + job_status[op[0]] + op[2] for op in feasible_operations]\n    return feasible_operations[int(np.argmin(scores))]\n",
  "minimal_start_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation that can start earliest.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    start_times = [max(machine_status[op[1]], job_status[op[0]]) for op in feasible_operations]\n    return feasible_operations[int(np.argmin(start_times))]\n",
  "minimal_completion_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation that will complete earliest.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    completion_times = [max(machine_status[op[1]], job_status[op[0]]) + op[2] for op in feasible_operations]\n    return feasible_operations[int(np.argmin(completion_times))]\n",
  "machine_utilization_max": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Maximize machine utilization: prefer longer operations on idle machines.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    # Negative processing time for machines with low status (more idle)\n    scores = [machine_status[op[1]] - 2.0 * op[2] for op in feasible_operations]\n    return feasible_operations[int(np.argmin(scores))]\n",
  "random_choice": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Random selection with deterministic seed based on current state.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    seed = int(sum(machine_status) + sum(job_status)) % (2**31)\n    rng = np.random.default_rng(seed)\n    idx = int(rng.integers(0, len(feasible_operations)))\n    return feasible_operations[idx]\n",
  "alternating_spt_lpt": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Alternate between SPT and LPT based on total scheduled operations.\"\"\"\n    if not feasible_operations:\n        return None\n    job_status = current_status['job_status']\n    \n    mode = int(sum(job_status)) % 2\n    if mode == 0:\n        return min(feasible_operations, key=lambda x: x[2])\n    else:\n        return max(feasible_operations, key=lambda x: x[2])\n",
  "processing_time_percentile": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation with processing time near 40th percentile.\"\"\"\n    if not feasible_operations:\n        return None\n    \n    proc_times = np.array([op[2] for op in feasible_operations])\n    target = float(np.percentile(proc_times, 40))\n    \n    deviations = np.abs(proc_times - target)\n    return feasible_operations[int(np.argmin(deviations))]\n",
  "machine_variance_min": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Minimize variance in machine completion times.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    best_op = None\n    best_var = float('inf')\n    \n    for op in feasible_operations:\n        new_status = machine_status.copy()\n        new_status[op[1]] = max(machine_status[op[1]], job_status[op[0]]) + op[2]\n        var = float(np.var(new_status))\n        if var < best_var:\n            best_var = var\n            best_op = op\n    \n    return best_op\n",
  "slack_time_priority": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Prioritize operations with minimal slack time.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    slacks = [abs(machine_status[op[1]] - job_status[op[0]]) for op in feasible_operations]\n    return feasible_operations[int(np.argmin(slacks))]\n",
  "bottleneck_machine_avoid": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Avoid scheduling on bottleneck (busiest) machines when possible.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    # Find operations NOT on the busiest machine\n    max_status = max(machine_status)\n    non_bottleneck = [op for op in feasible_operations if machine_status[op[1]] < max_status]\n    \n    candidates = non_bottleneck if non_bottleneck else feasible_operations\n    return min(candidates, key=lambda x: x[2])\n",
  "job_id_priority": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Prioritize lower job IDs (FIFO-like behavior).\"\"\"\n    if not feasible_operations:\n        return None\n    return min(feasible_operations, key=lambda x: (x[0], x[2]))\n",
  "machine_id_priority": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Prioritize lower machine IDs for tie-breaking.\"\"\"\n    if not feasible_operations:\n        return None\n    return min(feasible_operations, key=lambda x: (x[1], x[2]))\n",
  "weighted_job_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Weighted: 50% job availability + 50% machine availability.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    job_times = np.array([job_status[op[0]] for op in feasible_operations], dtype=float)\n    mach_times = np.array([machine_status[op[1]] for op in feasible_operations], dtype=float)\n    \n    job_norm = job_times / (np.mean(job_times) + 1e-9)\n    mach_norm = mach_times / (np.mean(mach_times) + 1e-9)\n    \n    scores = 0.5 * job_norm + 0.5 * mach_norm\n    return feasible_operations[int(np.argmin(scores))]\n",
  "adaptive_spt_lpt": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Start with LPT, transition to SPT as schedule progresses.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    progress = np.mean(machine_status) / (max(machine_status) + 1e-9)\n    \n    if progress < 0.4:\n        return max(feasible_operations, key=lambda x: x[2])\n    else:\n        return min(feasible_operations, key=lambda x: x[2])\n",
  "max_machine_min_processing": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Among operations on the busiest machine, pick shortest processing time.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    mach_times = [machine_status[op[1]] for op in feasible_operations]\n    max_time = max(mach_times)\n    \n    candidates = [op for op, mt in zip(feasible_operations, mach_times) if mt == max_time]\n    return min(candidates, key=lambda x: x[2])\n",
  "composite_three_factor": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Composite score: 40% processing + 30% machine + 30% job.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    mach_times = np.array([machine_status[op[1]] for op in feasible_operations], dtype=float)\n    job_times = np.array([job_status[op[0]] for op in feasible_operations], dtype=float)\n    \n    proc_norm = proc_times / (np.mean(proc_times) + 1e-9)\n    mach_norm = mach_times / (np.mean(mach_times) + 1e-9)\n    job_norm = job_times / (np.mean(job_times) + 1e-9)\n    \n    scores = 0.4 * proc_norm + 0.3 * mach_norm + 0.3 * job_norm\n    return feasible_operations[int(np.argmin(scores))]\n",
  "exponential_processing_weight": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Exponentially weight shorter processing times.\"\"\"\n    if not feasible_operations:\n        return None\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    weights = np.exp(-proc_times / (np.mean(proc_times) + 1e-9))\n    \n    machine_status = current_status['machine_status']\n    seed = int(sum(machine_status)) % (2**31)\n    rng = np.random.default_rng(seed)\n    \n    probs = weights / (np.sum(weights) + 1e-9)\n    idx = int(rng.choice(len(feasible_operations), p=probs))\n    return feasible_operations[idx]\n",
  "round_robin_jobs": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Round-robin through jobs, picking shortest operation per job.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    # Group by job_id\n    jobs = {}\n    for op in feasible_operations:\n        if op[0] not in jobs:\n            jobs[op[0]] = []\n        jobs[op[0]].append(op)\n    \n    # Pick job with lowest total machine time, then shortest operation\n    best_job = min(jobs.keys(), key=lambda j: sum([machine_status[o[1]] for o in jobs[j]]))\n    return min(jobs[best_job], key=lambda x: x[2])\n",
  "ratio_processing_availability": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Minimize ratio of processing time to machine availability.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    ratios = [op[2] / (machine_status[op[1]] + 1.0) for op in feasible_operations]\n    return feasible_operations[int(np.argmin(ratios))]\n",
  "stochastic_greedy": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Probabilistic selection favoring shorter processing times.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    \n    # Lower processing time = higher probability\n    inv_times = 1.0 / (proc_times + 1e-9)\n    probs = inv_times / (np.sum(inv_times) + 1e-9)\n    \n    seed = int(sum(machine_status) + sum(job_status)) % (2**31)\n    rng = np.random.default_rng(seed)\n    \n    idx = int(rng.choice(len(feasible_operations), p=probs))\n    return feasible_operations[idx]\n",
  "hybrid_makespan_estimator": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Estimate makespan impact and choose operation with minimal increase.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    best_op = None\n    best_makespan = float('inf')\n    \n    for op in feasible_operations:\n        new_mach_status = machine_status.copy()\n        new_job_status = job_status.copy()\n        \n        start = max(machine_status[op[1]], job_status[op[0]])\n        new_mach_status[op[1]] = start + op[2]\n        new_job_status[op[0]] = start + op[2]\n        \n        makespan = max(max(new_mach_status), max(new_job_status))\n        if makespan < best_makespan:\n            best_makespan = makespan\n            best_op = op\n    \n    return best_op\n",
  "normalized_multi_objective": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min-max normalize all factors and combine with equal weights.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    mach_times = np.array([machine_status[op[1]] for op in feasible_operations], dtype=float)\n    job_times = np.array([job_status[op[0]] for op in feasible_operations], dtype=float)\n    \n    def minmax_norm(x):\n        mn, mx = x.min(), x.max()\n        if mx - mn < 1e-9:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn + 1e-9)\n    \n    proc_norm = minmax_norm(proc_times)\n    mach_norm = minmax_norm(mach_times)\n    job_norm = minmax_norm(job_times)\n    \n    scores = proc_norm + mach_norm + job_norm\n    return feasible_operations[int(np.argmin(scores))]\n",
  "idle_time_minimizer": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Minimize total idle time across all machines.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    idle_times = [max(0, job_status[op[0]] - machine_status[op[1]]) for op in feasible_operations]\n    return feasible_operations[int(np.argmin(idle_times))]\n",
  "priority_score_blend": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Blend: inverse processing time + inverse machine load.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    mach_loads = np.array([machine_status[op[1]] for op in feasible_operations], dtype=float)\n    \n    inv_proc = 1.0 / (proc_times + 1e-9)\n    inv_mach = 1.0 / (mach_loads + 1.0)\n    \n    scores = inv_proc + inv_mach\n    return feasible_operations[int(np.argmax(scores))]\n",
  "earliest_start_longest_processing": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Earliest Start + Longest Processing (ES+LPT): start ASAP, then keep machine busy.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    def key(op):\n        start = max(ms[op[1]], js[op[0]])\n        return (start, -op[2], ms[op[1]])\n    return min(feasible_operations, key=key)\n",
  "latest_start_shortest_processing": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Latest Start + Shortest Processing (LS+SPT): delayable ops first, but keep them short.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    def key(op):\n        start = max(ms[op[1]], js[op[0]])\n        return (-start, op[2], js[op[0]])\n    return min(feasible_operations, key=key)\n",
  "job_waiting_pressure": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Job-Waiting Pressure: prioritize ops where the job has been waiting on the machine the most.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    # waiting = machine_time - job_time (positive means job is blocked by the machine)\n    pressures = [max(0.0, float(ms[op[1]] - js[op[0]])) for op in feasible_operations]\n    # Break ties by shorter processing to release the machine quickly\n    best = int(np.argmax(pressures))\n    best_pressure = pressures[best]\n    candidates = [op for op, p in zip(feasible_operations, pressures) if abs(p - best_pressure) < 1e-12]\n    return min(candidates, key=lambda op: op[2])\n",
  "machine_waiting_pressure": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Machine-Waiting Pressure: prioritize ops where the machine would otherwise wait for the job.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    # waiting = job_time - machine_time (positive means machine is blocked by the job)\n    pressures = [max(0.0, float(js[op[0]] - ms[op[1]])) for op in feasible_operations]\n    # Break ties by longest processing to avoid future fragmentation\n    best = int(np.argmax(pressures))\n    best_pressure = pressures[best]\n    candidates = [op for op, p in zip(feasible_operations, pressures) if abs(p - best_pressure) < 1e-12]\n    return max(candidates, key=lambda op: op[2])\n",
  "gini_machine_load_reducer": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Gini Machine Load Reducer: pick op that minimizes Gini coefficient of machine completion times after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = current_status['job_status']\n\n    def gini(x):\n        x = np.asarray(x, dtype=float)\n        if np.allclose(x, 0.0):\n            return 0.0\n        xs = np.sort(x)\n        n = xs.size\n        cum = np.cumsum(xs)\n        return float((n + 1 - 2 * np.sum(cum) / (cum[-1] + 1e-12)) / n)\n\n    best_op, best_val = None, float('inf')\n    for op in feasible_operations:\n        ms = ms0.copy()\n        start = max(ms[op[1]], float(js[op[0]]))\n        ms[op[1]] = start + float(op[2])\n        val = gini(ms)\n        if val < best_val - 1e-12:\n            best_val, best_op = val, op\n        elif abs(val - best_val) < 1e-12 and op[2] < best_op[2]:\n            best_op = op\n    return best_op\n",
  "gini_job_completion_reducer": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Gini Job Completion Reducer: pick op that minimizes Gini coefficient of job completion times after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js0 = np.array(current_status['job_status'], dtype=float)\n\n    def gini(x):\n        x = np.asarray(x, dtype=float)\n        if np.allclose(x, 0.0):\n            return 0.0\n        xs = np.sort(x)\n        n = xs.size\n        cum = np.cumsum(xs)\n        return float((n + 1 - 2 * np.sum(cum) / (cum[-1] + 1e-12)) / n)\n\n    best_op, best_val = None, float('inf')\n    for op in feasible_operations:\n        js = js0.copy()\n        start = max(float(ms[op[1]]), js[op[0]])\n        js[op[0]] = start + float(op[2])\n        val = gini(js)\n        if val < best_val - 1e-12:\n            best_val, best_op = val, op\n        elif abs(val - best_val) < 1e-12 and op[2] < best_op[2]:\n            best_op = op\n    return best_op\n",
  "minimize_max_machine_time_after": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Minimize Max Machine Time After: choose op that yields smallest max(machine_status) after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = current_status['job_status']\n\n    best_op, best_val = None, float('inf')\n    for op in feasible_operations:\n        ms = ms0.copy()\n        start = max(ms[op[1]], float(js[op[0]]))\n        ms[op[1]] = start + float(op[2])\n        val = float(ms.max())\n        if val < best_val - 1e-12:\n            best_val, best_op = val, op\n        elif abs(val - best_val) < 1e-12:\n            # tie-break: earlier start\n            s_best = max(ms0[best_op[1]], float(js[best_op[0]]))\n            s_now = max(ms0[op[1]], float(js[op[0]]))\n            if s_now < s_best - 1e-12:\n                best_op = op\n    return best_op\n",
  "minimize_max_job_time_after": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Minimize Max Job Time After: choose op that yields smallest max(job_status) after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js0 = np.array(current_status['job_status'], dtype=float)\n\n    best_op, best_val = None, float('inf')\n    for op in feasible_operations:\n        js = js0.copy()\n        start = max(float(ms[op[1]]), js[op[0]])\n        js[op[0]] = start + float(op[2])\n        val = float(js.max())\n        if val < best_val - 1e-12:\n            best_val, best_op = val, op\n        elif abs(val - best_val) < 1e-12 and op[2] < best_op[2]:\n            best_op = op\n    return best_op\n",
  "variance_adaptive_weighting": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Variance-Adaptive Weighting: weight availability vs processing using machine-load variance.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    v = float(np.var(ms))\n    # High variance -> emphasize balancing (availability); low variance -> emphasize processing time\n    w_avail = v / (v + 1.0)\n    w_proc = 1.0 - w_avail\n\n    proc = np.array([op[2] for op in feasible_operations], dtype=float)\n    start = np.array([max(ms[op[1]], js[op[0]]) for op in feasible_operations], dtype=float)\n\n    proc_n = proc / (np.mean(proc) + 1e-12)\n    start_n = start / (np.mean(start) + 1e-12)\n\n    score = w_proc * proc_n + w_avail * start_n\n    return feasible_operations[int(np.argmin(score))]\n",
  "dynamic_percentile_target": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Dynamic Percentile Target: choose processing time near percentile driven by load imbalance.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    imbalance = float((ms.max() - ms.min()) / (ms.mean() + 1e-12))\n    # More imbalance -> target longer ops (higher percentile) to stabilize busy machines; else shorter ops\n    pct = 30.0 + 50.0 * min(1.0, imbalance)\n\n    proc = np.array([op[2] for op in feasible_operations], dtype=float)\n    target = float(np.percentile(proc, pct))\n    idx = int(np.argmin(np.abs(proc - target)))\n    return feasible_operations[idx]\n",
  "least_loaded_machine_then_lpt": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Least-Loaded Machine then LPT: pick among least-loaded machine ops, take the longest op.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    loads = [ms[op[1]] for op in feasible_operations]\n    min_load = min(loads)\n    candidates = [op for op, ld in zip(feasible_operations, loads) if ld == min_load]\n    return max(candidates, key=lambda op: op[2])\n",
  "most_loaded_machine_then_earliest_start": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Most-Loaded Machine then Earliest Start: focus on busiest machine, but pick op that starts soonest.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    loads = [ms[op[1]] for op in feasible_operations]\n    max_load = max(loads)\n    candidates = [op for op, ld in zip(feasible_operations, loads) if ld == max_load]\n\n    return min(candidates, key=lambda op: (max(ms[op[1]], js[op[0]]), op[2]))\n",
  "regret_min_completion_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Regret-Min Completion: minimize regret = (2nd best completion) - (best completion) on the same machine.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    by_m = {}\n    for op in feasible_operations:\n        m = op[1]\n        start = max(ms[m], js[op[0]])\n        comp = start + op[2]\n        by_m.setdefault(m, []).append((comp, op))\n\n    best_op, best_regret = None, -float('inf')\n    for m, lst in by_m.items():\n        lst.sort(key=lambda x: x[0])\n        if len(lst) == 1:\n            regret = float('inf')\n            chosen = lst[0][1]\n        else:\n            regret = float(lst[1][0] - lst[0][0])\n            chosen = lst[0][1]\n        # Maximize regret (protect scarce good choices)\n        if regret > best_regret:\n            best_regret = regret\n            best_op = chosen\n        elif abs(regret - best_regret) < 1e-12:\n            # tie-break: shorter completion\n            s1 = max(ms[best_op[1]], js[best_op[0]]) + best_op[2]\n            s2 = max(ms[chosen[1]], js[chosen[0]]) + chosen[2]\n            if s2 < s1:\n                best_op = chosen\n    return best_op\n",
  "epsilon_greedy_completion": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Epsilon-Greedy on Completion: mostly pick min completion, sometimes explore deterministically.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    comp = np.array([max(ms[op[1]], js[op[0]]) + op[2] for op in feasible_operations], dtype=float)\n    greedy_idx = int(np.argmin(comp))\n\n    # Exploration rate increases when schedule is very imbalanced\n    imbalance = float((ms.max() - ms.min()) / (ms.mean() + 1e-12))\n    eps = min(0.35, 0.05 + 0.30 * min(1.0, imbalance))\n\n    seed = int(np.sum(ms) + 7 * np.sum(js)) % (2**31)\n    rng = np.random.default_rng(seed)\n    if float(rng.random()) < eps:\n        # Explore among top-k by completion time\n        k = min(3, len(feasible_operations))\n        topk = np.argsort(comp)[:k]\n        return feasible_operations[int(topk[int(rng.integers(0, k))])]\n    return feasible_operations[greedy_idx]\n",
  "softmax_makespan_delta": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Softmax on Makespan Delta: sample ops with probability favoring smaller estimated makespan increase.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js0 = np.array(current_status['job_status'], dtype=float)\n\n    cur_ms = float(max(ms0.max(), js0.max()))\n    deltas = []\n    for op in feasible_operations:\n        ms = ms0.copy(); js = js0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        finish = start + float(op[2])\n        ms[op[1]] = finish\n        js[op[0]] = finish\n        new_ms = float(max(ms.max(), js.max()))\n        deltas.append(new_ms - cur_ms)\n\n    deltas = np.array(deltas, dtype=float)\n    # Lower delta -> higher probability\n    scale = np.std(deltas) + 1e-9\n    logits = -deltas / scale\n    logits = logits - np.max(logits)\n    probs = np.exp(logits)\n    probs = probs / (np.sum(probs) + 1e-12)\n\n    seed = int(np.sum(ms0) + 13 * np.sum(js0)) % (2**31)\n    rng = np.random.default_rng(seed)\n    idx = int(rng.choice(len(feasible_operations), p=probs))\n    return feasible_operations[idx]\n",
  "avoid_last_machine_if_possible": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Avoid Last Machine: diversify machine usage using current_status['last_machine'] if present.\"\"\"\n    if not feasible_operations:\n        return None\n    last_m = current_status.get('last_machine', None)\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    if last_m is None:\n        # fallback: earliest completion\n        return min(feasible_operations, key=lambda op: max(ms[op[1]], js[op[0]]) + op[2])\n\n    non_last = [op for op in feasible_operations if op[1] != last_m]\n    candidates = non_last if non_last else feasible_operations\n\n    return min(candidates, key=lambda op: (max(ms[op[1]], js[op[0]]) + op[2], op[2]))\n",
  "avoid_last_job_if_possible": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Avoid Last Job: diversify job selection using current_status['last_job'] if present.\"\"\"\n    if not feasible_operations:\n        return None\n    last_j = current_status.get('last_job', None)\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    if last_j is None:\n        return min(feasible_operations, key=lambda op: max(ms[op[1]], js[op[0]]) + op[2])\n\n    non_last = [op for op in feasible_operations if op[0] != last_j]\n    candidates = non_last if non_last else feasible_operations\n\n    return min(candidates, key=lambda op: (max(ms[op[1]], js[op[0]]), op[2]))\n",
  "wait_then_process_tradeoff": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Wait-Then-Process Tradeoff: minimize (expected waiting) + alpha*(processing), alpha adapts to avg waiting.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    waits = np.array([abs(ms[op[1]] - js[op[0]]) for op in feasible_operations], dtype=float)\n    proc = np.array([op[2] for op in feasible_operations], dtype=float)\n\n    alpha = float(np.mean(waits) / (np.mean(proc) + 1e-12))\n    score = waits + alpha * proc\n    return feasible_operations[int(np.argmin(score))]\n",
  "min_idle_then_min_gini": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Lexicographic: minimize immediate machine idle-time, then minimize Gini of machine loads after op.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    def gini(x):\n        x = np.asarray(x, dtype=float)\n        if np.allclose(x, 0.0):\n            return 0.0\n        xs = np.sort(x)\n        n = xs.size\n        cum = np.cumsum(xs)\n        return float((n + 1 - 2 * np.sum(cum) / (cum[-1] + 1e-12)) / n)\n\n    best_op = None\n    best_key = None\n    for op in feasible_operations:\n        idle = max(0.0, js[op[0]] - ms0[op[1]])\n        ms = ms0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        ms[op[1]] = start + float(op[2])\n        key = (idle, gini(ms), op[2])\n        if best_key is None or key < best_key:\n            best_key = key\n            best_op = op\n    return best_op\n",
  "criticality_ratio_focus": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Criticality Ratio Focus: prioritize ops on machines that are far above median load, scaled by start-time.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    med = float(np.median(ms))\n    def score(op):\n        m = op[1]\n        start = max(ms[m], js[op[0]])\n        critical = max(0.0, ms[m] - med)\n        return (-critical / (start + 1.0), start, op[2])\n\n    return min(feasible_operations, key=score)\n",
  "harmonic_blend_score": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Harmonic Blend: maximize harmonic mean of (1/proc), (1/start), (1/machine_load).\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    best_op, best_val = None, -float('inf')\n    for op in feasible_operations:\n        start = max(ms[op[1]], js[op[0]])\n        proc = float(op[2])\n        load = float(ms[op[1]])\n        a = 1.0 / (proc + 1e-12)\n        b = 1.0 / (start + 1.0)\n        c = 1.0 / (load + 1.0)\n        hm = 3.0 / (1.0/(a+1e-12) + 1.0/(b+1e-12) + 1.0/(c+1e-12))\n        if hm > best_val + 1e-12:\n            best_val, best_op = hm, op\n        elif abs(hm - best_val) < 1e-12:\n            # tie-break: earlier completion\n            if start + proc < max(ms[best_op[1]], js[best_op[0]]) + best_op[2]:\n                best_op = op\n    return best_op\n",
  "two_stage_filter_then_score": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Two-Stage: filter to ops with start-time within (min_start + q), then pick best by completion-time dispersion.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    starts = np.array([max(ms0[op[1]], js[op[0]]) for op in feasible_operations], dtype=float)\n    min_s = float(starts.min())\n    q = float(np.percentile(starts, 25) - min_s)\n    threshold = min_s + max(0.0, q)\n\n    filtered = [op for op, s in zip(feasible_operations, starts) if s <= threshold + 1e-12]\n    candidates = filtered if filtered else feasible_operations\n\n    best_op, best_val = None, float('inf')\n    for op in candidates:\n        ms = ms0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        ms[op[1]] = start + float(op[2])\n        # dispersion proxy: mean absolute deviation\n        mad = float(np.mean(np.abs(ms - np.mean(ms))))\n        key = (mad, start + float(op[2]), op[2])\n        if best_op is None or key < best_val:\n            best_val = key\n            best_op = op\n    return best_op\n",
  "earliest_completion_shortest_processing": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Earliest Completion then SPT: minimize completion time; ties to shorter ops.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    return min(feasible_operations, key=lambda op: (max(ms[op[1]], js[op[0]]) + op[2], op[2], max(ms[op[1]], js[op[0]])))\n",
  "earliest_completion_longest_processing": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Earliest Completion then LPT: minimize completion time; ties to longer ops to reduce fragmentation.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    return min(feasible_operations, key=lambda op: (max(ms[op[1]], js[op[0]]) + op[2], -op[2], max(ms[op[1]], js[op[0]])))\n",
  "min_slack_to_mean_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Slack to Mean: slack = start - mean(machine_status). Smaller slack favored.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    mu = float(np.mean(ms))\n    def key(op):\n        start = max(ms[op[1]], js[op[0]])\n        slack = start - mu\n        return (slack, op[2], start)\n    return min(feasible_operations, key=key)\n",
  "max_slack_to_mean_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Max Slack to Mean: slack = start - mean(machine_status). Larger slack favored (defer-ready ops).\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    mu = float(np.mean(ms))\n    def key(op):\n        start = max(ms[op[1]], js[op[0]])\n        slack = start - mu\n        return (-slack, op[2], start)\n    return min(feasible_operations, key=key)\n",
  "zscore_machine_priority": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Z-score Machine Priority: prioritize operations on machines with highest standardized load.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    mu = float(np.mean(ms))\n    sd = float(np.std(ms) + 1e-12)\n    def key(op):\n        m = op[1]\n        z = (ms[m] - mu) / sd\n        start = max(ms[m], js[op[0]])\n        return (-z, start, op[2])\n    return min(feasible_operations, key=key)\n",
  "zscore_job_priority": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Z-score Job Priority: prioritize operations from jobs with highest standardized completion time.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    mu = float(np.mean(js))\n    sd = float(np.std(js) + 1e-12)\n    def key(op):\n        j = op[0]\n        z = (js[j] - mu) / sd\n        start = max(ms[op[1]], js[j])\n        return (-z, start, op[2])\n    return min(feasible_operations, key=key)\n",
  "min_pairwise_makespan_gap": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Pairwise Makespan Gap: pick op that minimizes gap between max(machine_status) and max(job_status) after.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js0 = np.array(current_status['job_status'], dtype=float)\n    best_op, best_val = None, float('inf')\n    for op in feasible_operations:\n        ms = ms0.copy(); js = js0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        fin = start + float(op[2])\n        ms[op[1]] = fin\n        js[op[0]] = fin\n        val = abs(float(ms.max()) - float(js.max()))\n        key = (val, fin, op[2])\n        if best_op is None or key < best_val:\n            best_val = key\n            best_op = op\n    return best_op\n",
  "min_mean_absolute_deviation_machines": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min MAD (machines): choose op that minimizes mean absolute deviation of machine completion times.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        ms = ms0.copy()\n        start = max(ms[op[1]], float(js[op[0]]))\n        ms[op[1]] = start + float(op[2])\n        mu = float(np.mean(ms))\n        mad = float(np.mean(np.abs(ms - mu)))\n        key = (mad, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key = key\n            best_op = op\n    return best_op\n",
  "min_mean_absolute_deviation_jobs": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min MAD (jobs): choose op that minimizes mean absolute deviation of job completion times.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js0 = np.array(current_status['job_status'], dtype=float)\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        js = js0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        js[op[0]] = start + float(op[2])\n        mu = float(np.mean(js))\n        mad = float(np.mean(np.abs(js - mu)))\n        key = (mad, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key = key\n            best_op = op\n    return best_op\n",
  "entropy_balanced_machines": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Entropy-Balanced Machines: pick op that maximizes entropy of normalized machine completion times after.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    def entropy(x):\n        x = np.asarray(x, dtype=float)\n        s = float(np.sum(x))\n        if s <= 1e-12:\n            return 0.0\n        p = x / s\n        p = np.clip(p, 1e-12, 1.0)\n        return float(-np.sum(p * np.log(p)))\n\n    best_op, best_val = None, -float('inf')\n    for op in feasible_operations:\n        ms = ms0.copy()\n        start = max(ms[op[1]], float(js[op[0]]))\n        ms[op[1]] = start + float(op[2])\n        val = entropy(ms)\n        key = (val, -(start + float(op[2])))\n        if best_op is None or key > (best_val, float('-inf')):\n            best_val = val\n            best_op = op\n    return best_op\n",
  "entropy_balanced_jobs": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Entropy-Balanced Jobs: pick op that maximizes entropy of normalized job completion times after.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js0 = np.array(current_status['job_status'], dtype=float)\n\n    def entropy(x):\n        x = np.asarray(x, dtype=float)\n        s = float(np.sum(x))\n        if s <= 1e-12:\n            return 0.0\n        p = x / s\n        p = np.clip(p, 1e-12, 1.0)\n        return float(-np.sum(p * np.log(p)))\n\n    best_op, best_val = None, -float('inf')\n    for op in feasible_operations:\n        js = js0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        js[op[0]] = start + float(op[2])\n        val = entropy(js)\n        if val > best_val + 1e-12:\n            best_val = val\n            best_op = op\n        elif abs(val - best_val) < 1e-12:\n            # tie-break: earlier completion\n            if start + op[2] < max(ms[best_op[1]], js0[best_op[0]]) + best_op[2]:\n                best_op = op\n    return best_op\n",
  "median_machine_pull": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Median Machine Pull: prefer machines closest to median load; then earliest start.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    med = float(np.median(ms))\n    def key(op):\n        m = op[1]\n        dist = abs(ms[m] - med)\n        start = max(ms[m], js[op[0]])\n        return (dist, start, op[2])\n    return min(feasible_operations, key=key)\n",
  "quantile_machine_pull_25": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"25th-Percentile Machine Pull: prefer machines closest to lower quartile load (accelerate lagging machines).\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    q = float(np.percentile(ms, 25))\n    def key(op):\n        m = op[1]\n        dist = abs(ms[m] - q)\n        start = max(ms[m], js[op[0]])\n        return (dist, start, -op[2])\n    return min(feasible_operations, key=key)\n",
  "quantile_machine_pull_75": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"75th-Percentile Machine Pull: prefer machines closest to upper quartile load (work on heavy machines).\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    q = float(np.percentile(ms, 75))\n    def key(op):\n        m = op[1]\n        dist = abs(ms[m] - q)\n        start = max(ms[m], js[op[0]])\n        return (dist, start, op[2])\n    return min(feasible_operations, key=key)\n",
  "min_idle_ratio": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Idle Ratio: minimize idle/(proc+1) to prefer ops that reduce idleness efficiently.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    def key(op):\n        idle = max(0.0, js[op[0]] - ms[op[1]])\n        ratio = idle / (float(op[2]) + 1.0)\n        start = max(ms[op[1]], js[op[0]])\n        return (ratio, start, op[2])\n    return min(feasible_operations, key=key)\n",
  "max_idle_ratio": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Max Idle Ratio: maximize idle/(proc+1) to aggressively fill large idle gaps with short work.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    def key(op):\n        idle = max(0.0, js[op[0]] - ms[op[1]])\n        ratio = idle / (float(op[2]) + 1.0)\n        start = max(ms[op[1]], js[op[0]])\n        return (-ratio, op[2], start)\n    return min(feasible_operations, key=key)\n",
  "local_best_in_machine_competition": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Local Best per Machine: for each machine take its best (min completion), then choose among them by max regret.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    by_m = {}\n    for op in feasible_operations:\n        m = op[1]\n        start = max(ms[m], js[op[0]])\n        comp = start + op[2]\n        by_m.setdefault(m, []).append((comp, op))\n\n    reps = []\n    for m, lst in by_m.items():\n        lst.sort(key=lambda x: x[0])\n        best_comp, best_op = lst[0]\n        second = lst[1][0] if len(lst) > 1 else best_comp + 1e9\n        regret = float(second - best_comp)\n        reps.append((regret, best_comp, best_op))\n\n    # pick machine whose best option is most \"fragile\" (largest regret)\n    reps.sort(key=lambda t: (-t[0], t[1]))\n    return reps[0][2]\n",
  "completion_time_gap_to_best": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Completion Gap to Best: pick op with largest (comp - best_comp), to postpone near-optimal ops.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    comps = [max(ms[op[1]], js[op[0]]) + op[2] for op in feasible_operations]\n    best = min(comps)\n    gaps = [c - best for c in comps]\n    mx = max(gaps)\n    candidates = [op for op, g in zip(feasible_operations, gaps) if abs(g - mx) < 1e-12]\n    # tie-break: earliest start among the worst-gap set\n    return min(candidates, key=lambda op: max(ms[op[1]], js[op[0]]))\n",
  "min_completion_time_gap_to_best": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Completion Gap to Best: pick op closest to best completion (near-greedy, but different tie-breaks).\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    comps = [max(ms[op[1]], js[op[0]]) + op[2] for op in feasible_operations]\n    best = min(comps)\n    gaps = [c - best for c in comps]\n    mn = min(gaps)\n    candidates = [op for op, g in zip(feasible_operations, gaps) if abs(g - mn) < 1e-12]\n    # tie-break: prefer ops on less-loaded machines\n    return min(candidates, key=lambda op: (ms[op[1]], op[2]))\n",
  "min_squared_load_after_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Sum of Squares (machines): choose op that minimizes sum(ms^2) after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = current_status['job_status']\n    best_op, best_val = None, float('inf')\n    for op in feasible_operations:\n        ms = ms0.copy()\n        start = max(ms[op[1]], float(js[op[0]]))\n        ms[op[1]] = start + float(op[2])\n        val = float(np.sum(ms * ms))\n        key = (val, start + float(op[2]), op[2])\n        if best_op is None or key < best_val:\n            best_val = key\n            best_op = op\n    return best_op\n",
  "min_squared_load_after_job": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Sum of Squares (jobs): choose op that minimizes sum(js^2) after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js0 = np.array(current_status['job_status'], dtype=float)\n    best_op, best_val = None, float('inf')\n    for op in feasible_operations:\n        js = js0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        js[op[0]] = start + float(op[2])\n        val = float(np.sum(js * js))\n        key = (val, start + float(op[2]), op[2])\n        if best_op is None or key < best_val:\n            best_val = key\n            best_op = op\n    return best_op\n",
  "inverse_temperature_rank_blend": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Inverse-Temperature Rank Blend: blend rank(proc) and rank(start) with temperature from imbalance.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    starts = np.array([max(ms[op[1]], js[op[0]]) for op in feasible_operations], dtype=float)\n    procs = np.array([op[2] for op in feasible_operations], dtype=float)\n\n    # ranks: 0 best\n    r_start = np.argsort(np.argsort(starts))\n    r_proc = np.argsort(np.argsort(procs))\n\n    imb = float((ms.max() - ms.min()) / (ms.mean() + 1e-12))\n    temp = 1.0 / (1.0 + 3.0 * min(1.0, imb))\n\n    score = temp * r_proc + (1.0 - temp) * r_start\n    return feasible_operations[int(np.argmin(score))]\n",
  "deterministic_hash_round_robin_jobs": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Deterministic Hash RR (jobs): choose among jobs in a rotating hash order based on current time state.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=int)\n    js = np.array(current_status['job_status'], dtype=int)\n    seed = int(np.sum(ms) + 31 * np.sum(js)) & 0x7fffffff\n\n    # group by job\n    by_j = {}\n    for op in feasible_operations:\n        by_j.setdefault(op[0], []).append(op)\n\n    jobs = sorted(by_j.keys())\n    if not jobs:\n        return feasible_operations[0]\n\n    start_idx = seed % len(jobs)\n    ms_f = current_status['machine_status']\n    js_f = current_status['job_status']\n\n    for k in range(len(jobs)):\n        j = jobs[(start_idx + k) % len(jobs)]\n        # pick job's best op by earliest completion\n        ops = by_j[j]\n        best = min(ops, key=lambda op: max(ms_f[op[1]], js_f[op[0]]) + op[2])\n        return best\n    return feasible_operations[0]\n",
  "deterministic_hash_round_robin_machines": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Deterministic Hash RR (machines): choose among machines in rotating hash order based on current time state.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=int)\n    js = np.array(current_status['job_status'], dtype=int)\n    seed = int(17 * np.sum(ms) + 7 * np.sum(js)) & 0x7fffffff\n\n    by_m = {}\n    for op in feasible_operations:\n        by_m.setdefault(op[1], []).append(op)\n\n    machines = sorted(by_m.keys())\n    if not machines:\n        return feasible_operations[0]\n\n    start_idx = seed % len(machines)\n    ms_f = current_status['machine_status']\n    js_f = current_status['job_status']\n\n    for k in range(len(machines)):\n        m = machines[(start_idx + k) % len(machines)]\n        ops = by_m[m]\n        # best by earliest start, then longest processing\n        best = min(ops, key=lambda op: (max(ms_f[op[1]], js_f[op[0]]), -op[2]))\n        return best\n    return feasible_operations[0]\n",
  "anti_starvation_oldest_job": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Anti-Starvation: prioritize the job with the smallest job_status (oldest/least progressed), then earliest start.\"\"\"\n    if not feasible_operations:\n        return None\n    js = current_status['job_status']\n    ms = current_status['machine_status']\n\n    min_jtime = min(js[op[0]] for op in feasible_operations)\n    candidates = [op for op in feasible_operations if js[op[0]] == min_jtime]\n    return min(candidates, key=lambda op: (max(ms[op[1]], js[op[0]]), op[2]))\n",
  "anti_starvation_oldest_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Anti-Starvation (machines): prioritize least advanced machine (smallest machine_status), then earliest completion.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    min_mtime = min(ms[op[1]] for op in feasible_operations)\n    candidates = [op for op in feasible_operations if ms[op[1]] == min_mtime]\n    return min(candidates, key=lambda op: (max(ms[op[1]], js[op[0]]) + op[2], op[2]))\n",
  "min_changeover_proxy": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Changeover Proxy: prefer repeating same machine if last_machine exists (opportunistic batching).\"\"\"\n    if not feasible_operations:\n        return None\n    last_m = current_status.get('last_machine', None)\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    def key(op):\n        penalty = 0 if (last_m is not None and op[1] == last_m) else 1\n        start = max(ms[op[1]], js[op[0]])\n        comp = start + op[2]\n        return (penalty, comp, op[2])\n    return min(feasible_operations, key=key)\n",
  "max_ready_queue_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Max Ready-Queue Machine: prioritize machines with the most feasible ops (high contention), then SPT.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    counts = {}\n    for op in feasible_operations:\n        counts[op[1]] = counts.get(op[1], 0) + 1\n\n    max_c = max(counts.values())\n    candidates = [op for op in feasible_operations if counts[op[1]] == max_c]\n    return min(candidates, key=lambda op: (max(ms[op[1]], js[op[0]]) + op[2], op[2]))\n",
  "max_ready_queue_job": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Max Ready-Queue Job: prioritize jobs with the most feasible ops (if representation differs), then earliest start.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    counts = {}\n    for op in feasible_operations:\n        counts[op[0]] = counts.get(op[0], 0) + 1\n\n    max_c = max(counts.values())\n    candidates = [op for op in feasible_operations if counts[op[0]] == max_c]\n    return min(candidates, key=lambda op: (max(ms[op[1]], js[op[0]]), op[2]))\n",
  "min_start_time_spread_after": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Start-Time Spread After: pick op that minimizes (max(ms)-min(ms)) after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        ms = ms0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        ms[op[1]] = start + float(op[2])\n        spread = float(ms.max() - ms.min())\n        key = (spread, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key, best_op = key, op\n    return best_op\n",
  "min_cv_machines_after": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min CV Machines After: choose op minimizing coefficient of variation of machine completion times.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        ms = ms0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        ms[op[1]] = start + float(op[2])\n        mu = float(np.mean(ms))\n        sd = float(np.std(ms))\n        cv = sd / (mu + 1e-12)\n        key = (cv, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key, best_op = key, op\n    return best_op\n",
  "min_cv_jobs_after": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min CV Jobs After: choose op minimizing coefficient of variation of job completion times.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js0 = np.array(current_status['job_status'], dtype=float)\n\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        js = js0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        js[op[0]] = start + float(op[2])\n        mu = float(np.mean(js))\n        sd = float(np.std(js))\n        cv = sd / (mu + 1e-12)\n        key = (cv, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key, best_op = key, op\n    return best_op\n",
  "max_machine_release_rate": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Max Machine Release Rate: maximize proc/(machine_idle+1) to keep machines productive.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    best_op, best_val = None, -float('inf')\n    for op in feasible_operations:\n        idle = max(0.0, js[op[0]] - ms[op[1]])\n        val = float(op[2]) / (idle + 1.0)\n        if val > best_val + 1e-12:\n            best_val, best_op = val, op\n        elif abs(val - best_val) < 1e-12:\n            start = max(ms[op[1]], js[op[0]])\n            bstart = max(ms[best_op[1]], js[best_op[0]])\n            if start < bstart:\n                best_op = op\n    return best_op\n",
  "min_machine_release_rate": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Machine Release Rate: minimize proc/(idle+1) (prefer short ops when idle is low).\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    def key(op):\n        idle = max(0.0, js[op[0]] - ms[op[1]])\n        r = float(op[2]) / (idle + 1.0)\n        start = max(ms[op[1]], js[op[0]])\n        return (r, start, op[2])\n    return min(feasible_operations, key=key)\n",
  "lookahead_two_step_makespan_proxy": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Two-step Lookahead (proxy): simulate op, then assume next picks earliest completion; minimize resulting makespan.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js0 = np.array(current_status['job_status'], dtype=float)\n\n    def greedy_next(ms, js, ops):\n        if not ops:\n            return None\n        comps = [max(ms[op[1]], js[op[0]]) + op[2] for op in ops]\n        return ops[int(np.argmin(comps))]\n\n    best_op, best_val = None, float('inf')\n    for op in feasible_operations:\n        ms = ms0.copy(); js = js0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        fin = start + float(op[2])\n        ms[op[1]] = fin\n        js[op[0]] = fin\n\n        # crude next-step set: all ops except the chosen one\n        remaining = [x for x in feasible_operations if x is not op]\n        nxt = greedy_next(ms, js, remaining)\n        if nxt is not None:\n            s2 = max(ms[nxt[1]], js[nxt[0]])\n            f2 = s2 + float(nxt[2])\n            ms2 = ms.copy(); js2 = js.copy()\n            ms2[nxt[1]] = f2\n            js2[nxt[0]] = f2\n            val = float(max(ms2.max(), js2.max()))\n        else:\n            val = float(max(ms.max(), js.max()))\n\n        key = (val, fin, op[2])\n        if key < (best_val, float('inf'), float('inf')):\n            best_val, best_op = val, op\n    return best_op\n",
  "min_kurtosis_machines_after": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Kurtosis (machines): reduce heavy tails in machine completion times after scheduling (proxy).\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    def kurtosis(x):\n        x = np.asarray(x, dtype=float)\n        mu = float(np.mean(x))\n        sd = float(np.std(x) + 1e-12)\n        z = (x - mu) / sd\n        return float(np.mean(z**4))\n\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        ms = ms0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        ms[op[1]] = start + float(op[2])\n        k = kurtosis(ms)\n        key = (k, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key, best_op = key, op\n    return best_op\n",
  "min_kurtosis_jobs_after": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Kurtosis (jobs): reduce heavy tails in job completion times after scheduling (proxy).\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js0 = np.array(current_status['job_status'], dtype=float)\n\n    def kurtosis(x):\n        x = np.asarray(x, dtype=float)\n        mu = float(np.mean(x))\n        sd = float(np.std(x) + 1e-12)\n        z = (x - mu) / sd\n        return float(np.mean(z**4))\n\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        js = js0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        js[op[0]] = start + float(op[2])\n        k = kurtosis(js)\n        key = (k, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key, best_op = key, op\n    return best_op\n",
  "min_l1_to_uniform_machines": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min L1 to Uniform (machines): minimize sum |ms - mean(ms)| after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        ms = ms0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        ms[op[1]] = start + float(op[2])\n        mu = float(np.mean(ms))\n        l1 = float(np.sum(np.abs(ms - mu)))\n        key = (l1, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key, best_op = key, op\n    return best_op\n",
  "min_l1_to_uniform_jobs": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min L1 to Uniform (jobs): minimize sum |js - mean(js)| after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js0 = np.array(current_status['job_status'], dtype=float)\n\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        js = js0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        js[op[0]] = start + float(op[2])\n        mu = float(np.mean(js))\n        l1 = float(np.sum(np.abs(js - mu)))\n        key = (l1, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key, best_op = key, op\n    return best_op\n",
  "min_l2_to_uniform_machines": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min L2 to Uniform (machines): minimize sum (ms-mean)^2 after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms0 = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        ms = ms0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        ms[op[1]] = start + float(op[2])\n        mu = float(np.mean(ms))\n        l2 = float(np.sum((ms - mu) ** 2))\n        key = (l2, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key, best_op = key, op\n    return best_op\n",
  "min_l2_to_uniform_jobs": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min L2 to Uniform (jobs): minimize sum (js-mean)^2 after scheduling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js0 = np.array(current_status['job_status'], dtype=float)\n\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        js = js0.copy()\n        start = max(ms[op[1]], js[op[0]])\n        js[op[0]] = start + float(op[2])\n        mu = float(np.mean(js))\n        l2 = float(np.sum((js - mu) ** 2))\n        key = (l2, start + float(op[2]), op[2])\n        if best_key is None or key < best_key:\n            best_key, best_op = key, op\n    return best_op\n",
  "max_parallelism_proxy": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Max Parallelism Proxy: prefer op with smallest max(machine_time, job_time) (keeps both dimensions low).\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    return min(feasible_operations, key=lambda op: (max(ms[op[1]], js[op[0]]), ms[op[1]] + js[op[0]], op[2]))\n",
  "min_parallelism_proxy": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Parallelism Proxy: prefer op with largest max(machine_time, job_time) (pushes long-delayed resources).\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    return min(feasible_operations, key=lambda op: (-max(ms[op[1]], js[op[0]]), op[2], ms[op[1]]))\n",
  "balanced_start_and_completion": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Balanced Start & Completion: minimize (start_norm + completion_norm) with min-max scaling.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n\n    starts = np.array([max(ms[op[1]], js[op[0]]) for op in feasible_operations], dtype=float)\n    comps = np.array([starts[i] + feasible_operations[i][2] for i in range(len(feasible_operations))], dtype=float)\n\n    def mm(x):\n        mn, mx = float(np.min(x)), float(np.max(x))\n        if mx - mn < 1e-12:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn)\n\n    sN = mm(starts)\n    cN = mm(comps)\n    score = sN + cN\n    return feasible_operations[int(np.argmin(score))]\n",
  "min_rank_of_sum_availability": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Rank of Sum Availability: rank by (machine_time + job_time), then tie by SPT.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    vals = np.array([ms[op[1]] + js[op[0]] for op in feasible_operations], dtype=float)\n    ranks = np.argsort(np.argsort(vals))\n    idx = int(np.argmin(ranks + 0.01 * np.array([op[2] for op in feasible_operations], dtype=float)))\n    return feasible_operations[idx]\n",
  "max_rank_of_sum_availability": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Max Rank of Sum Availability: pick highest (machine_time + job_time) rank, then earliest completion.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n\n    vals = np.array([ms[op[1]] + js[op[0]] for op in feasible_operations], dtype=float)\n    ranks = np.argsort(np.argsort(vals))\n    best_rank = int(np.max(ranks))\n    candidates = [op for op, r in zip(feasible_operations, ranks) if int(r) == best_rank]\n    return min(candidates, key=lambda op: max(ms[op[1]], js[op[0]]) + op[2])\n",
  "min_start_gap_machine_job": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Start Gap: minimize |machine_time - job_time| (promotes synchronized starts), then LPT.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    return min(feasible_operations, key=lambda op: (abs(ms[op[1]] - js[op[0]]), -op[2], max(ms[op[1]], js[op[0]])))\n",
  "max_start_gap_machine_job": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Max Start Gap: maximize |machine_time - job_time| (attack extreme mismatches), then SPT.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = current_status['machine_status']\n    js = current_status['job_status']\n    return min(feasible_operations, key=lambda op: (-abs(ms[op[1]] - js[op[0]]), op[2], max(ms[op[1]], js[op[0]])))\n",
  "min_estimated_blocking_risk": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min Blocking Risk: minimize (completion - min_machine_time) to reduce creating new bottlenecks.\"\"\"\n    if not feasible_operations:\n        return None\n    ms = np.array(current_status['machine_status'], dtype=float)\n    js = np.array(current_status['job_status'], dtype=float)\n    mmin = float(np.min(ms))\n\n    best_op, best_key = None, None\n    for op in feasible_operations:\n        start = max(ms[op[1]], js[op[0]])\n        comp = start + float(op[2])\n        risk = comp - mmin\n        key = (risk, comp, op[2])\n        if best_key is None or key < best_key:\n            best_key, best_op = key, op\n    return best_op\n"
}



