{
  "shortest_processing_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Shortest Processing Time (SPT): Select operation with minimum processing time.\"\"\"\n    if not feasible_operations:\n        return None\n    return min(feasible_operations, key=lambda x: x[2])\n",
  "longest_processing_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Longest Processing Time (LPT): Select operation with maximum processing time.\"\"\"\n    if not feasible_operations:\n        return None\n    return max(feasible_operations, key=lambda x: x[2])\n",
  "earliest_idle_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation for the machine that will be idle soonest.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    return min(feasible_operations, key=lambda x: machine_status[x[1]])\n",
  "latest_idle_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation for the busiest machine to keep it occupied.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    return max(feasible_operations, key=lambda x: machine_status[x[1]])\n",
  "earliest_available_job": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation from the job that becomes available earliest.\"\"\"\n    if not feasible_operations:\n        return None\n    job_status = current_status['job_status']\n    return min(feasible_operations, key=lambda x: job_status[x[0]])\n",
  "balanced_machine_load": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Balance machine workload: prefer operations on less-loaded machines.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    return min(feasible_operations, key=lambda x: (machine_status[x[1]], x[2]))\n",
  "weighted_spt_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Weighted combination: 60% processing time + 40% machine availability.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    mach_times = np.array([machine_status[op[1]] for op in feasible_operations], dtype=float)\n    \n    proc_norm = proc_times / (np.mean(proc_times) + 1e-9)\n    mach_norm = mach_times / (np.mean(mach_times) + 1e-9)\n    \n    scores = 0.6 * proc_norm + 0.4 * mach_norm\n    return feasible_operations[int(np.argmin(scores))]\n",
  "job_machine_balance": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Balance both job and machine availability times.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    scores = [machine_status[op[1]] + job_status[op[0]] + op[2] for op in feasible_operations]\n    return feasible_operations[int(np.argmin(scores))]\n",
  "minimal_start_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation that can start earliest.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    start_times = [max(machine_status[op[1]], job_status[op[0]]) for op in feasible_operations]\n    return feasible_operations[int(np.argmin(start_times))]\n",
  "minimal_completion_time": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation that will complete earliest.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    completion_times = [max(machine_status[op[1]], job_status[op[0]]) + op[2] for op in feasible_operations]\n    return feasible_operations[int(np.argmin(completion_times))]\n",
  "machine_utilization_max": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Maximize machine utilization: prefer longer operations on idle machines.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    # Negative processing time for machines with low status (more idle)\n    scores = [machine_status[op[1]] - 2.0 * op[2] for op in feasible_operations]\n    return feasible_operations[int(np.argmin(scores))]\n",
  "random_choice": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Random selection with deterministic seed based on current state.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    seed = int(sum(machine_status) + sum(job_status)) % (2**31)\n    rng = np.random.default_rng(seed)\n    idx = int(rng.integers(0, len(feasible_operations)))\n    return feasible_operations[idx]\n",
  "alternating_spt_lpt": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Alternate between SPT and LPT based on total scheduled operations.\"\"\"\n    if not feasible_operations:\n        return None\n    job_status = current_status['job_status']\n    \n    mode = int(sum(job_status)) % 2\n    if mode == 0:\n        return min(feasible_operations, key=lambda x: x[2])\n    else:\n        return max(feasible_operations, key=lambda x: x[2])\n",
  "processing_time_percentile": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Select operation with processing time near 40th percentile.\"\"\"\n    if not feasible_operations:\n        return None\n    \n    proc_times = np.array([op[2] for op in feasible_operations])\n    target = float(np.percentile(proc_times, 40))\n    \n    deviations = np.abs(proc_times - target)\n    return feasible_operations[int(np.argmin(deviations))]\n",
  "machine_variance_min": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Minimize variance in machine completion times.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    best_op = None\n    best_var = float('inf')\n    \n    for op in feasible_operations:\n        new_status = machine_status.copy()\n        new_status[op[1]] = max(machine_status[op[1]], job_status[op[0]]) + op[2]\n        var = float(np.var(new_status))\n        if var < best_var:\n            best_var = var\n            best_op = op\n    \n    return best_op\n",
  "slack_time_priority": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Prioritize operations with minimal slack time.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    slacks = [abs(machine_status[op[1]] - job_status[op[0]]) for op in feasible_operations]\n    return feasible_operations[int(np.argmin(slacks))]\n",
  "bottleneck_machine_avoid": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Avoid scheduling on bottleneck (busiest) machines when possible.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    # Find operations NOT on the busiest machine\n    max_status = max(machine_status)\n    non_bottleneck = [op for op in feasible_operations if machine_status[op[1]] < max_status]\n    \n    candidates = non_bottleneck if non_bottleneck else feasible_operations\n    return min(candidates, key=lambda x: x[2])\n",
  "job_id_priority": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Prioritize lower job IDs (FIFO-like behavior).\"\"\"\n    if not feasible_operations:\n        return None\n    return min(feasible_operations, key=lambda x: (x[0], x[2]))\n",
  "machine_id_priority": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Prioritize lower machine IDs for tie-breaking.\"\"\"\n    if not feasible_operations:\n        return None\n    return min(feasible_operations, key=lambda x: (x[1], x[2]))\n",
  "weighted_job_machine": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Weighted: 50% job availability + 50% machine availability.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    job_times = np.array([job_status[op[0]] for op in feasible_operations], dtype=float)\n    mach_times = np.array([machine_status[op[1]] for op in feasible_operations], dtype=float)\n    \n    job_norm = job_times / (np.mean(job_times) + 1e-9)\n    mach_norm = mach_times / (np.mean(mach_times) + 1e-9)\n    \n    scores = 0.5 * job_norm + 0.5 * mach_norm\n    return feasible_operations[int(np.argmin(scores))]\n",
  "adaptive_spt_lpt": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Start with LPT, transition to SPT as schedule progresses.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    progress = np.mean(machine_status) / (max(machine_status) + 1e-9)\n    \n    if progress < 0.4:\n        return max(feasible_operations, key=lambda x: x[2])\n    else:\n        return min(feasible_operations, key=lambda x: x[2])\n",
  "max_machine_min_processing": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Among operations on the busiest machine, pick shortest processing time.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    mach_times = [machine_status[op[1]] for op in feasible_operations]\n    max_time = max(mach_times)\n    \n    candidates = [op for op, mt in zip(feasible_operations, mach_times) if mt == max_time]\n    return min(candidates, key=lambda x: x[2])\n",
  "composite_three_factor": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Composite score: 40% processing + 30% machine + 30% job.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    mach_times = np.array([machine_status[op[1]] for op in feasible_operations], dtype=float)\n    job_times = np.array([job_status[op[0]] for op in feasible_operations], dtype=float)\n    \n    proc_norm = proc_times / (np.mean(proc_times) + 1e-9)\n    mach_norm = mach_times / (np.mean(mach_times) + 1e-9)\n    job_norm = job_times / (np.mean(job_times) + 1e-9)\n    \n    scores = 0.4 * proc_norm + 0.3 * mach_norm + 0.3 * job_norm\n    return feasible_operations[int(np.argmin(scores))]\n",
  "exponential_processing_weight": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Exponentially weight shorter processing times.\"\"\"\n    if not feasible_operations:\n        return None\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    weights = np.exp(-proc_times / (np.mean(proc_times) + 1e-9))\n    \n    machine_status = current_status['machine_status']\n    seed = int(sum(machine_status)) % (2**31)\n    rng = np.random.default_rng(seed)\n    \n    probs = weights / (np.sum(weights) + 1e-9)\n    idx = int(rng.choice(len(feasible_operations), p=probs))\n    return feasible_operations[idx]\n",
  "round_robin_jobs": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Round-robin through jobs, picking shortest operation per job.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    # Group by job_id\n    jobs = {}\n    for op in feasible_operations:\n        if op[0] not in jobs:\n            jobs[op[0]] = []\n        jobs[op[0]].append(op)\n    \n    # Pick job with lowest total machine time, then shortest operation\n    best_job = min(jobs.keys(), key=lambda j: sum([machine_status[o[1]] for o in jobs[j]]))\n    return min(jobs[best_job], key=lambda x: x[2])\n",
  "ratio_processing_availability": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Minimize ratio of processing time to machine availability.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    ratios = [op[2] / (machine_status[op[1]] + 1.0) for op in feasible_operations]\n    return feasible_operations[int(np.argmin(ratios))]\n",
  "stochastic_greedy": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Probabilistic selection favoring shorter processing times.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    \n    # Lower processing time = higher probability\n    inv_times = 1.0 / (proc_times + 1e-9)\n    probs = inv_times / (np.sum(inv_times) + 1e-9)\n    \n    seed = int(sum(machine_status) + sum(job_status)) % (2**31)\n    rng = np.random.default_rng(seed)\n    \n    idx = int(rng.choice(len(feasible_operations), p=probs))\n    return feasible_operations[idx]\n",
  "hybrid_makespan_estimator": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Estimate makespan impact and choose operation with minimal increase.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    best_op = None\n    best_makespan = float('inf')\n    \n    for op in feasible_operations:\n        new_mach_status = machine_status.copy()\n        new_job_status = job_status.copy()\n        \n        start = max(machine_status[op[1]], job_status[op[0]])\n        new_mach_status[op[1]] = start + op[2]\n        new_job_status[op[0]] = start + op[2]\n        \n        makespan = max(max(new_mach_status), max(new_job_status))\n        if makespan < best_makespan:\n            best_makespan = makespan\n            best_op = op\n    \n    return best_op\n",
  "normalized_multi_objective": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Min-max normalize all factors and combine with equal weights.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    mach_times = np.array([machine_status[op[1]] for op in feasible_operations], dtype=float)\n    job_times = np.array([job_status[op[0]] for op in feasible_operations], dtype=float)\n    \n    def minmax_norm(x):\n        mn, mx = x.min(), x.max()\n        if mx - mn < 1e-9:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn + 1e-9)\n    \n    proc_norm = minmax_norm(proc_times)\n    mach_norm = minmax_norm(mach_times)\n    job_norm = minmax_norm(job_times)\n    \n    scores = proc_norm + mach_norm + job_norm\n    return feasible_operations[int(np.argmin(scores))]\n",
  "idle_time_minimizer": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Minimize total idle time across all machines.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    job_status = current_status['job_status']\n    \n    idle_times = [max(0, job_status[op[0]] - machine_status[op[1]]) for op in feasible_operations]\n    return feasible_operations[int(np.argmin(idle_times))]\n",
  "priority_score_blend": "import numpy as np\n\ndef determine_next_operation(current_status, feasible_operations):\n    \"\"\"Blend: inverse processing time + inverse machine load.\"\"\"\n    if not feasible_operations:\n        return None\n    machine_status = current_status['machine_status']\n    \n    proc_times = np.array([op[2] for op in feasible_operations], dtype=float)\n    mach_loads = np.array([machine_status[op[1]] for op in feasible_operations], dtype=float)\n    \n    inv_proc = 1.0 / (proc_times + 1e-9)\n    inv_mach = 1.0 / (mach_loads + 1.0)\n    \n    scores = inv_proc + inv_mach\n    return feasible_operations[int(np.argmax(scores))]\n"
}
