{
  "density_ratio_classic": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Pick highest value/weight among items that fit (classic density greedy).\"\"\"\n    best_item = None\n    best_score = -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in remaining_items:\n      if w <= remaining_capacity and w > 0:\n        score = v / w\n        if score > best_score:\n          best_score, best_item = score, (w, v, idx)\n      elif w == 0 and v > 0:\n        return (w, v, idx)\n    return best_item\n",
  "highest_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Pick highest absolute value among items that fit.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "lightest_weight_tiebreak_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Prefer lightest item; break ties by density.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            dens = (v / w) if w > 0 else (np.inf if v > 0 else -np.inf)\n            score = -float(w) + 1e-6 * float(dens)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "heaviest_that_fits": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Pack-first heuristic: pick the heaviest item that still fits; break ties by value.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(w) + 1e-6 * float(v)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "closest_to_capacity_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Choose item that leaves the smallest leftover capacity (tight fill); break ties by density.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = C - float(w)\n            dens = (v / w) if w > 0 else (np.inf if v > 0 else -np.inf)\n            score = -leftover + 1e-6 * dens\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "capacity_scaled_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Density * (weight/capacity): biases toward filling capacity while keeping good density.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            score = (v / w) * (float(w) / C)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "log_weight_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Value / log(1+weight): dampens heavy-weight penalty compared to plain density.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            denom = np.log1p(max(0, w))\n            score = float(v) / (denom if denom > 0 else 1e-12)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "sqrt_weight_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Value / sqrt(weight): middle ground between value and density.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) / (np.sqrt(max(1e-12, float(w))))\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_over_weight_squared": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Value / weight^2: strongly favors light items (useful when many items fit).\"\"\"\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            ww = max(1e-12, float(w))\n            score = float(v) / (ww * ww)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "adaptive_value_vs_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Blend value and density; as capacity shrinks, emphasize tight/dense choices.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    weights = np.array([w for (w, _, _) in remaining_items], dtype=float)\n    wmax = float(np.max(weights)) if weights.size else 1.0\n    progress = 1.0 - (C / max(1.0, wmax))\n    alpha = float(np.clip(0.15 + 0.7 * progress, 0.15, 0.85))\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            score = alpha * dens + (1.0 - alpha) * float(v)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "median_value_filtered_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Prefer density, but require value >= median(value among fitting items) when possible.\"\"\"\n    fit_vals = [v for (w, v, _) in remaining_items if w <= remaining_capacity]\n    if not fit_vals:\n        return None\n    medv = float(np.median(np.array(fit_vals, dtype=float)))\n    best_item = None\n    best_score = -np.inf\n    found_strict = False\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            dens = float(v) / max(1e-12, float(w))\n            strict = float(v) >= medv\n            score = dens + (1e6 if strict else 0.0)\n            if (strict and not found_strict) or score > best_score:\n                best_score, best_item = score, (w, v, idx)\n                found_strict = found_strict or strict\n    return best_item\n",
  "deterministic_jitter_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Density with deterministic tiny jitter to break ties reproducibly.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            jitter = 1e-9 * np.sin((idx + 1.0) * (dens + 0.12345))\n            score = dens + jitter\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "regret_density_gap": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Regret heuristic: prefer items whose density is far above the runner-up (big gap).\"\"\"\n    candidates = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            candidates.append((float(v) / float(w), w, v, idx))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not candidates:\n        return None\n    densities = np.array([d for (d, _, _, _) in candidates], dtype=float)\n    best_item = None\n    best_score = -np.inf\n    for d, w, v, idx in candidates:\n        other = densities[densities != d]\n        second = float(np.max(other)) if other.size else -np.inf\n        score = d + 0.25 * (d - second)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "one_step_fractional_lookahead": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    cap = int(cap)\n    if cap <= 0 or not items:\n        return 0.0\n    arr = []\n    for w, v, _ in items:\n        if w <= 0:\n            if v > 0:\n                return float('inf')\n            continue\n        arr.append((float(v) / float(w), int(w), float(v)))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    val = 0.0\n    rem = cap\n    for d, w, v in arr:\n        if w <= rem:\n            val += v\n            rem -= w\n        else:\n            val += d * rem\n            break\n    return val\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Choose item maximizing value + fractional upper bound of leftover (1-step lookahead).\"\"\"\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            rest = [it for it in remaining_items if it[2] != idx]\n            bound = _fractional_upper_bound(leftover, rest)\n            score = float(v) + bound\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "two_candidate_fractional_lookahead_topk": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound_topk(cap: int, items: List[Tuple[int, int, int]], k: int = 25) -> float:\n    cap = int(cap)\n    if cap <= 0 or not items:\n        return 0.0\n    arr = []\n    for w, v, _ in items:\n        if w <= 0:\n            if v > 0:\n                return float('inf')\n            continue\n        arr.append((float(v) / float(w), int(w), float(v)))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    arr = arr[:max(1, int(k))]\n    val = 0.0\n    rem = cap\n    for d, w, v in arr:\n        if w <= rem:\n            val += v\n            rem -= w\n        else:\n            val += d * rem\n            break\n    return val\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Lookahead with fast fractional bound using only top-k densities.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            rest = [it for it in remaining_items if it[2] != idx]\n            bound = _fractional_upper_bound_topk(leftover, rest, k=25)\n            score = float(v) + bound\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "avoid_dead_end_min_weight_guard": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Prefer density but penalize choices that leave leftover < min remaining weight (likely dead-end).\"\"\"\n    weights_fit = [w for (w, _, _) in remaining_items if w > 0 and w <= remaining_capacity]\n    if not weights_fit:\n        return None\n    wmin = int(min(weights_fit))\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            dens = float(v) / max(1e-12, float(w))\n            leftover = remaining_capacity - w\n            penalty = 0.0\n            if leftover > 0 and leftover < wmin:\n                penalty = (wmin - leftover) / max(1.0, wmin)\n            score = dens - 0.5 * penalty\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "tight_then_high_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Lexicographic: minimize leftover first, then maximize value.\"\"\"\n    best_item = None\n    best_leftover = None\n    best_value = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            if best_leftover is None or leftover < best_leftover or (leftover == best_leftover and v > best_value):\n                best_leftover = leftover\n                best_value = v\n                best_item = (w, v, idx)\n    return best_item\n",
  "density_with_leftover_gaussian_target": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Density * exp(-((leftover - target)^2)/(2*sigma^2)): targets a preferred leftover fraction.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    target = 0.1 * C\n    sigma = 0.25 * C + 1e-12\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            leftover = C - float(w)\n            shape = np.exp(-((leftover - target) ** 2) / (2.0 * sigma * sigma))\n            score = dens * shape\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "zscore_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Pick item with highest z-scored density among fitting items (robust to scale).\"\"\"\n    dens_list = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens_list.append(float(v) / float(w))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not dens_list:\n        return None\n    dens_arr = np.array(dens_list, dtype=float)\n    mu = float(np.mean(dens_arr))\n    sd = float(np.std(dens_arr)) + 1e-12\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            d = float(v) / float(w)\n            score = (d - mu) / sd\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "rank_density_cdf": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Use empirical CDF rank of density (highest density -> highest score).\"\"\"\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            cand.append((float(v) / float(w), w, v, idx))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not cand:\n        return None\n    ds = np.array([d for d, _, _, _ in cand], dtype=float)\n    order = np.argsort(ds)\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.arange(order.size, dtype=float)\n    best_i = int(np.argmax(ranks))\n    d, w, v, idx = cand[best_i]\n    return (w, v, idx)\n",
  "lagrangian_surrogate_lambda_from_fractional": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _estimate_lambda(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    \"\"\"Estimate a Lagrangian multiplier from the fractional greedy breakpoint density.\"\"\"\n    arr = []\n    for w, v, idx in items:\n        if w > 0:\n            arr.append((float(v) / float(w), int(w)))\n    if not arr:\n        return 0.0\n    arr.sort(key=lambda x: x[0], reverse=True)\n    rem = int(cap)\n    lam = arr[-1][0]\n    for d, w in arr:\n        if w <= rem:\n            rem -= w\n            lam = d\n        else:\n            lam = d\n            break\n    return float(lam)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Score = value - lambda*weight (lambda estimated from fractional relaxation).\"\"\"\n    lam = _estimate_lambda(remaining_capacity, remaining_items)\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) - lam * float(w)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "lagrangian_value_minus_mu_weight_mu_mean_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Score = v - mu*w, where mu is mean density of fitting items (simple surrogate).\"\"\"\n    dens = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens.append(float(v) / float(w))\n    mu = float(np.mean(dens)) if dens else 0.0\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) - mu * float(w)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "defensive_greedy_max_of_all": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Max-of-all style: score = max(density_norm, value_norm, weight_fill_norm).\"\"\"\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    vals = np.array([v for (w, v, _) in fit], dtype=float)\n    wts = np.array([w for (w, _, _) in fit], dtype=float)\n    dens = np.array([(v / w) if w > 0 else (np.inf if v > 0 else -np.inf) for (w, v, _) in fit], dtype=float)\n    def norm(x):\n        lo, hi = float(np.nanmin(x)), float(np.nanmax(x))\n        return (x - lo) / (hi - lo + 1e-12)\n    vN = norm(vals)\n    dN = norm(np.nan_to_num(dens, nan=-1e18, posinf=1e18, neginf=-1e18))\n    fN = norm(wts / max(1.0, float(remaining_capacity)))\n    scores = np.maximum.reduce([vN, dN, fN])\n    j = int(np.nanargmax(scores))\n    return fit[j]\n",
  "max_of_two_density_or_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Score = max(density_norm, value_norm): a simple robust combo.\"\"\"\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    vals = np.array([v for (w, v, _) in fit], dtype=float)\n    dens = np.array([(v / w) if w > 0 else (np.inf if v > 0 else -np.inf) for (w, v, _) in fit], dtype=float)\n    def norm(x):\n        lo, hi = float(np.nanmin(x)), float(np.nanmax(x))\n        return (x - lo) / (hi - lo + 1e-12)\n    vN = norm(vals)\n    dN = norm(np.nan_to_num(dens, nan=-1e18, posinf=1e18, neginf=-1e18))\n    scores = np.maximum(vN, dN)\n    j = int(np.nanargmax(scores))\n    return fit[j]\n",
  "heavy_if_high_value_quantile": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"If item value is top-quartile, allow heavier bias; otherwise prefer density.\"\"\"\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    vals = np.array([v for (_, v, _) in fit], dtype=float)\n    q75 = float(np.quantile(vals, 0.75))\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    for w, v, idx in fit:\n        if float(v) >= q75:\n            score = float(v) + 0.25 * (float(w) / C) * float(v)\n        else:\n            score = float(v) / max(1e-12, float(w))\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "small_item_packability_bias": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Density * (1 / (1 + weight/median_weight)): nudges toward more packable items.\"\"\"\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    wmed = float(np.median(np.array([w for (w, _, _) in fit], dtype=float))) + 1e-12\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in fit:\n        dens = float(v) / max(1e-12, float(w))\n        pack = 1.0 / (1.0 + float(w) / wmed)\n        score = dens * pack\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "expected_fill_probability": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Prefer choices leaving leftover near mean remaining weight (heuristic for future fit likelihood).\"\"\"\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    all_w = np.array([w for (w, _, _) in remaining_items if w > 0], dtype=float)\n    mu = float(np.mean(all_w)) if all_w.size else 0.0\n    sd = float(np.std(all_w)) + 1e-12\n    best_item = None\n    best_score = -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in fit:\n        leftover = C - float(w)\n        closeness = np.exp(-((leftover - mu) ** 2) / (2.0 * sd * sd))\n        dens = float(v) / max(1e-12, float(w))\n        score = dens * (0.5 + 0.5 * closeness)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "maximize_value_then_density_tie": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Lexicographic: maximize value; break ties by density.\"\"\"\n    best_item = None\n    best_v = -np.inf\n    best_d = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            d = float(v) / max(1e-12, float(w))\n            if float(v) > best_v or (float(v) == best_v and d > best_d):\n                best_v = float(v)\n                best_d = d\n                best_item = (w, v, idx)\n    return best_item\n",
  "knapsack_core_bias_midweight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Prefer items with weight near remaining_capacity/2, weighted by density.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    target = 0.5 * C\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            clos = 1.0 - min(1.0, abs(float(w) - target) / target)\n            score = dens * (0.5 + 0.5 * clos)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "bounded_ratio_with_beta_mean_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Score = value / (weight + beta) where beta is mean weight (stabilizes small weights).\"\"\"\n    weights = np.array([w for (w, _, _) in remaining_items if w > 0], dtype=float)\n    beta = float(np.mean(weights)) if weights.size else 1.0\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) / (float(w) + beta)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "sigmoid_density_softcap": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Score = sigmoid(density) * (weight/cap): bounded + fill-aware.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    dens_fit = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens_fit.append(float(v) / float(w))\n    mu = float(np.mean(dens_fit)) if dens_fit else 0.0\n    sd = float(np.std(dens_fit)) + 1e-12\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            d = float(v) / float(w)\n            z = (d - mu) / sd\n            sig = 1.0 / (1.0 + np.exp(-z))\n            score = sig * (float(w) / C)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "minimize_slack_then_max_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Minimize leftover capacity; among equal leftover, choose higher density.\"\"\"\n    best_item = None\n    best_left = None\n    best_d = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            left = remaining_capacity - w\n            d = float(v) / max(1e-12, float(w))\n            if best_left is None or left < best_left or (left == best_left and d > best_d):\n                best_left = left\n                best_d = d\n                best_item = (w, v, idx)\n    return best_item\n",
  "density_minus_leftover_fraction_penalty": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Score = density - gamma*(leftover/capacity) to avoid leaving lots of slack.\"\"\"\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    gamma = 0.5\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            leftover = (C - float(w)) / C\n            score = dens - gamma * leftover\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "value_plus_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Score = value + k*density (k from remaining capacity scale).\"\"\"\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    k = 0.1 * C\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            score = float(v) + k * dens\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "density_with_small_gap_penalty_relative_item": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Density but penalize leaving leftover < weight/4 (often creates awkward unusable space).\"\"\"\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            leftover = remaining_capacity - w\n            penalty = 0.0\n            if leftover > 0 and leftover < 0.25 * w:\n                penalty = (0.25 * w - leftover) / max(1.0, w)\n            score = dens - 0.75 * penalty\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "top_density_then_maximize_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"Restrict to top-20% densities, then choose max weight (fills capacity among good items).\"\"\"\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            cand.append((float(v) / float(w), w, v, idx))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not cand:\n        return None\n    ds = np.array([d for d, _, _, _ in cand], dtype=float)\n    thr = float(np.quantile(ds, 0.80))\n    best = None\n    best_w = -1\n    best_d = -np.inf\n    for d, w, v, idx in cand:\n        if d >= thr:\n            if w > best_w or (w == best_w and d > best_d):\n                best_w = w\n                best_d = d\n                best = (w, v, idx)\n    return best\n"
}
