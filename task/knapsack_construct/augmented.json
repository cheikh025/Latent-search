{
  "density_ratio_classic": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in remaining_items:\n      if w <= remaining_capacity and w > 0:\n        score = v / w\n        if score > best_score:\n          best_score, best_item = score, (w, v, idx)\n      elif w == 0 and v > 0:\n        return (w, v, idx)\n    return best_item\n",
  "highest_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "lightest_weight_tiebreak_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            dens = (v / w) if w > 0 else (np.inf if v > 0 else -np.inf)\n            score = -float(w) + 1e-6 * float(dens)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "heaviest_that_fits": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(w) + 1e-6 * float(v)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "closest_to_capacity_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = C - float(w)\n            dens = (v / w) if w > 0 else (np.inf if v > 0 else -np.inf)\n            score = -leftover + 1e-6 * dens\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "capacity_scaled_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            score = (v / w) * (float(w) / C)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "log_weight_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            denom = np.log1p(max(0, w))\n            score = float(v) / (denom if denom > 0 else 1e-12)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "sqrt_weight_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) / (np.sqrt(max(1e-12, float(w))))\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_over_weight_squared": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            ww = max(1e-12, float(w))\n            score = float(v) / (ww * ww)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "adaptive_value_vs_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    weights = np.array([w for (w, _, _) in remaining_items], dtype=float)\n    wmax = float(np.max(weights)) if weights.size else 1.0\n    progress = 1.0 - (C / max(1.0, wmax))\n    alpha = float(np.clip(0.15 + 0.7 * progress, 0.15, 0.85))\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            score = alpha * dens + (1.0 - alpha) * float(v)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "median_value_filtered_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_vals = [v for (w, v, _) in remaining_items if w <= remaining_capacity]\n    if not fit_vals:\n        return None\n    medv = float(np.median(np.array(fit_vals, dtype=float)))\n    best_item = None\n    best_score = -np.inf\n    found_strict = False\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            dens = float(v) / max(1e-12, float(w))\n            strict = float(v) >= medv\n            score = dens + (1e6 if strict else 0.0)\n            if (strict and not found_strict) or score > best_score:\n                best_score, best_item = score, (w, v, idx)\n                found_strict = found_strict or strict\n    return best_item\n",
  "deterministic_jitter_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            jitter = 1e-9 * np.sin((idx + 1.0) * (dens + 0.12345))\n            score = dens + jitter\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "regret_density_gap": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            candidates.append((float(v) / float(w), w, v, idx))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not candidates:\n        return None\n    densities = np.array([d for (d, _, _, _) in candidates], dtype=float)\n    best_item = None\n    best_score = -np.inf\n    for d, w, v, idx in candidates:\n        other = densities[densities != d]\n        second = float(np.max(other)) if other.size else -np.inf\n        score = d + 0.25 * (d - second)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "one_step_fractional_lookahead": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    cap = int(cap)\n    if cap <= 0 or not items:\n        return 0.0\n    arr = []\n    for w, v, _ in items:\n        if w <= 0:\n            if v > 0:\n                return float('inf')\n            continue\n        arr.append((float(v) / float(w), int(w), float(v)))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    val = 0.0\n    rem = cap\n    for d, w, v in arr:\n        if w <= rem:\n            val += v\n            rem -= w\n        else:\n            val += d * rem\n            break\n    return val\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            rest = [it for it in remaining_items if it[2] != idx]\n            bound = _fractional_upper_bound(leftover, rest)\n            score = float(v) + bound\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "two_candidate_fractional_lookahead_topk": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound_topk(cap: int, items: List[Tuple[int, int, int]], k: int = 25) -> float:\n    cap = int(cap)\n    if cap <= 0 or not items:\n        return 0.0\n    arr = []\n    for w, v, _ in items:\n        if w <= 0:\n            if v > 0:\n                return float('inf')\n            continue\n        arr.append((float(v) / float(w), int(w), float(v)))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    arr = arr[:max(1, int(k))]\n    val = 0.0\n    rem = cap\n    for d, w, v in arr:\n        if w <= rem:\n            val += v\n            rem -= w\n        else:\n            val += d * rem\n            break\n    return val\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            rest = [it for it in remaining_items if it[2] != idx]\n            bound = _fractional_upper_bound_topk(leftover, rest, k=25)\n            score = float(v) + bound\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "avoid_dead_end_min_weight_guard": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    weights_fit = [w for (w, _, _) in remaining_items if w > 0 and w <= remaining_capacity]\n    if not weights_fit:\n        return None\n    wmin = int(min(weights_fit))\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            dens = float(v) / max(1e-12, float(w))\n            leftover = remaining_capacity - w\n            penalty = 0.0\n            if leftover > 0 and leftover < wmin:\n                penalty = (wmin - leftover) / max(1.0, wmin)\n            score = dens - 0.5 * penalty\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "tight_then_high_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_leftover = None\n    best_value = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            if best_leftover is None or leftover < best_leftover or (leftover == best_leftover and v > best_value):\n                best_leftover = leftover\n                best_value = v\n                best_item = (w, v, idx)\n    return best_item\n",
  "density_with_leftover_gaussian_target": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    target = 0.1 * C\n    sigma = 0.25 * C + 1e-12\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            leftover = C - float(w)\n            shape = np.exp(-((leftover - target) ** 2) / (2.0 * sigma * sigma))\n            score = dens * shape\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "zscore_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    dens_list = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens_list.append(float(v) / float(w))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not dens_list:\n        return None\n    dens_arr = np.array(dens_list, dtype=float)\n    mu = float(np.mean(dens_arr))\n    sd = float(np.std(dens_arr)) + 1e-12\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            d = float(v) / float(w)\n            score = (d - mu) / sd\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "rank_density_cdf": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            cand.append((float(v) / float(w), w, v, idx))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not cand:\n        return None\n    ds = np.array([d for d, _, _, _ in cand], dtype=float)\n    order = np.argsort(ds)\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.arange(order.size, dtype=float)\n    best_i = int(np.argmax(ranks))\n    d, w, v, idx = cand[best_i]\n    return (w, v, idx)\n",
  "lagrangian_surrogate_lambda_from_fractional": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _estimate_lambda(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    arr = []\n    for w, v, idx in items:\n        if w > 0:\n            arr.append((float(v) / float(w), int(w)))\n    if not arr:\n        return 0.0\n    arr.sort(key=lambda x: x[0], reverse=True)\n    rem = int(cap)\n    lam = arr[-1][0]\n    for d, w in arr:\n        if w <= rem:\n            rem -= w\n            lam = d\n        else:\n            lam = d\n            break\n    return float(lam)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    lam = _estimate_lambda(remaining_capacity, remaining_items)\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) - lam * float(w)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "lagrangian_value_minus_mu_weight_mu_mean_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    dens = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens.append(float(v) / float(w))\n    mu = float(np.mean(dens)) if dens else 0.0\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) - mu * float(w)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "defensive_greedy_max_of_all": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    vals = np.array([v for (w, v, _) in fit], dtype=float)\n    wts = np.array([w for (w, _, _) in fit], dtype=float)\n    dens = np.array([(v / w) if w > 0 else (np.inf if v > 0 else -np.inf) for (w, v, _) in fit], dtype=float)\n    def norm(x):\n        lo, hi = float(np.nanmin(x)), float(np.nanmax(x))\n        return (x - lo) / (hi - lo + 1e-12)\n    vN = norm(vals)\n    dN = norm(np.nan_to_num(dens, nan=-1e18, posinf=1e18, neginf=-1e18))\n    fN = norm(wts / max(1.0, float(remaining_capacity)))\n    scores = np.maximum.reduce([vN, dN, fN])\n    j = int(np.nanargmax(scores))\n    return fit[j]\n",
  "max_of_two_density_or_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    vals = np.array([v for (w, v, _) in fit], dtype=float)\n    dens = np.array([(v / w) if w > 0 else (np.inf if v > 0 else -np.inf) for (w, v, _) in fit], dtype=float)\n    def norm(x):\n        lo, hi = float(np.nanmin(x)), float(np.nanmax(x))\n        return (x - lo) / (hi - lo + 1e-12)\n    vN = norm(vals)\n    dN = norm(np.nan_to_num(dens, nan=-1e18, posinf=1e18, neginf=-1e18))\n    scores = np.maximum(vN, dN)\n    j = int(np.nanargmax(scores))\n    return fit[j]\n",
  "heavy_if_high_value_quantile": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    vals = np.array([v for (_, v, _) in fit], dtype=float)\n    q75 = float(np.quantile(vals, 0.75))\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    for w, v, idx in fit:\n        if float(v) >= q75:\n            score = float(v) + 0.25 * (float(w) / C) * float(v)\n        else:\n            score = float(v) / max(1e-12, float(w))\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "small_item_packability_bias": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    wmed = float(np.median(np.array([w for (w, _, _) in fit], dtype=float))) + 1e-12\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in fit:\n        dens = float(v) / max(1e-12, float(w))\n        pack = 1.0 / (1.0 + float(w) / wmed)\n        score = dens * pack\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "expected_fill_probability": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    all_w = np.array([w for (w, _, _) in remaining_items if w > 0], dtype=float)\n    mu = float(np.mean(all_w)) if all_w.size else 0.0\n    sd = float(np.std(all_w)) + 1e-12\n    best_item = None\n    best_score = -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in fit:\n        leftover = C - float(w)\n        closeness = np.exp(-((leftover - mu) ** 2) / (2.0 * sd * sd))\n        dens = float(v) / max(1e-12, float(w))\n        score = dens * (0.5 + 0.5 * closeness)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "maximize_value_then_density_tie": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_v = -np.inf\n    best_d = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            d = float(v) / max(1e-12, float(w))\n            if float(v) > best_v or (float(v) == best_v and d > best_d):\n                best_v = float(v)\n                best_d = d\n                best_item = (w, v, idx)\n    return best_item\n",
  "knapsack_core_bias_midweight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    target = 0.5 * C\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            clos = 1.0 - min(1.0, abs(float(w) - target) / target)\n            score = dens * (0.5 + 0.5 * clos)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "bounded_ratio_with_beta_mean_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    weights = np.array([w for (w, _, _) in remaining_items if w > 0], dtype=float)\n    beta = float(np.mean(weights)) if weights.size else 1.0\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) / (float(w) + beta)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "sigmoid_density_softcap": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    dens_fit = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens_fit.append(float(v) / float(w))\n    mu = float(np.mean(dens_fit)) if dens_fit else 0.0\n    sd = float(np.std(dens_fit)) + 1e-12\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            d = float(v) / float(w)\n            z = (d - mu) / sd\n            sig = 1.0 / (1.0 + np.exp(-z))\n            score = sig * (float(w) / C)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "minimize_slack_then_max_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_left = None\n    best_d = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            left = remaining_capacity - w\n            d = float(v) / max(1e-12, float(w))\n            if best_left is None or left < best_left or (left == best_left and d > best_d):\n                best_left = left\n                best_d = d\n                best_item = (w, v, idx)\n    return best_item\n",
  "density_minus_leftover_fraction_penalty": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    gamma = 0.5\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            leftover = (C - float(w)) / C\n            score = dens - gamma * leftover\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "value_plus_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    k = 0.1 * C\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            score = float(v) + k * dens\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "density_with_small_gap_penalty_relative_item": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            leftover = remaining_capacity - w\n            penalty = 0.0\n            if leftover > 0 and leftover < 0.25 * w:\n                penalty = (0.25 * w - leftover) / max(1.0, w)\n            score = dens - 0.75 * penalty\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "top_density_then_maximize_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            cand.append((float(v) / float(w), w, v, idx))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not cand:\n        return None\n    ds = np.array([d for d, _, _, _ in cand], dtype=float)\n    thr = float(np.quantile(ds, 0.80))\n    best = None\n    best_w = -1\n    best_d = -np.inf\n    for d, w, v, idx in cand:\n        if d >= thr:\n            if w > best_w or (w == best_w and d > best_d):\n                best_w = w\n                best_d = d\n                best = (w, v, idx)\n    return best\n",
  "pareto_frontier_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    # Zero-weight positive value is always best.\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Compute non-dominated set (w lower is better, v higher is better).\n    # Sort by weight asc, value desc; then keep items that improve best value seen.\n    fit2 = [(int(w), float(v), idx) for (w, v, idx) in fit if w > 0]\n    fit2.sort(key=lambda x: (x[0], -x[1], x[2]))\n    frontier = []\n    best_v = -np.inf\n    for w, v, idx in fit2:\n        if v > best_v + 1e-12:\n            frontier.append((w, v, idx))\n            best_v = v\n\n    best_item = None\n    best_score = -np.inf\n    best_v = -np.inf\n    for w, v, idx in frontier:\n        d = v / max(1e-12, float(w))\n        if d > best_score or (abs(d - best_score) <= 1e-12 and v > best_v):\n            best_score = d\n            best_v = v\n            best_item = (w, int(v) if float(v).is_integer() else v, idx)\n    # Ensure original v type (int) is preserved if possible; but output accepts int/float.\n    return (best_item[0], int(best_item[1]) if isinstance(best_item[1], float) and best_item[1].is_integer() else best_item[1], best_item[2])\n",
  "inverse_rank_aggregation": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _inv_rank_scores(arr: np.ndarray) -> np.ndarray:\n    # Highest value gets rank 1 => inv_rank 1.0; stable under ties.\n    order = np.argsort(-arr, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.arange(1, order.size + 1, dtype=float)\n    return 1.0 / ranks\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    vals = np.array([float(v) for (w, v, _) in fit], dtype=float)\n    wts = np.array([float(w) for (w, _, _) in fit], dtype=float)\n    dens = vals / np.maximum(1e-12, wts)\n    fill = wts / float(max(1, remaining_capacity))\n\n    score = _inv_rank_scores(vals) + _inv_rank_scores(dens) + 0.75 * _inv_rank_scores(fill)\n    j = int(np.argmax(score))\n    return fit[j]\n",
  "exponential_tradeoff_value_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    # Estimate tightness by fraction of items that fit.\n    frac_fit = float(len(fit)) / float(max(1, len(remaining_items)))\n    lam = float(np.clip(2.0 - 1.5 * frac_fit, 0.5, 2.0))  # tighter => larger lambda\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        score = float(v) * np.exp(-lam * (float(w) / C))\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "weight_rarity_bonus_density": "import numpy as np\nfrom typing import List, Tuple, Optional, Dict\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    freq: Dict[int, int] = {}\n    for w, _, _ in remaining_items:\n        ww = int(w)\n        freq[ww] = freq.get(ww, 0) + 1\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        w0 = int(w)\n        dens = float(v) / max(1e-12, float(w0))\n        rarity = 1.0 / np.sqrt(float(freq.get(w0, 1)))\n        score = dens * (0.85 + 0.15 * rarity) + 1e-9 * float(v)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "gcd_leftover_alignment": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom math import gcd\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    pos_w = [int(w) for (w, _, _) in remaining_items if int(w) > 0]\n    g = 0\n    for w in pos_w:\n        g = w if g == 0 else gcd(g, w)\n    g = int(g) if g > 0 else 1\n\n    best_item, best_score = None, -np.inf\n    C = float(max(1, remaining_capacity))\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / float(w)\n        leftover = int(remaining_capacity - w)\n        mod = leftover % g\n        # normalized distance to nearest multiple of g\n        dist = min(mod, g - mod) / max(1.0, float(g))\n        score = dens - 0.75 * dist + 1e-6 * (float(w) / C)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "mini_bitset_reachability_lookahead": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _reachable_bitset(weights: List[int], cap: int) -> int:\n    bits = 1  # weight 0 reachable\n    for w in weights:\n        if 0 < w <= cap:\n            bits |= (bits << w)\n            # Keep only up to cap bits\n            bits &= (1 << (cap + 1)) - 1\n            if bits == (1 << (cap + 1)) - 1:\n                break\n    return bits\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cap_dp = int(min(2048, max(0, remaining_capacity)))\n    # Use a limited set of lightest weights to keep DP fast and relevant for fill.\n    cand_w = sorted([int(w) for (w, _, _) in remaining_items if 0 < int(w) <= cap_dp])[:80]\n    base_bits = _reachable_bitset(cand_w, cap_dp)\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = int(remaining_capacity - ww)\n        if leftover < 0:\n            continue\n        l = min(leftover, cap_dp)\n        reachable = 1.0 if ((base_bits >> l) & 1) else 0.0\n        dens = float(v) / float(ww)\n        score = dens * (0.7 + 0.3 * reachable) + 0.05 * float(v) * reachable\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "two_step_best_pair_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Precompute best partner value by weight threshold using scanning.\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        leftover = remaining_capacity - int(w)\n        best_partner_v = 0.0\n        for w2, v2, idx2 in fit:\n            if idx2 == idx:\n                continue\n            if int(w2) <= leftover:\n                best_partner_v = max(best_partner_v, float(v2))\n        dens = float(v) / max(1e-12, float(w))\n        score = float(v) + best_partner_v + 1e-3 * dens\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "deterministic_gumbel_softmax_density": "import numpy as np\nfrom typing import List, Tuple, Optional\nimport math\n\ndef _hash01(x: float) -> float:\n    # deterministic pseudo-random in (0,1) from float input\n    s = math.sin(x) * 43758.5453123\n    return s - math.floor(s)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item, best_score = None, -np.inf\n    C = float(max(1, remaining_capacity))\n    # Higher temp early (large capacity), lower temp when tight.\n    temp = float(np.clip(0.35 * (C / (C + 50.0)), 0.05, 0.35))\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w <= 0:\n                continue\n            dens = float(v) / float(w)\n            u = _hash01((idx + 1.0) * 0.987 + C * 0.013)\n            u = min(1.0 - 1e-12, max(1e-12, u))\n            g = -math.log(-math.log(u))\n            score = dens + temp * g\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_quantile_gate_then_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    q = float(np.quantile(vals, 0.60))  # slightly above median\n    gated = [(w, v, idx) for (w, v, idx) in fit if float(v) >= q and w > 0]\n    pool = gated if len(gated) >= max(2, len(fit) // 5) else [(w, v, idx) for (w, v, idx) in fit if w > 0]\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in pool:\n        d = float(v) / float(w)\n        score = d + 1e-6 * float(v)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "interquartile_leftover_preference": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))  # degenerate\n    q1, q3 = float(np.quantile(ws, 0.25)), float(np.quantile(ws, 0.75))\n    iqr = max(1e-12, q3 - q1)\n\n    best_item, best_score = None, -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / float(w)\n        leftover = C - float(w)\n        # Penalty is 0 if leftover in [q1,q3], else proportional to distance to interval.\n        dist = 0.0\n        if leftover < q1:\n            dist = (q1 - leftover) / iqr\n        elif leftover > q3:\n            dist = (leftover - q3) / iqr\n        score = dens - 0.4 * dist\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "bimodal_light_or_heavy_switch": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    wmed = float(np.median(ws)) if ws.size else 1.0\n    # If we can fit ~3+ median items, start with heavy-ish; else favor light.\n    heavy_mode = float(remaining_capacity) >= 3.0 * wmed\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / float(w)\n        if heavy_mode:\n            score = dens + 0.15 * float(w)  # pushes heavier among good densities\n        else:\n            score = dens - 0.15 * float(w)  # pushes lighter among good densities\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "robust_mad_z_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _mad(x: np.ndarray) -> float:\n    med = float(np.median(x))\n    return float(np.median(np.abs(x - med))) + 1e-12\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                cand.append((float(v) / float(w), w, v, idx))\n    if not cand:\n        return None\n    ds = np.array([d for (d, _, _, _) in cand], dtype=float)\n    med = float(np.median(ds))\n    mad = _mad(ds)\n    best_item, best_score = None, -np.inf\n    for d, w, v, idx in cand:\n        z = (float(d) - med) / (1.4826 * mad)  # approx std for normal\n        score = z + 1e-6 * float(v)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "density_plus_value_share": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    total_v = float(np.sum([float(v) for (_, v, _) in fit])) + 1e-12\n    alpha = 0.75\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / float(w)\n        share = float(v) / total_v\n        score = dens + alpha * share\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "mod_bucket_leftover_favor_small_base": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    bases = list(range(2, 10))\n    # For each base, compute histogram of residues among remaining weights (positive only).\n    res_hist = {b: np.zeros(b, dtype=float) for b in bases}\n    for w, _, _ in remaining_items:\n        ww = int(w)\n        if ww > 0:\n            for b in bases:\n                res_hist[b][ww % b] += 1.0\n    # Normalize histograms.\n    for b in bases:\n        s = float(np.sum(res_hist[b])) + 1e-12\n        res_hist[b] /= s\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = int(remaining_capacity - ww)\n        # Average residue popularity across bases.\n        pop = 0.0\n        for b in bases:\n            pop += float(res_hist[b][leftover % b])\n        pop /= float(len(bases))\n        dens = float(v) / float(ww)\n        score = dens * (0.75 + 0.25 * pop)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "threshold_accept_then_best_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                cand.append((float(v) / float(w), w, v, idx))\n    if not cand:\n        return None\n\n    ds = np.array([d for (d, _, _, _) in cand], dtype=float)\n    mu = float(np.mean(ds))\n    sd = float(np.std(ds)) + 1e-12\n    # Tighter capacity -> higher k (be pickier).\n    tight = float(np.clip(1.0 - (float(remaining_capacity) / (float(remaining_capacity) + 100.0)), 0.0, 1.0))\n    k = 0.25 + 0.75 * tight\n    thr = mu + k * sd\n\n    above = [(d, w, v, idx) for (d, w, v, idx) in cand if d >= thr]\n    pool = above if above else cand\n\n    # Choose maximum fill among pool; tie-break by density.\n    best_item, best_w, best_d = None, -1, -np.inf\n    for d, w, v, idx in pool:\n        if int(w) > best_w or (int(w) == best_w and float(d) > best_d):\n            best_w, best_d = int(w), float(d)\n            best_item = (w, v, idx)\n    return best_item\n",
  "maximin_normalized_value_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _norm(x: np.ndarray) -> np.ndarray:\n    lo, hi = float(np.min(x)), float(np.max(x))\n    return (x - lo) / (hi - lo + 1e-12)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    wts = np.array([float(w) for (w, _, _) in fit], dtype=float)\n    dens = vals / np.maximum(1e-12, wts)\n\n    vN = _norm(vals)\n    dN = _norm(dens)\n    scores = np.minimum(vN, dN)\n    j = int(np.argmax(scores))\n    return fit[j]\n",
  "multiplicative_power_score": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    tight = float(np.clip(1.0 - (C / (C + 200.0)), 0.0, 1.0))\n    a = 0.9 - 0.4 * tight\n    b = 0.6 + 0.3 * tight\n    c = 0.2 + 0.4 * tight\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        val = max(1e-12, float(v))\n        dens = max(1e-12, float(v) / float(w))\n        fill = max(1e-12, float(w) / C)\n        score = (val ** a) * (dens ** b) * (fill ** c)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "dominance_count_heuristic": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dom = 0\n        for w2, v2, idx2 in fit:\n            if idx2 == idx:\n                continue\n            if int(w) <= int(w2) and float(v) >= float(v2) and (int(w) < int(w2) or float(v) > float(v2)):\n                dom += 1\n        dens = float(v) / float(w)\n        score = dens + 0.05 * float(dom)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "quantile_cluster_total_value_pick": "import numpy as np\nfrom typing import List, Tuple, Optional, Dict\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    wpos = np.array([float(w) for (w, _, _) in fit if w > 0], dtype=float)\n    if wpos.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n    q1, q2 = float(np.quantile(wpos, 1/3)), float(np.quantile(wpos, 2/3))\n\n    def bin_id(w: float) -> int:\n        if w <= q1: return 0\n        if w <= q2: return 1\n        return 2\n\n    bins: Dict[int, List[Tuple[int, int, int]]] = {0: [], 1: [], 2: []}\n    bin_value = {0: 0.0, 1: 0.0, 2: 0.0}\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        b = bin_id(float(w))\n        bins[b].append((w, v, idx))\n        bin_value[b] += float(v)\n\n    chosen_bin = int(max(bin_value.keys(), key=lambda b: bin_value[b]))\n    pool = bins[chosen_bin] if bins[chosen_bin] else [(w, v, idx) for (w, v, idx) in fit if w > 0]\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in pool:\n        d = float(v) / max(1e-12, float(w))\n        if d > best_score:\n            best_score, best_item = d, (w, v, idx)\n    return best_item\n",
  "topk_density_then_best_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                cand.append((float(v) / float(w), w, v, idx))\n    if not cand:\n        return None\n    cand.sort(key=lambda x: x[0], reverse=True)\n    k = int(max(1, round(np.sqrt(len(cand)))))\n    top = cand[:k]\n    best = max(top, key=lambda t: (float(t[2]), float(t[0])))\n    _, w, v, idx = best\n    return (w, v, idx)\n",
  "fractional_bound_lookahead": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int,int,int]]) -> float:\n    if cap <= 0:\n        return 0.0\n    cand = [(w, v) for (w, v, _) in items if w > 0 and w <= cap and v > 0]\n    if not cand:\n        return 0.0\n    cand.sort(key=lambda t: float(t[1]) / float(t[0]), reverse=True)\n    rem = float(cap)\n    ub = 0.0\n    for w, v in cand:\n        if rem <= 0:\n            break\n        if float(w) <= rem:\n            ub += float(v)\n            rem -= float(w)\n        else:\n            ub += float(v) * (rem / float(w))\n            rem = 0.0\n    return ub\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        leftover = remaining_capacity - int(w)\n        ub = _fractional_upper_bound(leftover, [(w2, v2, i2) for (w2, v2, i2) in remaining_items if i2 != idx])\n        score = float(v) + ub + 1e-6 * (float(v) / float(w))\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "closest_complement_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    weights = sorted({int(w) for (w, _, _) in remaining_items if int(w) > 0})\n    if not weights:\n        return max(fit, key=lambda t: float(t[1]))\n\n    def nearest_dist(x: int) -> int:\n        # binary search\n        lo, hi = 0, len(weights)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if weights[mid] < x:\n                lo = mid + 1\n            else:\n                hi = mid\n        best = abs(weights[min(lo, len(weights)-1)] - x)\n        if lo > 0:\n            best = min(best, abs(weights[lo-1] - x))\n        return best\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = remaining_capacity - ww\n        dist = float(nearest_dist(leftover))\n        dens = float(v) / float(ww)\n        score = dens - 0.02 * dist + 1e-9 * float(v)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_minus_slack_penalty": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    tight = float(np.clip(1.0 - (C / (C + 150.0)), 0.0, 1.0))\n    beta = 0.15 + 0.55 * tight\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        slack = float(remaining_capacity - int(w))\n        score = float(v) - beta * slack\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "log_value_over_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    best_item, best_score = None, -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                score = float(np.log1p(max(0.0, float(v)))) / float(w)\n                if score > best_score:\n                    best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_per_sqrt_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    best_item, best_score = None, -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                score = float(v) / float(np.sqrt(float(w)))\n                if score > best_score:\n                    best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "power_density_p_tightness": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    C = float(max(1, remaining_capacity))\n    tight = float(np.clip(1.0 - (C / (C + 120.0)), 0.0, 1.0))\n    p = 1.0 + 0.75 * tight\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                score = float(v) / float((float(w) ** p))\n                if score > best_score:\n                    best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "target_fill_fraction": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    phase = float(C / (C + 200.0))\n    target = 0.70 - 0.35 * phase\n    tw = target * C\n\n    # allow a band around target weight\n    band = 0.18 * C\n    near = [(w, v, idx) for (w, v, idx) in fit if w > 0 and abs(float(w) - tw) <= band]\n    pool = near if near else [(w, v, idx) for (w, v, idx) in fit if w > 0]\n\n    best = max(pool, key=lambda t: (float(t[1]), float(t[1]) / max(1e-12, float(t[0]))))\n    return best\n",
  "three_champion_runoff": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _best_by(items, key_fn):\n    best = None\n    bestk = -np.inf\n    for it in items:\n        k = key_fn(it)\n        if k > bestk:\n            bestk, best = k, it\n    return best\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    c1 = _best_by(cand, lambda t: float(t[1]))\n    c2 = _best_by(cand, lambda t: float(t[1]) / float(t[0]))\n    c3 = _best_by(cand, lambda t: float(t[0]))\n\n    champs = [c for c in [c1, c2, c3] if c is not None]\n    # Deduplicate\n    uniq = []\n    seen = set()\n    for w, v, idx in champs:\n        if idx not in seen:\n            uniq.append((w, v, idx))\n            seen.add(idx)\n\n    vals = np.array([float(v) for (_, v, _) in uniq], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in uniq], dtype=float)\n    fill = np.array([float(w) / float(max(1, remaining_capacity)) for (w, _, _) in uniq], dtype=float)\n\n    def norm(x):\n        return (x - float(np.min(x))) / (float(np.max(x)) - float(np.min(x)) + 1e-12)\n\n    score = norm(vals) + norm(dens) + 0.5 * norm(fill)\n    j = int(np.argmax(score))\n    return uniq[j]\n",
  "deterministic_softmax_roulette": "import numpy as np\nfrom typing import List, Tuple, Optional\nimport math\n\ndef _hashu(x: float) -> float:\n    s = math.sin(x) * 100000.12345\n    return s - math.floor(s)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    cand = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not cand:\n        return None\n    for w, v, idx in cand:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in cand if w > 0]\n    if not cand:\n        return max([(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity], key=lambda t: float(t[1]))\n\n    C = float(max(1, remaining_capacity))\n    T = float(np.clip(0.35 * (C / (C + 80.0)), 0.06, 0.35))\n\n    scores = np.array([float(v) / float(w) + 0.02 * float(v) for (w, v, _) in cand], dtype=float)\n    mx = float(np.max(scores))\n    probs = np.exp((scores - mx) / T)\n    probs = probs / (float(np.sum(probs)) + 1e-12)\n\n    u = _hashu(C * 0.031 + len(cand) * 0.17)\n    cdf = 0.0\n    for (w, v, idx), p in zip(cand, probs):\n        cdf += float(p)\n        if u <= cdf:\n            return (w, v, idx)\n    return cand[-1]\n",
  "winsorized_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    dens = np.array([float(v) / float(w) for (w, v, _) in fit if w > 0], dtype=float)\n    if dens.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n    cap = float(np.quantile(dens, 0.90))\n\n    best_item = None\n    best_score = -np.inf\n    best_v = -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        d = float(v) / float(w)\n        d2 = min(d, cap)\n        if d2 > best_score or (abs(d2 - best_score) <= 1e-12 and float(v) > best_v):\n            best_score = d2\n            best_v = float(v)\n            best_item = (w, v, idx)\n    return best_item\n",
  "cv_adaptive_linear_combo": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    ds = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    mu = float(np.mean(ds))\n    sd = float(np.std(ds))\n    cv = float(sd / (abs(mu) + 1e-12))\n    alpha = float(np.clip(cv / (cv + 1.0), 0.15, 0.85))  # weight on density\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    # normalize\n    dN = (ds - float(np.min(ds))) / (float(np.max(ds)) - float(np.min(ds)) + 1e-12)\n    vN = (vals - float(np.min(vals))) / (float(np.max(vals)) - float(np.min(vals)) + 1e-12)\n\n    score = alpha * dN + (1.0 - alpha) * vN\n    j = int(np.argmax(score))\n    return cand[j]\n",
  "regret_based_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    best_d = float(np.max(dens))\n\n    best_item, best_score = None, -np.inf\n    for (w, v, idx), d in zip(cand, dens):\n        regret = best_d - float(d)\n        score = -regret + 1e-3 * float(v)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "top_density_band_best_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    ds = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    thr = float(np.quantile(ds, 0.75))\n    band = [(w, v, idx) for (w, v, idx) in cand if float(v) / float(w) >= thr]\n    if not band:\n        return max(cand, key=lambda t: float(t[1]) / float(t[0]))\n    return max(band, key=lambda t: (int(t[0]), float(t[1]) / float(t[0])))\n",
  "nearest_weight_cluster_center": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n    center = float(np.median(ws))\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    # Keep closest 30% to center\n    cand.sort(key=lambda t: abs(float(t[0]) - center))\n    k = max(1, int(round(0.30 * len(cand))))\n    pool = cand[:k]\n\n    return max(pool, key=lambda t: (float(t[1]) / float(t[0]), float(t[1])))\n",
  "density_times_remaining_fraction": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    C = float(max(1, remaining_capacity))\n    best_item, best_score = None, -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                dens = float(v) / float(w)\n                score = dens * (float(w) / C) + 1e-9 * float(v)\n                if score > best_score:\n                    best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "harmonic_mean_value_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _hmean(a: float, b: float) -> float:\n    return 2.0 * a * b / (a + b + 1e-12)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    vN = (vals - float(np.min(vals))) / (float(np.max(vals)) - float(np.min(vals)) + 1e-12)\n    dN = (dens - float(np.min(dens))) / (float(np.max(dens)) - float(np.min(dens)) + 1e-12)\n\n    best_item, best_score = None, -np.inf\n    for (w, v, idx), a, b in zip(cand, vN, dN):\n        score = _hmean(float(a), float(b))\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "leftover_parity_match": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    pos = [int(w) for (w, _, _) in remaining_items if int(w) > 0]\n    if not pos:\n        return max(fit, key=lambda t: float(t[1]))\n    even_frac = sum(1 for w in pos if w % 2 == 0) / float(len(pos))\n    preferred_even = even_frac >= 0.5\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = (remaining_capacity - ww)\n        parity_match = 1.0 if ((leftover % 2 == 0) == preferred_even) else 0.0\n        dens = float(v) / float(ww)\n        score = dens + 0.12 * parity_match\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "small_weight_reserve": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n    small_thr = float(np.quantile(ws, 0.25))\n    small_count = sum(1 for (w, _, _) in remaining_items if 0 < int(w) <= small_thr)\n    small_frac = float(small_count) / float(max(1, len(remaining_items)))\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        dens = float(v) / float(ww)\n        # Penalize large weights more if many small items exist.\n        penalty = 0.25 * small_frac * (float(ww) / float(max(1, remaining_capacity)))\n        score = dens - penalty\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "max_value_then_min_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    # Always take zero-weight positive value.\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    best = None\n    for w, v, idx in fit:\n        if best is None:\n            best = (w, v, idx)\n        else:\n            bw, bv, _ = best\n            if float(v) > float(bv) or (float(v) == float(bv) and int(w) < int(bw)):\n                best = (w, v, idx)\n    return best\n",
  "min_weight_then_max_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    min_w = min(int(w) for (w, _, _) in cand)\n    light = [(w, v, idx) for (w, v, idx) in cand if int(w) == min_w]\n    return max(light, key=lambda t: float(t[1]) / float(t[0]))\n",
  "density_with_leftover_quadratic_penalty": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    gamma = 0.55\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / float(w)\n        leftover = (C - float(w)) / C\n        score = dens - gamma * (leftover ** 2)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "local_density_slope": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max([(w, v, idx) for (w, v, idx) in fit], key=lambda t: float(t[1]))\n\n    cand_sorted = sorted(cand, key=lambda t: t[0])\n    ws = np.array([w for (w, _, _) in cand_sorted], dtype=float)\n    vs = np.array([v for (_, v, _) in cand_sorted], dtype=float)\n\n    best_item, best_score = None, -np.inf\n    k = 3\n    for i, (w, v, idx) in enumerate(cand_sorted):\n        lo = max(0, i - k)\n        hi = min(len(cand_sorted), i + k + 1)\n        # local average density excluding self\n        wloc = np.delete(ws[lo:hi], i - lo)\n        vloc = np.delete(vs[lo:hi], i - lo)\n        if wloc.size == 0:\n            rel = 0.0\n        else:\n            local_d = float(np.mean(vloc / np.maximum(1e-12, wloc)))\n            rel = (float(v) / float(w)) - local_d\n        score = rel + 1e-3 * (float(v) / float(w))\n        if score > best_score:\n            best_score, best_item = score, (w, int(v) if float(v).is_integer() else v, idx)\n    # Return with original-ish types\n    w, v, idx = best_item\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n",
  "median_value_gate_then_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    med = float(np.median(vals))\n    gated = [(w, v, idx) for (w, v, idx) in fit if float(v) >= med and w > 0]\n    if not gated:\n        return max(fit, key=lambda t: float(t[1]))\n    return max(gated, key=lambda t: (int(t[0]), float(t[1])))\n",
  "anti_greedy_smallest_positive_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    ds = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    thr = float(np.quantile(ds, 0.60))\n    good = [(w, v, idx) for (w, v, idx) in cand if (float(v) / float(w)) >= thr]\n    pool = good if good else cand\n    return min(pool, key=lambda t: (float(t[1]), -float(t[1]) / float(t[0])))\n",
  "density_with_value_rank_bonus": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    order = np.argsort(vals, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.arange(1, len(cand) + 1, dtype=float)  # 1..n\n    rankN = ranks / float(len(cand))\n\n    best_item, best_score = None, -np.inf\n    for (w, v, idx), r in zip(cand, rankN):\n        dens = float(v) / float(w)\n        score = dens + 0.25 * float(r)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "kbest_density_diversified_by_weight_bins": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    ws_all = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws_all.size == 0:\n        return max(cand, key=lambda t: float(t[1]) / float(t[0]))\n    q1, q2 = float(np.quantile(ws_all, 1/3)), float(np.quantile(ws_all, 2/3))\n\n    def b(w):\n        if float(w) <= q1:\n            return 0\n        if float(w) <= q2:\n            return 1\n        return 2\n\n    bin_counts = [0, 0, 0]\n    for w, _, _ in remaining_items:\n        if w > 0:\n            bin_counts[b(w)] += 1\n\n    cand2 = sorted(cand, key=lambda t: float(t[1]) / float(t[0]), reverse=True)\n    k = max(1, int(round(np.sqrt(len(cand2)))))\n    top = cand2[:k]\n\n    # Choose from least-populated bin among top-k\n    top.sort(key=lambda t: (bin_counts[b(t[0])], -(float(t[1]) / float(t[0]))))\n    return top[0]\n",
  "mini_dp_value_lookahead_128": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _dp_best_value(items: List[Tuple[int,int,int]], cap: int) -> float:\n    dp = np.zeros(cap + 1, dtype=float)\n    for w, v, _ in items:\n        if 0 < int(w) <= cap and float(v) > 0:\n            ww = int(w)\n            vv = float(v)\n            dp[ww:] = np.maximum(dp[ww:], dp[:-ww] + vv)\n    return float(dp[cap])\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cap0 = int(min(128, max(0, remaining_capacity)))\n    # Use only items that could matter for this cap.\n    small_items = [(int(w), int(v), idx) for (w, v, idx) in remaining_items if 0 < int(w) <= cap0]\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = int(remaining_capacity - ww)\n        capL = int(min(cap0, max(0, leftover)))\n        ub = _dp_best_value([(w2, v2, i2) for (w2, v2, i2) in small_items if i2 != idx], capL)\n        score = float(v) + ub\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "density_rank_then_value_rank": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _rank_desc(x: np.ndarray) -> np.ndarray:\n    order = np.argsort(-x, kind=\"mergesort\")\n    r = np.empty_like(order, dtype=float)\n    r[order] = np.arange(1, len(x) + 1, dtype=float)\n    return r\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n\n    dr = _rank_desc(dens)\n    vr = _rank_desc(vals)\n\n    # Choose smallest density rank; if tie, smallest value rank (i.e., higher value)\n    best_i = 0\n    for i in range(1, len(cand)):\n        if dr[i] < dr[best_i] or (dr[i] == dr[best_i] and vr[i] < vr[best_i]):\n            best_i = i\n    return cand[int(best_i)]\n",
  "density_with_weight_log_bonus": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    eta = 0.06\n    best_item, best_score = None, -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                dens = float(v) / float(w)\n                score = dens + eta * float(np.log1p(float(w)))\n                if score > best_score:\n                    best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_density_cosine_to_ideal": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    vN = (vals - float(np.min(vals))) / (float(np.max(vals)) - float(np.min(vals)) + 1e-12)\n    dN = (dens - float(np.min(dens))) / (float(np.max(dens)) - float(np.min(dens)) + 1e-12)\n\n    best_item, best_score = None, -np.inf\n    for (w, v, idx), a, b in zip(cand, vN, dN):\n        a, b = float(a), float(b)\n        num = a + b\n        den = float(np.sqrt(a*a + b*b)) + 1e-12\n        score = num / den\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "bounded_knn_partner_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if v.is_integer() else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max([(w, v, idx) for (w, v, idx) in fit], key=lambda t: float(t[1]))\n\n    K = 8\n    best_item, best_score = None, -np.inf\n    for w, v, idx in cand:\n        leftover = remaining_capacity - w\n        partners = [(abs((remaining_capacity - w) - w2), v2) for (w2, v2, idx2) in cand if idx2 != idx and w2 <= leftover]\n        if partners:\n            partners.sort(key=lambda t: t[0])\n            best_p = max(pv for (_, pv) in partners[:K])\n        else:\n            best_p = 0.0\n        dens = float(v) / float(w)\n        score = float(v) + float(best_p) + 1e-3 * dens\n        if score > best_score:\n            best_score, best_item = score, (w, int(v) if v.is_integer() else v, idx)\n    w, v, idx = best_item\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n",
  "residue_mode_alignment_base10": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    residues = [int(w) % 10 for (w, _, _) in remaining_items if int(w) > 0]\n    if not residues:\n        return max(fit, key=lambda t: float(t[1]))\n    mode_res = Counter(residues).most_common(1)[0][0]\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = (remaining_capacity - ww) % 10\n        bonus = 1.0 if leftover == mode_res else 0.0\n        dens = float(v) / float(ww)\n        score = dens + 0.10 * bonus\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "min_variance_weight_pick": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    mean_w = float(np.mean([float(w) for (w, _, _) in remaining_items if w > 0]))\n    ds = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    thr = float(np.quantile(ds, 0.50))\n    pool = [(w, v, idx) for (w, v, idx), d in zip(cand, ds) if d >= thr]\n    pool = pool if pool else cand\n\n    # Closest to mean weight; tie-break by density\n    return min(pool, key=lambda t: (abs(float(t[0]) - mean_w), -(float(t[1]) / float(t[0]))))\n",
  "density_gap_to_next_heavier": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if v.is_integer() else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max([(w, v, idx) for (w, v, idx) in fit], key=lambda t: float(t[1]))\n\n    cand.sort(key=lambda t: t[0])\n    dens = [v / w for (w, v, _) in cand]\n\n    best_item, best_score = None, -np.inf\n    for i, (w, v, idx) in enumerate(cand):\n        d = float(dens[i])\n        # find next heavier\n        if i < len(cand) - 1:\n            d2 = float(dens[i + 1])\n            gap = d - d2\n        else:\n            gap = d\n        score = gap + 1e-3 * d\n        if score > best_score:\n            best_score, best_item = score, (w, int(v) if v.is_integer() else v, idx)\n    w, v, idx = best_item\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n",
  "value_density_product_normalized": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    vN = (vals - float(np.min(vals))) / (float(np.max(vals)) - float(np.min(vals)) + 1e-12)\n    dN = (dens - float(np.min(dens))) / (float(np.max(dens)) - float(np.min(dens)) + 1e-12)\n\n    score = vN * dN\n    j = int(np.argmax(score))\n    return cand[j]\n",
  "fill_first_then_density_threshold": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    ds = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    med = float(np.median(ds))\n    big = [(w, v, idx) for (w, v, idx) in cand if float(w) >= 0.90 * float(remaining_capacity) and (float(v) / float(w)) >= med]\n    if big:\n        return max(big, key=lambda t: float(t[1]))\n    return max(cand, key=lambda t: float(t[1]) / float(t[0]))\n",
  "density_with_rare_value_bonus": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    freq = Counter([int(v) for (_, v, _) in remaining_items])\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        d = float(v) / float(w)\n        rarity = 1.0 / float(np.sqrt(float(freq.get(int(v), 1))))\n        score = d + 0.10 * rarity\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "density_then_closest_to_capacity_endgame": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n    q30 = float(np.quantile(ws, 0.30))\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    if float(remaining_capacity) <= q30:\n        # Fill mode: choose maximum weight; tie-break by value\n        return max(cand, key=lambda t: (int(t[0]), float(t[1])))\n    # Normal mode: best density\n    return max(cand, key=lambda t: float(t[1]) / float(t[0]))\n",
  "density_ratio_classic_aug_0": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Unpack items\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.array([i for _, _, i in remaining_items], dtype=int)\n\n    # Handle zero\u2011weight items with positive value first\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        idx = np.argmax(zero_mask)\n        return (int(weights[idx]), int(values[idx]), int(indices[idx]))\n\n    # Mask items that exceed remaining capacity\n    fit_mask = weights <= remaining_capacity\n\n    # Compute density, clip to avoid extreme values, and mask infeasible items\n    density = values / (weights + 1e-12)            # add epsilon\n    density = np.clip(density, -1e9, 1e9)           # bound values\n    density = np.where(fit_mask, density, -np.inf)  # infeasible items set to -inf\n\n    # Deterministic tie\u2011breaking noise\n    density += np.arange(len(density)) * 1e-9\n\n    best = np.argmax(density)\n    if density[best] == -np.inf:\n        return None\n    return (int(weights[best]), int(values[best]), int(indices[best]))\n\n",
  "density_ratio_classic_aug_1": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    top_k = 7  # hyper\u2011parameter tuning\n    scores = []\n\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w > 0:\n                density = v / (w + 1e-12)  # epsilon\n                scores.append((density, w, v, idx))\n            elif w == 0 and v > 0:\n                return (w, v, idx)\n\n    if not scores:\n        return None\n\n    # Sort by density and keep top\u2011k\n    scores.sort(key=lambda x: x[0], reverse=True)\n    top_items = scores[:min(top_k, len(scores))]\n\n    # Randomly pick among the top\u2011k (soft selection)\n    chosen = np.random.choice(len(top_items))\n    _, w, v, idx = top_items[chosen]\n    return (w, v, idx)\n\n",
  "density_ratio_classic_aug_2": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.array([i for _, _, i in remaining_items], dtype=int)\n\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        idx = np.argmax(zero_mask)\n        return (int(weights[idx]), int(values[idx]), int(indices[idx]))\n\n    fit_mask = weights <= remaining_capacity\n\n    # Use np.divide with 'out' to avoid NaNs for infeasible items\n    density = np.divide(values, weights + 1e-12,\n                        out=np.full_like(values, -np.inf),\n                        where=fit_mask)\n    density = np.clip(density, -1e9, 1e9)  # bound values\n    density += np.arange(len(density)) * 1e-10  # deterministic noise\n\n    best = np.argmax(density)\n    if density[best] == -np.inf:\n        return None\n    return (int(weights[best]), int(values[best]), int(indices[best]))\n\n",
  "density_ratio_classic_aug_3": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.array([i for _, _, i in remaining_items], dtype=int)\n\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        idx = np.argmax(zero_mask)\n        return (int(weights[idx]), int(values[idx]), int(indices[idx]))\n\n    fit_mask = weights <= remaining_capacity\n    density = values / (weights + 1e-12)\n    density = np.clip(density, 1e-12, 1e12)  # prevent overflow\n\n    # Soft\u2011min via exponential\n    tau = 0.5\n    softmin = np.exp(-density / tau)\n    softmin = np.where(fit_mask, softmin, np.inf)\n\n    # Add tiny random noise for deterministic behaviour\n    softmin += np.random.uniform(-1e-9, 1e-9, size=softmin.shape)\n\n    best = np.argmin(softmin)\n    if softmin[best] == np.inf:\n        return None\n    return (int(weights[best]), int(values[best]), int(indices[best]))\n\n",
  "density_ratio_classic_aug_4": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    scores = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w > 0:\n                score = 0.8 * v + 0.2 * (1.0 / (w + 1e-12))\n                scores.append((score, w, v, idx))\n            elif w == 0 and v > 0:\n                return (w, v, idx)\n\n    if not scores:\n        return None\n\n    # Sort by combined score\n    scores.sort(key=lambda x: x[0], reverse=True)\n\n    # Randomly pick among top\u20115 items\n    top_k = min(5, len(scores))\n    chosen = np.random.choice(top_k)\n    _, w, v, idx = scores[chosen]\n    return (w, v, idx)\n\n",
  "highest_value_aug_5": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Unpack items into parallel numpy arrays\n    weights, values, indices = zip(*remaining_items)\n    weights = np.array(weights, dtype=float)\n    values  = np.array(values, dtype=float)\n\n    # Boolean mask of items that fit\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    # Base score is the value (scaled to avoid division by zero)\n    scores = values / (1.0 + 1e-12)\n    scores = np.clip(scores, -1e12, 1e12)          # safety clip\n\n    # Add deterministic noise for tie breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=scores.shape)\n    scores += noise\n    scores = np.clip(scores, -1e12, 1e12)\n\n    # Find index of the best score among fitting items\n    best_local_idx = np.argmax(scores[fit_mask])\n    best_global_idx = np.where(fit_mask)[0][best_local_idx]\n\n    return (int(weights[best_global_idx]),\n            int(values[best_global_idx]),\n            indices[best_global_idx])\n\n",
  "highest_value_aug_6": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    idx = 0\n    n = len(remaining_items)\n    best_item: Optional[Tuple[int, int, int]] = None\n    best_score = -np.inf\n\n    while idx < n:\n        w, v, i = remaining_items[idx]\n        # Invert the condition: skip items that *do* fit\n        if not (w <= remaining_capacity):\n            idx += 1\n            continue\n\n        # Score with a tiny epsilon added for stability\n        score = float(v) + 1e-12\n        score = np.clip(score, -1e12, 1e12)\n\n        if score >= best_score:          # deterministic tie\u2011break\n            best_score, best_item = score, (w, v, i)\n        idx += 1\n\n    return best_item\n\n",
  "highest_value_aug_7": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    weights, values, indices = zip(*remaining_items)\n    weights = np.array(weights, dtype=float)\n    values  = np.array(values, dtype=float)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    # Hyper\u2011parameterised score: 0.7 * value + 0.3 * remaining slack\n    slack = remaining_capacity - weights[fit_mask]\n    denom = 1.0 + 1e-12                       # avoid division by zero\n    scores = (0.7 * values[fit_mask] + 0.3 * slack) / denom\n    scores = np.clip(scores, -1e12, 1e12)\n\n    # Randomly pick among the top\u2011k items\n    top_k = min(7, len(scores))\n    top_indices = np.argpartition(-scores, top_k-1)[:top_k]\n    chosen_local = np.random.choice(top_indices)\n    chosen_global = np.where(fit_mask)[0][chosen_local]\n\n    return (int(weights[chosen_global]),\n            int(values[chosen_global]),\n            indices[chosen_global])\n\n",
  "highest_value_aug_8": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    weights, values, indices = zip(*remaining_items)\n    weights = np.array(weights, dtype=float)\n    values  = np.array(values, dtype=float)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    # Density: value per unit weight\n    density = values[fit_mask] / (weights[fit_mask] + 1e-12)\n    density = np.clip(density, -1e12, 1e12)\n\n    # Soft\u2011min probabilities (higher density \u2192 lower logit)\n    logits = -density\n    exp_logits = np.exp(logits - np.max(logits))\n    probs = exp_logits / (np.sum(exp_logits) + 1e-12)\n\n    # Top\u2011k exploration\n    top_k = min(5, len(probs))\n    top_indices = np.argpartition(probs, -top_k)[-top_k:]\n    probs_top = probs[top_indices]\n    probs_top = probs_top / (np.sum(probs_top) + 1e-12)\n\n    chosen_local = np.random.choice(top_indices, p=probs_top)\n    chosen_global = np.where(fit_mask)[0][chosen_local]\n\n    return (int(weights[chosen_global]),\n            int(values[chosen_global]),\n            indices[chosen_global])\n\n",
  "highest_value_aug_9": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    weights, values, indices = zip(*remaining_items)\n    weights = np.array(weights, dtype=float)\n    values  = np.array(values, dtype=float)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    # Density proxy\n    density = values[fit_mask] / (weights[fit_mask] + 1e-12)\n    density = np.clip(density, -1e12, 1e12)\n\n    # Normalise to probabilities\n    probs = density / (np.sum(density) + 1e-12)\n\n    # Choose an index according to the density\u2011based distribution\n    global_indices = np.where(fit_mask)[0]\n    chosen_global = np.random.choice(global_indices, p=probs)\n\n    return (int(weights[chosen_global]),\n            int(values[chosen_global]),\n            indices[chosen_global])\n\n",
  "lightest_weight_tiebreak_density_aug_10": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Convert to structured arrays for vectorised operations\n    arr = np.array(remaining_items, dtype=np.float64)\n    weights = arr[:, 0]\n    values  = arr[:, 1]\n    indices = arr[:, 2]\n\n    # Keep only items that fit into the remaining capacity\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    w = weights[fit_mask]\n    v = values[fit_mask]\n    idx = indices[fit_mask]\n\n    # Density with safe division and clipping\n    dens = np.divide(v, w + 1e-12)\n    dens = np.clip(dens, -1e9, 1e9)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(w)) * 1e-6\n\n    # Scoring function (lighter items are preferred, with a tiny density bonus)\n    score = -w + 1e-6 * dens + noise\n\n    # Choose the best candidate\n    best_pos = int(np.argmax(score))\n    return int(w[best_pos]), int(v[best_pos]), int(idx[best_pos])\n\n",
  "lightest_weight_tiebreak_density_aug_11": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    items = remaining_items.copy()\n    candidates = []\n    scores = []\n\n    while items:\n        w, v, idx = items.pop()\n        if w <= remaining_capacity:\n            dens = v / (w + 1e-12)\n            dens = np.clip(dens, -1e6, 1e6)\n            # Small penalty proportional to index to break ties deterministically\n            score = -0.5 * w + 1e-5 * dens + 1e-9 * idx\n            candidates.append((w, v, idx))\n            scores.append(score)\n\n    if not candidates:\n        return None\n\n    scores = np.array(scores)\n    top_k = min(4, len(scores))\n    # Sort ascending (smaller score is better)\n    sorted_idx = np.argsort(scores)[:top_k]\n    best_pos = sorted_idx[0]\n\n    w, v, idx = candidates[best_pos]\n    return int(w), int(v), int(idx)\n\n",
  "lightest_weight_tiebreak_density_aug_12": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = np.inf\n\n    for w, v, idx in remaining_items:\n        if w > remaining_capacity:          # inverted logic \u2013 skip too heavy items\n            continue\n\n        # Use the mean of value and weight as a crude density proxy\n        dens = np.mean([v, w]) / (w + 1e-12)\n        dens = np.clip(dens, -1e6, 1e6)\n\n        score = -w + 0.5 * dens\n        score = np.clip(score, -1e9, 1e9)\n\n        if score < best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "lightest_weight_tiebreak_density_aug_13": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    arr = np.array(remaining_items, dtype=np.float64)\n    fit_mask = arr[:, 0] <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    w = arr[fit_mask, 0]\n    v = arr[fit_mask, 1]\n    idx = arr[fit_mask, 2]\n\n    dens = np.divide(v, w + 1e-12)\n    dens = np.clip(dens, -1e6, 1e6)\n\n    # Build scores via list comprehension\n    scores = np.array([\n        -0.7 * wi + 1e-5 * di + 1e-8 * ii\n        for wi, di, ii in zip(w, dens, idx)\n    ])\n\n    best_pos = int(np.argmax(scores))   # choose maximum score\n    return int(w[best_pos]), int(v[best_pos]), int(idx[best_pos])\n\n",
  "lightest_weight_tiebreak_density_aug_14": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # First pass: collect densities of all feasible items\n    feasible = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not feasible:\n        return None\n\n    densities = [v / (w + 1e-12) for w, v, _ in feasible]\n    median_dens = np.median(densities)\n\n    best_item = None\n    best_score = np.inf\n\n    for w, v, idx in feasible:\n        dens = v / (w + 1e-12)\n        dens = np.clip(dens, -1e6, 1e6)\n        score = -w + 1e-6 * (dens - median_dens)\n        score = np.clip(score, -1e9, 1e9)\n\n        if score < best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "heaviest_that_fits_aug_15": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    weights = np.array([w for w, _, _ in remaining_items], dtype=np.float64)\n    values = np.array([v for _, v, _ in remaining_items], dtype=np.float64)\n    indices = np.arange(len(remaining_items), dtype=int)\n\n    mask = weights <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    # Score uses a division that requires an epsilon to avoid zero\u2011division\n    scores = weights[mask] / (1e-12 + 1.0) + 1e-6 * values[mask]\n    scores = np.clip(scores, 0, np.inf)          # keep scores non\u2011negative\n\n    best_local_idx = np.argmax(scores)\n    best_idx = indices[mask][best_local_idx]\n    return remaining_items[best_idx]\n\n",
  "heaviest_that_fits_aug_16": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    rng = np.random.default_rng(0)              # deterministic RNG\n    fitting = []\n    scores = []\n\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            # Tuned weight combination with epsilon in the division\n            score = 0.6 * float(w) / (1e-12 + 1.0) + 0.4 * float(v)\n            fitting.append((w, v, idx))\n            scores.append(score)\n\n    if not fitting:\n        return None\n\n    scores = np.array(scores, dtype=np.float64)\n    scores = np.clip(scores, 0, np.inf)         # avoid extreme values\n\n    sorted_idx = np.argsort(-scores)\n    top_k = 7\n    top_indices = sorted_idx[:min(top_k, len(sorted_idx))]\n    chosen = rng.choice(top_indices)\n\n    return fitting[chosen]\n\n",
  "heaviest_that_fits_aug_17": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fitting = []\n    scores = []\n\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            # Soft\u2011max style score (exponential) with clipping\n            score = np.exp(0.5 * float(w) + 0.5 * float(v))\n            fitting.append((w, v, idx))\n            scores.append(score)\n\n    if not fitting:\n        return None\n\n    scores = np.array(scores, dtype=np.float64)\n    scores = np.clip(scores, 0, 1e6)            # prevent overflow\n\n    probs = scores / (np.sum(scores) + 1e-12)   # epsilon in denominator\n    best_idx = np.argmax(probs)                # deterministic choice\n\n    return fitting[best_idx]\n\n",
  "heaviest_that_fits_aug_18": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    def helper(items, best_item, best_score):\n        if not items:\n            return best_item\n\n        w, v, idx = items[0]\n        rest = items[1:]\n\n        if w <= remaining_capacity:\n            # Tuned weights with epsilon, plus deterministic noise\n            score = 0.7 * float(w) / (1e-12 + 1.0) + 0.3 * float(v) + 1e-9 * idx\n            score = np.clip(score, 0, np.inf)\n            if score > best_score:\n                return helper(rest, (w, v, idx), score)\n\n        return helper(rest, best_item, best_score)\n\n    return helper(remaining_items, None, -np.inf)\n\n",
  "heaviest_that_fits_aug_19": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    scores = np.array([0.5 * w / (1e-12 + 1.0) + 0.5 * v\n                       if w <= remaining_capacity else -np.inf\n                       for w, v, _ in remaining_items],\n                      dtype=np.float64)\n\n    if np.all(scores == -np.inf):\n        return None\n\n    scores = np.clip(scores, 0, np.inf)         # keep scores non\u2011negative\n    median_score = np.median(scores)\n\n    # Select items whose score is at least the median\n    candidates = [item for item, s in zip(remaining_items, scores) if s >= median_score]\n    if not candidates:\n        return None\n\n    # Deterministic tie\u2011breaking using a small noise term\n    best = max(candidates, key=lambda it: it[0] + 1e-8 * it[2])\n    return best\n\n",
  "closest_to_capacity_fill_aug_20": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Convert list of tuples into structured arrays for vectorized ops\n    arr = np.array(remaining_items, dtype=[('weight', np.int64),\n                                           ('value', np.int64),\n                                           ('idx', np.int64)])\n    weights = arr['weight']\n    values  = arr['value']\n    indices = arr['idx']\n\n    # Mask items that fit\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    # Compute leftover capacity and density safely\n    leftover = remaining_capacity - weights[fit_mask]\n    density  = values[fit_mask] / (weights[fit_mask] + 1e-12)   # epsilon to avoid div\u2011by\u2011zero\n\n    # Clamp density to avoid extreme values\n    density = np.clip(density, 0, 1e6)\n\n    # Score: negative leftover (tight fill) plus tiny density bonus\n    scores = -leftover + 1e-6 * density\n\n    # Pick the index with the maximum score\n    best_idx = np.argmax(scores)\n    w, v, idx = weights[fit_mask][best_idx], values[fit_mask][best_idx], indices[fit_mask][best_idx]\n    return (int(w), int(v), int(idx))\n\n",
  "closest_to_capacity_fill_aug_21": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    rc = float(remaining_capacity)\n\n    for w, v, idx in remaining_items:\n        if w > remaining_capacity:\n            continue\n\n        leftover = rc - float(w)\n        density  = v / (w + 1e-12)  # epsilon\n        # Add a tiny deterministic noise based on the item index\n        noise = (idx * 1e-9)\n        score = -leftover + 1e-6 * density + noise\n\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "closest_to_capacity_fill_aug_22": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Compute a cost that prefers tighter fill; lower cost is better\n    costs = [\n        (remaining_capacity - w,\n         v / (w + 1e-12),  # density\n         idx,\n         (w, v, idx))\n        for w, v, idx in remaining_items if w <= remaining_capacity\n    ]\n\n    if not costs:\n        return None\n\n    # Apply soft\u2011min: convert costs to a probability-like score\n    # Lower leftover and higher density should yield lower cost\n    # We compute a score as leftover - 1e-6*density\n    scores = np.array([c[0] - 1e-6 * c[1] for c in costs])\n\n    # Add deterministic noise to break ties\n    noise = np.arange(len(scores)) * 1e-9\n    scores += noise\n\n    best_pos = np.argmin(scores)\n    return costs[best_pos][3]\n\n",
  "closest_to_capacity_fill_aug_23": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    rng = np.random.default_rng()\n    if not remaining_items:\n        return None\n\n    # Vectorized scoring\n    arr = np.array(remaining_items, dtype=[('w', np.int64),\n                                           ('v', np.int64),\n                                           ('idx', np.int64)])\n    weights = arr['w']\n    values  = arr['v']\n    indices = arr['idx']\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    leftover = remaining_capacity - weights[fit_mask]\n    density  = values[fit_mask] / (weights[fit_mask] + 1e-12)\n    density  = np.clip(density, 0, 1e6)\n\n    scores = -leftover + 1e-6 * density\n    top_k = min(3, len(scores))\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    chosen = top_indices[rng.integers(0, top_k)]\n    w, v, idx = weights[fit_mask][chosen], values[fit_mask][chosen], indices[fit_mask][chosen]\n    return (int(w), int(v), int(idx))\n\n",
  "closest_to_capacity_fill_aug_24": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Compute densities for all items safely\n    densities = np.array([v / (w + 1e-12) for w, v, _ in remaining_items])\n    median_dens = np.median(densities)\n\n    # Filter items that fit and have density >= median\n    candidates = [\n        (w, v, idx)\n        for (w, v, idx), dens in zip(remaining_items, densities)\n        if w <= remaining_capacity and dens >= median_dens\n    ]\n\n    if not candidates:\n        return None\n\n    # Use a simple greedy criterion: smallest leftover capacity\n    best_item = min(candidates, key=lambda it: remaining_capacity - it[0])\n    return best_item\n\n",
  "capacity_scaled_density_aug_25": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if remaining_capacity <= 0 or not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=int)\n    weights = arr[:, 0].astype(float)\n    values = arr[:, 1].astype(float)\n    indices = arr[:, 2].astype(int)\n\n    # Filter items that fit the capacity and have positive weight\n    fit_mask = (weights <= remaining_capacity) & (weights > 0)\n    if np.any(fit_mask):\n        w = weights[fit_mask]\n        v = values[fit_mask]\n        idx = indices[fit_mask]\n\n        C = float(max(1, remaining_capacity))\n        density = v / (w + 1e-12)                 # density with epsilon\n        ratio   = np.clip(w / (C + 1e-12), 0, 1)   # ratio bounded to [0,1]\n        score   = density * ratio\n\n        best_pos = np.argmax(score)\n        return int(w[best_pos]), int(v[best_pos]), int(idx[best_pos])\n\n    # Handle zero\u2011weight items with positive value\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        w0 = int(weights[zero_mask][0])\n        v0 = int(values[zero_mask][0])\n        i0 = int(indices[zero_mask][0])\n        return w0, v0, i0\n\n    return None\n\n",
  "capacity_scaled_density_aug_26": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if remaining_capacity <= 0 or not remaining_items:\n        return None\n\n    best_item: Optional[Tuple[int, int, int]] = None\n    best_score = -np.inf\n    i = 0\n    C = float(max(1, remaining_capacity))\n\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity and w > 0:\n            density = v / (w + 1e-12)\n            ratio   = np.clip(w / (C + 1e-12), 0, 1)\n            # Tuned weighting: 70% density, 30% ratio\n            score = 0.7 * density + 0.3 * ratio\n            # Deterministic tie\u2011breaker using a small noise proportional to index\n            score += i * 1e-9\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n        i += 1\n\n    return best_item\n\n",
  "capacity_scaled_density_aug_27": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if remaining_capacity <= 0 or not remaining_items:\n        return None\n\n    C = float(max(1, remaining_capacity))\n    candidates = [(w, v, idx) for w, v, idx in remaining_items\n                  if not (w <= 0 or w > remaining_capacity)]\n\n    if candidates:\n        scores = []\n        for i, (w, v, idx) in enumerate(candidates):\n            density = v / (w + 1e-12)\n            ratio   = np.clip(w / (C + 1e-12), 0, 1)\n            score   = density * ratio\n            # Small deterministic noise to break ties\n            score -= i * 1e-9\n            scores.append(score)\n\n        best_idx = int(np.argmax(scores))\n        w, v, idx = candidates[best_idx]\n        return int(w), int(v), int(idx)\n\n    # Zero\u2011weight items\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    return None\n\n",
  "capacity_scaled_density_aug_28": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if remaining_capacity <= 0 or not remaining_items:\n        return None\n\n    C = float(max(1, remaining_capacity))\n    candidates = [(w, v, idx) for w, v, idx in remaining_items\n                  if w <= remaining_capacity and w > 0]\n\n    if not candidates:\n        # Handle zero\u2011weight positive\u2011value items\n        for w, v, idx in remaining_items:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n        return None\n\n    # Compute scores with a different weighting scheme\n    scores = np.array([0.6 * (v / (w + 1e-12)) + 0.4 * np.clip(w / (C + 1e-12), 0, 1)\n                       for w, v, _ in candidates])\n\n    # Softmax probabilities for random sampling\n    exp_scores = np.exp(scores - np.max(scores))  # stability trick\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n\n    chosen_idx = int(np.random.choice(len(candidates), p=probs))\n    w, v, idx = candidates[chosen_idx]\n    return int(w), int(v), int(idx)\n\n",
  "capacity_scaled_density_aug_29": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if remaining_capacity <= 0 or not remaining_items:\n        return None\n\n    best_item: Optional[Tuple[int, int, int]] = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    i = 0\n\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity and w > 0:\n            density = v / (w * w + 1e-12)          # use squared weight\n            ratio   = np.clip(w / (C + 1e-12), 0, 1)\n            score = density * ratio\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n        i += 1\n\n    return best_item\n\n",
  "log_weight_density_aug_30": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item: Optional[Tuple[int, int, int]] = None\n    best_score: float = -np.inf\n    idx = 0\n\n    # Use a while loop instead of a for\u2011loop for structural variation\n    while idx < len(remaining_items):\n        w, v, item_id = remaining_items[idx]\n        if w <= remaining_capacity:\n            # Clip the denominator to avoid division by zero and add epsilon\n            denom = np.clip(np.log1p(w), 1e-12, None) + 1e-12\n            score = v / denom + 1e-6 * idx          # deterministic tie\u2011breaker\n            if score > best_score:\n                best_score, best_item = score, (w, v, item_id)\n        idx += 1\n\n    return best_item\n\n",
  "log_weight_density_aug_31": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=int)\n    # Keep only items that fit into the remaining capacity\n    mask = arr[:, 0] <= remaining_capacity\n    if not mask.any():\n        return None\n\n    cand = arr[mask]\n    # Scale the log\u2011penalty and clip to a safe minimum\n    denom = np.clip(0.9 * np.log1p(cand[:, 0]), 1e-12, None) + 1e-12\n    scores = cand[:, 1] / denom\n    best_idx = np.argmax(scores)\n\n    return tuple(cand[best_idx])\n\n",
  "log_weight_density_aug_32": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=int)\n    mask = arr[:, 0] <= remaining_capacity\n    if not mask.any():\n        return None\n\n    cand = arr[mask]\n    denom = np.log1p(cand[:, 0]) + 1e-12\n    scores = cand[:, 1] / denom\n    # Add deterministic noise to break ties\n    scores += np.arange(len(scores)) * 1e-8\n\n    top_k = min(3, len(scores))\n    # Get indices of the top\u2011k scores\n    top_idx = np.argpartition(-scores, top_k - 1)[:top_k]\n    best_idx = top_idx[np.argmax(scores[top_idx])]\n\n    return tuple(cand[best_idx])\n\n",
  "log_weight_density_aug_33": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item: Optional[Tuple[int, int, int]] = None\n    best_score: float = -np.inf\n\n    # Iterate over items in reverse order\n    for w, v, item_id in reversed(remaining_items):\n        if w <= remaining_capacity:\n            denom = np.clip(np.log1p(w), 1e-12, None) + 1e-12\n            # Scale the value and add tie\u2011breaking term\n            score = 1.1 * v / denom + 1e-8 * item_id\n            if score > best_score:\n                best_score, best_item = score, (w, v, item_id)\n\n    return best_item\n\n",
  "log_weight_density_aug_34": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    def _search(items, best, best_score):\n        if not items:\n            return best\n        w, v, idx = items[0]\n        rest = items[1:]\n        if w <= remaining_capacity:\n            denom = np.clip(np.log1p(w), 1e-12, None) + 1e-12\n            score = v / denom + 1e-9 * idx   # deterministic noise\n            if score > best_score:\n                return _search(rest, (w, v, idx), score)\n        return _search(rest, best, best_score)\n\n    return _search(remaining_items, None, -np.inf)\n\n",
  "value_over_weight_squared_aug_35": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    # keep only items that fit\n    candidates = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    # compute a score that prefers light items and adds deterministic noise for tie\u2011breaking\n    scores = np.clip(\n        [float(v) / (float(w)**2 + eps) + 1e-9 * idx for w, v, idx in candidates],\n        0,\n        None,\n    )\n    best = int(np.argmax(scores))\n    return candidates[best]\n\n",
  "value_over_weight_squared_aug_36": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    best_item = None\n    best_score = -np.inf\n    items = list(remaining_items)\n\n    while items:\n        w, v, idx = items.pop()\n        if w > remaining_capacity:\n            continue\n        score = float(v) / (float(w)**2 + eps) + 1e-9 * idx\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "value_over_weight_squared_aug_37": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    candidates = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    # soft\u2011max style weighted choice (deterministic: pick the highest probability)\n    scores = np.array([float(v) / (float(w)**2 + eps) + 1e-9 * idx for w, v, idx in candidates])\n    probs = np.exp(scores - np.max(scores))\n    probs /= np.sum(probs)\n    best = int(np.argmax(probs))\n    return candidates[best]\n\n",
  "value_over_weight_squared_aug_38": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    candidates = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    # use a linear proxy for weight, clip scores, then pick from top\u2011k with smallest index\n    scores = np.clip(\n        [float(v) / (float(w) + eps) + 1e-9 * idx for w, v, idx in candidates],\n        0,\n        1,\n    )\n    top_k = 3\n    top_indices = np.argsort(-scores)[:top_k]\n    # deterministic tie\u2011breaking: smallest original index among the top\u2011k\n    best = int(top_indices[np.argmin([candidates[i][2] for i in top_indices])])\n    return candidates[best]\n\n",
  "value_over_weight_squared_aug_39": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    if not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=float)\n    w = arr[:, 0]\n    v = arr[:, 1]\n    idx = arr[:, 2]\n    mask = w <= remaining_capacity\n\n    if not np.any(mask):\n        return None\n\n    scores = np.clip(v / (np.square(w) + eps) + 1e-9 * idx, 0, None)\n    # mask invalid items so they cannot be selected\n    scores = scores * mask\n    best = int(np.argmax(scores))\n    return remaining_items[best]\n\n",
  "adaptive_value_vs_density_aug_40": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    wmax = float(np.max(weights)) if weights.size else 1.0\n    progress = 1.0 - (C / max(1.0, wmax))\n    alpha = float(np.clip(0.2 + 0.6 * progress, 0.15, 0.85))\n    idx = 0\n    while idx < len(remaining_items):\n        w, v, i = remaining_items[idx]\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / (float(w) + 1e-12)\n            score = alpha * dens + (1.0 - alpha) * float(v)\n            score += i * 1e-9  # deterministic tie\u2011breaking noise\n            if score > best_score:\n                best_score, best_item = score, (w, v, i)\n        elif w == 0 and v > 0:\n            return (w, v, i)\n        idx += 1\n    return best_item\n\n",
  "adaptive_value_vs_density_aug_41": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n    # Prepare arrays\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.array([i for _, _, i in remaining_items], dtype=int)\n    # Zero\u2011weight positive\u2011value shortcut\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        idx = int(np.argmax(zero_mask))\n        return (int(weights[idx]), int(values[idx]), int(indices[idx]))\n    # Candidate mask\n    cap_mask = (weights <= remaining_capacity) & (weights > 0)\n    if not np.any(cap_mask):\n        return None\n    # Progress and alpha\n    C = float(max(1, remaining_capacity))\n    wmax = float(np.max(weights)) if weights.size else 1.0\n    progress = 1.0 - (C / max(1.0, wmax))\n    alpha = float(np.clip(0.3 + 0.5 * progress, 0.15, 0.85))\n    # Scores\n    dens = values[cap_mask] / (weights[cap_mask] + 1e-12)\n    scores = alpha * dens + (1.0 - alpha) * values[cap_mask]\n    scores += np.arange(scores.size) * 1e-9  # tie\u2011breaking noise\n    # Random pick among top\u2011k\n    top_k = 3\n    if scores.size <= top_k:\n        chosen = 0\n    else:\n        top_indices = np.argpartition(-scores, top_k)[:top_k]\n        rng = np.random.default_rng(int(np.sum(indices)) % (2**32 - 1))\n        chosen = rng.choice(top_indices)\n    best_idx = np.where(cap_mask)[0][chosen]\n    return (int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx]))\n\n",
  "adaptive_value_vs_density_aug_42": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    # Compute scores via list comprehension\n    C = float(max(1, remaining_capacity))\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    wmax = float(np.max(weights)) if weights.size else 1.0\n    progress = 1.0 - (C / max(1.0, wmax))\n    alpha = float(np.clip(0.1 + 0.8 * progress, 0.15, 0.85))\n    scores = [\n        alpha * (v / (w + 1e-12)) + (1.0 - alpha) * v\n        if w <= remaining_capacity and w > 0 else -np.inf\n        for w, v, idx in remaining_items\n    ]\n    # Add deterministic noise\n    scores = np.array(scores) + np.arange(len(scores)) * 1e-9\n    best_idx = int(np.argmax(scores))\n    if scores[best_idx] == -np.inf:\n        return None\n    return remaining_items[best_idx]\n\n",
  "adaptive_value_vs_density_aug_43": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    # Prepare arrays\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.array([i for _, _, i in remaining_items], dtype=int)\n    mask = (weights <= remaining_capacity) & (weights > 0)\n    if not np.any(mask):\n        return None\n    C = float(max(1, remaining_capacity))\n    wmax = float(np.max(weights)) if weights.size else 1.0\n    progress = 1.0 - (C / max(1.0, wmax))\n    alpha = float(np.clip(0.35 + 0.45 * progress, 0.15, 0.85))\n    dens = values[mask] / (weights[mask] + 1e-12)\n    scores = alpha * dens + (1.0 - alpha) * values[mask]\n    # Randomly pick among top\u2011k\n    top_k = 5\n    if scores.size <= top_k:\n        chosen = 0\n    else:\n        top_indices = np.argpartition(-scores, top_k)[:top_k]\n        rng = np.random.default_rng(remaining_capacity % (2**32 - 1))\n        chosen = rng.choice(top_indices)\n    best_idx = np.where(mask)[0][chosen]\n    return (int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx]))\n\n",
  "median_value_filtered_density_aug_44": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_vals = [val for (wgt, val, _) in remaining_items if wgt <= remaining_capacity]\n    if not fit_vals:\n        return None\n    median_val = float(np.median(np.array(fit_vals, dtype=float)))\n\n    best_item = None\n    best_score = -np.inf\n    found_strict = False\n    idx = 0\n    while idx < len(remaining_items):\n        wgt, val, idx_item = remaining_items[idx]\n        if wgt <= remaining_capacity:\n            density = float(val) / max(1e-12, float(wgt))\n            strict = float(val) >= median_val\n            score = density + (1e6 if strict else 0.0)\n            if (strict and not found_strict) or score > best_score:\n                best_score, best_item = score, (wgt, val, idx_item)\n                found_strict = found_strict or strict\n        idx += 1\n    return best_item\n\n",
  "median_value_filtered_density_aug_45": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.arange(len(remaining_items))\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    fit_values = values[fit_mask]\n    median_val = float(np.median(fit_values))\n\n    densities = values / np.clip(weights, 1e-12, None)\n    strict_mask = values >= median_val\n    scores = densities + np.where(strict_mask, 1e5, 0.0)\n\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(len(remaining_items)) * 1e-9\n    scores += noise\n\n    best_idx = np.argmax(scores)\n    wgt, val, idx_item = remaining_items[best_idx]\n    if wgt > remaining_capacity:\n        return None\n    return (wgt, val, idx_item)\n\n",
  "median_value_filtered_density_aug_46": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    values = np.array([v for _, v, _ in fit_items], dtype=float)\n    mean_val = float(np.mean(values))\n\n    densities = np.array([v / max(1e-12, float(w)) for w, v, _ in fit_items], dtype=float)\n    densities = np.clip(densities, 0.0, np.inf)\n\n    strict_mask = values >= mean_val\n    scores = densities + np.where(strict_mask, 5e4, 0.0)\n\n    # deterministic tie\u2011breaking by index\n    best_idx = np.argmax(scores)\n    return fit_items[best_idx]\n\n",
  "median_value_filtered_density_aug_47": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_gen = ((w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity)\n    fit_list = list(fit_gen)\n    if not fit_list:\n        return None\n\n    vals = np.array([v for _, v, _ in fit_list], dtype=float)\n    median_val = float(np.median(vals))\n\n    # density using squared weight as an alternative formulation\n    dens = np.array([v / max(1e-12, float(np.square(w))) for w, v, _ in fit_list], dtype=float)\n\n    strict = vals >= median_val\n    scores = dens + np.where(strict, 1e4, 0.0)\n\n    # deterministic noise based on index\n    noise = np.arange(len(fit_list)) * 1e-8\n    scores += noise\n\n    best_idx = np.argmax(scores)\n    return fit_list[best_idx]\n\n",
  "deterministic_jitter_density_aug_48": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n    # Convert to numpy arrays for vectorised operations\n    arr = np.array(remaining_items)\n    weights, values, indices = arr.T\n    # Return first zero\u2011weight, positive\u2011value item if any\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        idx = np.argmax(zero_mask)\n        return (int(weights[idx]), int(values[idx]), int(indices[idx]))\n    # Items that fit the remaining capacity\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n    w_fit = weights[fit_mask]\n    v_fit = values[fit_mask]\n    idx_fit = indices[fit_mask]\n    # Density with epsilon and clipping\n    dens = v_fit / (w_fit + 1e-12)\n    dens = np.clip(dens, 0, None)\n    # Deterministic jitter for tie breaking\n    jitter = 1e-9 * np.sin((idx_fit + 1) * (dens + 0.12345))\n    scores = dens + jitter\n    # Choose item with maximum score\n    best_idx = np.argmax(scores)\n    return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(idx_fit[best_idx]))\n\n",
  "deterministic_jitter_density_aug_49": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n    # Immediate return for zero\u2011weight, positive\u2011value items\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    # Candidates that fit the capacity\n    candidates = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n    densities = []\n    jitters = []\n    for w, v, idx in candidates:\n        dens = v / (w + 1e-11)          # different epsilon\n        dens = np.clip(dens, 0, None)\n        jitter = 1e-8 * np.cos((idx + 1) * (dens + 0.54321))\n        densities.append(dens)\n        jitters.append(jitter)\n    densities = np.array(densities)\n    jitters = np.array(jitters)\n    scores = densities + jitters\n    # Top\u2011k selection (k = 7)\n    top_k = min(7, len(scores))\n    top_indices = np.argpartition(-scores, top_k-1)[:top_k]\n    # Pick the item with the highest density among the top\u2011k\n    best_idx = top_indices[np.argmax(densities[top_indices])]\n    w, v, idx = candidates[best_idx]\n    return (int(w), int(v), int(idx))\n\n",
  "deterministic_jitter_density_aug_50": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n    arr = np.array(remaining_items)\n    weights, values, indices = arr.T\n    # Zero\u2011weight, positive\u2011value shortcut\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        idx = np.argmax(zero_mask)\n        return (int(weights[idx]), int(values[idx]), int(indices[idx]))\n    # Fit mask\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n    w_fit = weights[fit_mask]\n    v_fit = values[fit_mask]\n    idx_fit = indices[fit_mask]\n    # Density with epsilon and clipping to [0,1]\n    dens = v_fit / (w_fit + 1e-13)\n    dens = np.clip(dens, 0, 1)\n    # Use mean density as a proxy: pick the item closest to the mean\n    mean_density = np.mean(dens)\n    diff = np.abs(dens - mean_density)\n    best_idx = np.argmin(diff)\n    return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(idx_fit[best_idx]))\n\n",
  "deterministic_jitter_density_aug_51": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n    # Inverted logic: check zero\u2011weight first\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    # Build candidate list of fitting items\n    candidates = []\n    for w, v, idx in remaining_items:\n        if 0 < w <= remaining_capacity:\n            candidates.append((w, v, idx))\n    if not candidates:\n        return None\n    densities = []\n    jitters = []\n    for w, v, idx in candidates:\n        dens = v / (w + 1e-10)\n        dens = np.clip(dens, 0, None)\n        jitter = 1e-8 * np.sin((idx + 1) * (dens + 0.98765))\n        densities.append(dens)\n        jitters.append(jitter)\n    densities = np.array(densities)\n    jitters = np.array(jitters)\n    scores = densities + jitters\n    # Top\u20113 selection\n    top_k = min(3, len(scores))\n    top_indices = np.argpartition(-scores, top_k-1)[:top_k]\n    # Deterministically pick the candidate with the smallest original index among top\u2011k\n    top_candidate_indices = [candidates[i][2] for i in top_indices]\n    min_pos = np.argmin(top_candidate_indices)\n    best = top_indices[min_pos]\n    w, v, idx = candidates[best]\n    return (int(w), int(v), int(idx))\n\n",
  "deterministic_jitter_density_aug_52": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n    # Immediate return for zero\u2011weight, positive\u2011value items\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    # Filter items that fit the capacity\n    fit_items = [(w, v, idx) for w, v, idx in remaining_items if 0 < w <= remaining_capacity]\n    if not fit_items:\n        return None\n    scores = []\n    for w, v, idx in fit_items:\n        dens = v / (w + 1e-12)\n        proxy = dens / np.sqrt(w + 1e-12)  # penalise large weight\n        proxy = np.clip(proxy, 0, 1)\n        jitter = 1e-9 * np.cos((idx + 1) * (proxy + 0.321))\n        scores.append(proxy + jitter)\n    scores = np.array(scores)\n    # Top\u20115 selection\n    top_k = min(5, len(scores))\n    top_indices = np.argpartition(-scores, top_k-1)[:top_k]\n    # Pick the candidate with the highest raw density among the top\u2011k\n    densities_top = [fit_items[i][1] / (fit_items[i][0] + 1e-12) for i in top_indices]\n    best = top_indices[np.argmax(densities_top)]\n    w, v, idx = fit_items[best]\n    return (int(w), int(v), int(idx))\n\n",
  "regret_density_gap_aug_53": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n\n    # Immediate return for zero\u2011weight items with positive value\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Build arrays for weights, values and indices\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.array([idx for _, _, idx in remaining_items], dtype=int)\n\n    # Candidate mask: weight <= remaining_capacity and weight > 0\n    mask = (weights <= remaining_capacity) & (weights > 0)\n    if not np.any(mask):\n        return None\n\n    # Filtered arrays\n    w_f = weights[mask]\n    v_f = values[mask]\n    i_f = indices[mask]\n\n    # Density calculation with epsilon and clipping\n    densities = np.clip(v_f / (w_f + eps), 0, 1e6)\n\n    # Compute second\u2011best density efficiently\n    max_d = np.max(densities)\n    second_max = np.max(densities[densities != max_d]) if len(densities) > 1 else -np.inf\n\n    # Score with 0.25 weight on the gap\n    score = densities + 0.25 * (densities - second_max)\n\n    # Small deterministic noise for deterministic tie\u2011breaking\n    noise = np.arange(len(score)) * 1e-9\n    best_idx = np.argmax(score + noise)\n\n    return (int(w_f[best_idx]), int(v_f[best_idx]), int(i_f[best_idx]))\n\n",
  "regret_density_gap_aug_54": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n\n    # Zero\u2011weight items with value\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Candidate extraction\n    candidates = [(w, v, idx) for w, v, idx in remaining_items\n                  if w <= remaining_capacity and w > 0]\n    if not candidates:\n        return None\n\n    weights = np.array([c[0] for c in candidates], dtype=float)\n    values  = np.array([c[1] for c in candidates], dtype=float)\n    indices = np.array([c[2] for c in candidates], dtype=int)\n\n    densities = values / (weights + eps)\n    mean_d    = np.mean(densities)\n    densities = np.clip(densities, 0, 2 * mean_d)   # mean\u2011based clipping\n\n    # Second best via median of all densities\n    second_best = np.median(densities)\n\n    score = densities + 0.25 * (densities - second_best)\n\n    # Noise from total density sum for deterministic tie\u2011breaking\n    noise = np.sum(densities) * 1e-9\n    best_idx = np.argmax(score + noise)\n\n    return (int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx]))\n\n",
  "regret_density_gap_aug_55": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n\n    # Handle zero\u2011weight items\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Candidate arrays\n    candidates = [(w, v, idx) for w, v, idx in remaining_items\n                  if w <= remaining_capacity and w > 0]\n    if not candidates:\n        return None\n\n    weights = np.array([c[0] for c in candidates], dtype=float)\n    values  = np.array([c[1] for c in candidates], dtype=float)\n    indices = np.array([c[2] for c in candidates], dtype=int)\n\n    densities = np.clip(values / (weights + eps), 0, 1e6)\n\n    # Find max and second max efficiently\n    max_d = np.max(densities)\n    if len(densities) > 1:\n        second_d = np.partition(densities, -2)[-2]\n    else:\n        second_d = -np.inf\n\n    # Score computation\n    score = densities + 0.25 * (densities - second_d)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(score)) * 1e-8\n    best_idx = np.argmax(score + noise)\n\n    return (int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx]))\n\n",
  "regret_density_gap_aug_56": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n\n    # Immediate return for zero\u2011weight items with positive value\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Build candidate list\n    candidates = [(w, v, idx) for w, v, idx in remaining_items\n                  if w <= remaining_capacity and w > 0]\n    if not candidates:\n        return None\n\n    weights = np.array([c[0] for c in candidates], dtype=float)\n    values  = np.array([c[1] for c in candidates], dtype=float)\n    indices = np.array([c[2] for c in candidates], dtype=int)\n\n    densities = np.clip(values / (weights + eps), 0, 1e6)\n\n    # Compute second\u2011best density for each item\n    max_d = np.max(densities)\n    second_max = np.max(densities[densities != max_d]) if len(densities) > 1 else -np.inf\n\n    # Score as density divided by (1 + second_best)\n    score = densities / (1.0 + second_max + eps)\n\n    # Select top\u20113 scores\n    top_k = 3\n    if len(score) < top_k:\n        top_k = len(score)\n    top_indices = np.argpartition(-score, top_k - 1)[:top_k]\n    chosen = np.random.choice(top_indices)\n\n    return (int(weights[chosen]), int(values[chosen]), int(indices[chosen]))\n\n",
  "one_step_fractional_lookahead_aug_57": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    capacity = int(cap)\n    if capacity <= 0 or not items:\n        return 0.0\n    arr = np.array(items, dtype=np.float64)\n    weights = arr[:, 0]\n    values = arr[:, 1]\n    eps = 1e-12\n    ratios = values / np.clip(weights, eps, None)\n    order = np.argsort(-ratios)\n    weights = weights[order]\n    values = values[order]\n    cum_weights = np.cumsum(weights)\n    idx = np.searchsorted(cum_weights, capacity, side='right')\n    if idx >= len(cum_weights):\n        return float(np.sum(values))\n    bound = np.sum(values[:idx])\n    rem = capacity - cum_weights[idx - 1] if idx > 0 else capacity\n    bound += ratios[order[idx]] * rem\n    return float(bound)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    capacity = int(remaining_capacity)\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= capacity:\n            leftover = capacity - w\n            rest = [(ww, vv, ii) for (ww, vv, ii) in remaining_items if ii != idx]\n            bound = _fractional_upper_bound(leftover, rest)\n            noise = 1e-9 * idx\n            score = float(v) + bound + noise\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "one_step_fractional_lookahead_aug_58": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    capacity = int(cap)\n    if capacity <= 0 or not items:\n        return 0.0\n    arr = np.array(items, dtype=np.float64)\n    weights = arr[:, 0]\n    values = arr[:, 1]\n    eps = 1e-12\n    ratios = values / np.clip(weights, eps, None)\n    order = np.argsort(-ratios)\n    weights = weights[order]\n    values = values[order]\n    val = 0.0\n    rem = capacity\n    i = 0\n    n = len(weights)\n    while i < n and rem > 0:\n        w = weights[i]\n        v = values[i]\n        if w > rem:\n            val += ratios[i] * rem\n            break\n        val += v\n        rem -= w\n        i += 1\n    return float(val)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    capacity = int(remaining_capacity)\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w > capacity:\n            continue\n        leftover = capacity - w\n        rest = [(ww, vv, ii) for (ww, vv, ii) in remaining_items if ii != idx]\n        bound = _fractional_upper_bound(leftover, rest)\n        noise = 1e-9 * idx\n        score = float(v) + bound + noise\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "one_step_fractional_lookahead_aug_59": "import numpy as np\nfrom typing import List, Tuple, Optional\n\n_rng = np.random.default_rng(0)\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    capacity = int(cap)\n    if capacity <= 0 or not items:\n        return 0.0\n    arr = np.array(items, dtype=np.float64)\n    weights = arr[:, 0]\n    values = arr[:, 1]\n    eps = 1e-12\n    ratios = values / np.clip(weights, eps, None)\n    order = np.argsort(-ratios)\n    weights = weights[order]\n    values = values[order]\n    val = 0.0\n    rem = capacity\n    i = 0\n    n = len(weights)\n    while i < n and rem > 0:\n        w = weights[i]\n        v = values[i]\n        if w > rem:\n            val += ratios[i] * rem\n            break\n        val += v\n        rem -= w\n        i += 1\n    return float(val)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    capacity = int(remaining_capacity)\n    scores = []\n    for w, v, idx in remaining_items:\n        if w <= capacity:\n            leftover = capacity - w\n            rest = [(ww, vv, ii) for (ww, vv, ii) in remaining_items if ii != idx]\n            bound = _fractional_upper_bound(leftover, rest)\n            noise = 1e-9 * idx\n            scores.append((float(v) + bound + noise, (w, v, idx)))\n    if not scores:\n        return None\n    top_k = 5\n    if len(scores) <= top_k:\n        candidates = [item for _, item in scores]\n    else:\n        scores.sort(key=lambda x: x[0], reverse=True)\n        candidates = [item for _, item in scores[:top_k]]\n    chosen = _rng.choice(candidates, replace=False)\n    return tuple(chosen)\n\n",
  "one_step_fractional_lookahead_aug_60": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    capacity = int(cap)\n    if capacity <= 0 or not items:\n        return 0.0\n    arr = np.array(items, dtype=np.float64)\n    weights = arr[:, 0]\n    values = arr[:, 1]\n    eps = 1e-12\n    ratios = values / np.clip(weights, eps, None)\n    order = np.argsort(-ratios)\n    weights = weights[order]\n    values = values[order]\n    val = 0.0\n    rem = capacity\n    i = 0\n    n = len(weights)\n    while i < n and rem > 0:\n        w = weights[i]\n        v = values[i]\n        if w > rem:\n            val += ratios[i] * rem\n            break\n        val += v\n        rem -= w\n        i += 1\n    return float(val)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    capacity = int(remaining_capacity)\n    scores = []\n    for w, v, idx in remaining_items:\n        if w <= capacity:\n            leftover = capacity - w\n            rest = [(ww, vv, ii) for (ww, vv, ii) in remaining_items if ii != idx]\n            bound = _fractional_upper_bound(leftover, rest)\n            noise = 1e-9 * idx\n            scores.append((float(v) + bound + noise, (w, v, idx)))\n    if not scores:\n        return None\n    scores_arr = np.array([s for s, _ in scores], dtype=np.float64)\n    T = 1.0\n    exp_vals = np.exp(-(scores_arr) / T)\n    probs = exp_vals / np.clip(exp_vals.sum(), 1e-12, None)\n    idx = np.argmax(probs)\n    return scores[idx][1]\n\n",
  "one_step_fractional_lookahead_aug_61": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    capacity = int(cap)\n    if capacity <= 0 or not items:\n        return 0.0\n    arr = np.array(items, dtype=np.float64)\n    weights = arr[:, 0]\n    values = arr[:, 1]\n    eps = 1e-12\n    ratios = values / np.clip(weights, eps, None)\n    max_idx = int(np.argmax(ratios))\n    w = int(weights[max_idx])\n    v = float(values[max_idx])\n    if w <= capacity:\n        remaining = [it for i, it in enumerate(items) if i != max_idx]\n        return v + _fractional_upper_bound(capacity - w, remaining)\n    else:\n        return float(ratios[max_idx] * capacity)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    capacity = int(remaining_capacity)\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w > capacity:\n            continue\n        leftover = capacity - w\n        rest = [(ww, vv, ii) for (ww, vv, ii) in remaining_items if ii != idx]\n        bound = _fractional_upper_bound(leftover, rest)\n        noise = 1e-9 * idx\n        score = float(v) + bound + noise\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "two_candidate_fractional_lookahead_topk_aug_62": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound_topk(cap: int, items: List[Tuple[int, int, int]], k: int=25) -> float:\n    cap = int(cap)\n    if cap <= 0 or not items:\n        return 0.0\n\n    # Convert to numpy arrays for vectorised operations\n    weights = np.array([w for w, _, _ in items], dtype=float)\n    values  = np.array([v for _, v, _ in items], dtype=float)\n\n    # Avoid division by zero\n    eps = 1e-12\n    densities = np.divide(values, weights, out=np.full_like(values, np.inf), where=weights > eps)\n    # Items with zero weight but positive value give an infinite density\n    zero_weight = (weights <= eps) & (values > 0)\n    densities[zero_weight] = np.inf\n\n    # Select top\u2011k densities using argpartition for efficiency\n    k = max(1, int(k))\n    topk_idx = np.argpartition(-densities, k - 1)[:k]\n    topk_idx = topk_idx[np.argsort(-densities[topk_idx])]\n\n    val = 0.0\n    rem = cap\n    for idx in topk_idx:\n        w, v = int(weights[idx]), float(values[idx])\n        if w <= rem:\n            val += v\n            rem -= w\n        else:\n            val += densities[idx] * rem\n            break\n    return float(val)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            rest = [it for it in remaining_items if it[2] != idx]\n            bound = _fractional_upper_bound_topk(leftover, rest, k=25)\n            score = float(v) + bound\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "two_candidate_fractional_lookahead_topk_aug_63": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound_topk(cap: int, items: List[Tuple[int, int, int]], k: int=50) -> float:\n    cap = int(cap)\n    if cap <= 0 or not items:\n        return 0.0\n\n    weights = np.array([w for w, _, _ in items], dtype=float)\n    values  = np.array([v for _, v, _ in items], dtype=float)\n\n    eps = 1e-12\n    densities = np.divide(values, weights, out=np.full_like(values, np.inf), where=weights > eps)\n    zero_mask = (weights <= eps) & (values > 0)\n    densities[zero_mask] = np.inf\n\n    # Add deterministic noise for tie breaking\n    noise = 1e-6 * np.arange(len(items))\n    densities_noisy = densities + noise\n\n    k = max(1, int(k))\n    topk_idx = np.argpartition(-densities_noisy, k - 1)[:k]\n    topk_idx = topk_idx[np.argsort(-densities_noisy[topk_idx])]\n\n    val = 0.0\n    rem = cap\n    for idx in topk_idx:\n        w, v = int(weights[idx]), float(values[idx])\n        if w <= rem:\n            val += v\n            rem -= w\n        else:\n            val += densities_noisy[idx] * rem\n            break\n    return float(val)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            rest = [it for it in remaining_items if it[2] != idx]\n            bound = _fractional_upper_bound_topk(leftover, rest, k=50)\n            # Slightly bias score with noise to avoid deterministic ties\n            noise = 1e-6 * idx\n            score = float(v) + bound + noise\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "two_candidate_fractional_lookahead_topk_aug_64": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound_topk(cap: int, items: List[Tuple[int, int, int]], k: int=25) -> float:\n    cap = int(cap)\n    if cap <= 0 or not items:\n        return 0.0\n\n    weights = np.array([w for w, _, _ in items], dtype=float)\n    values  = np.array([v for _, v, _ in items], dtype=float)\n\n    eps = 1e-12\n    densities = np.divide(values, weights, out=np.full_like(values, np.inf), where=weights > eps)\n    zero_mask = (weights <= eps) & (values > 0)\n    densities[zero_mask] = np.inf\n\n    # Use median density as a simple bound\n    median_density = np.median(densities)\n    return float(median_density * cap)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            rest = [it for it in remaining_items if it[2] != idx]\n            bound = _fractional_upper_bound_topk(leftover, rest, k=25)\n            score = float(v) + bound\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "two_candidate_fractional_lookahead_topk_aug_65": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound_topk(cap: int, items: List[Tuple[int, int, int]], k: int=25) -> float:\n    cap = int(cap)\n    if cap <= 0 or not items:\n        return 0.0\n\n    weights = np.array([w for w, _, _ in items], dtype=float)\n    values  = np.array([v for _, v, _ in items], dtype=float)\n\n    eps = 1e-12\n    densities = np.divide(values, weights, out=np.full_like(values, np.inf), where=weights > eps)\n    zero_mask = (weights <= eps) & (values > 0)\n    densities[zero_mask] = np.inf\n\n    # Use maximum density but clip to avoid overflow\n    max_density = np.max(densities)\n    max_density = np.clip(max_density, 0, 1e6)\n    return float(max_density * cap + 1e-12)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            rest = [it for it in remaining_items if it[2] != idx]\n            bound = _fractional_upper_bound_topk(leftover, rest, k=25)\n            # Softmin weighting: higher bound gives lower probability\n            score = float(v) + bound\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "avoid_dead_end_min_weight_guard_aug_66": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    weights_fit = [w for (w, _, _) in remaining_items if 0 < w <= remaining_capacity]\n    if not weights_fit:\n        return None\n\n    wmin = int(min(weights_fit))\n    best_item = None\n    best_score = -np.inf\n    idx = 0\n    while idx < len(remaining_items):\n        w, v, id_ = remaining_items[idx]\n        if w <= remaining_capacity:\n            density = float(v) / max(1e-12, float(w))\n            leftover = remaining_capacity - w\n            penalty = 0.0\n            if leftover > 0 and leftover < wmin:\n                penalty = (wmin - leftover) / max(1.0, wmin)\n            penalty = np.clip(penalty, 0.0, 1.0)\n            score = density - 0.6 * penalty\n            # deterministic tie\u2011breaker\n            score += id_ * 1e-6\n            if score > best_score:\n                best_score = score\n                best_item = (w, v, id_)\n        idx += 1\n    return best_item\n\n",
  "avoid_dead_end_min_weight_guard_aug_67": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=np.int64)\n    weights, values, indices = arr[:, 0], arr[:, 1], arr[:, 2]\n    mask = weights <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    wmin = int(np.min(weights[mask]))\n    density = values / (weights + 1e-12)\n    leftover = remaining_capacity - weights\n    penalty = np.where((leftover > 0) & (leftover < wmin), (wmin - leftover) / wmin, 0.0)\n    penalty = np.clip(penalty, 0.0, 1.0)\n    score = density - 0.3 * penalty\n\n    # Top\u2011k selection\n    top_k = 3\n    top_indices = np.argpartition(-score, top_k - 1)[:top_k]\n    best_idx = top_indices[np.argmax(score[top_indices])]\n    return tuple(arr[best_idx])\n\n",
  "avoid_dead_end_min_weight_guard_aug_68": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=np.int64)\n    weights, values, indices = arr[:, 0], arr[:, 1], arr[:, 2]\n    mask = weights <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    wmin = int(np.min(weights[mask]))\n    density = values / (weights + 1e-12)\n    leftover = remaining_capacity - weights\n    penalty = np.where((leftover > 0) & (leftover < wmin), (wmin - leftover) / wmin, 0.0)\n    penalty = np.clip(penalty, 0.0, 1.0)\n    score = density - 0.4 * penalty\n\n    # Softmin probabilities\n    probs = np.exp(-score)\n    probs /= probs.sum()\n    rng = np.random.RandomState(42)\n    chosen = rng.choice(len(arr), p=probs)\n    return tuple(arr[chosen])\n\n",
  "avoid_dead_end_min_weight_guard_aug_69": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    weights_fit = [w for (w, _, _) in remaining_items if 0 < w <= remaining_capacity]\n    if not weights_fit:\n        return None\n\n    wmin = int(min(weights_fit))\n    density_arr = np.array([v / max(1e-12, w) for w, v, _ in remaining_items])\n    median_density = np.median(density_arr)\n\n    def _search(idx: int, best_item: Optional[Tuple[int, int, int]], best_score: float) -> Optional[Tuple[int, int, int]]:\n        if idx >= len(remaining_items):\n            return best_item\n        w, v, id_ = remaining_items[idx]\n        if w <= remaining_capacity:\n            density = float(v) / max(1e-12, float(w))\n            density = np.clip(density, 0.0, 1.0)\n            leftover = remaining_capacity - w\n            penalty = 0.0\n            if leftover > 0 and leftover < wmin:\n                penalty = (wmin - leftover) / max(1.0, wmin)\n            penalty = np.clip(penalty, 0.0, 1.0)\n            score = density / (median_density + 1e-12) - 0.7 * penalty\n            score += id_ * 1e-5  # tie\u2011breaker\n            if score > best_score:\n                return _search(idx + 1, (w, v, id_), score)\n        return _search(idx + 1, best_item, best_score)\n\n    return _search(0, None, -np.inf)\n\n",
  "avoid_dead_end_min_weight_guard_aug_70": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=np.int64)\n    weights, values, indices = arr[:, 0], arr[:, 1], arr[:, 2]\n    mask = weights <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    wmin = int(np.min(weights[mask]))\n    # Proxy density: value per weight plus a small log term\n    density = values / (weights + 1e-12) + 0.01 * np.log(weights + 1)\n    leftover = remaining_capacity - weights\n    penalty = np.where((leftover > 0) & (leftover < wmin), (wmin - leftover) / wmin, 0.0)\n    penalty = np.clip(penalty, 0.0, 1.0)\n    score = density - 0.5 * penalty\n\n    top_k = 5\n    top_indices = np.argpartition(-score, top_k - 1)[:top_k]\n    best_idx = top_indices[np.argmax(score[top_indices])]\n    return tuple(arr[best_idx])\n\n",
  "tight_then_high_value_aug_71": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if remaining_capacity <= 0 or not remaining_items:\n        return None\n\n    # Convert to a structured array for vectorised operations\n    arr = np.array(remaining_items, dtype=np.int64)\n    weights, values, idxs = arr[:, 0], arr[:, 1], arr[:, 2]\n\n    # Keep only items that fit\n    mask = weights <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    weights, values, idxs = weights[mask], values[mask], idxs[mask]\n    leftover = remaining_capacity - weights\n    leftover = np.clip(leftover, 0, remaining_capacity)\n\n    # Find the minimum leftover\n    min_leftover = np.min(leftover)\n    tie_idx = np.where(leftover == min_leftover)[0]\n\n    # Tie\u2011break by maximum value (+ small noise)\n    noisy_values = values[tie_idx] + np.arange(len(tie_idx)) * 1e-9\n    best = tie_idx[np.argmax(noisy_values)]\n\n    return (int(weights[best]), int(values[best]), int(idxs[best]))\n\n",
  "tight_then_high_value_aug_72": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if remaining_capacity <= 0 or not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=np.int64)\n    w, v, idx = arr[:, 0], arr[:, 1], arr[:, 2]\n\n    mask = w <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    w, v, idx = w[mask], v[mask], idx[mask]\n    leftover = remaining_capacity - w\n\n    # Weighted score: lower is better\n    score = 0.6 * leftover - 0.4 * v\n    # Normalise by capacity (add epsilon to denominator)\n    norm_score = score / (remaining_capacity + 1e-12)\n    # Clip to avoid extreme values\n    norm_score = np.clip(norm_score, -1e6, 1e6)\n\n    best = np.argmin(norm_score)\n    return (int(w[best]), int(v[best]), int(idx[best]))\n\n",
  "tight_then_high_value_aug_73": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if remaining_capacity <= 0 or not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=np.int64)\n    w, v, idx = arr[:, 0], arr[:, 1], arr[:, 2]\n\n    mask = w <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    w, v, idx = w[mask], v[mask], idx[mask]\n    leftover = remaining_capacity - w\n    score = leftover - v  # lower is better\n\n    top_k = min(5, len(score))\n    # indices of the k smallest scores\n    top_idx = np.argpartition(score, top_k - 1)[:top_k]\n\n    # Soft\u2011min probabilities\n    exp_vals = np.exp(-score[top_idx] / (remaining_capacity + 1e-12))\n    probs = exp_vals / np.clip(np.sum(exp_vals), 1e-12, None)\n\n    chosen = np.random.choice(top_idx, p=probs)\n    return (int(w[chosen]), int(v[chosen]), int(idx[chosen]))\n\n",
  "tight_then_high_value_aug_74": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if remaining_capacity <= 0 or not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=np.int64)\n    w, v, idx = arr[:, 0], arr[:, 1], arr[:, 2]\n\n    mask = w <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    w, v, idx = w[mask], v[mask], idx[mask]\n    leftover = remaining_capacity - w\n\n    # Normalise to [0,1]\n    norm_leftover = leftover / (remaining_capacity + 1e-12)\n    norm_value = v / (np.max(v) + 1e-12)\n\n    # Proxy metric: average of (1\u2011leftover) and value\n    metric = np.mean(np.stack([1 - norm_leftover, norm_value]), axis=0)\n    metric = np.clip(metric, 0, 1)\n\n    best = np.argmax(metric)\n    return (int(w[best]), int(v[best]), int(idx[best]))\n\n",
  "tight_then_high_value_aug_75": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Keep only items that fit\n    candidates = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    # Compute a sorting key with an epsilon\u2011augmented ratio\n    key_func = lambda t: (\n        (remaining_capacity - t[0]) / (remaining_capacity + 1e-12),   # leftover ratio\n        -t[1] - 1e-9 * t[2]                                            # value with noise\n    )\n    candidates.sort(key=key_func)\n\n    best_w, best_v, best_idx = candidates[0]\n    return (int(best_w), int(best_v), int(best_idx))\n\n",
  "density_with_leftover_gaussian_target_aug_76": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    C = float(max(1, remaining_capacity))\n    target = np.clip(0.1 * C, 0.0, C)\n    sigma = 0.25 * C + 1e-12\n\n    if not remaining_items:\n        return None\n\n    # Extract arrays\n    w_arr = np.array([item[0] for item in remaining_items], dtype=float)\n    v_arr = np.array([item[1] for item in remaining_items], dtype=float)\n    idx_arr = np.array([item[2] for item in remaining_items], dtype=int)\n\n    # Handle zero-weight items with positive value\n    zero_mask = (w_arr == 0) & (v_arr > 0)\n    if np.any(zero_mask):\n        zero_idx = np.argmax(zero_mask)  # first occurrence\n        return (int(w_arr[zero_idx]), int(v_arr[zero_idx]), int(idx_arr[zero_idx]))\n\n    # Valid items mask\n    valid_mask = (w_arr <= remaining_capacity) & (w_arr > 0)\n    if not np.any(valid_mask):\n        return None\n\n    w_valid = w_arr[valid_mask]\n    v_valid = v_arr[valid_mask]\n    idx_valid = idx_arr[valid_mask]\n\n    dens = v_valid / (w_valid + 1e-12)\n    leftover = C - w_valid\n    shape = np.exp(-((leftover - target) ** 2) / (2.0 * sigma * sigma))\n    # Deterministic tie-breaking noise\n    noise = np.arange(len(shape)) * 1e-6\n    score = dens * shape + noise\n\n    best_pos = np.argmax(score)\n    return (int(w_valid[best_pos]), int(v_valid[best_pos]), int(idx_valid[best_pos]))\n\n",
  "density_with_leftover_gaussian_target_aug_77": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    target = 0.1 * C\n    sigma = 0.25 * C + 1e-12\n\n    idx = 0\n    n = len(remaining_items)\n    while idx < n:\n        w, v, item_id = remaining_items[idx]\n        # Skip items that cannot fit or have non-positive weight\n        if w > remaining_capacity or w <= 0:\n            idx += 1\n            continue\n        if w == 0 and v > 0:\n            return (w, v, item_id)\n\n        dens = float(v) / (float(w) + 1e-12)\n        leftover = C - float(w)\n        shape = np.exp(-((leftover - target) ** 2) / (2.0 * sigma * sigma))\n        score = dens * shape + idx * 1e-7  # deterministic tie-breaking\n        if score > best_score:\n            best_score, best_item = score, (w, v, item_id)\n        idx += 1\n\n    return best_item\n\n",
  "density_with_leftover_gaussian_target_aug_78": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    C = float(max(1, remaining_capacity))\n    target = 0.1 * C\n    sigma = 0.3 * C + 1e-12  # tuned sigma\n\n    # Extract arrays\n    w_arr = np.array([t[0] for t in remaining_items], dtype=float)\n    v_arr = np.array([t[1] for t in remaining_items], dtype=float)\n    idx_arr = np.array([t[2] for t in remaining_items], dtype=int)\n\n    # Zero-weight handling\n    zero_mask = (w_arr == 0) & (v_arr > 0)\n    if np.any(zero_mask):\n        z = np.argmax(zero_mask)\n        return (int(w_arr[z]), int(v_arr[z]), int(idx_arr[z]))\n\n    # Valid items\n    valid_mask = (w_arr <= remaining_capacity) & (w_arr > 0)\n    if not np.any(valid_mask):\n        return None\n\n    w_valid = w_arr[valid_mask]\n    v_valid = v_arr[valid_mask]\n    idx_valid = idx_arr[valid_mask]\n\n    dens = v_valid / (w_valid + 1e-12)\n    dens_scaled = dens / (np.max(dens) + 1e-12)  # scale by max density\n    leftover = C - w_valid\n    # Linear shape approximation: higher when leftover close to target\n    shape = 1.0 - np.clip(np.abs(leftover - target) / sigma, 0.0, 1.0)\n    score = dens_scaled * shape + 1e-6 * np.arange(len(shape))  # tie-breaking noise\n\n    best_pos = np.argmax(score)\n    return (int(w_valid[best_pos]), int(v_valid[best_pos]), int(idx_valid[best_pos]))\n\n",
  "zscore_density_aug_79": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Keep only items that fit and have positive weight\n    fit_items = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity and w > 0]\n    if not fit_items:\n        return None\n\n    weights = np.array([w for w, _, _ in fit_items], dtype=float)\n    values = np.array([v for _, v, _ in fit_items], dtype=float)\n    densities = values / (weights + 1e-12)          # epsilon to avoid division by zero\n    densities = np.clip(densities, 0, 1e6)           # bound densities\n\n    mu = float(np.mean(densities))\n    sd = float(np.std(densities)) + 1e-12            # epsilon for std\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.array([1e-9 * (idx % 1000) for _, _, idx in fit_items])\n    scores = (densities - mu) / sd + noise\n\n    best_idx = int(np.argmax(scores))\n    return fit_items[best_idx]\n\n",
  "zscore_density_aug_80": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    rng = np.random.default_rng(seed=42)\n\n    # Immediate return for zero\u2011weight, positive\u2011value items\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Use a while loop to collect fitting items\n    i = 0\n    fit_items = []\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity and w > 0:\n            fit_items.append((w, v, idx))\n        i += 1\n\n    if not fit_items:\n        return None\n\n    densities = np.array([v / (w + 1e-12) for w, v, _ in fit_items], dtype=float)\n    mu = float(np.median(densities))                     # median instead of mean\n    sd = float(np.max(densities) - np.min(densities) + 1e-12)  # use range for scaling\n    scores = (densities - mu) / sd\n\n    # Randomly choose among the top\u2011k items\n    k = min(5, len(scores))\n    top_k_idx = np.argpartition(-scores, k-1)[:k]\n    chosen = rng.choice(top_k_idx)\n    return fit_items[chosen]\n\n",
  "zscore_density_aug_81": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    arr = np.array(remaining_items, dtype=np.int64)\n    weights = arr[:, 0].astype(float)\n    values  = arr[:, 1].astype(float)\n    indices = arr[:, 2]\n\n    fit_mask = (weights <= remaining_capacity) & (weights > 0)\n    if not np.any(fit_mask):\n        return None\n\n    fit_w = weights[fit_mask]\n    fit_v = values[fit_mask]\n    fit_idx = indices[fit_mask]\n\n    densities = fit_v / (fit_w + 1e-12)\n    densities = np.clip(densities, 0, 1e6)\n\n    best_pos = int(np.argmax(densities))\n    return (int(fit_w[best_pos]), int(fit_v[best_pos]), int(fit_idx[best_pos]))\n\n",
  "zscore_density_aug_82": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Keep only fitting items\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity and w > 0]\n    if not fit:\n        return None\n\n    densities = np.array([v / (w + 1e-12) for w, v, _ in fit], dtype=float)\n    penalties = np.array([w / (remaining_capacity + 1e-12) for w, _, _ in fit], dtype=float)\n\n    # Weighted score: 60% density, 40% penalty\n    scores = 0.6 * densities - 0.4 * penalties\n    best_idx = int(np.argmax(scores))\n    return fit[best_idx]\n\n",
  "rank_density_cdf_aug_83": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for weight, value, idx in remaining_items:\n        if weight == 0 and value > 0:\n            return (weight, value, idx)\n\n    # Build candidate list and compute densities\n    candidates = [\n        (weight, value, idx)\n        for weight, value, idx in remaining_items\n        if weight <= remaining_capacity and weight > 0\n    ]\n    if not candidates:\n        return None\n\n    weights = np.array([c[0] for c in candidates], dtype=float)\n    values = np.array([c[1] for c in candidates], dtype=float)\n    densities = values / (weights + 1e-12)          # avoid div\u2011by\u2011zero\n    densities = np.clip(densities, 0, 1)            # keep values sane\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(len(densities)) * 1e-9\n    scores = densities + noise\n\n    best_idx = int(np.argmax(scores))\n    return candidates[best_idx]\n\n",
  "rank_density_cdf_aug_84": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for weight, value, idx in remaining_items:\n        if weight == 0 and value > 0:\n            return (weight, value, idx)\n\n    # Build candidate list with a while loop\n    candidates = []\n    i = 0\n    while i < len(remaining_items):\n        weight, value, idx = remaining_items[i]\n        if weight <= remaining_capacity and weight > 0:\n            candidates.append((weight, value, idx))\n        i += 1\n    if not candidates:\n        return None\n\n    weights = np.array([c[0] for c in candidates], dtype=float)\n    values = np.array([c[1] for c in candidates], dtype=float)\n\n    # Weighted score: 60% density + 40% inverse weight\n    densities = values / (weights + 1e-12)\n    inv_weights = 1.0 / (weights + 1e-12)\n    scores = 0.6 * densities + 0.4 * inv_weights\n    scores = np.clip(scores, 0, 1)\n\n    # Randomly pick among the top\u2011k candidates\n    top_k = 5\n    if len(scores) <= top_k:\n        best_idx = int(np.argmax(scores))\n    else:\n        top_indices = np.argpartition(-scores, top_k)[:top_k]\n        best_idx = int(np.random.choice(top_indices))\n\n    return candidates[best_idx]\n\n",
  "rank_density_cdf_aug_85": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for weight, value, idx in remaining_items:\n        if weight == 0 and value > 0:\n            return (weight, value, idx)\n\n    # Candidate list and densities\n    candidates = [\n        (weight, value, idx)\n        for weight, value, idx in remaining_items\n        if weight <= remaining_capacity and weight > 0\n    ]\n    if not candidates:\n        return None\n\n    weights = np.array([c[0] for c in candidates], dtype=float)\n    values = np.array([c[1] for c in candidates], dtype=float)\n    densities = values / (weights + 1e-12)\n    densities = np.clip(densities, 0, 1)\n\n    # Use median density as a threshold\n    median_density = np.median(densities)\n    mask = densities >= median_density\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(len(densities)) * 1e-9\n    scores = densities + noise\n    eligible_scores = np.where(mask, scores, -np.inf)\n\n    best_idx = int(np.argmax(eligible_scores))\n    return candidates[best_idx]\n\n",
  "rank_density_cdf_aug_86": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Convert to numpy arrays for vectorised operations\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.array([i for _, _, i in remaining_items], dtype=int)\n\n    mask = (weights <= remaining_capacity) & (weights > 0)\n    if not np.any(mask):\n        return None\n\n    cand_weights = weights[mask]\n    cand_values = values[mask]\n    cand_indices = indices[mask]\n\n    densities = cand_values / (cand_weights + 1e-12)\n    densities = np.clip(densities, 0, 1)\n\n    # Pick the item(s) with the maximum density\n    max_density = np.max(densities)\n    top_indices = np.where(np.isclose(densities, max_density, atol=1e-12))[0]\n\n    # Deterministic noise to break ties\n    noise = np.arange(len(cand_weights)) * 1e-9\n    scores = densities + noise\n    best_local_idx = int(np.argmax(scores[top_indices]))\n    best_idx = top_indices[best_local_idx]\n\n    return (int(cand_weights[best_idx]),\n            int(cand_values[best_idx]),\n            int(cand_indices[best_idx]))\n\n",
  "lagrangian_surrogate_lambda_from_fractional_aug_87": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _estimate_lambda(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    if not items:\n        return 0.0\n    weights = np.array([w for w, _, _ in items], dtype=float)\n    values  = np.array([v for _, v, _ in items], dtype=float)\n    densities = values / (weights + 1e-12)          # epsilon to avoid div\u2011by\u2011zero\n    order = np.argsort(-densities)                 # descending densities\n    sorted_w = weights[order]\n    cum_w = np.cumsum(sorted_w)\n    idx = np.searchsorted(cum_w, cap, side=\"right\") - 1\n    lam = densities[order][idx] if idx >= 0 else densities[order][0]\n    return float(np.clip(lam, 0.0, 1e6))\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    lam = _estimate_lambda(remaining_capacity, remaining_items)\n    best_item, best_score = None, -np.inf\n    for i, (w, v, idx) in enumerate(remaining_items):\n        if w <= remaining_capacity:\n            score = float(v) - lam * float(w) + 1e-9 * i   # deterministic tie\u2011breaker\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "lagrangian_surrogate_lambda_from_fractional_aug_88": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _estimate_lambda(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    if not items:\n        return 0.0\n    densities = [v / (w + 1e-12) for w, v, _ in items]\n    sorted_pairs = sorted(zip(densities, items), key=lambda x: x[0], reverse=True)\n    remaining = cap\n    lam = 0.0\n    for d, (w, _, _) in sorted_pairs:\n        if w <= remaining:\n            remaining -= w\n            lam = d\n        else:\n            lam = d\n            break\n    return float(np.clip(lam, 0.0, 1e6))\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    lam = _estimate_lambda(remaining_capacity, remaining_items)\n    top_k = 5\n    scored = [(v - lam * w + 1e-9 * i, (w, v, idx))\n              for i, (w, v, idx) in enumerate(remaining_items) if w <= remaining_capacity]\n    if not scored:\n        return None\n    scored.sort(key=lambda x: x[0], reverse=True)\n    top_candidates = scored[:top_k]\n    best_score, best_item = max(top_candidates, key=lambda x: x[0])\n    return best_item\n\n",
  "lagrangian_surrogate_lambda_from_fractional_aug_89": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _estimate_lambda(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    if not items:\n        return 0.0\n    weights = np.array([w for w, _, _ in items], dtype=float)\n    values  = np.array([v for _, v, _ in items], dtype=float)\n    densities = values / (weights + 1e-12)\n    lam = np.median(densities)\n    return float(np.clip(lam, 0.0, 1e6))\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    lam = _estimate_lambda(remaining_capacity, remaining_items)\n    best_item, best_score = None, -np.inf\n    for i, (w, v, idx) in enumerate(remaining_items):\n        if w <= remaining_capacity:\n            score = float(v) - lam * float(w) + 1e-9 * i\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "lagrangian_surrogate_lambda_from_fractional_aug_90": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _estimate_lambda(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    if not items:\n        return 0.0\n    weights = np.array([w for w, _, _ in items], dtype=float)\n    values  = np.array([v for _, v, _ in items], dtype=float)\n    densities = values / (weights + 1e-12)\n    weighted_lam = np.sum(densities * weights) / (np.sum(weights) + 1e-12)\n    return float(np.clip(weighted_lam, 0.0, 1e6))\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    lam = _estimate_lambda(remaining_capacity, remaining_items)\n    top_k = 7\n    scored = [(v - lam * w + 1e-9 * i, (w, v, idx))\n              for i, (w, v, idx) in enumerate(remaining_items) if w <= remaining_capacity]\n    if not scored:\n        return None\n    scored.sort(key=lambda x: x[0], reverse=True)\n    top_candidates = scored[:top_k]\n    best_score, best_item = max(top_candidates, key=lambda x: x[0])\n    return best_item\n\n",
  "lagrangian_surrogate_lambda_from_fractional_aug_91": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _estimate_lambda(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    if not items:\n        return 0.0\n    densities = [v / (w + 1e-12) for w, v, _ in items if w <= cap]\n    if not densities:\n        return 0.0\n    lam = max(densities)\n    return float(np.clip(lam, 0.0, 1e6))\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    lam = _estimate_lambda(remaining_capacity, remaining_items)\n    best_item, best_score = None, -np.inf\n    for i, (w, v, idx) in enumerate(remaining_items):\n        if w <= remaining_capacity:\n            score = float(v) - lam * float(w) + 1e-9 * i\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "lagrangian_value_minus_mu_weight_mu_mean_density_aug_92": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Compute densities with a small epsilon to avoid division by zero\n    densities = np.array([float(v) / (float(w) + 1e-12) for w, v, _ in fit])\n    mu = np.mean(densities)\n    mu = np.clip(mu, 0, None)  # ensure non\u2011negative\n\n    # Compute scores and add tiny deterministic noise for tie\u2011breaking\n    scores = np.array([float(v) - mu * float(w) for w, v, _ in fit])\n    noise = np.arange(len(fit)) * 1e-6\n    scores += noise\n\n    best_idx = np.argmax(scores)\n    return fit[best_idx]\n\n",
  "lagrangian_value_minus_mu_weight_mu_mean_density_aug_93": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    idx = 0\n    fit = []\n    while idx < len(remaining_items):\n        w, v, i = remaining_items[idx]\n        if w <= remaining_capacity:\n            fit.append((w, v, i))\n        idx += 1\n\n    if not fit:\n        return None\n\n    # Median density as the surrogate\n    densities = np.array([float(v) / (float(w) + 1e-12) for w, v, _ in fit])\n    mu = np.median(densities)\n    mu = np.clip(mu, 0, None)\n\n    # Greedy selection with deterministic tie\u2011breaking (first occurrence wins)\n    best_item = None\n    best_score = -np.inf\n    for w, v, i in fit:\n        score = float(v) - mu * float(w)\n        if score > best_score:\n            best_score, best_item = score, (w, v, i)\n\n    return best_item\n\n",
  "lagrangian_value_minus_mu_weight_mu_mean_density_aug_94": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    densities = np.array([float(v) / (float(w) + 1e-12) for w, v, _ in fit])\n    mu = np.mean(densities)\n    mu = np.clip(mu, 0, None)\n\n    scores = np.array([float(v) - mu * float(w) for w, v, _ in fit])\n\n    # Softmax probabilities for weighted random choice\n    exp_scores = np.exp(scores - np.max(scores))\n    probs = exp_scores / (exp_scores.sum() + 1e-12)\n\n    # Randomly pick from the top\u2011k items\n    top_k = min(3, len(fit))\n    top_indices = np.argsort(-scores)[:top_k]\n    top_probs = probs[top_indices]\n    top_probs = top_probs / (top_probs.sum() + 1e-12)\n\n    chosen_idx = np.random.choice(top_indices, p=top_probs)\n    return fit[chosen_idx]\n\n",
  "lagrangian_value_minus_mu_weight_mu_mean_density_aug_95": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    densities = np.array([float(v) / (float(w) + 1e-12) for w, v, _ in fit])\n    # Use sum of densities as surrogate instead of mean\n    mu = np.sum(densities) / (len(densities) + 1e-12)\n    mu = np.clip(mu, 0, None)\n\n    # Weighted scoring with custom coefficients\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in fit:\n        score = 0.7 * float(v) - 0.3 * float(w) * mu\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "lagrangian_value_minus_mu_weight_mu_mean_density_aug_96": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Convert list to structured array for vectorised operations\n    arr = np.array(remaining_items, dtype=float)\n    weights = arr[:, 0]\n    values = arr[:, 1]\n    indices = arr[:, 2].astype(int)\n\n    # Boolean mask for items that fit\n    mask = weights <= remaining_capacity\n    if not mask.any():\n        return None\n\n    fit_w = weights[mask]\n    fit_v = values[mask]\n    fit_idx = indices[mask]\n\n    densities = fit_v / (fit_w + 1e-12)\n    mu = np.mean(densities)\n    mu = np.clip(mu, 0, None)\n\n    scores = fit_v - mu * fit_w\n    best_pos = np.argmax(scores)\n\n    return (int(fit_w[best_pos]), int(fit_v[best_pos]), int(fit_idx[best_pos]))\n\n",
  "defensive_greedy_max_of_all_aug_97": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = []\n    i = 0\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity:          # keep original condition\n            fit.append((w, v, idx))\n        i += 1\n    if not fit:\n        return None\n\n    vals = np.array([v for (w, v, _) in fit], dtype=float)\n    wts  = np.array([w for (w, _, _) in fit], dtype=float)\n\n    # Density with safe division\n    dens = np.divide(vals, wts, out=np.full_like(vals, np.inf), where=wts > 0)\n\n    # Normalisation helper\n    def norm(x: np.ndarray) -> np.ndarray:\n        lo = np.nanmin(x)\n        hi = np.nanmax(x)\n        return np.divide(\n            x - lo,\n            (hi - lo + 1e-12),\n            out=np.full_like(x, 0.0),\n            where=(hi - lo + 1e-12) > 0,\n        )\n\n    vN = norm(vals)\n    dN = norm(dens)\n    fN = norm(np.divide(\n        wts,\n        max(1.0, float(remaining_capacity)),\n        out=np.full_like(wts, 0.0),\n        where=remaining_capacity > 0,\n    ))\n\n    # Weighted score with different weights\n    scores = 0.5 * vN + 0.3 * dN + 0.2 * fN\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(scores)) * 1e-6\n    scores += noise\n\n    j = int(np.nanargmax(scores))\n    return fit[j]\n\n",
  "defensive_greedy_max_of_all_aug_98": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    vals = np.array([v for (w, v, _) in fit], dtype=float)\n    wts  = np.array([w for (w, _, _) in fit], dtype=float)\n\n    # Proxy density with epsilon to avoid division by zero\n    dens = np.divide(vals, wts + 1e-12)\n\n    # Clip densities to avoid extreme values\n    dens = np.clip(dens, 0, 1)\n\n    def norm(x: np.ndarray) -> np.ndarray:\n        lo = np.nanmin(x)\n        hi = np.nanmax(x)\n        return np.divide(\n            x - lo,\n            (hi - lo + 1e-12),\n            out=np.full_like(x, 0.0),\n            where=(hi - lo + 1e-12) > 0,\n        )\n\n    vN = norm(vals)\n    dN = norm(dens)\n    fN = norm(np.divide(\n        wts,\n        max(1.0, float(remaining_capacity)),\n        out=np.full_like(wts, 0.0),\n        where=remaining_capacity > 0,\n    ))\n\n    # Use np.max aggregation (semantic change)\n    scores = np.maximum.reduce([vN, dN, fN])\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(scores)) * 1e-7\n    scores += noise\n\n    j = int(np.nanargmax(scores))\n    return fit[j]\n\n",
  "defensive_greedy_max_of_all_aug_99": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if not (w > remaining_capacity)]\n    if not fit:\n        return None\n\n    vals = np.array([v for (w, v, _) in fit], dtype=float)\n    wts  = np.array([w for (w, _, _) in fit], dtype=float)\n\n    dens = np.divide(vals, wts, out=np.full_like(vals, np.inf), where=wts > 0)\n\n    # Normalisation with clipping\n    def norm(x: np.ndarray) -> np.ndarray:\n        lo = np.nanmin(x)\n        hi = np.nanmax(x)\n        return np.clip((x - lo) / (hi - lo + 1e-12), 0, 1)\n\n    vN = norm(vals)\n    dN = norm(dens)\n    fN = norm(np.divide(\n        wts,\n        max(1.0, float(remaining_capacity)),\n        out=np.full_like(wts, 0.0),\n        where=remaining_capacity > 0,\n    ))\n\n    # Weighted sum with altered weights\n    scores = 0.4 * vN + 0.4 * dN + 0.2 * fN\n\n    # Add small random noise for tie\u2011breaking\n    scores += np.random.uniform(-1e-6, 1e-6, size=scores.shape)\n\n    j = int(np.nanargmax(scores))\n    return fit[j]\n\n",
  "defensive_greedy_max_of_all_aug_100": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    vals = np.array([v for (w, v, _) in fit], dtype=float)\n    wts  = np.array([w for (w, _, _) in fit], dtype=float)\n\n    dens = np.divide(vals, wts, out=np.full_like(vals, np.inf), where=wts > 0)\n\n    # Log\u2011based scoring (semantic change)\n    v_log = np.log(np.maximum(vals, 1e-12))\n    d_log = np.log(np.maximum(dens, 1e-12))\n    f_log = np.log(np.maximum(wts / max(1.0, float(remaining_capacity)), 1e-12))\n\n    def norm(x: np.ndarray) -> np.ndarray:\n        lo = np.nanmin(x)\n        hi = np.nanmax(x)\n        return np.clip((x - lo) / (hi - lo + 1e-12), 0, 1)\n\n    vN = norm(v_log)\n    dN = norm(d_log)\n    fN = norm(f_log)\n\n    scores = 0.5 * vN + 0.5 * dN  # ignore weight\u2011fill term\n\n    # Random choice among top\u20113 after sorting\n    top_k = min(3, len(scores))\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    chosen = np.random.choice(top_indices)\n\n    return tuple(fit[chosen])\n\n",
  "max_of_two_density_or_value_aug_101": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = []\n    i = 0\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity:\n            fit.append((w, v, idx))\n        i += 1\n    if not fit:\n        return None\n\n    vals = np.array([v for _, v, _ in fit], dtype=float)\n    dens = np.array([v / (w + 1e-12) if w > 0 else (np.inf if v > 0 else -np.inf) for w, v, _ in fit], dtype=float)\n    dens = np.clip(dens, -1e18, 1e18)\n\n    def _norm(x: np.ndarray) -> np.ndarray:\n        lo, hi = np.nanmin(x), np.nanmax(x)\n        return (x - lo) / (hi - lo + 1e-12)\n\n    vN = _norm(vals)\n    dN = _norm(dens)\n    scores = 0.6 * vN + 0.4 * dN\n\n    # Deterministic tie\u2011breaking with a tiny noise\n    scores += 1e-8 * np.arange(len(scores))\n    j = int(np.argmax(scores))\n    return fit[j]\n\n",
  "max_of_two_density_or_value_aug_102": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = []\n    idx = 0\n    while idx < len(remaining_items):\n        w, v, i = remaining_items[idx]\n        if w <= remaining_capacity:\n            fit.append((w, v, i))\n        idx += 1\n    if not fit:\n        return None\n\n    vals = np.array([v for _, v, _ in fit], dtype=float)\n    dens = np.divide(vals, np.array([w for w, _, _ in fit], dtype=float) + 1e-12,\n                     out=np.full(len(vals), np.inf, dtype=float),\n                     where=np.array([w for w, _, _ in fit], dtype=float) > 0)\n    dens = np.nan_to_num(dens, nan=-1e18, posinf=1e18, neginf=-1e18)\n    dens = np.clip(dens, -1e18, 1e18)\n\n    def _norm(x):\n        lo = np.nanmedian(x)\n        hi = np.nanmax(x)\n        return (x - lo) / (hi - lo + 1e-12)\n\n    vN = _norm(vals)\n    dN = _norm(dens)\n    scores = 0.7 * vN + 0.3 * dN\n\n    # Small deterministic noise for tie\u2011breaking\n    scores += 1e-7 * np.arange(len(scores))\n\n    # Randomly pick among the two best candidates\n    top_k = 2\n    top_idx = np.argpartition(-scores, top_k - 1)[:top_k]\n    rng = np.random.default_rng(123)\n    chosen = rng.choice(top_idx)\n    return fit[chosen]\n\n",
  "max_of_two_density_or_value_aug_103": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = []\n    pos = 0\n    while pos < len(remaining_items):\n        w, v, idx = remaining_items[pos]\n        if w <= remaining_capacity:\n            fit.append((w, v, idx))\n        pos += 1\n    if not fit:\n        return None\n\n    vals = np.array([v for _, v, _ in fit], dtype=float)\n    dens = np.array([v / (w + 1e-12) if w > 0 else (np.inf if v > 0 else -np.inf) for w, v, _ in fit], dtype=float)\n    dens = np.clip(dens, -1e18, 1e18)\n\n    def _norm(x):\n        lo, hi = np.nanmedian(x), np.nanmax(x)\n        return (x - lo) / (hi - lo + 1e-12)\n\n    vN = _norm(vals)\n    dN = _norm(dens)\n    scores = np.maximum(vN, dN)\n\n    # Deterministic noise for tie\u2011breaking\n    scores += 1e-9 * np.arange(len(scores))\n\n    # Randomly select among the five best\n    top_k = 5\n    top_idx = np.argpartition(-scores, top_k - 1)[:top_k]\n    rng = np.random.default_rng(99)\n    chosen = rng.choice(top_idx)\n    return fit[chosen]\n\n",
  "heavy_if_high_value_quantile_aug_104": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    weights = np.array([w for w, _, _ in fit_items], dtype=float)\n    values  = np.array([v for _, v, _ in fit_items], dtype=float)\n    indices = np.array([idx for _, _, idx in fit_items], dtype=int)\n\n    # Threshold at 75th percentile of values\n    q75 = float(np.quantile(values, 0.75))\n\n    C = float(max(1, remaining_capacity))\n\n    # Compute scores vectorized\n    heavy_mask = values >= q75\n    scores = np.where(\n        heavy_mask,\n        values + 0.3 * (weights / C) * values,\n        values / (weights + 1e-12)   # epsilon added\n    )\n\n    best_pos = int(np.argmax(scores))\n    return (int(weights[best_pos]), int(values[best_pos]), int(indices[best_pos]))\n\n",
  "heavy_if_high_value_quantile_aug_105": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            fit.append((w, v, idx))\n    if not fit:\n        return None\n\n    weights = np.array([w for w, _, _ in fit], dtype=float)\n    values  = np.array([v for _, v, _ in fit], dtype=float)\n    indices = np.array([idx for _, _, idx in fit], dtype=int)\n\n    # Threshold using mean of values\n    mean_val = float(np.mean(values))\n\n    C = float(max(1, remaining_capacity))\n    eps = 1e-12\n\n    scores = []\n    for w, v in zip(weights, values):\n        if v >= mean_val:\n            score = v + 0.25 * (w / C) * v\n        else:\n            score = v / (w + eps)\n        scores.append(score)\n\n    scores = np.array(scores)\n    # Add small deterministic noise to break ties\n    noise = np.arange(len(scores)) * 1e-6\n    scores += noise\n\n    # Identify top\u20113 scores\n    top_k = 3\n    if len(scores) <= top_k:\n        candidates = np.argsort(-scores)\n    else:\n        threshold = np.partition(-scores, top_k-1)[top_k-1]\n        candidates = np.where(-scores >= threshold)[0]\n\n    chosen = int(np.random.choice(candidates))\n    return (int(weights[chosen]), int(values[chosen]), int(indices[chosen]))\n\n",
  "heavy_if_high_value_quantile_aug_106": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    weights = np.array([w for w, _, _ in fit], dtype=float)\n    values  = np.array([v for _, v, _ in fit], dtype=float)\n    indices = np.array([idx for _, _, idx in fit], dtype=int)\n\n    # Use median as threshold\n    thresh = float(np.median(values))\n\n    C = float(max(1, remaining_capacity))\n    eps = 1e-12\n\n    # Compute raw scores\n    raw = np.where(\n        values >= thresh,\n        values + 0.2 * (weights / C) * values,\n        values / (weights + eps)\n    )\n\n    # Softmax probabilities\n    exp_scores = np.exp(raw - np.max(raw))  # stability\n    probs = exp_scores / (np.sum(exp_scores) + eps)\n\n    # Add deterministic noise to probabilities\n    noise = np.arange(len(probs)) * 1e-7\n    probs = np.clip(probs + noise, 0, 1)\n    probs = probs / (np.sum(probs) + eps)\n\n    chosen = int(np.random.choice(len(probs), p=probs))\n    return (int(weights[chosen]), int(values[chosen]), int(indices[chosen]))\n\n",
  "heavy_if_high_value_quantile_aug_107": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = []\n    i = 0\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity:\n            fit.append((w, v, idx))\n        i += 1\n    if not fit:\n        return None\n\n    weights = np.array([w for w, _, _ in fit], dtype=float)\n    values  = np.array([v for _, v, _ in fit], dtype=float)\n    indices = np.array([idx for _, _, idx in fit], dtype=int)\n\n    # Threshold using maximum value\n    max_val = float(np.max(values))\n\n    C = float(max(1, remaining_capacity))\n    eps = 1e-12\n\n    # Compute scores with density clipped to [0,1]\n    density = np.clip(values / (weights + eps), 0, 1)\n    scores = np.where(\n        values >= max_val,\n        values + 0.15 * (weights / C) * values,\n        density\n    )\n\n    # Find best score\n    best_idx = int(np.argmax(scores))\n    return (int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx]))\n\n",
  "heavy_if_high_value_quantile_aug_108": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    weights = np.array([w for w, _, _ in fit], dtype=float)\n    values  = np.array([v for _, v, _ in fit], dtype=float)\n    indices = np.array([idx for _, _, idx in fit], dtype=int)\n\n    # Compute density and clip to [0, 1]\n    eps = 1e-12\n    density = np.clip(values / (weights + eps), 0, 1)\n\n    # Threshold at 90th percentile of values\n    thresh = float(np.percentile(values, 90))\n\n    C = float(max(1, remaining_capacity))\n\n    scores = np.where(\n        values >= thresh,\n        values + 0.4 * (weights / C) * values,\n        density\n    )\n\n    # Randomly select among top\u20115 scores\n    top_k = 5\n    if len(scores) <= top_k:\n        candidates = np.argsort(-scores)\n    else:\n        threshold_score = np.partition(-scores, top_k-1)[top_k-1]\n        candidates = np.where(-scores >= threshold_score)[0]\n\n    chosen = int(np.random.choice(candidates))\n    return (int(weights[chosen]), int(values[chosen]), int(indices[chosen]))\n\n",
  "small_item_packability_bias_aug_109": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Filter items that fit\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    weights, values, indices = np.array(fit, dtype=float).T\n    median_w = np.median(weights) + 1e-12\n\n    # Compute densities and packability\n    density = values / (weights + 1e-12)\n    pack = 1.0 / (1.0 + weights / median_w)\n    pack = np.clip(pack, 0.0, 1.0)\n\n    # Deterministic noise to break ties\n    noise = np.arange(len(fit)) * 1e-9\n\n    # Combined score\n    scores = density * pack + noise\n\n    # Find index of best item\n    best_idx = int(np.argmax(scores))\n    return int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx])\n\n",
  "small_item_packability_bias_aug_110": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Fit items\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    w_arr, v_arr, idx_arr = np.array(fit, dtype=float).T\n    mean_w = np.mean(w_arr) + 1e-12\n\n    # Density and packability\n    density = v_arr / (w_arr + 1e-12)\n    pack = 1.0 / (1.0 + w_arr / mean_w)\n    pack = np.clip(pack, 0.0, 1.0)\n\n    # Weighted score: 0.7 density + 0.3 pack\n    scores = 0.7 * density + 0.3 * pack\n\n    # Small deterministic noise (seeded RNG for reproducibility)\n    rng = np.random.default_rng(42)\n    noise = rng.uniform(0, 1e-9, size=scores.shape)\n    scores += noise\n\n    best = int(np.argmax(scores))\n    return int(w_arr[best]), int(v_arr[best]), int(idx_arr[best])\n\n",
  "small_item_packability_bias_aug_111": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    w_arr, v_arr, idx_arr = np.array(fit, dtype=float).T\n    median_w = np.median(w_arr) + 1e-12\n\n    density = v_arr / (w_arr + 1e-12)\n    pack = 1.0 / (1.0 + w_arr / median_w)\n    pack = np.clip(pack, 0.0, 1.0)\n\n    scores = density * pack\n\n    # Top\u2011k selection\n    k = 3\n    if len(scores) <= k:\n        top_indices = np.arange(len(scores))\n    else:\n        top_indices = np.argpartition(-scores, k-1)[:k]\n    rng = np.random.default_rng(1)\n    chosen = int(rng.choice(top_indices))\n    return int(w_arr[chosen]), int(v_arr[chosen]), int(idx_arr[chosen])\n\n",
  "small_item_packability_bias_aug_112": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    w_arr, v_arr, idx_arr = np.array(fit, dtype=float).T\n    median_w = np.median(w_arr) + 1e-12\n\n    density = v_arr / (w_arr + 1e-12)\n    # Proxy for packability: heavier items get lower scores\n    pack_proxy = w_arr / (median_w + 1e-12)\n    pack_proxy = np.clip(pack_proxy, 1e-12, None)\n\n    scores = density / pack_proxy\n\n    best = int(np.argmax(scores))\n    return int(w_arr[best]), int(v_arr[best]), int(idx_arr[best])\n\n",
  "expected_fill_probability_aug_113": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Statistics over all remaining weights\n    all_w = np.array([w for w, _, _ in remaining_items if w > 0], dtype=float)\n    mu = float(np.mean(all_w)) if all_w.size else 0.0\n    sd = float(np.std(all_w)) + 1e-12\n\n    # Vectorised scoring\n    w_arr = np.array([w for w, _, _ in fit], dtype=float)\n    v_arr = np.array([v for _, v, _ in fit], dtype=float)\n    C = float(remaining_capacity)\n\n    leftover = C - w_arr\n    closeness = np.exp(-((leftover - mu) ** 2) / (2.0 * sd * sd))\n    density = np.clip(v_arr / (w_arr + 1e-12), 0, 1e6)\n    scores = density * (0.5 + 0.5 * closeness)\n\n    # Small deterministic noise to break ties\n    noise = np.random.uniform(-1e-6, 1e-6, size=scores.shape)\n    scores += noise\n\n    best_idx = int(np.argmax(scores))\n    return fit[best_idx]\n\n",
  "expected_fill_probability_aug_114": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    all_w = np.array([w for w, _, _ in remaining_items if w > 0], dtype=float)\n    mu = float(np.median(all_w)) if all_w.size else 0.0\n    sd = float(np.std(all_w)) + 1e-12\n\n    w_arr = np.array([w for w, _, _ in fit], dtype=float)\n    v_arr = np.array([v for _, v, _ in fit], dtype=float)\n    C = float(remaining_capacity)\n\n    leftover = C - w_arr\n    closeness = np.exp(-((leftover - mu) ** 2) / (4.0 * sd * sd))  # heavier weight on closeness\n    density = np.clip(v_arr / (w_arr + 1e-12), 0, 1e6)\n    scores = density * (0.3 + 0.7 * closeness)\n\n    # Softmin selection with random tie\u2011break among top\u20113\n    softmin = np.exp(-scores)\n    top_k = 3\n    idxs = np.argsort(softmin)[:top_k]\n    best_idx = int(np.random.choice(idxs)) if idxs.size else int(np.argmin(scores))\n    return fit[best_idx]\n\n",
  "expected_fill_probability_aug_115": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    all_w = np.array([w for w, _, _ in remaining_items if w > 0], dtype=float)\n    mu = float(np.mean(all_w)) if all_w.size else 0.0\n    sd = float(np.std(all_w)) + 1e-12\n    C = float(remaining_capacity)\n\n    best_item = None\n    best_score = -np.inf\n    i = 0\n    while i < len(fit):\n        w, v, idx = fit[i]\n        leftover = C - float(w)\n        closeness = np.exp(-((leftover - mu) ** 2) / (2.0 * sd * sd))\n        density = np.clip(float(v) / (w + 1e-12), 0, 1e6)\n        score = density * (0.6 + 0.4 * closeness)\n\n        # Deterministic tie\u2011break using a tiny epsilon\n        if score > best_score + 1e-9:\n            best_score, best_item = score, (w, v, idx)\n        i += 1\n\n    return best_item\n\n",
  "expected_fill_probability_aug_116": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    all_w = np.array([w for w, _, _ in remaining_items if w > 0], dtype=float)\n    mu = float(np.mean(all_w)) if all_w.size else 0.0\n    sd = float(np.std(all_w)) + 1e-12\n    C = float(remaining_capacity)\n\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w > C:\n            continue\n\n        leftover = C - float(w)\n        # Proxy for exp: rational approximation\n        closeness = 1.0 / (1.0 + ((leftover - mu) / sd) ** 2)\n\n        density = np.clip(float(v) / (w + 1e-12), 0, 1e6)\n        score = density * (0.4 + 0.6 * closeness)\n\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "expected_fill_probability_aug_117": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    all_w = np.array([w for w, _, _ in remaining_items if w > 0], dtype=float)\n    mu = float(np.mean(all_w)) if all_w.size else 0.0\n    sd = float(np.std(all_w)) + 1e-12\n    C = float(remaining_capacity)\n    total_weight = float(np.sum(all_w)) + 1e-12\n\n    scores = []\n    for w, v, idx in fit:\n        leftover = C - float(w)\n        closeness = np.exp(-((leftover - mu) ** 2) / (3.0 * sd * sd))\n        density = np.clip(float(v) / (w + 1e-12), 0, 1e6)\n        # Scale by total remaining weight to favour heavier items\n        score = density * (total_weight / (C + 1e-12)) * (0.2 + 0.8 * closeness)\n        scores.append(score)\n\n    best_idx = int(np.argmax(np.array(scores)))\n    return fit[best_idx]\n\n",
  "maximize_value_then_density_tie_aug_118": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    weights = np.array([it[0] for it in remaining_items], dtype=np.int64)\n    values = np.array([it[1] for it in remaining_items], dtype=np.int64)\n    indices = np.array([it[2] for it in remaining_items], dtype=np.int64)\n\n    # Keep only items that fit in the remaining capacity\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    w_fit = weights[fit_mask]\n    v_fit = values[fit_mask]\n    i_fit = indices[fit_mask]\n\n    # Density with epsilon to avoid division by zero\n    densities = np.divide(v_fit, np.maximum(w_fit, 1e-12))\n    densities = np.clip(densities, 0, np.inf)\n\n    # Deterministic noise to break ties\n    noise = i_fit.astype(np.float64) * 1e-9\n    densities += noise\n\n    # Lexicographic ordering: first by value, then by density\n    order = np.lexsort((densities, v_fit))\n    best_idx = order[-1]\n\n    return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(i_fit[best_idx]))\n\n",
  "maximize_value_then_density_tie_aug_119": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = []\n\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            density = float(v) / max(1e-12, float(w))\n            # Deterministic noise to break ties\n            density += idx * 1e-9\n            candidates.append((w, v, idx, density))\n\n    if not candidates:\n        return None\n\n    # Sort by value (descending) and then by noisy density\n    candidates.sort(key=lambda x: (x[1], x[3]), reverse=True)\n\n    # Keep a fixed number of top candidates\n    top_k = min(7, len(candidates))\n    top_candidates = candidates[:top_k]\n\n    # Randomly pick one among the best k\n    chosen = np.random.choice(len(top_candidates))\n    w, v, idx, _ = top_candidates[chosen]\n    return (w, v, idx)\n\n",
  "maximize_value_then_density_tie_aug_120": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_value = -np.inf\n    best_density = -np.inf\n\n    for w, v, idx in remaining_items:\n        if w > remaining_capacity:   # inverted check\n            continue\n\n        density = float(v) / max(1e-12, float(w))\n        density = np.clip(density, 0, np.inf)\n        density += idx * 1e-9          # deterministic noise\n\n        if (v > best_value) or (v == best_value and density > best_density):\n            best_value = v\n            best_density = density\n            best_item = (w, v, idx)\n\n    return best_item\n\n",
  "maximize_value_then_density_tie_aug_121": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = []\n\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            density = float(v) / max(1e-12, float(w))\n            score = 0.6 * v + 0.4 * density\n            candidates.append((w, v, idx, score))\n\n    if not candidates:\n        return None\n\n    # Sort by the composite score\n    candidates.sort(key=lambda x: x[3], reverse=True)\n\n    # Keep only the best few candidates\n    top_k = min(5, len(candidates))\n    top_candidates = candidates[:top_k]\n\n    # Randomly pick one among the best k\n    chosen = np.random.choice(len(top_candidates))\n    w, v, idx, _ = top_candidates[chosen]\n    return (w, v, idx)\n\n",
  "maximize_value_then_density_tie_aug_122": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    remaining = list(remaining_items)   # copy to avoid side effects\n    best_item = None\n    best_score = -np.inf\n\n    while remaining:\n        w, v, idx = remaining.pop()\n        if w > remaining_capacity:\n            continue\n\n        density = float(v) / max(1e-12, float(w))\n        density = np.clip(density, 0, np.inf)\n\n        # Simple composite score\n        score = v + density\n        score += idx * 1e-9          # deterministic noise\n\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n\n    return best_item\n\n",
  "knapsack_core_bias_midweight_aug_123": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    cap = float(max(1, remaining_capacity))\n    target = 0.5 * cap\n    idx = 0\n    while idx < len(remaining_items):\n        w, v, i = remaining_items[idx]\n        # Immediate zero\u2011weight, positive\u2011value item\n        if w == 0 and v > 0:\n            return (w, v, i)\n        if w > 0 and w <= remaining_capacity:\n            dens = float(v) / (float(w) + 1e-12)\n            clos = np.clip(1.0 - abs(float(w) - target) / (target + 1e-12), 0.0, 1.0)\n            # Hyper\u2011parameter tuning: give more weight to closeness\n            score = dens * (0.7 + 0.3 * clos)\n            # Deterministic tie\u2011breaker\n            noise = (i % 1000) / 1e6\n            if score + noise > best_score:\n                best_score = score + noise\n                best_item = (w, v, i)\n        idx += 1\n    return best_item\n\n",
  "knapsack_core_bias_midweight_aug_124": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    items_arr = np.array(remaining_items, dtype=np.int64)\n    w_arr, v_arr, idx_arr = items_arr[:, 0], items_arr[:, 1], items_arr[:, 2]\n\n    # Immediate zero\u2011weight, positive\u2011value item\n    zero_mask = (w_arr == 0) & (v_arr > 0)\n    if np.any(zero_mask):\n        z = np.argmax(zero_mask)\n        return (int(w_arr[z]), int(v_arr[z]), int(idx_arr[z]))\n\n    cap = float(max(1, remaining_capacity))\n    target = 0.5 * cap\n\n    valid_mask = (w_arr > 0) & (w_arr <= remaining_capacity)\n    if not np.any(valid_mask):\n        return None\n\n    dens = v_arr[valid_mask] / (w_arr[valid_mask] + 1e-12)\n    clos = 1.0 - np.clip(np.abs(w_arr[valid_mask] - target) / (target + 1e-12), 0.0, 1.0)\n    score = dens * (0.6 + 0.4 * clos)\n\n    # Deterministic noise based on original index\n    noise = (idx_arr[valid_mask] % 1000) / 1e6\n    scores = score + noise\n\n    best_idx = np.argmax(scores)\n    best_item = (\n        int(w_arr[valid_mask][best_idx]),\n        int(v_arr[valid_mask][best_idx]),\n        int(idx_arr[valid_mask][best_idx]),\n    )\n    return best_item\n\n",
  "knapsack_core_bias_midweight_aug_125": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for w, v, i in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    candidates = [(w, v, i) for w, v, i in remaining_items if w > 0 and w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    cap = float(max(1, remaining_capacity))\n    target = 0.5 * cap\n\n    scores = []\n    for w, v, i in candidates:\n        dens = float(v) / (float(w) + 1e-12)\n        clos = np.clip(1.0 - abs(float(w) - target) / (target + 1e-12), 0.0, 1.0)\n        score = dens * (0.4 + 0.6 * clos)\n        scores.append((score, (w, v, i)))\n\n    # Select top\u2011k (k=3) and pick deterministically among them\n    top_k = min(3, len(scores))\n    scores.sort(key=lambda x: x[0], reverse=True)\n    top_items = [item for _, item in scores[:top_k]]\n\n    seed = int(remaining_capacity) % (2**32 - 1)\n    rng = np.random.default_rng(seed)\n    chosen = rng.choice(top_items)\n    return tuple(chosen)\n\n",
  "knapsack_core_bias_midweight_aug_126": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    cap = float(max(1, remaining_capacity))\n    target = 0.5 * cap\n\n    idx = len(remaining_items) - 1\n    while idx >= 0:\n        w, v, i = remaining_items[idx]\n        # Immediate zero\u2011weight, positive\u2011value item\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n        if w > 0 and w <= remaining_capacity:\n            dens = float(v) / (float(w) + 1e-12)\n            clos = np.clip(1.0 - abs(float(w) - target) / (target + 1e-12), 0.0, 1.0)\n            # Different scoring: emphasize density\n            score = (dens ** 0.8) * (clos ** 0.2)\n            noise = (i % 100) / 1e6\n            if score + noise > best_score:\n                best_score = score + noise\n                best_item = (w, v, i)\n        idx -= 1\n    return best_item\n\n",
  "knapsack_core_bias_midweight_aug_127": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for w, v, i in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    cap = float(max(1, remaining_capacity))\n    target = 0.5 * cap\n\n    candidates = [(w, v, i) for w, v, i in remaining_items if w > 0 and w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    def score_fn(item: Tuple[int, int, int]) -> float:\n        w, v, i = item\n        dens = float(v) / (float(w) + 1e-12)\n        clos = np.clip(1.0 - abs(float(w) - target) / (target + 1e-12), 0.0, 1.0)\n        return dens * (0.5 + 0.5 * clos)\n\n    # Max with tie\u2011breaker (higher original index preferred)\n    best_item = max(candidates, key=lambda it: (score_fn(it), -it[2]))\n    return best_item\n\n",
  "bounded_ratio_with_beta_mean_weight_aug_128": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    items = remaining_items\n    weights = np.array([w for (w, _, _) in items if w > 0], dtype=float)\n    beta = float(np.median(weights)) if weights.size else 1.0\n    best_item = None\n    best_score = -np.inf\n    i = 0\n    while i < len(items):\n        w, v, idx = items[i]\n        if w <= remaining_capacity:\n            denom = float(w) + beta + 1e-12          # epsilon to avoid div\u2011by\u2011zero\n            score = np.clip(float(v) / denom, 0, 1e6)  # clip to keep values sane\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        i += 1\n    return best_item\n\n",
  "bounded_ratio_with_beta_mean_weight_aug_129": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    arr = np.array(remaining_items, dtype=object)\n    fit_mask = arr[:, 0] <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n    fit = arr[fit_mask]\n    weights = fit[:, 0].astype(float)\n    values = fit[:, 1].astype(float)\n    idxs = fit[:, 2].astype(float)\n    beta = float(np.mean(weights)) if weights.size else 1.0\n    denom = weights + beta + 1e-12\n    noise = 1e-6 * idxs                               # deterministic noise\n    scores = np.clip(values / denom + noise, 0, 1e6)    # clip to avoid extreme values\n    best_idx = np.argmax(scores)\n    return (int(weights[best_idx]), int(values[best_idx]), int(idxs[best_idx]))\n\n",
  "bounded_ratio_with_beta_mean_weight_aug_130": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    items = remaining_items\n    weights = np.array([w for (w, _, _) in items if w > 0], dtype=float)\n    beta = float(np.max(weights)) if weights.size else 1.0\n    best_item = None\n    best_score = -np.inf\n    i = 0\n    while i < len(items):\n        w, v, idx = items[i]\n        if w <= remaining_capacity:\n            denom = float(w) + beta + 1e-12\n            score = np.clip(float(v) / denom, 0, 1e6)\n            # deterministic tie\u2011break using index\n            if score + 1e-6 * idx > best_score:\n                best_score = score + 1e-6 * idx\n                best_item = (w, v, idx)\n        i += 1\n    return best_item\n\n",
  "sigmoid_density_softcap_aug_131": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Capacity guard and base for normalization\n    C = float(max(1, remaining_capacity))\n\n    # Immediate return for zero\u2011weight items with positive value\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Build list of valid densities\n    densities = [float(v) / float(w) for w, v, _ in remaining_items\n                 if 0 < w <= remaining_capacity]\n\n    mu = np.mean(densities) if densities else 0.0\n    sd = np.std(densities) + 1e-12  # epsilon to avoid division by zero\n\n    best_item = None\n    best_score = -np.inf\n\n    # Iterate again to compute scores\n    for w, v, idx in remaining_items:\n        if 0 < w <= remaining_capacity:\n            d = float(v) / float(w)\n            z = (d - mu) / sd\n            sig = 1.0 / (1.0 + np.exp(-z))\n            score = sig * (float(w) / C) + 1e-6 * idx  # deterministic tie\u2011break\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "sigmoid_density_softcap_aug_132": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    C = float(max(1, remaining_capacity))\n\n    # Immediate zero\u2011weight positive\u2011value return\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    densities = [float(v) / float(w) for w, v, _ in remaining_items\n                 if 0 < w <= remaining_capacity]\n\n    mu = np.mean(densities) if densities else 0.0\n    sd = np.std(densities) + 1e-12\n\n    scores = []\n    for w, v, idx in remaining_items:\n        if 0 < w <= remaining_capacity:\n            d = float(v) / float(w)\n            z = (d - mu) / sd\n            sig = 1.0 / (1.0 + np.exp(-z))\n            # sqrt scaling and deterministic noise\n            score = sig * np.sqrt(float(w) / C) + 1e-6 * idx\n            scores.append((score, (w, v, idx)))\n\n    if not scores:\n        return None\n\n    # Select the top\u2011k candidates\n    scores.sort(key=lambda x: x[0], reverse=True)\n    top_k = 5\n    top_candidates = [item for _, item in scores[:top_k]]\n\n    # Randomly pick one of the top candidates (reproducible)\n    rng = np.random.default_rng(12345)\n    chosen = rng.choice(top_candidates)\n    return chosen\n\n",
  "sigmoid_density_softcap_aug_133": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    C = float(max(1, remaining_capacity))\n\n    # Handle zero\u2011weight positive\u2011value items first\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    densities = [float(v) / float(w) for w, v, _ in remaining_items\n                 if 0 < w <= remaining_capacity]\n\n    if densities:\n        mu = np.median(densities)\n        sd = (max(densities) - min(densities)) + 1e-12\n    else:\n        mu, sd = 0.0, 1e-12\n\n    # Pre\u2011compute softmin denominator\n    exp_neg = np.exp(-np.array(densities))\n    softmin_den = np.sum(exp_neg) + 1e-12\n\n    best_item = None\n    best_score = -np.inf\n\n    for w, v, idx in remaining_items:\n        if 0 < w <= remaining_capacity:\n            d = float(v) / float(w)\n            softmin = np.exp(-d) / softmin_den\n            score = softmin * (float(w) / C) + 1e-6 * idx\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "sigmoid_density_softcap_aug_134": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    C = float(max(1, remaining_capacity))\n\n    # Convert to numpy arrays\n    w_arr = np.array([w for w, _, _ in remaining_items], dtype=float)\n    v_arr = np.array([v for _, v, _ in remaining_items], dtype=float)\n    idx_arr = np.array([idx for _, _, idx in remaining_items], dtype=int)\n\n    # Immediate return for any zero\u2011weight positive\u2011value item\n    zero_mask = (w_arr == 0) & (v_arr > 0)\n    if np.any(zero_mask):\n        z_idx = np.argmax(zero_mask)\n        return (int(w_arr[z_idx]), int(v_arr[z_idx]), int(idx_arr[z_idx]))\n\n    # Mask for items that can be considered\n    valid_mask = (w_arr > 0) & (w_arr <= remaining_capacity)\n    if not np.any(valid_mask):\n        return None\n\n    w_valid = w_arr[valid_mask]\n    v_valid = v_arr[valid_mask]\n    idx_valid = idx_arr[valid_mask]\n\n    densities = v_valid / w_valid\n    mu = np.mean(densities)\n    sd = np.std(densities) + 1e-12\n\n    z = (densities - mu) / sd\n    sig = 1.0 / (1.0 + np.exp(-z))\n    scores = sig * (w_valid / C)\n\n    # Add deterministic noise for tie\u2011breaking\n    scores += 1e-6 * idx_valid\n\n    # Clip to avoid extreme values\n    scores = np.clip(scores, -1e9, 1e9)\n\n    best_idx = np.argmax(scores)\n    return (int(w_valid[best_idx]),\n            int(v_valid[best_idx]),\n            int(idx_valid[best_idx]))\n\n",
  "minimize_slack_then_max_density_aug_135": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best = None\n    best_left = None\n    best_dens = -np.inf\n    idx = 0\n    while idx < len(remaining_items):\n        w, v, id_ = remaining_items[idx]\n        if w <= remaining_capacity:\n            left = np.clip(remaining_capacity - w, 0, remaining_capacity)\n            dens = float(v) / max(1e-12, float(w))\n            if best_left is None or left < best_left or (left == best_left and dens > best_dens):\n                best_left = left\n                best_dens = dens\n                best = (w, v, id_)\n        idx += 1\n    return best\n\n",
  "minimize_slack_then_max_density_aug_136": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = []\n    for w, v, id_ in remaining_items:\n        if w <= remaining_capacity:\n            left = remaining_capacity - w\n            dens = float(v) / max(1e-12, float(w))\n            # soft\u2011min score: lower is better\n            score = left + 0.5 * (1.0 / dens)\n            candidates.append((score, w, v, id_))\n    if not candidates:\n        return None\n    scores = np.array([c[0] for c in candidates])\n    top_k = min(3, len(scores))\n    top_idx = np.argpartition(scores, top_k - 1)[:top_k]\n    chosen = np.random.choice(top_idx)\n    _, w, v, id_ = candidates[chosen]\n    return (w, v, id_)\n\n",
  "minimize_slack_then_max_density_aug_137": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best = None\n    best_left = None\n    best_dens = -np.inf\n    for idx, (w, v, id_) in enumerate(remaining_items):\n        if w <= remaining_capacity:\n            # deterministic tie\u2011breaker: tiny noise based on index\n            left = remaining_capacity - w + idx * 1e-9\n            dens = float(v) / max(1e-12, float(w))\n            if best_left is None or left < best_left or (left == best_left and dens > best_dens):\n                best_left = left\n                best_dens = dens\n                best = (w, v, id_)\n    return best\n\n",
  "minimize_slack_then_max_density_aug_138": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n    weights = np.array([w for w, _, _ in remaining_items], dtype=np.float64)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=np.float64)\n    indices = np.arange(len(remaining_items), dtype=np.int64)\n\n    mask = weights <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    left_arr  = np.clip(remaining_capacity - weights[mask], 0, remaining_capacity)\n    dens_arr  = values[mask] / np.clip(weights[mask], 1e-12, None)\n    score_arr = left_arr + 0.3 * (1.0 / dens_arr)          # weighted sum\n\n    best_idx = np.argmin(score_arr)\n    w, v, id_ = remaining_items[indices[mask][best_idx]]\n    return (w, v, id_)\n\n",
  "density_minus_leftover_fraction_penalty_aug_139": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    if not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=np.int64)\n    weights = arr[:, 0].astype(np.float64)\n    values = arr[:, 1].astype(np.float64)\n    indices = arr[:, 2]\n\n    mask = (weights <= remaining_capacity) & (weights > 0)\n    if not np.any(mask):\n        zero_mask = (weights == 0) & (values > 0)\n        if np.any(zero_mask):\n            zidx = np.argmax(zero_mask)\n            return (int(weights[zidx]), int(values[zidx]), int(indices[zidx]))\n        return None\n\n    valid_w = weights[mask]\n    valid_v = values[mask]\n    valid_idx = indices[mask]\n\n    C = float(max(1, remaining_capacity))\n    gamma = 0.6\n\n    densities = valid_v / (valid_w + eps)\n    leftover = (C - valid_w) / (C + eps)\n    leftover = np.clip(leftover, 0, 1)\n    scores = densities - gamma * leftover\n\n    best_pos = np.argmax(scores)\n    return (int(valid_w[best_pos]), int(valid_v[best_pos]), int(valid_idx[best_pos]))\n\n",
  "density_minus_leftover_fraction_penalty_aug_140": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    gamma = 0.5\n\n    idx_iter = 0\n    while idx_iter < len(remaining_items):\n        w, v, idx = remaining_items[idx_iter]\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / (float(w) + eps)\n            leftover = (C - float(w)) / (C + eps)\n            leftover = np.clip(leftover, 0, 1)\n            score = dens - gamma * leftover\n            score += 1e-9 * idx_iter  # deterministic tie\u2011breaker\n            if score > best_score:\n                best_score = score\n                best_item = (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n        idx_iter += 1\n\n    return best_item\n\n",
  "density_minus_leftover_fraction_penalty_aug_141": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    gamma = 0.4\n\n    for w, v, idx in remaining_items:\n        if w == 0:\n            if v > 0:\n                return (w, v, idx)\n            continue\n        if w > remaining_capacity:\n            continue\n\n        dens_proxy = np.log(v + 1.0) / np.log(w + 1.0)\n        leftover = (C - float(w)) / (C + eps)\n        leftover = np.clip(leftover, 0, 1)\n        score = dens_proxy - gamma * leftover\n\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n\n    return best_item\n\n",
  "value_plus_density_aug_142": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    k = 0.15 * C\n    i = 0\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / (float(w) + 1e-12)\n            dens = np.clip(dens, 0, 1)\n            score = float(v) + k * dens + idx * 1e-9   # deterministic tie\u2011breaking\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n        i += 1\n    return best_item\n\n",
  "value_plus_density_aug_143": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    C = float(max(1, remaining_capacity))\n    k = 0.05 * C\n\n    # Filter items that fit and have positive weight\n    candidates = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity and w > 0]\n    if not candidates:\n        # Immediate return for zero\u2011weight positive\u2011value items\n        for w, v, idx in remaining_items:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n        return None\n\n    # Compute densities with epsilon and clip\n    densities = np.array([float(v) / (float(w) + 1e-12) for w, v, _ in candidates])\n    densities = np.clip(densities, 0, 1)\n    values = np.array([float(v) for _, v, _ in candidates])\n\n    # Score and deterministic noise\n    scores = values + k * densities + np.arange(len(candidates)) * 1e-9\n\n    # Select top\u2011k candidates\n    top_k = min(3, len(candidates))\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    top_scores = scores[top_indices]\n\n    # Find maximum score among top\u2011k\n    max_score = np.max(top_scores)\n    best_candidates = [candidates[i] for i in top_indices if scores[i] == max_score]\n\n    # Deterministic tie\u2011breaking: smallest index\n    best_item = min(best_candidates, key=lambda x: x[2])\n    return best_item\n\n",
  "value_plus_density_aug_144": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Immediate return for zero\u2011weight positive\u2011value items\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    if not remaining_items:\n        return None\n\n    items_arr = np.array(remaining_items, dtype=np.float64)\n    weights = items_arr[:, 0]\n    values = items_arr[:, 1]\n    indices = items_arr[:, 2].astype(int)\n\n    fit_mask = (weights <= remaining_capacity) & (weights > 0)\n    if not np.any(fit_mask):\n        return None\n\n    fit_weights = weights[fit_mask]\n    fit_values = values[fit_mask]\n    fit_indices = indices[fit_mask]\n\n    densities = fit_values / (fit_weights + 1e-12)\n    densities = np.clip(densities, 0, 1)\n\n    C = float(max(1, remaining_capacity))\n    k = 0.1 * C\n    scores = fit_values + k * densities + fit_indices * 1e-9   # deterministic noise\n\n    best_idx = np.argmax(scores)\n    return (int(fit_weights[best_idx]), int(fit_values[best_idx]), int(fit_indices[best_idx]))\n\n",
  "value_plus_density_aug_145": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Immediate return for zero\u2011weight positive\u2011value items\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    if not remaining_items:\n        return None\n\n    C = float(max(1, remaining_capacity))\n    k = 0.2 * C\n\n    scores = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / (float(w) + 1e-12)\n            dens = np.clip(dens, 0, 1)\n            score = float(v) + k * dens + idx * 1e-9\n            scores.append((score, w, v, idx))\n\n    if not scores:\n        return None\n\n    # Sort by score (desc), then by weight (asc), value (asc), index (asc) for deterministic tie\u2011breaking\n    sorted_scores = sorted(scores, key=lambda x: (-x[0], x[1], x[2], x[3]))\n    top_k = min(5, len(sorted_scores))\n    top_candidates = sorted_scores[:top_k]\n    best = top_candidates[0]\n    return (int(best[1]), int(best[2]), int(best[3]))\n\n",
  "density_with_small_gap_penalty_relative_item_aug_146": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Handle zero\u2011weight items that give positive value immediately\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    if not remaining_items:\n        return None\n\n    # Build numpy arrays for vectorised operations\n    weights   = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values    = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices   = np.array([idx for _, _, idx in remaining_items], dtype=int)\n\n    # Keep only items that fit into the remaining capacity\n    fit_mask = (weights <= remaining_capacity) & (weights > 0)\n    if not np.any(fit_mask):\n        return None\n    weights_fit   = weights[fit_mask]\n    values_fit    = values[fit_mask]\n    indices_fit   = indices[fit_mask]\n\n    eps = 1e-12\n    # Density and penalty computation\n    densities = values_fit / (weights_fit + eps)\n    densities = np.clip(densities, 0, np.inf)            # safety bound\n\n    leftovers = remaining_capacity - weights_fit\n    penalty = np.where(\n        (leftovers > 0) & (leftovers < 0.25 * weights_fit),\n        (0.25 * weights_fit - leftovers) / (np.maximum(1.0, weights_fit) + eps),\n        0.0\n    )\n    scores = densities - 0.75 * penalty\n\n    best_idx = np.argmax(scores)\n    return (int(weights_fit[best_idx]),\n            int(values_fit[best_idx]),\n            int(indices_fit[best_idx]))\n\n",
  "density_with_small_gap_penalty_relative_item_aug_147": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Immediate return for a zero\u2011weight, positive\u2011value item\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    candidates = []\n    eps = 1e-12\n\n    # First pass: gather fitting items and compute raw densities\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / (float(w) + eps)\n            dens = np.clip(dens, 0, np.inf)\n            candidates.append((w, v, idx, dens))\n\n    if not candidates:\n        return None\n\n    # Median density for normalisation\n    dens_array = np.array([c[3] for c in candidates])\n    median_dens = np.median(dens_array)\n\n    best_item = None\n    best_score = -np.inf\n\n    # Second pass: compute penalty, normalised score and apply deterministic tie\u2011breaker\n    for w, v, idx, dens in candidates:\n        leftover = remaining_capacity - w\n        penalty = 0.0\n        if 0 < leftover < 0.25 * w:\n            penalty = (0.25 * w - leftover) / (max(1.0, w) + eps)\n        # Normalise density by median and apply tuned penalty weight\n        score = (dens / (median_dens + eps)) - 0.5 * penalty\n        # Deterministic tie\u2011breaker: small offset proportional to index\n        score += 1e-6 * idx\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "density_with_small_gap_penalty_relative_item_aug_148": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Zero\u2011weight, positive\u2011value shortcut\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    if not remaining_items:\n        return None\n\n    # Build arrays\n    weights   = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values    = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices   = np.array([idx for _, _, idx in remaining_items], dtype=int)\n\n    # Keep items that fit\n    fit_mask = (weights <= remaining_capacity) & (weights > 0)\n    if not np.any(fit_mask):\n        return None\n    weights_fit   = weights[fit_mask]\n    values_fit    = values[fit_mask]\n    indices_fit   = indices[fit_mask]\n\n    eps = 1e-12\n    # Penalty for awkward leftover space\n    leftovers = remaining_capacity - weights_fit\n    penalty = np.where(\n        (leftovers > 0) & (leftovers < 0.25 * weights_fit),\n        (0.25 * weights_fit - leftovers) / (np.maximum(1.0, weights_fit) + eps),\n        0.0\n    )\n\n    # Proxy score: value minus a weighted weight and the penalty\n    proxy_score = values_fit - 0.3 * weights_fit - 0.6 * penalty\n    proxy_score = np.clip(proxy_score, 0, np.inf)  # safety bound\n\n    best_idx = np.argmax(proxy_score)\n    return (int(weights_fit[best_idx]),\n            int(values_fit[best_idx]),\n            int(indices_fit[best_idx]))\n\n",
  "top_density_then_maximize_fill_aug_149": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Gather items that can fit\n    ws, vs, ids = [], [], []\n    for w, v, idx in remaining_items:\n        if 0 < w <= remaining_capacity:\n            ws.append(w)\n            vs.append(v)\n            ids.append(idx)\n\n    if not ws:\n        return None\n\n    ws_np = np.array(ws, dtype=float)\n    vs_np = np.array(vs, dtype=float)\n\n    # Density with a tiny epsilon in the denominator\n    dens = vs_np / (ws_np + 1e-12)\n\n    # Threshold at the 75th percentile, clipped to [0, 1]\n    thr = np.quantile(dens, 0.75)\n    thr = np.clip(thr, 0, 1)\n\n    # Candidates above the threshold\n    mask = dens >= thr\n    if not np.any(mask):\n        return None\n\n    cand_ws = ws_np[mask]\n    cand_vs = vs_np[mask]\n    cand_ids = np.array(ids)[mask]\n    cand_dens = dens[mask]\n\n    # Pick the heaviest item, tie\u2011broken by density plus a tiny deterministic noise\n    best_idx = np.argmax(cand_ws + 1e-8 * cand_dens)\n    return (int(cand_ws[best_idx]), int(cand_vs[best_idx]), int(cand_ids[best_idx]))\n\n",
  "top_density_then_maximize_fill_aug_150": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    rng = np.random.default_rng(42)\n\n    # Zero\u2011weight positive\u2011value shortcut\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Build lists using a while loop\n    i = 0\n    ws, vs, ids = [], [], []\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if 0 < w <= remaining_capacity:\n            ws.append(w)\n            vs.append(v)\n            ids.append(idx)\n        i += 1\n\n    if not ws:\n        return None\n\n    ws_np = np.array(ws, dtype=float)\n    vs_np = np.array(vs, dtype=float)\n\n    # Weighted density: 0.6 * value / weight\n    dens = 0.6 * vs_np / (ws_np + 1e-12)\n    dens = np.clip(dens, 0, 1)\n\n    # Median threshold, clipped to [0, 1]\n    thr = np.median(dens)\n    thr = np.clip(thr, 0, 1)\n\n    mask = dens >= thr\n    if not np.any(mask):\n        return None\n\n    cand_ws = ws_np[mask]\n    cand_vs = vs_np[mask]\n    cand_ids = np.array(ids)[mask]\n    cand_dens = dens[mask]\n\n    # Take the top 5 densities and pick one randomly\n    top_k = min(5, len(cand_ws))\n    top_indices = np.argsort(cand_dens)[::-1][:top_k]\n    chosen = rng.choice(top_indices)\n\n    return (int(cand_ws[chosen]), int(cand_vs[chosen]), int(cand_ids[chosen]))\n\n",
  "top_density_then_maximize_fill_aug_151": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    rng = np.random.default_rng(12345)\n\n    # Zero\u2011weight positive\u2011value shortcut\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws, vs, ids = [], [], []\n    for w, v, idx in remaining_items:\n        if 0 < w <= remaining_capacity:\n            ws.append(w)\n            vs.append(v)\n            ids.append(idx)\n\n    if not ws:\n        return None\n\n    ws_np = np.array(ws, dtype=float)\n    vs_np = np.array(vs, dtype=float)\n\n    # Softmin density: lower value/weight gives higher density\n    dens = 1.0 / (vs_np / (ws_np + 1e-12) + 1.0)\n    dens = np.clip(dens, 0, 1)\n\n    # Threshold at 90\u202f% of the mean density\n    thr = 0.9 * np.mean(dens)\n    thr = np.clip(thr, 0, 1)\n\n    mask = dens >= thr\n    if not np.any(mask):\n        return None\n\n    cand_ws = ws_np[mask]\n    cand_vs = vs_np[mask]\n    cand_ids = np.array(ids)[mask]\n    cand_dens = dens[mask]\n\n    # Choose among the top 3 densities\n    top_k = min(3, len(cand_ws))\n    top_indices = np.argsort(cand_dens)[::-1][:top_k]\n    chosen = rng.choice(top_indices)\n\n    return (int(cand_ws[chosen]), int(cand_vs[chosen]), int(cand_ids[chosen]))\n\n",
  "top_density_then_maximize_fill_aug_152": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    for weight, value, item_id in remaining_items:\n        if weight == 0 and value > 0:\n            return (weight, value, item_id)\n\n    # Collect feasible items\n    weights, values, ids = [], [], []\n    for weight, value, item_id in remaining_items:\n        if 0 < weight <= remaining_capacity:\n            weights.append(weight)\n            values.append(value)\n            ids.append(item_id)\n\n    if not weights:\n        return None\n\n    w_arr = np.array(weights, dtype=float)\n    v_arr = np.array(values, dtype=float)\n\n    # Density with epsilon\n    dens = v_arr / (w_arr + 1e-12)\n    dens = np.clip(dens, 0, 1)\n\n    # Threshold: 60\u202f% of the average density\n    avg_dens = np.mean(dens)\n    thr = 0.6 * avg_dens\n    thr = np.clip(thr, 0, 1)\n\n    mask = dens >= thr\n    if not np.any(mask):\n        return None\n\n    # Sort by density descending, then weight descending\n    sorted_idx = np.lexsort((-w_arr[mask], -dens[mask]))\n    best_idx = sorted_idx[0]\n\n    return (int(w_arr[mask][best_idx]),\n            int(v_arr[mask][best_idx]),\n            int(np.array(ids)[mask][best_idx]))\n\n",
  "pareto_frontier_density_aug_153": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Convert to numpy array for vectorised operations\n    items = np.array(remaining_items, dtype=object)\n    n = items.shape[0]\n    idx = 0\n    fit_list = []\n\n    # while loop replaces the typical for\u2011loop\n    while idx < n:\n        w, v, i = items[idx]\n        if w <= remaining_capacity:\n            fit_list.append((w, v, i))\n        idx += 1\n\n    if not fit_list:\n        return None\n\n    fit = np.array(fit_list, dtype=object)\n\n    # Zero\u2011weight, positive\u2011value items are immediately optimal\n    zero_mask = (fit[:, 0] == 0) & (fit[:, 1] > 0)\n    if np.any(zero_mask):\n        w, v, i = fit[zero_mask][0]\n        return (int(w), int(v), int(i))\n\n    # Pareto frontier extraction: sort by weight asc, value desc\n    order = np.lexsort((-fit[:, 1].astype(float), fit[:, 0].astype(int)))\n    sorted_fit = fit[order]\n\n    frontier = []\n    best_val = -np.inf\n    for w, v, i in sorted_fit:\n        if v > best_val + 1e-12:\n            frontier.append((int(w), float(v), int(i)))\n            best_val = v\n\n    if not frontier:\n        return None\n\n    frontier_arr = np.array(frontier, dtype=object)\n    weights = frontier_arr[:, 0].astype(float)\n    values = frontier_arr[:, 1].astype(float)\n\n    # Compute density with epsilon and clip to avoid extreme values\n    density = values / np.clip(weights, 1e-12, None)\n    density = np.clip(density, 0, np.inf)\n\n    # Tie\u2011breaking by adding a deterministic noise proportional to index\n    noise = np.arange(len(density)) * 1e-8\n    density += noise\n\n    best_idx = np.argmax(density)\n    w_best, v_best, i_best = frontier_arr[best_idx]\n    return (int(w_best), int(v_best), int(i_best))\n\n",
  "pareto_frontier_density_aug_154": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Filter fitting items\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight, positive\u2011value shortcut\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (int(w), int(v), int(idx))\n\n    # Convert to arrays for vectorised operations\n    arr = np.array(fit, dtype=object)\n    weights = arr[:, 0].astype(float)\n    values = arr[:, 1].astype(float)\n    indices = arr[:, 2].astype(int)\n\n    # Scale density: value / (weight ** 0.9) to favour lighter items slightly more\n    density = values / np.clip(weights ** 0.9, 1e-12, None)\n    density = np.clip(density, 0, np.inf)\n\n    # Add a tiny deterministic noise for tie\u2011breaking\n    noise = np.arange(len(density)) * 1e-9\n    density += noise\n\n    # Take top\u2011k candidates\n    top_k = 3\n    if len(density) <= top_k:\n        candidates = np.arange(len(density))\n    else:\n        candidates = np.argpartition(-density, top_k)[:top_k]\n        # Ensure sorted by density descending\n        candidates = candidates[np.argsort(-density[candidates])]\n\n    # Randomly pick one among the top\u2011k\n    chosen = np.random.choice(candidates)\n    return (int(weights[chosen]), int(values[chosen]), int(indices[chosen]))\n\n",
  "pareto_frontier_density_aug_155": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Fit items\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Immediate return for zero\u2011weight positive\u2011value items\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (int(w), int(v), int(idx))\n\n    # Convert to arrays\n    arr = np.array(fit, dtype=object)\n    weights = arr[:, 0].astype(float)\n    values = arr[:, 1].astype(float)\n    indices = arr[:, 2].astype(int)\n\n    # Density with epsilon\n    density = values / np.clip(weights, 1e-12, None)\n    density = np.clip(density, 0, np.inf)\n\n    # Soft\u2011min: higher density -> lower exponent\n    alpha = 10.0\n    logits = -alpha * density\n    probs = np.exp(logits - np.max(logits))\n    probs /= np.sum(probs)\n\n    # Random choice weighted by probs\n    chosen = np.random.choice(len(probs), p=probs)\n    return (int(weights[chosen]), int(values[chosen]), int(indices[chosen]))\n\n",
  "pareto_frontier_density_aug_156": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Gather fitting items\n    fit = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            fit.append((w, v, idx))\n    if not fit:\n        return None\n\n    # Zero\u2011weight positive\u2011value shortcut\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (int(w), int(v), int(idx))\n\n    # Convert to arrays\n    arr = np.array(fit, dtype=object)\n    weights = arr[:, 0].astype(float)\n    values = arr[:, 1].astype(float)\n    indices = arr[:, 2].astype(int)\n\n    # Compute density with sqrt weight and clip to avoid extremes\n    sqrt_w = np.sqrt(np.clip(weights, 1e-12, None))\n    density = values / sqrt_w\n    density = np.clip(density, 0, np.inf)\n\n    # Add deterministic noise for tie\u2011breaking\n    noise = np.arange(len(density)) * 5e-9\n    density += noise\n\n    # Choose the item with maximum density using np.max\n    best_idx = np.argmax(density)\n    return (int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx]))\n\n",
  "inverse_rank_aggregation_aug_157": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _inv_rank_scores(arr: np.ndarray) -> np.ndarray:\n    order = np.argsort(-arr, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.arange(1, order.size + 1, dtype=float)\n    return 1.0 / ranks\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = []\n    i = 0\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            fit.append((w, v, idx))\n        i += 1\n    if not fit:\n        return None\n\n    values = np.array([float(v) for _, v, _ in fit], dtype=float)\n    weights = np.array([float(w) for w, _, _ in fit], dtype=float)\n\n    densities = values / np.maximum(1e-12, weights)\n    fill_frac = weights / float(max(1, remaining_capacity))\n    fill_frac = np.clip(fill_frac, 0, 1)\n\n    score = (_inv_rank_scores(values) +\n             _inv_rank_scores(densities) +\n             0.75 * _inv_rank_scores(fill_frac))\n    j = int(np.argmax(score))\n    return fit[j]\n\n",
  "inverse_rank_aggregation_aug_158": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _inv_rank_scores(arr: np.ndarray) -> np.ndarray:\n    order = np.argsort(-arr, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.arange(1, order.size + 1, dtype=float)\n    return 1.0 / ranks\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    if any(w == 0 and v > 0 for w, v, _ in fit):\n        return next(item for item in fit if item[0] == 0 and item[1] > 0)\n\n    values = np.array([float(v) for _, v, _ in fit], dtype=float)\n    weights = np.array([float(w) for w, _, _ in fit], dtype=float)\n\n    densities = values / np.maximum(1e-12, weights)\n    fill_frac = weights / float(max(1, remaining_capacity))\n    fill_frac = np.clip(fill_frac, 0, 1)\n\n    median_vals = np.median(values)\n    median_dens = np.median(densities)\n    median_fill = np.median(fill_frac)\n\n    # Relative scores with deterministic noise\n    noise = np.arange(len(fit), dtype=float) * 1e-9\n    score = ((values - median_vals) +\n             0.5 * (densities - median_dens) +\n             0.75 * (fill_frac - median_fill) +\n             noise)\n\n    j = int(np.argmax(score))\n    return fit[j]\n\n",
  "inverse_rank_aggregation_aug_159": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _inv_rank_scores(arr: np.ndarray) -> np.ndarray:\n    order = np.argsort(-arr, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.arange(1, order.size + 1, dtype=float)\n    return np.clip(1.0 / (ranks + 1e-12), 0, 1)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    if any(w == 0 and v > 0 for w, v, _ in fit):\n        return next(item for item in fit if item[0] == 0 and item[1] > 0)\n\n    values = np.array([float(v) for _, v, _ in fit], dtype=float)\n    weights = np.array([float(w) for w, _, _ in fit], dtype=float)\n\n    densities = values / np.maximum(1e-12, weights)\n    densities = np.clip(densities, 0, None)\n    fill_frac = weights / float(max(1, remaining_capacity))\n    fill_frac = np.clip(fill_frac, 0, 1)\n\n    score = (_inv_rank_scores(values) +\n             0.5 * _inv_rank_scores(densities) +\n             0.75 * _inv_rank_scores(fill_frac))\n    j = int(np.argmax(score))\n    return fit[j]\n\n",
  "exponential_tradeoff_value_weight_aug_160": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Filter items that fit into the remaining capacity\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Special case: zero weight with positive value\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Avoid division by zero\n    C = float(max(1, remaining_capacity)) + 1e-12\n\n    # Fraction of items that fit (avoid zero denominator)\n    frac_fit = float(len(fit)) / float(max(1, len(remaining_items))) + 1e-12\n\n    # Adaptive lambda: tighter capacity \u2192 larger penalty\n    lam = np.clip(2.0 - 1.5 * frac_fit, 0.5, 2.0)\n\n    best_item, best_score = None, -np.inf\n    idx = 0\n    while idx < len(fit):\n        w, v, itm_idx = fit[idx]\n        score = float(v) * np.exp(-lam * (float(w) / C))\n        # Deterministic tie\u2011breaking noise\n        score += 1e-9 * idx\n        if score > best_score:\n            best_score, best_item = score, (w, v, itm_idx)\n        idx += 1\n\n    return best_item\n\n",
  "exponential_tradeoff_value_weight_aug_161": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Unpack items into separate arrays\n    weights, values, indices = zip(*remaining_items)\n    weights = np.array(weights, dtype=np.float64)\n    values  = np.array(values,  dtype=np.float64)\n    indices = np.array(indices, dtype=np.int64)\n\n    # Mask of items that fit\n    mask = weights <= float(remaining_capacity) + 1e-12\n    if not np.any(mask):\n        return None\n\n    # Special case: zero weight with positive value\n    zero_fit = np.where((weights == 0) & (values > 0) & mask)[0]\n    if zero_fit.size > 0:\n        idx = zero_fit[0]\n        return (int(weights[idx]), int(values[idx]), int(indices[idx]))\n\n    # Avoid division by zero\n    C = float(max(1, remaining_capacity)) + 1e-12\n\n    # Fraction of items that fit\n    frac_fit = np.sum(mask) / (float(len(remaining_items)) + 1e-12)\n\n    # Adaptive lambda\n    lam = np.clip(2.0 - 1.5 * frac_fit, 0.5, 2.0)\n\n    # Compute scores for all items\n    scores = values * np.exp(-lam * (weights / C))\n\n    # Apply deterministic noise to break ties\n    noise = 1e-9 * np.arange(len(weights))\n    scores += noise\n\n    # Select the index with the maximum score among fitting items\n    best_idx = np.argmax(scores * mask)\n\n    return (int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx]))\n\n",
  "exponential_tradeoff_value_weight_aug_162": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Unpack items\n    weights, values, indices = zip(*remaining_items)\n    weights = np.array(weights, dtype=np.float64)\n    values  = np.array(values,  dtype=np.float64)\n    indices = np.array(indices, dtype=np.int64)\n\n    # Items that fit\n    mask = weights <= float(remaining_capacity) + 1e-12\n    if not np.any(mask):\n        return None\n\n    # Zero\u2011weight, positive\u2011value shortcut\n    zero_fit = np.where((weights == 0) & (values > 0) & mask)[0]\n    if zero_fit.size > 0:\n        idx = zero_fit[0]\n        return (int(weights[idx]), int(values[idx]), int(indices[idx]))\n\n    # Avoid division by zero\n    C = float(max(1, remaining_capacity)) + 1e-12\n\n    # Tightness estimate using median of weight ratios of fitting items\n    ratio = weights[mask] / C\n    frac_fit = np.median(ratio) + 1e-12  # median ratio as a proxy for tightness\n\n    # Adaptive lambda: tighter capacity \u2192 larger penalty\n    lam = np.clip(1.0 + 0.5 * (1.0 - frac_fit), 0.5, 2.0)\n\n    # Compute scores\n    scores = values * np.exp(-lam * (weights / C))\n\n    # Add deterministic noise for tie breaking\n    noise = 1e-9 * np.arange(len(weights))\n    scores += noise\n\n    # Select the item with the maximum score\n    best_idx = np.argmax(scores * mask)\n\n    return (int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx]))\n\n",
  "weight_rarity_bonus_density_aug_163": "import numpy as np\nfrom typing import List, Tuple, Optional, Dict\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Items that can fit into the remaining capacity\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Immediate win: zero\u2011weight item with positive value\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Frequency of each weight in the entire list\n    freq: Dict[int, int] = {}\n    for w, _, _ in remaining_items:\n        freq[w] = freq.get(w, 0) + 1\n\n    best_item = None\n    best_score = -np.inf\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(fit), dtype=float) * 1e-6\n\n    for i, (w, v, idx) in enumerate(fit):\n        w0 = int(w)\n        dens = float(v) / max(1e-12, float(w0))\n        dens = np.clip(dens, 0, 1e6)                     # avoid overflow\n        rarity = 1.0 / np.sqrt(float(freq.get(w0, 1)))\n        score = dens * (0.9 + 0.1 * rarity) + 1e-9 * float(v) + noise[i]\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n\n    return best_item\n\n",
  "weight_rarity_bonus_density_aug_164": "import numpy as np\nfrom typing import List, Tuple, Optional, Dict\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    freq: Dict[int, int] = {}\n    for w, _, _ in remaining_items:\n        freq[w] = freq.get(w, 0) + 1\n\n    scores = []\n    i = 0\n    while i < len(fit):\n        w, v, idx = fit[i]\n        w0 = int(w)\n        dens = float(v) / max(1e-12, float(w0))\n        dens = np.clip(dens, 0, 1e6)\n        rarity = 1.0 / np.sqrt(float(freq.get(w0, 1)))\n        score = dens * (0.7 + 0.3 * rarity) + 1e-9 * float(v)\n        scores.append((score, (w, v, idx)))\n        i += 1\n\n    # Keep only the top\u20113 items\n    scores.sort(key=lambda x: x[0], reverse=True)\n    top_k = min(3, len(scores))\n    candidates = [item for _, item in scores[:top_k]]\n    chosen = np.random.choice(len(candidates))\n    return candidates[chosen]\n\n",
  "weight_rarity_bonus_density_aug_165": "import numpy as np\nfrom typing import List, Tuple, Optional, Dict\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=np.int64)\n    weights = arr[:, 0]\n    values  = arr[:, 1]\n    indices = arr[:, 2]\n\n    mask = weights <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    w_fit = weights[mask]\n    v_fit = values[mask]\n    idx_fit = indices[mask]\n\n    # Zero\u2011weight with positive value\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        z = np.where(zero_mask)[0][0]\n        return (int(w_fit[z]), int(v_fit[z]), int(idx_fit[z]))\n\n    uniq, counts = np.unique(weights, return_counts=True)\n    freq_map = dict(zip(uniq, counts))\n\n    dens = v_fit.astype(float) / np.maximum(1e-12, w_fit.astype(float))\n    dens = np.clip(dens, 0, 1e6)\n    rarity = 1.0 / np.sqrt(np.array([freq_map.get(int(w), 1) for w in w_fit], dtype=float))\n    score = dens * (0.8 + 0.2 * rarity) + 1e-9 * v_fit.astype(float)\n\n    # Small random noise to break ties deterministically\n    noise = np.random.uniform(0, 1e-9, size=score.shape)\n    score += noise\n\n    best_idx = int(np.argmax(score))\n    return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(idx_fit[best_idx]))\n\n",
  "gcd_leftover_alignment_aug_166": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom math import gcd\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Immediate return for a zero\u2011weight item with positive value\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Compute gcd of all positive weights\n    pos_weights = [int(w) for (w, _, _) in remaining_items if w > 0]\n    g = 0\n    for weight in pos_weights:\n        g = weight if g == 0 else gcd(g, weight)\n    g = int(g) if g > 0 else 1\n\n    # Scoring\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    eps = 1e-12\n    idx_iter = 0\n    for w, v, idx in fit_items:\n        if w <= 0:\n            continue\n        dens = float(v) / (float(w) + eps)\n        leftover = int(remaining_capacity - w)\n        mod = leftover % g\n        dist = min(mod, g - mod) / (float(g) + eps)\n        dist = np.clip(dist, 0.0, 1.0)\n        noise = idx_iter * 1e-9          # deterministic tie\u2011breaker\n        idx_iter += 1\n        score = dens - 0.5 * dist + 1e-6 * (float(w) / C) + noise\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "gcd_leftover_alignment_aug_167": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom math import gcd\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=int)          # shape (n, 3)\n    w, v, idx = arr[:, 0], arr[:, 1], arr[:, 2]\n    fit_mask = w <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    w_fit, v_fit, idx_fit = w[fit_mask], v[fit_mask], idx[fit_mask]\n\n    # Zero\u2011weight positive\u2011value shortcut\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        i = np.argmax(zero_mask)\n        return (int(w_fit[i]), int(v_fit[i]), int(idx_fit[i]))\n\n    # GCD of all positive weights\n    pos_weights = w[w > 0]\n    g = 0\n    for weight in pos_weights:\n        g = int(weight) if g == 0 else gcd(g, int(weight))\n    g = int(g) if g > 0 else 1\n\n    eps = 1e-12\n    C = float(max(1, remaining_capacity))\n\n    dens = v_fit.astype(float) / (w_fit.astype(float) + eps)\n    leftovers = remaining_capacity - w_fit\n    mod = leftovers % g\n    dist = np.minimum(mod, g - mod) / (float(g) + eps)\n    dist = np.clip(dist, 0.0, 1.0)\n\n    scores = dens - 0.75 * dist + 1e-6 * (w_fit.astype(float) / C)\n\n    # Softmax weighting for a stochastic choice among all candidates\n    max_score = np.max(scores)\n    exp_vals = np.exp(scores - max_score)\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n    chosen_idx = np.random.choice(len(scores), p=probs)\n\n    return (int(w_fit[chosen_idx]), int(v_fit[chosen_idx]), int(idx_fit[chosen_idx]))\n\n",
  "gcd_leftover_alignment_aug_168": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom math import gcd\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    pos_w = [int(w) for (w, _, _) in remaining_items if w > 0]\n    g = 0\n    for weight in pos_w:\n        g = weight if g == 0 else gcd(g, weight)\n    g = int(g) if g > 0 else 1\n\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    eps = 1e-12\n\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / (float(w) + eps)\n        leftover = int(remaining_capacity - w)\n        mod = leftover % g\n        dist = min(mod, g - mod) / (float(g) + eps)\n        dist = np.clip(dist, 0.0, 1.0)\n        noise = idx * 1e-8\n        score = dens - 0.6 * dist + 1e-6 * (float(w) / C) + noise\n        if score > best_score or (abs(score - best_score) < 1e-12 and w > best_item[0]):\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "gcd_leftover_alignment_aug_169": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom math import gcd\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    pos_w = [int(w) for (w, _, _) in remaining_items if w > 0]\n    g = 0\n    for weight in pos_w:\n        g = weight if g == 0 else gcd(g, weight)\n    g = int(g) if g > 0 else 1\n\n    best_score = -np.inf\n    best_items = []\n    C = float(max(1, remaining_capacity))\n    eps = 1e-12\n\n    for w, v, idx in candidates:\n        if w <= 0:\n            continue\n        dens = float(v) / (float(w) + eps)\n        leftover = int(remaining_capacity - w)\n        mod = leftover % g\n        dist = min(mod, g - mod) / (float(g) + eps)\n        dist = np.clip(dist, 0.0, 1.0)\n        score = dens - 0.8 * dist + 1e-6 * (float(w) / C)\n        if score > best_score + 1e-12:\n            best_score = score\n            best_items = [(w, v, idx)]\n        elif abs(score - best_score) <= 1e-12:\n            best_items.append((w, v, idx))\n\n    if len(best_items) == 1:\n        return best_items[0]\n    idx_chosen = np.random.randint(len(best_items))\n    chosen = best_items[idx_chosen]\n    return (int(chosen[0]), int(chosen[1]), int(chosen[2]))\n\n",
  "mini_bitset_reachability_lookahead_aug_170": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _reachable_bitset(weights: List[int], cap: int) -> int:\n    bits = 1  # weight 0 reachable\n    for w in weights:\n        if 0 < w <= cap:\n            bits |= bits << w\n            bits &= (1 << (cap + 1)) - 1\n            if bits == (1 << (cap + 1)) - 1:\n                break\n    return bits\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Immediate return for zero\u2011weight positive\u2011value items\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Limited subset\u2011sum DP for feasibility check\n    cap_dp = min(2048, max(0, remaining_capacity))\n    cand_w = sorted([int(w) for (w, _, _) in remaining_items if 0 < int(w) <= cap_dp])[:80]\n    base_bits = _reachable_bitset(cand_w, cap_dp)\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = int(remaining_capacity - ww)\n        if leftover < 0:\n            continue\n        l = min(leftover, cap_dp)\n        reachable = 1.0 if ((base_bits >> l) & 1) else 0.0\n        dens = float(v) / (float(ww) + 1e-12)\n        dens = np.clip(dens, 0, np.inf)\n        score = dens * (0.6 + 0.4 * reachable) + 0.02 * float(v) * reachable\n        score += 1e-9 * idx  # deterministic tie\u2011breaker\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "mini_bitset_reachability_lookahead_aug_171": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _reachable_bitset(weights: List[int], cap: int) -> int:\n    bits = 1\n    for w in weights:\n        if 0 < w <= cap:\n            bits |= bits << w\n            bits &= (1 << (cap + 1)) - 1\n            if bits == (1 << (cap + 1)) - 1:\n                break\n    return bits\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    weights = np.array([w for w, _, _ in remaining_items], dtype=int)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.array([idx for _, _, idx in remaining_items], dtype=int)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    zero_mask = (weights == 0) & (values > 0) & fit_mask\n    if np.any(zero_mask):\n        zidx = np.argmax(zero_mask)\n        return (int(weights[zidx]), int(values[zidx]), int(indices[zidx]))\n\n    cap_dp = min(2048, max(0, remaining_capacity))\n    cand_w = np.sort(weights[(weights > 0) & (weights <= cap_dp)])[:80]\n    base_bits = _reachable_bitset(cand_w.tolist(), cap_dp)\n\n    total_sum = np.sum(weights)\n    scores, items = [], []\n\n    for i in range(len(weights)):\n        if not fit_mask[i]:\n            continue\n        w = int(weights[i])\n        if w <= 0:\n            continue\n        leftover = int(remaining_capacity - w)\n        if leftover < 0:\n            continue\n        l = min(leftover, cap_dp)\n        reachable = 1.0 if ((base_bits >> l) & 1) else 0.0\n        # Rough future packability check\n        if leftover <= total_sum - w:\n            reachable += 0.5\n        reachable = np.clip(reachable, 0, 1)\n\n        dens = values[i] / (w + 1e-12)\n        dens = np.clip(dens, 0, np.inf)\n        score = dens * (0.55 + 0.45 * reachable) + 0.04 * values[i] * reachable\n        score += 1e-9 * indices[i]\n        scores.append(score)\n        items.append((int(w), int(values[i]), int(indices[i])))\n\n    if not scores:\n        return None\n\n    scores_np = np.array(scores, dtype=float)\n    top_k = min(3, len(scores_np))\n    top_indices = np.argpartition(-scores_np, top_k-1)[:top_k]\n    chosen = np.random.choice(top_indices)\n    return items[chosen]\n\n",
  "two_step_best_pair_value_aug_172": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Convert to numpy arrays for fast operations\n    items = np.array(remaining_items, dtype=np.float64)\n    weights, values, idxs = items[:, 0], items[:, 1], items[:, 2].astype(int)\n\n    # Items that fit into the remaining capacity\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    fit_w, fit_v, fit_idx = weights[fit_mask], values[fit_mask], idxs[fit_mask]\n\n    # Prefer a zero\u2011weight item with positive value\n    zero_mask = (fit_w == 0) & (fit_v > 0)\n    if np.any(zero_mask):\n        i = np.argmax(zero_mask)\n        return int(fit_w[i]), int(fit_v[i]), int(fit_idx[i])\n\n    best_item, best_score = None, -np.inf\n\n    for w, v, idx in zip(fit_w, fit_v, fit_idx):\n        leftover = remaining_capacity - int(w)\n        partner_mask = (weights <= leftover) & (idxs != idx)\n        best_partner_v = np.max(values[partner_mask]) if np.any(partner_mask) else 0.0\n        density = v / (w + 1e-12)\n        density = np.clip(density, 0, 1e6)          # safety clip\n        score = v + best_partner_v + 5e-4 * density\n        if score > best_score:\n            best_score, best_item = score, (int(w), int(v), int(idx))\n    return best_item\n\n",
  "two_step_best_pair_value_aug_173": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Immediate zero\u2011weight, positive value\n    i = 0\n    while i < len(fit):\n        w, v, idx = fit[i]\n        if w == 0 and v > 0:\n            return (w, v, idx)\n        i += 1\n\n    scores = []\n    for w, v, idx in fit:\n        leftover = remaining_capacity - int(w)\n        best_partner_v = 0.0\n        j = 0\n        while j < len(fit):\n            w2, v2, idx2 = fit[j]\n            if idx2 != idx and int(w2) <= leftover:\n                if v2 > best_partner_v:\n                    best_partner_v = float(v2)\n            j += 1\n        density = float(v) / max(1e-12, float(w))\n        noise = 1e-6 * idx                      # deterministic tie\u2011breaker\n        score = float(v) + best_partner_v + 1e-3 * density + noise\n        scores.append(score)\n\n    scores = np.array(scores)\n    top_k = min(3, len(scores))\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n    return fit[chosen_idx]\n\n",
  "two_step_best_pair_value_aug_174": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    scores = []\n    for w, v, idx in fit:\n        leftover = remaining_capacity - int(w)\n        partner_v = 0.0\n        for w2, v2, idx2 in fit:\n            if idx2 == idx:\n                continue\n            if int(w2) <= leftover:\n                partner_v = max(partner_v, float(v2))\n        density = float(v) / (float(w) + 1e-12)\n        density = np.clip(density, 0, 10.0)      # clip to avoid extremes\n        scores.append(float(v) + partner_v + 1e-3 * density)\n\n    scores = np.array(scores)\n    best_score = np.max(scores)\n    close_indices = np.where(np.abs(scores - best_score) < 1e-9)[0]\n    chosen = np.random.choice(close_indices) if len(close_indices) > 1 else np.argmax(scores)\n    best_item = fit[chosen]\n\n    # After scoring, give priority to zero\u2011weight, positive\u2011value items\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n\n",
  "two_step_best_pair_value_aug_175": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    items = np.array(remaining_items, dtype=np.float64)\n    weights, values, idxs = items[:, 0], items[:, 1], items[:, 2].astype(int)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    fit_w, fit_v, fit_idx = weights[fit_mask], values[fit_mask], idxs[fit_mask]\n\n    # Prefer zero\u2011weight, positive\u2011value items\n    zero_mask = (fit_w == 0) & (fit_v > 0)\n    if np.any(zero_mask):\n        i = np.argmax(zero_mask)\n        return int(fit_w[i]), int(fit_v[i]), int(fit_idx[i])\n\n    leftovers = remaining_capacity - fit_w.astype(int)\n\n    # Broadcast to evaluate partner feasibility\n    partner_mask = weights[None, :] <= leftovers[:, None]\n    partner_mask &= idxs[None, :] != fit_idx[:, None]\n    partner_vals = np.where(partner_mask, values[None, :], -np.inf)\n\n    best_partner_v = np.max(partner_vals, axis=1)\n    best_partner_v = np.where(best_partner_v == -np.inf, 0.0, best_partner_v)\n\n    density = fit_v / (fit_w + 1e-12)\n    density = np.clip(density, 0, 5.0)\n\n    score = fit_v + best_partner_v + 1e-3 * density\n    score += 1e-7 * fit_idx                      # deterministic noise\n\n    chosen = np.argmax(score)\n    return int(fit_w[chosen]), int(fit_v[chosen]), int(fit_idx[chosen])\n\n",
  "deterministic_gumbel_softmax_density_aug_176": "import numpy as np\nimport math\nfrom typing import List, Tuple, Optional\n\ndef _hash01(x):\n    s = np.sin(x) * 43758.5453123\n    return s - np.floor(s)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Convert to numpy arrays for vectorized operations\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.array([idx for _, _, idx in remaining_items], dtype=int)\n\n    # Keep only items that fit\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    # Immediate return for zero\u2011weight items with positive value\n    zero_mask = (weights == 0) & (values > 0) & fit_mask\n    if np.any(zero_mask):\n        z = np.argmax(zero_mask)\n        return (int(weights[z]), int(values[z]), int(indices[z]))\n\n    weights = weights[fit_mask]\n    values  = values[fit_mask]\n    indices = indices[fit_mask]\n\n    C = float(max(1, remaining_capacity))\n    temp = np.clip(0.3 * (C / (C + 40.0)), 0.05, 0.3)\n\n    density = values / (weights + 1e-12)\n\n    # Gumbel noise via deterministic hash\n    u = _hash01((indices + 1) * 0.987 + C * 0.013)\n    u = np.clip(u, 1e-12, 1.0 - 1e-12)\n    gumbel = -np.log(-np.log(u))\n\n    score = density + temp * gumbel\n    best_idx = int(np.argmax(score))\n    return (int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx]))\n\n",
  "deterministic_gumbel_softmax_density_aug_177": "import numpy as np\nimport math\nfrom typing import List, Tuple, Optional\n\ndef _hash01(x: float) -> float:\n    s = math.sin(x) * 43758.5453123\n    return s - math.floor(s)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Filter items that fit\n    candidates = [\n        (w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity\n    ]\n    if not candidates:\n        return None\n\n    # Immediate return for zero\u2011weight items with positive value\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    temp = np.clip(0.35 * (C / (C + 50.0)), 0.05, 0.35)\n\n    scores = []\n    for w, v, idx in candidates:\n        density = float(v) / float(w + 1e-12)\n        u = _hash01((idx + 1.0) * 0.987 + C * 0.013)\n        u = min(1.0 - 1e-12, max(1e-12, u))\n        gumbel = -math.log(-math.log(u))\n        scores.append(density + temp * gumbel)\n\n    # Select top\u2011k candidates\n    top_k = min(7, len(scores))\n    top_indices = np.argpartition(scores, -top_k)[-top_k:]\n\n    # Deterministic tie\u2011breaking: prefer lower index on equal scores\n    best = top_indices[0]\n    for idx in top_indices[1:]:\n        if scores[idx] > scores[best] + 1e-12:\n            best = idx\n        elif abs(scores[idx] - scores[best]) <= 1e-12 and candidates[idx][2] < candidates[best][2]:\n            best = idx\n\n    return candidates[best]\n\n",
  "deterministic_gumbel_softmax_density_aug_178": "import numpy as np\nimport math\nfrom typing import List, Tuple, Optional\n\ndef _hash01(x: float) -> float:\n    s = math.sin(x) * 43758.5453123\n    return s - math.floor(s)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = [\n        (w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity\n    ]\n    if not candidates:\n        return None\n\n    # Immediate return for zero\u2011weight items with positive value\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    temp = np.clip(0.4 * (C / (C + 30.0)), 0.05, 0.4)\n\n    scores = []\n    for w, v, idx in candidates:\n        density = float(v) / float(w + 1e-12)\n        u = _hash01((idx + 1.0) * 0.987 + C * 0.013)\n        u = min(1.0 - 1e-12, max(1e-12, u))\n        gumbel = -math.log(-math.log(u))\n        # Multiplicative scoring with a tiny deterministic tie\u2011breaker\n        score = density * (1.0 + temp * gumbel) + _hash01(idx) * 1e-6\n        scores.append(score)\n\n    best = int(np.argmax(scores))\n    return candidates[best]\n\n",
  "deterministic_gumbel_softmax_density_aug_179": "import numpy as np\nimport math\nfrom typing import List, Tuple, Optional\n\ndef _hash01(x: float) -> float:\n    s = math.sin(x) * 43758.5453123\n    return s - math.floor(s)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = [\n        (w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity\n    ]\n    if not candidates:\n        return None\n\n    # Immediate return for zero\u2011weight items with positive value\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    temp = np.clip(0.3 * (C / (C + 45.0)), 0.05, 0.3)\n\n    scores = []\n    for w, v, idx in candidates:\n        density = float(v) / float(w + 1e-12)\n        u = _hash01((idx + 1.0) * 0.987 + C * 0.013)\n        u = min(1.0 - 1e-12, max(1e-12, u))\n        # Proxy Gumbel: add a small epsilon inside the inner log\n        gumbel = -np.log(-np.log(u + 1e-12))\n        scores.append(density + temp * gumbel)\n\n    top_k = min(5, len(scores))\n    top_indices = np.argpartition(scores, -top_k)[-top_k:]\n\n    # Deterministically pick the second\u2011best among the top\u2011k\n    if len(top_indices) > 1:\n        sorted_top = sorted(top_indices, key=lambda i: scores[i], reverse=True)\n        best = sorted_top[1]\n    else:\n        best = top_indices[0]\n\n    return candidates[best]\n\n",
  "value_quantile_gate_then_density_aug_180": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n    # filter items that fit\n    fit = []\n    i = 0\n    while i < len(items):\n        w, v, idx = items[i]\n        if w <= cap:\n            fit.append((w, v, idx))\n        i += 1\n    if not fit:\n        return None\n    # special case: zero\u2011weight, positive\u2011value item\n    i = 0\n    while i < len(fit):\n        w, v, idx = fit[i]\n        if w == 0 and v > 0:\n            return (w, v, idx)\n        i += 1\n    # gate by value quantile\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    q = float(np.quantile(vals, 0.60))\n    gated = [(w, v, idx) for (w, v, idx) in fit if float(v) >= q and w > 0]\n    pool = gated if len(gated) >= max(2, len(fit) // 5) else [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    best_item = None\n    best_score = -np.inf\n    i = 0\n    while i < len(pool):\n        w, v, idx = pool[i]\n        denom = float(w) + 1e-12\n        density = float(v) / denom\n        density = np.clip(density, 0, 1e3)\n        score = 0.7 * density + 1e-6 * float(v) + 1e-9 * idx  # deterministic tie\u2011breaking\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n        i += 1\n    return best_item\n\n",
  "value_quantile_gate_then_density_aug_181": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    items_arr = np.array(remaining_items, dtype=int)\n    weights = items_arr[:,0]\n    values  = items_arr[:,1]\n    indices = items_arr[:,2]\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n    fit_w = weights[fit_mask]\n    fit_v = values[fit_mask]\n    fit_idx = indices[fit_mask]\n    # zero\u2011weight, positive\u2011value shortcut\n    zero_mask = (fit_w == 0) & (fit_v > 0)\n    if np.any(zero_mask):\n        z = np.argmax(zero_mask)\n        return (int(fit_w[zero_mask][z]), int(fit_v[zero_mask][z]), int(fit_idx[zero_mask][z]))\n    # gating by median value\n    q = np.median(fit_v)\n    gated_mask = (fit_v >= q) & (fit_w > 0)\n    if np.sum(gated_mask) >= max(2, len(fit_w)//5):\n        gw = fit_w[gated_mask]\n        gv = fit_v[gated_mask]\n        gidx = fit_idx[gated_mask]\n    else:\n        gw = fit_w[fit_w>0]\n        gv = fit_v[fit_w>0]\n        gidx = fit_idx[fit_w>0]\n    denom = gw + 1e-12\n    densities = gv / denom\n    densities = np.clip(densities, 0, 1e3)\n    # choose among top\u20113 densities\n    if len(densities) <= 3:\n        top_indices = np.arange(len(densities))\n    else:\n        top_indices = np.argpartition(-densities, 3)[:3]\n    top_w = gw[top_indices]\n    top_v = gv[top_indices]\n    top_idx = gidx[top_indices]\n    chosen = np.random.choice(len(top_indices))\n    return (int(top_w[chosen]), int(top_v[chosen]), int(top_idx[chosen]))\n\n",
  "value_quantile_gate_then_density_aug_182": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    # zero\u2011weight, positive\u2011value shortcut\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    w_arr = np.array([w for (w, _, _) in fit], dtype=float)\n    v_arr = np.array([v for (_, v, _) in fit], dtype=float)\n    idx_arr = np.array([idx for (_, _, idx) in fit], dtype=int)\n    gate_mask = v_arr > 0\n    w_gate = w_arr[gate_mask]\n    v_gate = v_arr[gate_mask]\n    idx_gate = idx_arr[gate_mask]\n    denom = w_gate + 1e-12\n    density = v_gate / denom\n    density = np.clip(density, 0, 1e3)\n    score = 0.5 * density + 1e-6 * v_gate + 1e-9 * idx_gate  # deterministic noise\n    best_pos = np.argmax(score)\n    return (int(w_gate[best_pos]), int(v_gate[best_pos]), int(idx_gate[best_pos]))\n\n",
  "interquartile_leftover_preference_aug_183": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Build list of items that fit\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Prefer zero\u2011weight items with positive value\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Positive weight distribution for IQR calculation\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        # Degenerate case: pick the item with highest value\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    q1 = float(np.percentile(ws, 25))\n    q3 = float(np.percentile(ws, 75))\n    iqr = max(1e-12, q3 - q1)\n\n    best_item = None\n    best_score = -np.inf\n    C = float(remaining_capacity)\n\n    for w, v, idx in fit_items:\n        if w <= 0:\n            continue\n        dens = float(v) / (float(w) + 1e-12)  # avoid division by zero\n        leftover = C - float(w)\n\n        # Compute distance penalty\n        if leftover < q1:\n            dist = (q1 - leftover) / iqr\n        elif leftover > q3:\n            dist = (leftover - q3) / iqr\n        else:\n            dist = 0.0\n\n        # Small deterministic noise for tie\u2011breaking\n        noise = 1e-6 * float(idx)  # deterministic via index\n        score = dens - 0.3 * dist + noise\n\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "interquartile_leftover_preference_aug_184": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Convert to arrays\n    weights = np.array([w for (w, _, _) in remaining_items], dtype=float)\n    values  = np.array([v for (_, v, _) in remaining_items], dtype=float)\n    indices = np.arange(len(remaining_items), dtype=int)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    w_fit = weights[fit_mask]\n    v_fit = values[fit_mask]\n    idx_fit = indices[fit_mask]\n\n    # Handle zero\u2011weight positive\u2011value items first\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        z = np.where(zero_mask)[0][0]\n        return (int(w_fit[z]), int(v_fit[z]), int(idx_fit[z]))\n\n    # Positive weight distribution for IQR\n    positive_ws = weights[weights > 0]\n    if positive_ws.size == 0:\n        # Degenerate: choose max value among fit\n        best = np.argmax(v_fit)\n        return (int(w_fit[best]), int(v_fit[best]), int(idx_fit[best]))\n\n    q1 = float(np.percentile(positive_ws, 25))\n    q3 = float(np.percentile(positive_ws, 75))\n    iqr = max(1e-12, q3 - q1)\n\n    dens = v_fit / (w_fit + 1e-12)  # density with epsilon\n    leftover = remaining_capacity - w_fit\n\n    dist = np.where(leftover < q1,\n                    (q1 - leftover) / iqr,\n                    np.where(leftover > q3,\n                             (leftover - q3) / iqr,\n                             0.0))\n    # Score with weight on distance\n    score = dens - 0.5 * dist\n    # Add tiny random noise for deterministic tie\u2011breaking\n    rng = np.random.default_rng(seed=42)  # fixed seed for reproducibility\n    noise = rng.random(len(score)) * 1e-7\n    score += noise\n\n    best_idx = np.argmax(score)\n    return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(idx_fit[best_idx]))\n\n",
  "bimodal_light_or_heavy_switch_aug_185": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Build fit list with a while loop\n    fit: list[Tuple[int, int, int]] = []\n    idx = 0\n    while idx < len(items):\n        w, v, i = items[idx]\n        if w <= cap:\n            fit.append((w, v, i))\n        idx += 1\n\n    if not fit:\n        return None\n\n    # Immediate return for zero\u2011weight high\u2011value items\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # Compute median weight of all positive\u2011weight items\n    pos_weights = np.array([float(w) for (w, _, _) in items if w > 0], dtype=float)\n    wmed = float(np.mean(pos_weights)) if pos_weights.size else 1.0\n\n    heavy_mode = float(cap) >= 2.5 * wmed\n\n    best_item, best_score = None, -np.inf\n    idx = 0\n    while idx < len(fit):\n        w, v, i = fit[idx]\n        if w <= 0:\n            idx += 1\n            continue\n        # --- Semantic\u2011preserving behavior ---\n        dens = np.clip(float(v) / (float(w) + 1e-12), 0, 1e6)   # epsilon + clipping\n        if heavy_mode:\n            score = dens + 0.12 * float(w)\n        else:\n            score = dens - 0.12 * float(w)\n        # deterministic tie\u2011breaking noise\n        score += 1e-6 * i\n        if score > best_score:\n            best_score, best_item = score, (w, v, i)\n        idx += 1\n\n    return best_item\n\n",
  "bimodal_light_or_heavy_switch_aug_186": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Filter items that fit using a boolean mask\n    fit_mask = np.array([w <= cap for (w, _, _) in items], dtype=bool)\n    if not fit_mask.any():\n        return None\n    fit_indices = np.nonzero(fit_mask)[0]\n    fit_w = np.array([items[i][0] for i in fit_indices], dtype=float)\n    fit_v = np.array([items[i][1] for i in fit_indices], dtype=float)\n    fit_i = np.array([items[i][2] for i in fit_indices], dtype=int)\n\n    # Zero\u2011weight high\u2011value shortcut\n    zero_mask = (fit_w == 0) & (fit_v > 0)\n    if zero_mask.any():\n        z = np.flatnonzero(zero_mask)[0]\n        return (int(fit_w[z]), int(fit_v[z]), int(fit_i[z]))\n\n    # Median weight of all positive\u2011weight items\n    pos_weights = np.array([float(w) for (w, _, _) in items if w > 0], dtype=float)\n    wmed = float(np.median(pos_weights)) if pos_weights.size else 1.0\n\n    heavy_mode = float(cap) >= 4.0 * wmed\n\n    # Vectorised density with epsilon and clipping\n    dens = np.clip(fit_v / (fit_w + 1e-12), 0, 1e6)\n\n    # Vectorised score\n    weight_factor = 0.20 if heavy_mode else -0.10\n    score = dens + weight_factor * fit_w\n\n    # Deterministic noise for tie\u2011breaking\n    score += 1e-6 * fit_i\n\n    # Choose best index\n    best_idx = int(np.argmax(score))\n    return (int(fit_w[best_idx]), int(fit_v[best_idx]), int(fit_i[best_idx]))\n\n",
  "bimodal_light_or_heavy_switch_aug_187": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Build fit list with list comprehension\n    fit = [(w, v, i) for (w, v, i) in items if w <= cap]\n    if not fit:\n        return None\n\n    # Zero\u2011weight high\u2011value shortcut\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # Use np.max for the weight reference instead of median\n    pos_weights = np.array([float(w) for (w, _, _) in items if w > 0], dtype=float)\n    wmed = float(np.max(pos_weights)) if pos_weights.size else 1.0\n\n    # Invert heavy\u2011mode condition\n    heavy_mode = float(cap) <= 1.5 * wmed\n\n    best_item, best_score = None, -np.inf\n    for w, v, i in fit:\n        if w <= 0:\n            continue\n        dens = np.clip(float(v) / (float(w) + 1e-12), 0, 1e6)   # epsilon + clipping\n        if heavy_mode:\n            score = dens + 0.10 * float(w)\n        else:\n            score = dens - 0.20 * float(w)\n        # deterministic tie\u2011breaking with negative noise\n        score -= 1e-6 * i\n        if score > best_score:\n            best_score, best_item = score, (w, v, i)\n\n    return best_item\n\n",
  "bimodal_light_or_heavy_switch_aug_188": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom functools import reduce\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Filter items that fit\n    fit = list(filter(lambda x: x[0] <= cap, items))\n    if not fit:\n        return None\n\n    # Zero\u2011weight high\u2011value shortcut\n    zero = next((x for x in fit if x[0] == 0 and x[1] > 0), None)\n    if zero is not None:\n        return zero\n\n    # Compute median weight of all positive\u2011weight items\n    pos_weights = np.array([float(w) for (w, _, _) in items if w > 0], dtype=float)\n    wmed = float(np.median(pos_weights)) if pos_weights.size else 1.0\n\n    heavy_mode = float(cap) >= 3.5 * wmed\n\n    # Score each item\n    def score_item(item):\n        w, v, i = item\n        dens = float(v) / (float(w) + 1e-12)\n        dens = np.clip(dens, 0, 1e6)           # clipping\n        weight_factor = 0.15 if heavy_mode else -0.15\n        s = dens + weight_factor * float(w)\n        s += 1e-6 * i                          # deterministic noise\n        return (s, item)\n\n    scored = list(map(score_item, fit))\n    scored.sort(key=lambda x: x[0], reverse=True)\n\n    # Randomly pick among the top\u20115 (or fewer)\n    top_k = min(5, len(scored))\n    rng = np.random.default_rng(42)\n    chosen = rng.choice([item for _, item in scored[:top_k]], size=1)[0]\n    return chosen\n\n",
  "robust_mad_z_density_aug_189": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Build candidate list with vectorised filtering\n    cand = [(w, v, idx) for w, v, idx in remaining_items\n            if w <= remaining_capacity and not (w == 0 and v == 0)]\n\n    # Immediate return for a zero\u2011weight, positive\u2011value item\n    zero_items = [c for c in cand if c[0] == 0 and c[1] > 0]\n    if zero_items:\n        return zero_items[0]\n\n    if not cand:\n        return None\n\n    # Density (value per unit weight) \u2013 guard against division by zero\n    densities = np.array([v / (w + 1e-12) for w, v, _ in cand], dtype=float)\n\n    # Mean and standard deviation for a robust scaling\n    mean_d = np.mean(densities)\n    std_d  = np.std(densities) + 1e-12\n\n    # Robust z\u2011score using a scaled standard deviation\n    z_scores = (densities - mean_d) / (1.4826 * std_d)\n\n    # Deterministic noise to break ties (index\u2011based)\n    noise = 1e-9 * np.arange(len(cand))\n\n    # Final score combines z\u2011score and a tiny value component\n    scores = z_scores + 1e-6 * np.array([v for _, v, _ in cand]) + noise\n\n    best_idx = int(np.argmax(scores))\n    return cand[best_idx]\n\n",
  "robust_mad_z_density_aug_190": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = [(w, v, idx) for w, v, idx in remaining_items\n            if w <= remaining_capacity and not (w == 0 and v == 0)]\n\n    zero_items = [c for c in cand if c[0] == 0 and c[1] > 0]\n    if zero_items:\n        return zero_items[0]\n\n    if not cand:\n        return None\n\n    densities = np.array([v / (w + 1e-12) for w, v, _ in cand], dtype=float)\n\n    # Trim 10\u202f% from each side to reduce outlier influence\n    trim = max(1, int(0.1 * len(densities)))\n    sorted_d = np.sort(densities)\n    trimmed = sorted_d[trim:len(sorted_d)-trim] if len(sorted_d) > 2*trim else sorted_d\n\n    mean_trim = np.mean(trimmed)\n    mad_trim  = np.median(np.abs(trimmed - mean_trim)) + 1e-12\n\n    z_scores = (densities - mean_trim) / (1.4826 * mad_trim)\n\n    # Heavier emphasis on value (scaled by 1e\u20115)\n    scores = z_scores + 1e-5 * np.array([v for _, v, _ in cand])\n\n    # Randomly choose among the top\u2011k scores\n    k = min(5, len(scores))\n    topk_idx = np.argpartition(-scores, k-1)[:k]\n    rng = np.random.default_rng(12345)\n    chosen = topk_idx[rng.integers(0, len(topk_idx))]\n\n    return cand[chosen]\n\n",
  "robust_mad_z_density_aug_191": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = [(w, v, idx) for w, v, idx in remaining_items\n            if w <= remaining_capacity and not (w == 0 and v == 0)]\n\n    zero_items = [c for c in cand if c[0] == 0 and c[1] > 0]\n    if zero_items:\n        return zero_items[0]\n\n    if not cand:\n        return None\n\n    densities = np.array([v / (w + 1e-12) for w, v, _ in cand], dtype=float)\n\n    # Soft\u2011min weights (higher density \u2192 lower weight)\n    softmin_weights = np.exp(-densities)\n    softmin_weights /= np.sum(softmin_weights) + 1e-12\n\n    # Select top\u2011k dense items\n    k = min(3, len(densities))\n    topk_idx = np.argpartition(-densities, k-1)[:k]\n    topk_weights = softmin_weights[topk_idx]\n    topk_weights /= np.sum(topk_weights) + 1e-12\n\n    chosen = topk_idx[np.argmax(topk_weights)]\n    return cand[chosen]\n\n",
  "robust_mad_z_density_aug_192": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = [(w, v, idx) for w, v, idx in remaining_items\n            if w <= remaining_capacity and not (w == 0 and v == 0)]\n\n    zero_items = [c for c in cand if c[0] == 0 and c[1] > 0]\n    if zero_items:\n        return zero_items[0]\n\n    if not cand:\n        return None\n\n    densities = np.array([v / (w + 1e-12) for w, v, _ in cand], dtype=float)\n    densities = np.clip(densities, 0, 1)  # bound densities\n\n    mean_d = np.mean(densities)\n    mad_d  = np.median(np.abs(densities - mean_d)) + 1e-12\n    z_scores = (densities - mean_d) / (1.4826 * mad_d)\n    z_scores = np.clip(z_scores, -5, 5)\n\n    # Small deterministic noise to avoid exact ties\n    noise = 1e-9 * np.arange(len(cand))\n    z_scores -= noise\n\n    best_idx = int(np.argmin(z_scores))\n    return cand[best_idx]\n\n",
  "density_plus_value_share_aug_193": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Filter items that fit using a while loop\n    fit = []\n    idx = 0\n    while idx < len(items):\n        w, v, i = items[idx]\n        if w <= cap:\n            fit.append((w, v, i))\n        idx += 1\n\n    if not fit:\n        return None\n\n    # Immediate return for zero\u2011weight, positive\u2011value items\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # Compute total value with epsilon\n    total_v = np.sum([float(v) for (_, v, _) in fit]) + 1e-12\n\n    # Compute score: density + alpha * share\n    alpha = 0.75\n    best_item = None\n    best_score = -np.inf\n    rng = np.random.default_rng(42)  # deterministic noise source\n\n    for w, v, i in fit:\n        if w <= 0:\n            continue\n        dens = np.clip(float(v) / float(w), 0, 1e12)   # clip to avoid overflow\n        share = float(v) / total_v\n        noise = rng.random() * 1e-6                    # deterministic tiny noise\n        score = dens + alpha * share + noise\n        if score > best_score:\n            best_score, best_item = score, (w, v, i)\n\n    return best_item\n\n",
  "density_plus_value_share_aug_194": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Fit items via list comprehension\n    fit = [(w, v, i) for (w, v, i) in items if w <= cap]\n\n    if not fit:\n        return None\n\n    # Zero\u2011weight, positive\u2011value shortcut\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # Total value via np.mean (semantic change) with epsilon\n    total_v = np.mean([float(v) for (_, v, _) in fit]) + 1e-12\n\n    alpha = 0.6\n    best_item = None\n    best_score = -np.inf\n    rng = np.random.default_rng(12345)  # deterministic noise\n\n    for w, v, i in fit:\n        if w <= 0:\n            continue\n        dens = np.clip(float(v) / float(w), 0, 1e12)\n        share = float(v) / total_v\n        noise = rng.random() * 1e-6\n        score = dens + alpha * share + noise\n        if score > best_score:\n            best_score, best_item = score, (w, v, i)\n\n    return best_item\n\n",
  "density_plus_value_share_aug_195": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Fit items\n    fit = [(w, v, i) for (w, v, i) in items if w <= cap]\n\n    if not fit:\n        return None\n\n    # Zero\u2011weight, positive\u2011value shortcut\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # Total value via np.sum with epsilon\n    total_v = np.sum([float(v) for (_, v, _) in fit]) + 1e-12\n\n    alpha = 0.8\n    scores = []\n    for w, v, i in fit:\n        if w <= 0:\n            continue\n        dens = np.clip(float(v) / float(w), 0, 1e12)\n        share = float(v) / total_v\n        scores.append((dens + alpha * share, (w, v, i)))\n\n    if not scores:\n        return None\n\n    # Sort by score descending and pick top\u2011k\n    k = 5\n    top_k = sorted(scores, key=lambda x: x[0], reverse=True)[:k]\n    rng = np.random.default_rng(98765)\n    chosen = rng.choice([item for (_, item) in top_k])\n    return chosen\n\n",
  "mod_bucket_leftover_favor_small_base_aug_196": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Filter items that fit\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Immediate return for zero\u2011weight items with positive value\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Bases for residue analysis\n    bases = np.arange(2, 10, dtype=int)\n\n    # Gather all positive weights for histogram calculation\n    pos_weights = np.array([w for w, _, _ in remaining_items if w > 0], dtype=int)\n\n    # Build normalised residue histograms for each base\n    histograms = {}\n    for b in bases:\n        residues = pos_weights % b\n        hist = np.bincount(residues, minlength=b).astype(float)\n        histograms[b] = hist / (hist.sum() + 1e-12)\n\n    # Greedy selection using a while loop\n    best_item, best_score = None, -np.inf\n    i = 0\n    while i < len(fit):\n        w, v, idx = fit[i]\n        if w <= 0:\n            i += 1\n            continue\n        leftover = remaining_capacity - w\n        # Average popularity of the leftover residue across all bases\n        pop = np.mean([histograms[b][leftover % b] for b in bases])\n        pop = np.clip(pop, 0.0, 1.0)\n        dens = v / (w + 1e-12)\n        score = dens * (0.8 + 0.2 * pop)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n        i += 1\n\n    return best_item\n\n",
  "mod_bucket_leftover_favor_small_base_aug_197": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    bases = list(range(2, 10))\n    histograms = {}\n    for b in bases:\n        hist = np.zeros(b, dtype=float)\n        for w, _, _ in remaining_items:\n            if w > 0:\n                hist[w % b] += 1.0\n        histograms[b] = hist / (hist.sum() + 1e-9)\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        leftover = remaining_capacity - w\n        pop = np.mean([histograms[b][leftover % b] for b in bases])\n        pop = np.clip(pop, 0.0, 1.0)\n        dens = v / (w + 1e-12)\n        # Small random noise for deterministic tie\u2011breaking\n        noise = np.random.uniform(-1e-6, 1e-6)\n        score = dens * (0.75 + 0.25 * pop) + noise\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "mod_bucket_leftover_favor_small_base_aug_198": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    bases = np.arange(2, 10, dtype=int)\n    pos_weights = np.array([w for w, _, _ in remaining_items if w > 0], dtype=int)\n\n    histograms = {}\n    for b in bases:\n        residues = pos_weights % b\n        hist = np.bincount(residues, minlength=b).astype(float)\n        histograms[b] = hist / (hist.sum() + 1e-12)\n\n    scores = []\n    for w, v, idx in fit:\n        if w <= 0:\n            scores.append(-np.inf)\n            continue\n        leftover = remaining_capacity - w\n        pop = np.mean([histograms[b][leftover % b] for b in bases])\n        pop = np.clip(pop, 0.0, 1.0)\n        dens = v / (w + 1e-12)\n        scores.append(dens * (0.75 + 0.25 * pop))\n\n    scores = np.array(scores, dtype=float)\n    exp_scores = np.exp(scores - np.max(scores))\n    probs = exp_scores / (exp_scores.sum() + 1e-12)\n\n    top_k = min(3, len(scores))\n    if top_k == 0:\n        return None\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    chosen_idx = np.random.choice(top_indices, p=probs[top_indices] / probs[top_indices].sum())\n    return fit[chosen_idx]\n\n",
  "mod_bucket_leftover_favor_small_base_aug_199": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    bases = np.arange(3, 12, dtype=int)\n    pos_weights = np.array([w for w, _, _ in remaining_items if w > 0], dtype=int)\n\n    histograms = {}\n    for b in bases:\n        residues = pos_weights % b\n        hist = np.bincount(residues, minlength=b).astype(float)\n        histograms[b] = hist / (hist.sum() + 1e-12)\n\n    scores = []\n    for w, v, idx in fit:\n        if w <= 0:\n            scores.append(-np.inf)\n            continue\n        leftover = remaining_capacity - w\n        pop = np.max([histograms[b][leftover % b] for b in bases])\n        pop = np.clip(pop, 0.0, 1.0)\n        dens = v / (w + 1e-12)\n        scores.append(dens * (0.70 + 0.30 * pop))\n\n    scores = np.array(scores, dtype=float)\n    top_k = min(5, len(scores))\n    if top_k == 0:\n        return None\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    # Deterministic selection: pick the highest score, break ties with noise\n    best_score = scores[top_indices].max()\n    best_candidates = top_indices[scores[top_indices] == best_score]\n    if len(best_candidates) == 1:\n        chosen_idx = best_candidates[0]\n    else:\n        noise = np.random.uniform(-1e-6, 1e-6, size=best_candidates.shape[0])\n        chosen_idx = best_candidates[np.argmax(noise)]\n    return fit[chosen_idx]\n\n",
  "threshold_accept_then_best_fill_aug_200": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Build candidate list with while loop\n    cand = []\n    i = 0\n    n = len(remaining_items)\n    while i < n:\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                density = v / (w + 1e-12)\n                cand.append((density, w, v, idx))\n        i += 1\n\n    if not cand:\n        return None\n\n    ds = np.array([c[0] for c in cand], dtype=float)\n    mu = float(np.mean(ds))\n    sd = float(np.std(ds)) + 1e-12\n\n    # Tightness with clipping\n    tight = np.clip(1.0 - (remaining_capacity / (remaining_capacity + 100.0)), 0.0, 1.0)\n    k = 0.25 + 0.75 * tight\n    thr = mu + k * sd\n\n    above = [c for c in cand if c[0] >= thr]\n    pool = above if above else cand\n\n    # Deterministic noise for tie-breaking\n    best_item = None\n    best_w = -1\n    best_d = -np.inf\n    for d, w, v, idx in pool:\n        noise = (idx % 1000) * 1e-9  # deterministic small noise\n        if w > best_w or (w == best_w and d + noise > best_d):\n            best_w, best_d = w, d + noise\n            best_item = (w, v, idx)\n    return best_item\n\n",
  "threshold_accept_then_best_fill_aug_201": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = [\n        (v / (w + 1e-12), w, v, idx)\n        for w, v, idx in remaining_items\n        if w <= remaining_capacity and w > 0\n    ]\n\n    # Handle zero\u2011weight positive value\n    for w, v, idx in remaining_items:\n        if w == 0 and v > 0 and w <= remaining_capacity:\n            return (w, v, idx)\n\n    if not cand:\n        return None\n\n    ds = np.array([c[0] for c in cand], dtype=float)\n    mu = float(np.median(ds))\n    sd = float(np.std(ds)) + 1e-12\n\n    tight = np.clip(1.0 - (remaining_capacity / (remaining_capacity + 100.0)), 0.0, 1.0)\n    k = 0.3 + 0.7 * tight\n    thr = mu + k * sd\n\n    above = [c for c in cand if c[0] >= thr]\n    pool = above if above else cand\n\n    # Select top_k items by density\n    pool_sorted = sorted(pool, key=lambda c: c[0], reverse=True)\n    top_k = min(7, len(pool_sorted))\n    top_items = pool_sorted[:top_k]\n\n    # Deterministically pick one among top_k using modulo of remaining_capacity\n    pick_idx = remaining_capacity % top_k\n    d, w, v, idx = top_items[pick_idx]\n    return (w, v, idx)\n\n",
  "threshold_accept_then_best_fill_aug_202": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    weights = np.array([w for w, _, _ in remaining_items], dtype=int)\n    values = np.array([v for _, v, _ in remaining_items], dtype=int)\n    indices = np.array([idx for _, _, idx in remaining_items], dtype=int)\n\n    mask = (weights <= remaining_capacity) & (weights > 0)\n    if not np.any(mask):\n        zero_mask = (weights == 0) & (values > 0) & (weights <= remaining_capacity)\n        if np.any(zero_mask):\n            z_idx = np.argmax(zero_mask)\n            return (0, values[z_idx], indices[z_idx])\n        return None\n\n    w_sel = weights[mask]\n    v_sel = values[mask]\n    idx_sel = indices[mask]\n\n    density = np.divide(v_sel, w_sel, out=np.full_like(v_sel, np.inf, dtype=float), where=w_sel>0) + 1e-12\n\n    # Threshold using mean + k*sd\n    mu = float(np.mean(density))\n    sd = float(np.std(density)) + 1e-12\n\n    tight = np.clip(1.0 - (remaining_capacity / (remaining_capacity + 100.0)), 0.0, 1.0)\n    k = 0.5 + 0.5 * tight\n    thr = mu + k * sd\n\n    above_mask = density >= thr\n    if np.any(above_mask):\n        density = density[above_mask]\n        w_sel = w_sel[above_mask]\n        v_sel = v_sel[above_mask]\n        idx_sel = idx_sel[above_mask]\n\n    # Softmax weighting\n    max_d = np.max(density)\n    exp_weights = np.exp(density - max_d)\n    noise = (idx_sel % 1000) * 1e-9\n    weighted = exp_weights * (1.0 + noise)\n\n    best_pos = np.argmax(weighted)\n    return (int(w_sel[best_pos]), int(v_sel[best_pos]), int(idx_sel[best_pos]))\n\n",
  "threshold_accept_then_best_fill_aug_203": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                density = v / (w + 1e-12)\n                cand.append((density, w, v, idx))\n\n    if not cand:\n        return None\n\n    ds = np.array([c[0] for c in cand], dtype=float)\n    mu = float(np.sum(ds) / (len(ds) + 1e-12))\n    sd = float(np.std(ds)) + 1e-12\n\n    tight = np.clip(1.0 - (remaining_capacity / (remaining_capacity + 100.0)), 0.0, 1.0)\n    k = 0.4 + 0.6 * tight\n    thr = mu + k * sd\n\n    above = [c for c in cand if c[0] >= thr]\n    pool = above if above else cand\n\n    best_item = None\n    best_w = -1\n    best_d = -np.inf\n    for d, w, v, idx in pool:\n        noise = (remaining_capacity + idx) * 1e-9\n        if w > best_w or (w == best_w and d + noise > best_d):\n            best_w, best_d = w, d + noise\n            best_item = (w, v, idx)\n    return best_item\n\n",
  "maximin_normalized_value_density_aug_204": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _norm(x: np.ndarray) -> np.ndarray:\n    lo, hi = float(np.min(x)), float(np.max(x))\n    denom = hi - lo + 1e-12\n    normed = (x - lo) / denom\n    return np.clip(normed, 0.0, 1.0)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    fit = []\n    idx = 0\n    while idx < len(items):\n        w, v, id_ = items[idx]\n        if w <= cap:\n            fit.append((w, v, id_))\n        idx += 1\n\n    if not fit:\n        return None\n\n    for w, v, id_ in fit:\n        if w == 0 and v > 0:\n            return (w, v, id_)\n\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    wts = np.array([float(w) for (w, _, _) in fit], dtype=float)\n    dens = vals / np.maximum(1e-12, wts)\n\n    vN = _norm(vals)\n    dN = _norm(dens)\n    scores = np.minimum(vN, dN)\n\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(len(scores)) * 1e-6\n    j = int(np.argmax(scores + noise))\n    return fit[j]\n\n",
  "maximin_normalized_value_density_aug_205": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _norm(x: np.ndarray) -> np.ndarray:\n    lo, hi = float(np.min(x)), float(np.max(x))\n    denom = hi - lo + 1e-12\n    return np.clip((x - lo) / denom, 0.0, 1.0)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    wts = np.array([float(w) for (w, _, _) in fit], dtype=float)\n    dens = vals / np.maximum(1e-12, wts)\n\n    vN = _norm(vals)\n    dN = _norm(dens)\n\n    # weighted aggregation with tunable coefficients\n    w_val, w_den = 0.6, 0.4\n    scores = w_val * vN + w_den * dN\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(len(scores)) * 1e-7\n    scores += noise\n\n    # softmax\u2011like selection: pick one of the top\u2011k items\n    top_k = 3\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    chosen = int(np.random.choice(top_indices))\n    return fit[chosen]\n\n",
  "maximin_normalized_value_density_aug_206": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _norm(x: np.ndarray) -> np.ndarray:\n    lo, hi = float(np.min(x)), float(np.max(x))\n    denom = hi - lo + 1e-12\n    return np.clip((x - lo) / denom, 0.0, 1.0)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    fit = []\n    for w, v, idx in items:\n        if w <= cap:\n            fit.append((w, v, idx))\n\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    wts  = np.array([float(w) for (w, _, _) in fit], dtype=float)\n\n    dens = vals / np.maximum(1e-12, wts)\n\n    vN = _norm(vals)\n    dN = _norm(dens)\n\n    # weighted aggregation with different coefficients\n    scores = 0.7 * vN + 0.3 * dN\n\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(len(scores)) * 1e-7\n    scores += noise\n\n    # random pick among the top\u2011k scores\n    top_k = 5\n    if top_k > len(scores):\n        top_k = len(scores)\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    chosen = int(np.random.choice(top_indices))\n    return fit[chosen]\n\n",
  "multiplicative_power_score_aug_207": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Immediate return for a zero\u2011weight item with positive value\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    # Tightness factor with clipping\n    tight = float(np.clip(1.0 - (C / (C + 200.0)), 0.0, 1.0))\n\n    # Tuned exponents\n    a = 0.85 - 0.35 * tight\n    b = 0.55 + 0.35 * tight\n    c = 0.25 + 0.45 * tight\n\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in fit_items:\n        if w <= 0:\n            continue\n        val   = max(1e-12, float(v))\n        dens  = max(1e-12, float(v) / (float(w) + 1e-12))\n        fill  = max(1e-12, float(w) / (C + 1e-12))\n        score = (val ** a) * (dens ** b) * (fill ** c)\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n    return best_item\n\n",
  "multiplicative_power_score_aug_208": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Convert to numpy arrays for vectorised processing\n    arr = np.array(remaining_items, dtype=np.int64)\n    weights = arr[:, 0].astype(np.float64)\n    values  = arr[:, 1].astype(np.float64)\n    idxs    = arr[:, 2].astype(np.int64)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    w_fit = weights[fit_mask]\n    v_fit = values[fit_mask]\n    i_fit = idxs[fit_mask]\n\n    # Special case: zero weight with positive value\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        z = np.argmax(zero_mask)\n        return (int(w_fit[z]), int(v_fit[z]), int(i_fit[z]))\n\n    C = float(max(1, remaining_capacity))\n    tight = float(np.clip(1.0 - (C / (C + 200.0)), 0.0, 1.0))\n\n    a = 0.8 - 0.3 * tight\n    b = 0.6 + 0.4 * tight\n    c = 0.3 + 0.3 * tight\n\n    dens = np.maximum(1e-12, v_fit / (w_fit + 1e-12))\n    fill = np.maximum(1e-12, w_fit / (C + 1e-12))\n    scores = (v_fit ** a) * (dens ** b) * (fill ** c)\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(len(scores)) * 1e-9\n    scores += noise\n\n    best_idx = np.argmax(scores)\n    return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(i_fit[best_idx]))\n\n",
  "multiplicative_power_score_aug_209": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Fit items\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Immediate return for zero\u2011weight, positive\u2011value item\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    tight = float(np.clip(1.0 - (C / (C + 200.0)), 0.0, 1.0))\n\n    a = 0.8 - 0.3 * tight\n    b = 0.7 + 0.2 * tight\n    c = 0.3 + 0.4 * tight\n\n    items = []\n    scores = []\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        val  = max(1e-12, float(v))\n        dens = max(1e-12, float(v) / (float(w) + 1e-12))\n        fill = max(1e-12, float(w) / (C + 1e-12))\n        score = (val ** a) * (dens ** b) * (fill ** c)\n        items.append((w, v, idx))\n        scores.append(score)\n\n    scores = np.array(scores)\n    if len(scores) <= 3:\n        top = np.argmax(scores)\n        return items[top]\n\n    # Random choice among the top\u20113 scores\n    top_indices = np.argpartition(-scores, 3)[:3]\n    chosen = np.random.choice(top_indices)\n    return items[chosen]\n\n",
  "multiplicative_power_score_aug_210": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = []\n    i = 0\n    n = len(remaining_items)\n    while i < n:\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity:\n            fit.append((w, v, idx))\n        i += 1\n    if not fit:\n        return None\n\n    # Zero\u2011weight, positive\u2011value shortcut\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    tight = float(np.clip(1.0 - (C / (C + 200.0)), 0.0, 1.0))\n\n    a = 0.75 - 0.25 * tight\n    b = 0.65 + 0.35 * tight\n    c = 0.35 + 0.45 * tight\n\n    best_item = None\n    best_score = -np.inf\n    j = 0\n    while j < len(fit):\n        w, v, idx = fit[j]\n        if w <= 0:\n            j += 1\n            continue\n        val   = max(1e-12, float(v))\n        dens  = max(1e-12, float(v) / (float(w) + 1e-12))\n        fill  = max(1e-12, float(w) / (C + 1e-12))\n        score = (val ** a) * (dens ** b) * (fill ** c)\n        # Deterministic tie\u2011breaking with a tiny index\u2011based noise\n        score += j * 1e-9\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n        j += 1\n    return best_item\n\n",
  "dominance_count_heuristic_aug_211": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Convert to a NumPy array for efficient broadcasting\n    items = np.array(remaining_items, dtype=int)\n    weights, values, indices = items[:, 0], items[:, 1], items[:, 2]\n\n    # Mask items that fit into the remaining capacity\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    fit_w, fit_v, fit_idx = weights[fit_mask], values[fit_mask], indices[fit_mask]\n\n    # Immediate return for zero\u2011weight, positive\u2011value items\n    zero_pos = (fit_w == 0) & (fit_v > 0)\n    if np.any(zero_pos):\n        z = np.argmax(zero_pos)\n        return (int(fit_w[z]), int(fit_v[z]), int(fit_idx[z]))\n\n    eps = 1e-12\n\n    # Dominance counts (vectorised)\n    w_mat = fit_w[:, None]\n    v_mat = fit_v[:, None]\n    dom_mat = (w_mat <= w_mat.T) & (v_mat >= v_mat.T) & ((w_mat < w_mat.T) | (v_mat > v_mat.T))\n    dom_counts = np.sum(dom_mat, axis=1)\n\n    # Density with epsilon to avoid division by zero\n    density = fit_v / (fit_w + eps)\n    density = np.clip(density, 0, None)  # ensure non\u2011negative\n\n    # Scoring: weighted sum of density and dominance\n    score = 0.6 * density + 0.4 * dom_counts\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(len(score)) * 1e-6\n    best_idx = np.argmax(score + noise)\n\n    return (int(fit_w[best_idx]), int(fit_v[best_idx]), int(fit_idx[best_idx]))\n\n",
  "dominance_count_heuristic_aug_212": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight positive\u2011value shortcut\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    eps = 1e-12\n    best_score = -np.inf\n    best_item = None\n    i = 0\n    while i < len(fit):\n        w, v, idx = fit[i]\n        if w <= 0:\n            i += 1\n            continue\n\n        # Dominance count\n        dom = 0\n        j = 0\n        while j < len(fit):\n            if i == j:\n                j += 1\n                continue\n            w2, v2, _ = fit[j]\n            if int(w) <= int(w2) and float(v) >= float(v2) and (int(w) < int(w2) or float(v) > float(v2)):\n                dom += 1\n            j += 1\n\n        dens = float(v) / (float(w) + eps)\n        dens = np.clip(dens, 0, None)\n        score = 0.5 * dens + 0.1 * dom\n\n        # Deterministic noise for tie\u2011breaking\n        noise = 1e-7 * i\n        if score + noise > best_score:\n            best_score = score + noise\n            best_item = (w, v, idx)\n\n        i += 1\n\n    # Top\u2011k random choice among the best candidates\n    top_k = min(5, len(fit))\n    scores = []\n    for w, v, idx in fit:\n        dom = 0\n        for w2, v2, _ in fit:\n            if idx == _:\n                continue\n            if int(w) <= int(w2) and float(v) >= float(v2) and (int(w) < int(w2) or float(v) > float(v2)):\n                dom += 1\n        dens = float(v) / (float(w) + eps)\n        scores.append(0.5 * dens + 0.1 * dom)\n\n    scores = np.array(scores)\n    top_indices = np.argpartition(-scores, top_k)[:top_k]\n    rng = np.random.default_rng(42)\n    chosen = rng.choice(top_indices)\n    return fit[chosen]\n\n",
  "dominance_count_heuristic_aug_213": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    eps = 1e-12\n\n    # Proxy density with logarithms\n    densities = np.array([np.log(v + 1) / np.log(w + 1 + eps) for w, v, _ in fit])\n    dens_norm = (densities - np.median(densities)) / (np.ptp(densities) + eps)\n    dens_norm = np.clip(dens_norm, 0, None)\n\n    # Dominance counts (simple loop)\n    dom_counts = []\n    for i, (w, v, _) in enumerate(fit):\n        dom = 0\n        for j, (w2, v2, _) in enumerate(fit):\n            if i == j:\n                continue\n            if w <= w2 and v >= v2 and (w < w2 or v > v2):\n                dom += 1\n        dom_counts.append(dom)\n    dom_counts = np.array(dom_counts)\n\n    # Scoring\n    score = 0.4 * dens_norm + 0.2 * dom_counts\n    noise = np.arange(len(score)) * 1e-8\n    best_idx = np.argmax(score + noise)\n    w, v, idx = fit[best_idx]\n    return (w, v, idx)\n\n",
  "dominance_count_heuristic_aug_214": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom functools import reduce\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    eps = 1e-12\n\n    # Vectorised dominance and density\n    fit_arr = np.array(fit, dtype=int)\n    w, v, idx_arr = fit_arr[:, 0], fit_arr[:, 1], fit_arr[:, 2]\n\n    w_mat = w[:, None]\n    v_mat = v[:, None]\n    dom_mat = (w_mat <= w_mat.T) & (v_mat >= v_mat.T) & ((w_mat < w_mat.T) | (v_mat > v_mat.T))\n    dom_counts = np.sum(dom_mat, axis=1)\n\n    density = v / (w + eps)\n    density = np.clip(density, 0, None)\n\n    score = 0.7 * density + 0.3 * dom_counts\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(score)) * 1e-9\n    score_noisy = score + noise\n\n    # Reduce to find index of maximum score\n    best_index = reduce(lambda a, b: a if score_noisy[a] > score_noisy[b] else b, range(len(score_noisy)))\n\n    return (int(w[best_index]), int(v[best_index]), int(idx_arr[best_index]))\n\n",
  "quantile_cluster_total_value_pick_aug_215": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Keep only items that fit in the remaining capacity\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    # Zero\u2011weight items with positive value are chosen immediately\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Positive weights for quantile calculation\n    pos_weights = np.array([float(w) for w, _, _ in fit if w > 0], dtype=float)\n    if pos_weights.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    q1, q2 = np.quantile(pos_weights, [1/3, 2/3])\n\n    def bin_index(w: float) -> int:\n        if w <= q1:\n            return 0\n        if w <= q2:\n            return 1\n        return 2\n\n    bins = {0: [], 1: [], 2: []}\n    bin_total = {0: 0.0, 1: 0.0, 2: 0.0}\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        b = bin_index(float(w))\n        bins[b].append((w, v, idx))\n        bin_total[b] += float(v)\n\n    # Choose the bin with the highest total value\n    chosen_bin = max(bin_total, key=lambda b: bin_total[b])\n    pool = bins[chosen_bin] if bins[chosen_bin] else [(w, v, idx) for (w, v, idx) in fit if w > 0]\n\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in pool:\n        density = float(v) / max(1e-12, float(w))\n        # Deterministic tie\u2011breaking with tiny noise proportional to the index\n        noise = 1e-6 * idx\n        score = density + noise\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n\n    return best_item\n\n",
  "quantile_cluster_total_value_pick_aug_216": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Filter items that fit\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    # Handle zero\u2011weight items with positive value\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    pos_w = np.array([float(w) for w, _, _ in fit if w > 0], dtype=float)\n    if pos_w.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Use 25th and 75th percentiles instead of 33rd/66th\n    q_low, q_high = np.quantile(pos_w, [0.25, 0.75])\n\n    def bin_id(w: float) -> int:\n        if w <= q_low:\n            return 0\n        if w <= q_high:\n            return 1\n        return 2\n\n    bins = {0: [], 1: [], 2: []}\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        b = bin_id(float(w))\n        bins[b].append((w, v, idx))\n\n    # Choose bin based on median value (semantic change)\n    bin_median = {}\n    for b in bins:\n        if bins[b]:\n            bin_median[b] = np.median([float(v) for _, v, _ in bins[b]])\n        else:\n            bin_median[b] = -np.inf\n    chosen_bin = max(bin_median, key=lambda b: bin_median[b])\n    pool = bins[chosen_bin] if bins[chosen_bin] else [(w, v, idx) for (w, v, idx) in fit if w > 0]\n\n    # Compute densities and pick randomly among the top 3\n    densities = []\n    for w, v, idx in pool:\n        d = float(v) / max(1e-12, float(w))\n        d = np.clip(d, 0, np.inf)\n        densities.append((d, w, v, idx))\n    densities.sort(key=lambda x: x[0], reverse=True)\n    top_k = min(3, len(densities))\n    chosen_index = np.random.choice(top_k, size=1, replace=False)[0]\n    chosen = densities[chosen_index]\n    return (int(chosen[1]), int(chosen[2]), int(chosen[3]))\n\n",
  "quantile_cluster_total_value_pick_aug_217": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Convert to numpy arrays for vectorized operations\n    w_arr = np.array([w for w, _, _ in items], dtype=float)\n    v_arr = np.array([v for _, v, _ in items], dtype=float)\n    idx_arr = np.array([idx for _, _, idx in items], dtype=int)\n\n    fit_mask = w_arr <= cap\n    if not np.any(fit_mask):\n        return None\n\n    w_fit = w_arr[fit_mask]\n    v_fit = v_arr[fit_mask]\n    idx_fit = idx_arr[fit_mask]\n\n    # Zero\u2011weight items with positive value\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        z_idx = np.argmax(zero_mask)  # first match\n        return (int(w_fit[z_idx]), int(v_fit[z_idx]), int(idx_fit[z_idx]))\n\n    pos_mask = w_fit > 0\n    if not np.any(pos_mask):\n        return max(zip(w_fit, v_fit, idx_fit), key=lambda t: float(t[1]))\n\n    pos_w = w_fit[pos_mask]\n    q1, q2 = np.quantile(pos_w, [1/3, 2/3])\n\n    # Assign items to bins\n    bins = [[], [], []]\n    for w, v, idx in zip(w_fit, v_fit, idx_fit):\n        if w <= 0:\n            continue\n        b = 0 if w <= q1 else 1 if w <= q2 else 2\n        bins[b].append((w, v, idx))\n\n    # Total value per bin\n    bin_totals = [np.sum([v for _, v, _ in bins[b]]) for b in range(3)]\n    chosen_bin = int(np.argmax(bin_totals))\n    pool = bins[chosen_bin] if bins[chosen_bin] else [(w, v, idx) for w, v, idx in zip(w_fit, v_fit, idx_fit) if w > 0]\n\n    # Vectorized density calculation with deterministic noise\n    pool_arr = np.array(pool, dtype=object)\n    w_pool = pool_arr[:,0].astype(float)\n    v_pool = pool_arr[:,1].astype(float)\n    idx_pool = pool_arr[:,2].astype(int)\n\n    densities = v_pool / np.maximum(1e-12, w_pool)\n    densities = np.clip(densities, 0, np.inf)\n    noise = 1e-7 * idx_pool\n    scores = densities + noise\n    best_idx = int(np.argmax(scores))\n    return (int(w_pool[best_idx]), int(v_pool[best_idx]), int(idx_pool[best_idx]))\n\n",
  "topk_density_then_best_value_aug_218": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(cap: int, items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    idx = 0\n    cand = []\n    while idx < len(items):\n        w, v, id_ = items[idx]\n        if w <= cap:\n            if w == 0 and v > 0:\n                return (w, v, id_)\n            if w > 0:\n                density = v / (w + 1e-12)          # epsilon added\n                cand.append((density, w, v, id_))\n        idx += 1\n    if not cand:\n        return None\n    cand.sort(key=lambda x: x[0], reverse=True)\n    k = int(max(1, round(np.sqrt(len(cand)))))\n    top = cand[:k]\n    best = max(top, key=lambda t: (t[2], t[0]))\n    _, w, v, id_ = best\n    return (w, v, id_)\n\n",
  "topk_density_then_best_value_aug_219": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(cap: int, items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = [(w, v, idx) for w, v, idx in items if w <= cap and w > 0]\n    if not cand:\n        for w, v, idx in items:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n        return None\n\n    # Compute densities and add deterministic noise for tie\u2011breaking\n    densities = np.array([v / (w + 1e-12) for w, v, _ in cand])\n    noise = np.arange(len(cand)) * 1e-6\n    densities += noise\n\n    k = int(max(1, round(np.sqrt(len(cand)))))\n    top_idx = np.argpartition(-densities, k - 1)[:k]\n    top_cand = [cand[i] for i in top_idx]\n\n    # Pick the item with the highest value among the top\u2011k densities\n    best = max(top_cand, key=lambda t: t[1])\n    return best\n\n",
  "topk_density_then_best_value_aug_220": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(cap: int, items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = [(w, v, idx) for w, v, idx in items if w <= cap and w > 0]\n    if not cand:\n        for w, v, idx in items:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n        return None\n\n    # Densities with small noise to avoid exact ties\n    densities = np.array([v / (w + 1e-12) for w, v, _ in cand])\n    noise = np.arange(len(cand)) * 1e-9\n    densities_noisy = densities + noise\n\n    # Keep only items whose density is above the median of the noisy set\n    median_d = np.median(densities_noisy)\n    filtered = [cand[i] for i, d in enumerate(densities_noisy) if d >= median_d]\n    if not filtered:\n        filtered = cand\n\n    # Return the highest\u2011value item among the filtered set\n    best = max(filtered, key=lambda t: t[1])\n    return best\n\n",
  "topk_density_then_best_value_aug_221": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(cap: int, items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = int(np.clip(cap, 0, np.inf))\n\n    # Build candidate list\n    cand = [(w, v, idx) for w, v, idx in items if w <= cap and w > 0]\n    if not cand:\n        for w, v, idx in items:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n        return None\n\n    # Compute densities\n    densities = np.array([v / (w + 1e-12) for w, v, _ in cand])\n\n    # Use a larger top\u2011k window (k + 3)\n    k = int(max(1, round(np.sqrt(len(cand))) + 3))\n    top_idx = np.argpartition(-densities, k - 1)[:k]\n    top_cand = [cand[i] for i in top_idx]\n\n    # Pick the item with the maximum value among the enlarged top\u2011k\n    best = max(top_cand, key=lambda t: t[1])\n    return best\n\n",
  "fractional_bound_lookahead_aug_222": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    capacity = cap\n    # Keep only items that can fit and have positive value\n    candidate_items = [(w, v) for (w, v, _) in items if w > 0 and w <= capacity and v > 0]\n    if not candidate_items:\n        return 0.0\n\n    # Sort by value/weight ratio (with epsilon to avoid div\u2011by\u2011zero)\n    candidate_items.sort(\n        key=lambda t: float(t[1]) / (float(t[0]) + 1e-12),\n        reverse=True\n    )\n\n    remaining = float(capacity)\n    ub = 0.0\n    i = 0\n    while remaining > 0 and i < len(candidate_items):\n        w, v = candidate_items[i]\n        if remaining < w:\n            ub += float(v) * (remaining / (float(w) + 1e-12))\n            remaining = 0.0\n        else:\n            ub += float(v)\n            remaining -= float(w)\n        i += 1\n    return ub\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    item_list = remaining_items\n\n    # Items that fit\n    fit_items = [(w, v, idx) for (w, v, idx) in item_list if w <= cap]\n    if not fit_items:\n        return None\n\n    # Prefer zero\u2011weight items with positive value\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in fit_items:\n        if w <= 0:\n            continue\n        leftover = cap - int(w)\n        ub = _fractional_upper_bound(leftover, [(w2, v2, i2) for (w2, v2, i2) in item_list if i2 != idx])\n        score = float(v) + ub + 1e-6 * (float(v) / (float(w) + 1e-12))\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n    return best_item\n\n",
  "fractional_bound_lookahead_aug_223": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    capacity = float(cap)\n    weights = np.array([w for w, v, _ in items], dtype=np.float64)\n    values  = np.array([v for w, v, _ in items], dtype=np.float64)\n\n    mask = (weights > 0) & (weights <= capacity) & (values > 0)\n    if not np.any(mask):\n        return 0.0\n\n    w_fit = weights[mask]\n    v_fit = values[mask]\n    ratios = v_fit / np.clip(w_fit, 1e-12, None)\n\n    # Sort by ratio descending\n    order = np.argsort(-ratios)\n    w_sorted = w_fit[order]\n    v_sorted = v_fit[order]\n\n    cum_w = np.cumsum(w_sorted)\n    # How many items fit completely\n    fully_fit = np.searchsorted(cum_w, capacity, side='right')\n\n    ub = np.sum(v_sorted[:fully_fit])\n    if fully_fit < len(v_sorted):\n        rem = capacity - (cum_w[fully_fit - 1] if fully_fit > 0 else 0.0)\n        ub += v_sorted[fully_fit] * (rem / np.clip(w_sorted[fully_fit], 1e-12, None))\n    return float(ub)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    weights = np.array([w for w, v, _ in items], dtype=np.int64)\n    values  = np.array([v for w, v, _ in items], dtype=np.int64)\n    indices = np.array([idx for w, v, idx in items], dtype=np.int64)\n\n    mask = weights <= cap\n    if not np.any(mask):\n        return None\n\n    # Immediate zero\u2011weight, positive\u2011value items\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(mask & zero_mask):\n        idx0 = indices[np.argmax(mask & zero_mask)]\n        return (int(weights[idx0]), int(values[idx0]), int(indices[idx0]))\n\n    best_item = None\n    best_score = -np.inf\n    for i in np.where(mask)[0]:\n        w = weights[i]\n        v = values[i]\n        leftover = cap - int(w)\n        ub = _fractional_upper_bound(leftover,\n                                     [(w2, v2, idx2) for (w2, v2, idx2) in items if idx2 != indices[i]])\n        score = float(v) + ub + 1e-6 * (float(v) / np.clip(float(w), 1e-12, None))\n        if score > best_score:\n            best_score = score\n            best_item = (int(w), int(v), int(indices[i]))\n    return best_item\n\n",
  "fractional_bound_lookahead_aug_224": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    capacity = float(cap)\n    weights = np.array([w for w, v, _ in items], dtype=np.float64)\n    values  = np.array([v for w, v, _ in items], dtype=np.float64)\n\n    mask = (weights > 0) & (weights <= capacity) & (values > 0)\n    if not np.any(mask):\n        return 0.0\n\n    w_fit = weights[mask]\n    v_fit = values[mask]\n    ratios = v_fit / np.clip(w_fit, 1e-12, None)\n    mean_ratio = np.mean(ratios)\n    return float(mean_ratio * capacity)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    weights = np.array([w for w, v, idx in items], dtype=np.int64)\n    values  = np.array([v for w, v, idx in items], dtype=np.int64)\n    indices = np.array([idx for w, v, idx in items], dtype=np.int64)\n\n    mask = weights <= cap\n    if not np.any(mask):\n        return None\n\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(mask & zero_mask):\n        idx0 = indices[np.argmax(mask & zero_mask)]\n        return (int(weights[idx0]), int(values[idx0]), int(indices[idx0]))\n\n    scores = np.full_like(values, -np.inf, dtype=np.float64)\n    for i in np.where(mask)[0]:\n        w = weights[i]\n        v = values[i]\n        leftover = cap - int(w)\n        ub = _fractional_upper_bound(leftover,\n                                     [(w2, v2, idx2) for (w2, v2, idx2) in items if idx2 != indices[i]])\n        scores[i] = float(v) + ub + 1e-6 * (float(v) / np.clip(float(w), 1e-12, None))\n\n    # Deterministic noise for stable tie\u2011breaking\n    rng = np.random.default_rng(seed=42)\n    noise = rng.uniform(0, 1e-6, size=scores.shape)\n    scores += noise\n\n    top_k = min(3, np.count_nonzero(mask))\n    top_indices = np.argpartition(-scores, top_k-1)[:top_k]\n    chosen = rng.choice(top_indices)\n    return (int(weights[chosen]), int(values[chosen]), int(indices[chosen]))\n\n",
  "closest_complement_weight_aug_225": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Items that fit into the remaining capacity\n    fit_items = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Immediate return for zero\u2011weight positive\u2011value items\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Positive weights from the whole pool\n    pos_weights = sorted({int(w) for w, _, _ in remaining_items if int(w) > 0})\n    if not pos_weights:\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    weights_arr = np.array(pos_weights, dtype=int)\n\n    # Vectorised nearest\u2011distance calculation\n    def nearest_dist(x: int) -> int:\n        diffs = np.abs(weights_arr - x)\n        return int(np.min(diffs))\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit_items:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = np.clip(remaining_capacity - ww, 0, remaining_capacity)\n        dist = float(nearest_dist(leftover))\n        dens = float(v) / (float(ww) + 1e-12)          # epsilon in denominator\n        score = dens - 0.03 * dist + 1e-8 * float(v)  # tuned weighting\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "closest_complement_weight_aug_226": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    weight_set = {int(w) for w, _, _ in remaining_items if int(w) > 0}\n    weights_arr = np.array(sorted(weight_set), dtype=int)\n    if weights_arr.size == 0:\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    def nearest_dist(x: int) -> int:\n        diffs = np.abs(weights_arr - x)\n        return int(np.min(diffs))\n\n    scores = []\n    for w, v, idx in fit_items:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = np.clip(remaining_capacity - ww, 0, remaining_capacity)\n        dist = float(nearest_dist(leftover))\n        dens = float(v) / (float(ww) + 1e-12)\n        score = 0.6 * dens - 0.04 * dist + 5e-9 * float(v)  # tuned constants\n        scores.append((score, (w, v, idx)))\n\n    if not scores:\n        return None\n\n    # Sort descending and keep top\u2011k\n    scores.sort(key=lambda t: t[0], reverse=True)\n    top_k = min(5, len(scores))\n    top_items = [item for _, item in scores[:top_k]]\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(top_items)) * 1e-12\n    chosen = top_items[np.argmin(noise)]   # picks the first item\n    return chosen\n\n",
  "closest_complement_weight_aug_227": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    pos_weights = sorted({int(w) for w, _, _ in remaining_items if int(w) > 0})\n    if not pos_weights:\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    weights_arr = np.array(pos_weights, dtype=int)\n\n    def nearest_dist(x: int) -> int:\n        diffs = np.abs(weights_arr - x)\n        return int(np.min(diffs))\n\n    # Reference median density over all items\n    all_dens = [float(v) / (float(w) + 1e-12) for v, w, _ in remaining_items if w > 0]\n    median_dens = float(np.median(all_dens)) if all_dens else 0.0\n\n    scores = []\n    for w, v, idx in fit_items:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = np.clip(remaining_capacity - ww, 0, remaining_capacity)\n        dist = float(nearest_dist(leftover))\n        dens = float(v) / (float(ww) + 1e-12)\n        score = dens - 0.015 * dist + 1e-9 * (dens / (median_dens + 1e-12))\n        scores.append((score, (w, v, idx)))\n\n    if not scores:\n        return None\n\n    scores.sort(key=lambda t: t[0], reverse=True)\n    top_k = min(5, len(scores))\n    top_items = [item for _, item in scores[:top_k]]\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(top_items)) * 1e-12\n    chosen = top_items[np.argmin(noise)]\n    return chosen\n\n",
  "closest_complement_weight_aug_228": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    weight_set = {int(w) for w, _, _ in remaining_items if int(w) > 0}\n    weights_arr = np.array(sorted(weight_set), dtype=int)\n    if weights_arr.size == 0:\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    def nearest_dist(x: int) -> int:\n        diffs = np.abs(weights_arr - x)\n        return int(np.min(diffs))\n\n    scores = []\n    for w, v, idx in fit_items:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = np.clip(remaining_capacity - ww, 0, remaining_capacity)\n        dist = float(nearest_dist(leftover))\n        dens = float(v) / (float(ww) + 1e-12)\n        score = np.max([dens, 0.0]) - 0.025 * dist + 2e-9 * float(v)\n        scores.append((score, (w, v, idx)))\n\n    if not scores:\n        return None\n\n    scores.sort(key=lambda t: t[0], reverse=True)\n    top_k = min(3, len(scores))\n    top_items = [item for _, item in scores[:top_k]]\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(top_items)) * 1e-12\n    chosen = top_items[np.argmin(noise)]\n    return chosen\n\n",
  "value_minus_slack_penalty_aug_229": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # items that fit into the remaining capacity\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # early return for zero\u2011weight items with positive value\n    i = 0\n    while i < len(fit):\n        w, v, idx = fit[i]\n        if w == 0 and v > 0:\n            return (w, v, idx)\n        i += 1\n\n    C = float(max(1, remaining_capacity))\n    tight = np.clip(1.0 - (C / (C + 150.0 + 1e-12)), 0.0, 1.0)\n    beta = 0.15 + 0.55 * tight\n\n    weights = np.array([w for w, _, _ in fit], dtype=np.float64)\n    values  = np.array([v for _, v, _ in fit], dtype=np.float64)\n    idxs    = np.array([idx for _, _, idx in fit], dtype=np.int64)\n\n    slack  = remaining_capacity - weights\n    scores = values - beta * slack\n\n    best_idx = np.argmax(scores)\n    return (int(weights[best_idx]), int(values[best_idx]), int(idxs[best_idx]))\n\n",
  "value_minus_slack_penalty_aug_230": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # handle zero\u2011weight, positive\u2011value items\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    # larger denominator \u2192 slower increase of tightness\n    tight = np.clip(1.0 - (C / (C + 200.0 + 1e-12)), 0.0, 1.0)\n    # adjusted base and slope\n    beta = 0.20 + 0.60 * tight\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        slack = float(remaining_capacity - int(w))\n        score = float(v) - beta * slack\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "value_minus_slack_penalty_aug_231": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    tight = np.clip(1.0 - (C / (C + 150.0 + 1e-12)), 0.0, 1.0)\n    beta = 0.15 + 0.55 * tight\n\n    weights = np.array([w for w, _, _ in fit], dtype=np.float64)\n    values  = np.array([v for _, v, _ in fit], dtype=np.float64)\n    idxs    = np.array([idx for _, _, idx in fit], dtype=np.int64)\n\n    slack  = remaining_capacity - weights\n    scores = values - beta * slack\n\n    # deterministic tie\u2011breaking noise\n    noise      = idxs.astype(np.float64) / 1e6\n    scores_noisy = scores + noise\n\n    best_idx = np.argmax(scores_noisy)\n    return (int(weights[best_idx]), int(values[best_idx]), int(idxs[best_idx]))\n\n",
  "value_minus_slack_penalty_aug_232": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # early return for zero\u2011weight, positive\u2011value items\n    zero_idx = next((i for i, (w, v, _) in enumerate(fit) if w == 0 and v > 0), None)\n    if zero_idx is not None:\n        w, v, idx = fit[zero_idx]\n        return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    tight = np.clip(1.0 - (C / (C + 150.0 + 1e-12)), 0.0, 1.0)\n    beta = 0.15 + 0.55 * tight\n\n    weights = np.array([w for w, _, _ in fit], dtype=np.float64)\n    values  = np.array([v for _, v, _ in fit], dtype=np.float64)\n    idxs    = np.array([idx for _, _, idx in fit], dtype=np.int64)\n\n    slack  = remaining_capacity - weights\n    scores = values - beta * slack\n\n    k = min(3, len(scores))\n    topk_idx = np.argpartition(-scores, k-1)[:k]\n    top_scores = scores[topk_idx]\n\n    # soft\u2011min (negative\u2011score softmax)\n    exp_vals = np.exp(-top_scores - np.max(-top_scores))\n    probs    = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    rng = np.random.default_rng(42)  # deterministic for reproducibility\n    chosen = rng.choice(k, p=probs)\n    idx = topk_idx[chosen]\n\n    return (int(weights[idx]), int(values[idx]), int(idxs[idx]))\n\n",
  "log_value_over_weight_aug_233": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    eps = 1e-12\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            # Special case: zero\u2011weight items with positive value are taken immediately\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            # Score: diminishing returns on value\n            score = np.log1p(np.clip(v, 0, None)) / (float(w) + eps)\n            # Deterministic tie\u2011breaking using the item index\n            score += idx * 1e-9\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "log_value_over_weight_aug_234": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n    # Convert the list of tuples into a NumPy array for vectorised operations\n    arr = np.array(remaining_items, dtype=np.int64)\n    weights, values, idxs = arr[:,0], arr[:,1], arr[:,2]\n    # Mask of items that fit into the remaining capacity\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n    # Handle zero\u2011weight items with positive value\n    zero_mask = (weights == 0) & (values > 0) & fit_mask\n    if np.any(zero_mask):\n        z = np.argmax(zero_mask)\n        return (int(weights[z]), int(values[z]), int(idxs[z]))\n    eps = 1e-12\n    # Vectorised score calculation\n    scores = np.log1p(np.clip(values, 0, None)) / (weights.astype(np.float64) + eps)\n    # Deterministic tie\u2011breaking\n    scores += idxs * 1e-9\n    # Exclude items that do not fit\n    scores[~fit_mask] = -np.inf\n    best_idx = np.argmax(scores)\n    if scores[best_idx] == -np.inf:\n        return None\n    return (int(weights[best_idx]), int(values[best_idx]), int(idxs[best_idx]))\n\n",
  "log_value_over_weight_aug_235": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    best_item = None\n    best_score = np.inf  # lower score is better (soft\u2011min)\n    for w, v, idx in remaining_items:\n        if w > remaining_capacity:\n            continue\n        if w == 0 and v > 0:\n            return (w, v, idx)\n        # Different weighting scheme and soft\u2011min objective\n        score = 0.7 * np.log1p(np.clip(v, 0, None)) / (float(w) + eps)\n        # Deterministic tie\u2011breaking\n        score += idx * 1e-9\n        if score < best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n\n",
  "value_per_sqrt_weight_aug_236": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    idx = 0\n    best_item = None\n    best_score = -np.inf\n\n    while idx < len(remaining_items):\n        w, v, idx_id = remaining_items[idx]\n        if w <= remaining_capacity:\n            # Immediate return for zero\u2011weight positive\u2011value items\n            if w == 0 and v > 0:\n                return (w, v, idx_id)\n\n            denom = np.sqrt(np.clip(float(w), 1e-12, None)) + 1e-12\n            score = float(v) / denom\n\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx_id)\n        idx += 1\n\n    return best_item\n\n",
  "value_per_sqrt_weight_aug_237": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n\n    for w, v, idx_id in remaining_items:\n        if w > remaining_capacity:\n            continue\n\n        if w == 0 and v > 0:\n            return (w, v, idx_id)\n\n        # Tuned denominator: sqrt(weight) + 0.2 * weight**0.1\n        denom = np.sqrt(np.clip(float(w), 1e-12, None)) + 0.2 * (float(w) ** 0.1 + 1e-12)\n        score = float(v) / (denom + 1e-12)\n\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx_id)\n\n    return best_item\n\n",
  "value_per_sqrt_weight_aug_238": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    rng = np.random.default_rng(seed=42)  # deterministic RNG for reproducibility\n    scores = []\n    valid = []\n\n    for i, (w, v, idx_id) in enumerate(remaining_items):\n        if w > remaining_capacity:\n            continue\n        if w == 0 and v > 0:\n            return (w, v, idx_id)\n\n        denom = np.sqrt(np.clip(float(w), 1e-12, None)) + 1e-12\n        base_score = float(v) / denom\n\n        # Add deterministic noise proportional to the index\n        noise = (i + 1) * 1e-6\n        scores.append(base_score + noise)\n        valid.append((w, v, idx_id))\n\n    if not scores:\n        return None\n\n    # Convert scores to softmax probabilities (temperature 10)\n    exp_scores = np.exp(np.array(scores) / 10.0)\n    probs = exp_scores / exp_scores.sum()\n    chosen_idx = np.argmax(probs)  # deterministic choice\n    return valid[chosen_idx]\n\n",
  "value_per_sqrt_weight_aug_239": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    rng = np.random.default_rng()\n    top_k = 5\n\n    scores = []\n    candidates = []\n\n    for w, v, idx_id in remaining_items:\n        if w > remaining_capacity:\n            continue\n        if w == 0 and v > 0:\n            return (w, v, idx_id)\n\n        denom = np.sqrt(np.clip(float(w), 1e-12, None)) + 1e-12\n        scores.append(float(v) / denom)\n        candidates.append((w, v, idx_id))\n\n    if not scores:\n        return None\n\n    # Sort indices by descending score\n    sorted_idx = np.argsort(-np.array(scores))\n    top_indices = sorted_idx[:top_k]\n    chosen_idx = rng.choice(top_indices)\n    return candidates[chosen_idx]\n\n",
  "power_density_p_tightness_aug_240": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = max(1, remaining_capacity)\n    tight = np.clip(1.0 - (cap / (cap + 120.0)), 0.0, 1.0)\n    p = 1.0 + 0.75 * tight\n\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values = np.array([v for _, v, _ in remaining_items], dtype=float)\n    idxs   = np.array([i for _, _, i in remaining_items], dtype=int)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        z = np.argmax(zero_mask)\n        return (int(weights[z]), int(values[z]), int(idxs[z]))\n\n    denom = np.power(weights[fit_mask], p) + 1e-12\n    scores = values[fit_mask] / denom\n    best_local = np.argmax(scores)\n    best_idx = idxs[fit_mask][best_local]\n    return (int(weights[fit_mask][best_local]), int(values[fit_mask][best_local]), int(best_idx))\n\n",
  "power_density_p_tightness_aug_241": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = max(1, remaining_capacity)\n    tight = np.clip(1.0 - (cap / (cap + 120.0)), 0.0, 1.0)\n    p = 1.0 + 0.75 * tight\n\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values = np.array([v for _, v, _ in remaining_items], dtype=float)\n    idxs   = np.array([i for _, _, i in remaining_items], dtype=int)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        z = np.argmax(zero_mask)\n        return (int(weights[z]), int(values[z]), int(idxs[z]))\n\n    denom = np.power(weights[fit_mask], p) + 1e-12\n    scores = values[fit_mask] / denom\n\n    k = min(5, scores.size)           # top\u2011k\n    topk_idx = np.argpartition(-scores, k-1)[:k]\n    rng = np.random.default_rng()\n    chosen_local = rng.choice(topk_idx)\n\n    best_idx = idxs[fit_mask][chosen_local]\n    return (int(weights[fit_mask][chosen_local]), int(values[fit_mask][chosen_local]), int(best_idx))\n\n",
  "power_density_p_tightness_aug_242": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = max(1, remaining_capacity)\n    tight = np.clip(1.0 - (cap / (cap + 120.0)), 0.0, 1.0)\n    p = 1.0 + 0.5 * tight   # different exponent scaling\n\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values = np.array([v for _, v, _ in remaining_items], dtype=float)\n    idxs   = np.array([i for _, _, i in remaining_items], dtype=int)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        z = np.argmax(zero_mask)\n        return (int(weights[z]), int(values[z]), int(idxs[z]))\n\n    denom = np.power(weights[fit_mask], p) + 1e-12\n    scores = values[fit_mask] / denom\n\n    # deterministic noise (fixed seed for reproducibility)\n    rng = np.random.default_rng(42)\n    noise = rng.uniform(-1e-6, 1e-6, size=scores.shape)\n    scores_noisy = scores + noise\n\n    best_local = np.argmax(scores_noisy)\n    best_idx = idxs[fit_mask][best_local]\n    return (int(weights[fit_mask][best_local]), int(values[fit_mask][best_local]), int(best_idx))\n\n",
  "target_fill_fraction_aug_243": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(cap: int, items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not items:\n        return None\n    arr = np.array(items, dtype=np.int64)\n    weights = arr[:,0]\n    values = arr[:,1]\n    idxs = arr[:,2]\n    mask = weights <= cap\n    if not np.any(mask):\n        return None\n    zero_mask = (weights == 0) & (values > 0) & mask\n    if np.any(zero_mask):\n        zidx = np.where(zero_mask)[0][0]\n        return (int(weights[zidx]), int(values[zidx]), int(idxs[zidx]))\n    C = float(max(1, cap))\n    phase = C / (C + 200.0)\n    target = np.clip(0.6 - 0.4 * phase, 0.0, 1.0)\n    tw = target * C\n    band = np.clip(0.2 * C, 0.0, C)\n    near_mask = mask & (np.abs(weights - tw) <= band)\n    pool_mask = near_mask if np.any(near_mask) else mask\n    denom = np.maximum(1e-12, weights[pool_mask].astype(float))\n    score = 0.6 * values[pool_mask].astype(float) + 0.4 * (values[pool_mask].astype(float) / denom)\n    noise = 1e-9 * np.arange(len(score))\n    score += noise\n    best_idx = np.argmax(score)\n    w = int(weights[pool_mask][best_idx])\n    v = int(values[pool_mask][best_idx])\n    idx = int(idxs[pool_mask][best_idx])\n    return (w, v, idx)\n\n",
  "three_champion_runoff_aug_244": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _best_by(items_list, key_func):\n    best_item = None\n    best_key = -np.inf\n    for itm in items_list:\n        k = key_func(itm)\n        if k > best_key:\n            best_key, best_item = k, itm\n    return best_item\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Vectorised filtering of items that fit\n    weights = np.array([w for w, _, _ in items], dtype=int)\n    values  = np.array([v for _, v, _ in items], dtype=int)\n    indices = np.arange(len(items))\n    fit_mask = weights <= cap\n    if not np.any(fit_mask):\n        return None\n\n    fit_idx = indices[fit_mask]\n    fit_weights = weights[fit_mask]\n    fit_values  = values[fit_mask]\n    fit_indices = [items[i][2] for i in fit_idx]  # keep original idx\n\n    # Zero\u2011weight items with positive value\n    zero_mask = (fit_weights == 0) & (fit_values > 0)\n    if np.any(zero_mask):\n        idx = fit_idx[zero_mask][0]\n        return items[idx]\n\n    # Candidates with positive weight\n    cand_mask = fit_weights > 0\n    if not np.any(cand_mask):\n        idx = fit_idx[np.argmax(fit_values)]\n        return items[idx]\n\n    cand_idx = fit_idx[cand_mask]\n    cand_weights = fit_weights[cand_mask]\n    cand_values  = fit_values[cand_mask]\n    cand_indices = [items[i][2] for i in cand_idx]\n\n    # Champions\n    c1 = _best_by([(w, v, idx) for w, v, idx in zip(cand_weights, cand_values, cand_indices)],\n                  lambda t: float(t[1]))\n    c2 = _best_by([(w, v, idx) for w, v, idx in zip(cand_weights, cand_values, cand_indices)],\n                  lambda t: float(t[1]) / (float(t[0]) + 1e-12))\n    c3 = _best_by([(w, v, idx) for w, v, idx in zip(cand_weights, cand_values, cand_indices)],\n                  lambda t: float(t[0]))\n\n    champs = [c for c in [c1, c2, c3] if c is not None]\n    uniq = []\n    seen = set()\n    for w, v, idx in champs:\n        if idx not in seen:\n            uniq.append((w, v, idx))\n            seen.add(idx)\n\n    vals = np.array([float(v) for (_, v, _) in uniq], dtype=float)\n    dens = np.array([float(v) / (float(w) + 1e-12) for (w, v, _) in uniq], dtype=float)\n    fill = np.array([float(w) / (float(cap) + 1e-12) for (w, _, _) in uniq], dtype=float)\n\n    # Clip to keep values in a reasonable range\n    dens = np.clip(dens, 0, np.inf)\n    fill = np.clip(fill, 0, 1)\n\n    def norm(x):\n        mn = np.min(x)\n        mx = np.max(x)\n        return (x - mn) / (mx - mn + 1e-12)\n\n    score = norm(vals) + norm(dens) + 0.5 * norm(fill)\n    j = int(np.argmax(score))\n    return uniq[j]\n\n",
  "three_champion_runoff_aug_245": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _best_by(items, key_fn):\n    best = None\n    bestk = -np.inf\n    for it in items:\n        k = key_fn(it)\n        if k > bestk:\n            bestk, best = k, it\n    return best\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    c1 = _best_by(cand, lambda t: float(t[1]))\n    c2 = _best_by(cand, lambda t: float(t[1]) / (float(t[0]) + 1e-12))\n    c3 = _best_by(cand, lambda t: float(t[0]))\n\n    champs = [c for c in [c1, c2, c3] if c is not None]\n    uniq = []\n    seen = set()\n    for w, v, idx in champs:\n        if idx not in seen:\n            uniq.append((w, v, idx))\n            seen.add(idx)\n\n    vals = np.array([float(v) for (_, v, _) in uniq], dtype=float)\n    dens = np.array([float(v) / (float(w) + 1e-12) for (w, v, _) in uniq], dtype=float)\n    fill = np.array([float(w) / (float(cap) + 1e-12) for (w, _, _) in uniq], dtype=float)\n\n    vals = np.clip(vals, 0, np.inf)\n    dens = np.clip(dens, 0, np.inf)\n    fill = np.clip(fill, 0, 1)\n\n    def norm(x):\n        mn = np.min(x)\n        mx = np.max(x)\n        return (x - mn) / (mx - mn + 1e-12)\n\n    # Weighted score favouring density\n    score = 0.4 * norm(vals) + 0.6 * norm(dens) + 0.3 * norm(fill)\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(len(uniq)) * 1e-8\n    score += noise\n    j = int(np.argmax(score))\n    return uniq[j]\n\n",
  "deterministic_softmax_roulette_aug_246": "import numpy as np\nimport math\nfrom typing import List, Tuple, Optional\n\ndef _hashu(x: float) -> float:\n    s = math.sin(x) * 100000.12345\n    return s - math.floor(s)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n    candidates = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not candidates:\n        return None\n    # Zero\u2011weight, positive\u2011value preference\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    candidates = [(w, v, idx) for (w, v, idx) in candidates if w > 0]\n    if not candidates:\n        best = max([(w, v, idx) for (w, v, idx) in items if w <= cap], key=lambda t: float(t[1]))\n        return best\n    C = float(max(1, cap))\n    # Temperature with tuned bounds\n    T = float(np.clip(0.3 * (C / (C + 90.0)), 0.04, 0.3))\n    # Deterministic noise added to scores\n    noise = np.array([_hashu(C * 0.02 + idx * 0.07) * 1e-3 for (_, _, idx) in candidates], dtype=float)\n    base_scores = np.array([float(v) / float(w) + 0.03 * float(v) for (w, v, _) in candidates], dtype=float)\n    scores = base_scores + noise\n    # Select top\u2011k (k=3) candidates\n    k = min(3, len(candidates))\n    top_indices = np.argpartition(-scores, k-1)[:k]\n    top_candidates = [candidates[i] for i in top_indices]\n    top_scores = scores[top_indices]\n    # Softmin over top candidates\n    min_score = np.min(top_scores)\n    exp_vals = np.exp(-(top_scores - min_score) / T)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    u = _hashu(C * 0.025 + len(top_candidates) * 0.12)\n    cum = 0.0\n    for (w, v, idx), p in zip(top_candidates, probs):\n        cum += float(p)\n        if u <= cum:\n            return (w, v, idx)\n    return top_candidates[-1]\n\n",
  "deterministic_softmax_roulette_aug_247": "import numpy as np\nimport math\nfrom typing import List, Tuple, Optional\n\ndef _hashu(x: float) -> float:\n    s = math.sin(x) * 100000.12345\n    return s - math.floor(s)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = int(remaining_capacity)\n    # Convert to numpy arrays for vectorized filtering\n    w_arr = np.array([item[0] for item in remaining_items], dtype=int)\n    v_arr = np.array([item[1] for item in remaining_items], dtype=float)\n    idx_arr = np.array([item[2] for item in remaining_items], dtype=int)\n    fit_mask = w_arr <= cap\n    if not np.any(fit_mask):\n        return None\n    w_fit = w_arr[fit_mask]\n    v_fit = v_arr[fit_mask]\n    idx_fit = idx_arr[fit_mask]\n    # Prefer zero\u2011weight, positive\u2011value items\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        z_idx = np.argmax(zero_mask)\n        return (int(w_fit[z_idx]), int(v_fit[z_idx]), int(idx_fit[z_idx]))\n    # Remove zero\u2011weight items\n    pos_mask = w_fit > 0\n    w_pos = w_fit[pos_mask]\n    v_pos = v_fit[pos_mask]\n    idx_pos = idx_fit[pos_mask]\n    if len(w_pos) == 0:\n        best_idx = np.argmax(v_fit)\n        return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(idx_fit[best_idx]))\n    C = float(max(1, cap))\n    T = float(np.clip(0.32 * (C / (C + 85.0)), 0.05, 0.32))\n    # Base score and deterministic noise\n    base = v_pos / w_pos + 0.04 * v_pos\n    noise = np.array([_hashu(C * 0.015 + i * 0.09) * 5e-4 for i in range(len(w_pos))], dtype=float)\n    scores = base + noise\n    # Softmax probabilities\n    mx = np.max(scores)\n    exp_vals = np.exp((scores - mx) / T)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    # Deterministic roulette\n    u = _hashu(C * 0.03 + len(w_pos) * 0.18)\n    cum = 0.0\n    for w, v, idx, p in zip(w_pos, v_pos, idx_pos, probs):\n        cum += float(p)\n        if u <= cum:\n            return (int(w), int(v), int(idx))\n    return (int(w_pos[-1]), int(v_pos[-1]), int(idx_pos[-1]))\n\n",
  "winsorized_density_aug_248": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    # Items that can still fit\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    # Immediate win: zero weight with positive value\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Compute densities, protecting against division by zero\n    dens = np.array([float(v) / (float(w) + eps) for (w, v, _) in fit if w > 0], dtype=float)\n    if dens.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Winsorise at the 90th percentile\n    cap = np.quantile(dens, 0.90)\n    capped = np.clip(dens, None, cap)\n\n    # Greedy selection with deterministic tie\u2011breaking noise\n    best_item = None\n    best_score = -np.inf\n    best_v = -np.inf\n    for i, (w, v, idx) in enumerate(fit):\n        if w <= 0:\n            continue\n        d = float(v) / (float(w) + eps)\n        d2 = min(d, cap)\n        noise = 1e-12 * (i + 1)          # deterministic noise for tie\u2011breaking\n        score = d2 + noise\n        if score > best_score or (abs(score - best_score) <= eps and float(v) > best_v):\n            best_score = score\n            best_v = float(v)\n            best_item = (w, v, idx)\n    return best_item\n\n",
  "winsorized_density_aug_249": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Compute densities using a while loop\n    densities = []\n    i = 0\n    while i < len(fit):\n        w, v, _ = fit[i]\n        if w > 0:\n            densities.append(float(v) / (float(w) + eps))\n        i += 1\n    dens_arr = np.array(densities, dtype=float)\n    if dens_arr.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Use mean density as the winsorisation cap\n    cap = np.mean(dens_arr)\n    capped = np.clip(dens_arr, None, cap)\n\n    # Soft\u2011max weighting on the capped densities\n    # Subtract max for numerical stability\n    weights = np.exp(capped - np.max(capped))\n    idx_max = int(np.argmax(weights))\n\n    # Map back to the original list of fit items\n    positive_indices = [i for i, (w, _, _) in enumerate(fit) if w > 0]\n    chosen_idx = positive_indices[idx_max]\n    return fit[chosen_idx]\n\n",
  "winsorized_density_aug_250": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    # Convert to a structured numpy array for vectorised operations\n    items = np.array(remaining_items,\n                     dtype=[('w', np.int64), ('v', np.int64), ('idx', np.int64)])\n    mask = items['w'] <= remaining_capacity\n    if not np.any(mask):\n        return None\n    fit = items[mask]\n\n    # Immediate win: zero weight with positive value\n    zero_mask = (fit['w'] == 0) & (fit['v'] > 0)\n    if np.any(zero_mask):\n        z = fit[zero_mask][0]\n        return (int(z['w']), int(z['v']), int(z['idx']))\n\n    w_arr = fit['w'].astype(float)\n    v_arr = fit['v'].astype(float)\n    dens = v_arr / (w_arr + eps)\n    if dens.size == 0:\n        max_item = max(remaining_items, key=lambda t: float(t[1]))\n        return max_item\n\n    # Winsorise using the median density\n    cap = np.median(dens)\n    capped = np.clip(dens, None, cap)\n\n    # Greedy pick of the highest capped density\n    idx_best = int(np.argmax(capped))\n    best_item = fit[idx_best]\n    return (int(best_item['w']), int(best_item['v']), int(best_item['idx']))\n\n",
  "winsorized_density_aug_251": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eps = 1e-12\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    dens = np.array([float(v) / (float(w) + eps) for (w, v, _) in fit if w > 0], dtype=float)\n    if dens.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Winsorise at the 90th percentile\n    cap = np.quantile(dens, 0.90)\n    capped = np.clip(dens, None, cap)\n\n    # Choose among the top\u2011k capped densities\n    top_k = 5\n    if capped.size < top_k:\n        top_k = capped.size\n    top_indices = np.argpartition(-capped, top_k - 1)[:top_k]\n    chosen = np.random.choice(top_indices)\n\n    # Map back to the original list of fit items\n    positive_indices = [i for i, (w, _, _) in enumerate(fit) if w > 0]\n    chosen_fit_idx = positive_indices[chosen]\n    return fit[chosen_fit_idx]\n\n",
  "regret_based_density_aug_252": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap, items = remaining_capacity, remaining_items\n\n    # Filter items that fit into the remaining capacity\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    # Prefer items with zero weight and positive value\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Exclude zero\u2011weight items from density calculation\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        # All remaining items are zero\u2011weight \u2013 pick the most valuable\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Compute densities safely (avoid division by zero)\n    dens = np.array([float(v) / (float(w) + 1e-12) for (w, v, _) in cand], dtype=float)\n    dens = np.clip(dens, 1e-12, 1e6)                      # keep values bounded\n\n    best_d = np.max(dens) + 1e-12\n\n    # Deterministic noise to break ties (index\u2011based)\n    noise = np.arange(len(cand)) * 1e-9\n\n    # Score each candidate: lower regret + small value bonus\n    scores = -(best_d - dens) + 2e-4 * np.array([v for (_, v, _) in cand], dtype=float) + noise\n    best_idx = int(np.argmax(scores))\n    return cand[best_idx]\n\n",
  "regret_based_density_aug_253": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap, items = remaining_capacity, remaining_items\n\n    # Items that fit\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    # Zero\u2011weight, positive\u2011value preference\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Vectorised densities\n    ws = np.array([w for (w, _, _) in cand], dtype=float)\n    vs = np.array([v for (_, v, _) in cand], dtype=float)\n    dens = vs / (ws + 1e-12)\n    dens = np.clip(dens, 1e-12, 1e6)\n\n    # Use mean density as the \u201cbest\u201d reference\n    best_d = np.mean(dens) + 1e-12\n\n    # Compute regret and score\n    regret = best_d - dens\n    score = -regret + 3e-4 * vs\n\n    # Select the top\u20113 scores and deterministically pick the first\n    top_k = min(3, len(score))\n    top_indices = np.argsort(score)[-top_k:][::-1]      # descending order\n    chosen = top_indices[0]\n    return cand[chosen]\n\n",
  "regret_based_density_aug_254": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap, items = remaining_capacity, remaining_items\n\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Median density as reference\n    dens = np.array([float(v) / (float(w) + 1e-12) for (w, v, _) in cand], dtype=float)\n    dens = np.clip(dens, 1e-12, 1e6)\n    best_d = np.median(dens) + 1e-12\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(cand)) * 1e-8\n\n    # Compute regrets and scores\n    regrets = best_d - dens\n    scores = -regrets + 1e-3 * np.array([v for (_, v, _) in cand], dtype=float) + noise\n\n    # Pick the candidate with the lowest regret among the two highest scores\n    top2 = np.argsort(scores)[-2:][::-1]\n    chosen = top2[0]\n    return cand[chosen]\n\n",
  "regret_based_density_aug_255": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap, items = remaining_capacity, remaining_items\n\n    # Fit items\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    # Handle zero\u2011weight, positive\u2011value items\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Compute densities safely\n    dens = np.array([float(v) / (float(w) + 1e-12) for (w, v, _) in cand], dtype=float)\n    dens = np.clip(dens, 1e-12, 1e6)\n\n    # Reference density via maximum\n    best_d = np.max(dens) + 1e-12\n\n    # Compute regret, clip it, and add a tiny value bonus\n    regrets = best_d - dens\n    regrets = np.clip(regrets, 0, 1e3)          # prevent large negative values\n    score = -regrets + 1e-4 * np.array([v for (_, v, _) in cand], dtype=float)\n\n    # Deterministic noise (negative index)\n    noise = -np.arange(len(cand)) * 1e-9\n    score += noise\n\n    # Choose the item with the highest score\n    chosen = int(np.argmax(score))\n    return cand[chosen]\n\n",
  "top_density_band_best_fill_aug_256": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = []\n    idx = 0\n    while idx < len(remaining_items):\n        w, v, i = remaining_items[idx]\n        if w <= remaining_capacity:\n            fit.append((w, v, i))\n        idx += 1\n    if not fit:\n        return None\n\n    # Immediate return for zero weight but positive value\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # Compute densities with epsilon\n    densities = np.array([float(v) / (float(w) + 1e-12) for w, v, _ in fit], dtype=float)\n    densities = np.clip(densities, 0, 1e12)\n\n    # Threshold using mean density\n    thr = float(np.mean(densities) + 0.05)\n\n    # Candidates above threshold\n    band = [(w, v, i) for (w, v, i), d in zip(fit, densities) if d >= thr]\n    if not band:\n        band = fit\n\n    # Choose item maximizing weighted score (weight prioritized)\n    best_item = None\n    best_score = -np.inf\n    for w, v, i in band:\n        score = 0.4 * float(w) + 0.6 * float(v) + 1e-6 * i\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, i)\n    return best_item\n\n",
  "top_density_band_best_fill_aug_257": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    arr = np.array(remaining_items, dtype=int)\n    if arr.size == 0:\n        return None\n    weights = arr[:,0]\n    values = arr[:,1]\n    indices = arr[:,2]\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n    weights = weights[fit_mask]\n    values = values[fit_mask]\n    indices = indices[fit_mask]\n\n    # Immediate return for zero weight but positive value\n    zero_mask = (weights == 0) & (values > 0)\n    if np.any(zero_mask):\n        idx = np.argmax(zero_mask)\n        return int(weights[idx]), int(values[idx]), int(indices[idx])\n\n    # Densities with epsilon and clipping\n    densities = np.divide(values, weights + 1e-12, out=np.zeros_like(values, dtype=float), where=weights!=0)\n    densities = np.clip(densities, 0, 1e12)\n\n    # Threshold as 80th percentile\n    thr = float(np.quantile(densities, 0.8))\n    band_mask = densities >= thr\n    if not np.any(band_mask):\n        band_mask = np.ones_like(densities, dtype=bool)\n\n    band_weights = weights[band_mask]\n    band_values = values[band_mask]\n    band_indices = indices[band_mask]\n    band_densities = densities[band_mask]\n\n    # Random choice among top-3 densities, deterministic by weight\n    top_k = min(3, len(band_weights))\n    top_indices = np.argsort(-band_densities)[:top_k]\n    candidate_weights = band_weights[top_indices]\n    candidate_values = band_values[top_indices]\n    candidate_indices = band_indices[top_indices]\n    best_idx = np.argmax(candidate_weights + 1e-6 * candidate_indices)\n    return int(candidate_weights[best_idx]), int(candidate_values[best_idx]), int(candidate_indices[best_idx])\n\n",
  "top_density_band_best_fill_aug_258": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, i) for w, v, i in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Immediate return for zero weight but positive value\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    weights = np.array([w for w, _, _ in fit], dtype=float)\n    values = np.array([v for _, v, _ in fit], dtype=float)\n    indices = np.array([i for _, _, i in fit], dtype=int)\n\n    # Compute densities with epsilon\n    densities = np.divide(values, weights + 1e-12, out=np.zeros_like(values), where=weights!=0)\n    densities = np.clip(densities, 0, 1e12)\n\n    # Threshold using median density\n    thr = float(np.median(densities))\n    band_mask = densities >= thr\n    if not np.any(band_mask):\n        band_mask = np.ones_like(densities, dtype=bool)\n\n    band_weights = weights[band_mask]\n    band_values = values[band_mask]\n    band_indices = indices[band_mask]\n    band_densities = densities[band_mask]\n\n    # Sort by density descending and pick top-3\n    top_k = min(3, len(band_weights))\n    sorted_idx = np.argsort(-band_densities)[:top_k]\n    candidate_weights = band_weights[sorted_idx]\n    candidate_values = band_values[sorted_idx]\n    candidate_indices = band_indices[sorted_idx]\n\n    # Randomly choose one among top_k items\n    np.random.seed(0)\n    chosen = np.random.choice(top_k)\n    return int(candidate_weights[chosen]), int(candidate_values[chosen]), int(candidate_indices[chosen])\n\n",
  "nearest_weight_cluster_center_aug_259": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Prefer a zero\u2011weight item with positive value (stability)\n    i = 0\n    while i < len(fit):\n        w, v, idx = fit[i]\n        if w == 0 and v > 0:\n            return (w, v, idx)\n        i += 1\n\n    # Build an array of positive weights from all remaining items\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        # No positive weights \u2013 just pick the item with the largest value\n        return max(fit, key=lambda t: float(t[1]))\n\n    center = float(np.median(ws))\n\n    # Candidates that have positive weight\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    # Distance from the cluster centre\n    dist_arr = np.array([abs(float(w) - center) for (w, _, _) in cand], dtype=float)\n    order = np.argsort(dist_arr)\n    sorted_cand = [cand[j] for j in order]\n\n    # Keep the closest 30\u202f% of the candidates\n    k = max(1, int(round(0.30 * len(sorted_cand))))\n    pool = sorted_cand[:k]\n\n    # Density with a tiny epsilon in the denominator\n    dens = np.array([float(v) / (float(w) + 1e-12) for (w, v, _) in pool], dtype=float)\n    dens = np.clip(dens, 0, 1)  # keep values in a sane range\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(pool)) * 1e-9\n    scores = dens + noise\n    best_idx = int(np.argmax(scores))\n    return pool[best_idx]\n\n",
  "nearest_weight_cluster_center_aug_260": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    center = float(np.median(ws))\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    dist_arr = np.array([abs(float(w) - center) for (w, _, _) in cand], dtype=float)\n    order = np.argsort(dist_arr)\n    sorted_cand = [cand[i] for i in order]\n\n    # Keep the closest 40\u202f% of the candidates\n    k = max(1, int(round(0.40 * len(sorted_cand))))\n    pool = sorted_cand[:k]\n\n    dens = np.array([float(v) / (float(w) + 1e-12) for (w, v, _) in pool], dtype=float)\n    dens = np.clip(dens, 0, 1)\n\n    # Randomly pick among the top\u201130\u202f% densities\n    top_k = max(1, int(round(0.30 * len(pool))))\n    top_indices = np.argsort(-dens)[:top_k]\n    rng = np.random.default_rng(42)\n    chosen = rng.choice(top_indices)\n    return pool[chosen]\n\n",
  "nearest_weight_cluster_center_aug_261": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    center = float(np.mean(ws))\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    rel_diff = np.array([abs(float(w) - center) / center for (w, _, _) in cand], dtype=float)\n    mask = rel_diff <= 0.20\n    pool = [cand[i] for i, m in enumerate(mask) if m]\n    if not pool:\n        pool = cand\n\n    dens = np.array([float(v) / (float(w) + 1e-12) for (w, v, _) in pool], dtype=float)\n    dens = np.clip(dens, 0, 1)\n\n    rng = np.random.default_rng(123)\n    probs = dens / dens.sum() if dens.sum() > 0 else np.ones_like(dens) / len(dens)\n    chosen = rng.choice(len(pool), p=probs)\n    return pool[chosen]\n\n",
  "nearest_weight_cluster_center_aug_262": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    vs = np.array([float(v) for (_, v, _) in remaining_items], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Weighted median using values as weights\n    sorted_idx = np.argsort(ws)\n    sorted_ws = ws[sorted_idx]\n    sorted_vs = vs[sorted_idx]\n    cum = np.cumsum(sorted_vs)\n    half = cum[-1] / 2\n    w_med = sorted_ws[np.searchsorted(cum, half)]\n    center = float(w_med)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    dist_arr = np.array([abs(float(w) - center) for (w, _, _) in cand], dtype=float)\n    order = np.argsort(dist_arr)\n    sorted_cand = [cand[i] for i in order]\n\n    k = max(1, int(round(0.30 * len(sorted_cand))))\n    pool = sorted_cand[:k]\n\n    dens = np.array([float(v) / (float(w) + 1e-12) for (w, v, _) in pool], dtype=float)\n    max_val = np.max(vs)\n    val_ratio = np.array([float(v) / (float(max_val) + 1e-12) for (_, v, _) in pool], dtype=float)\n    scores = 0.6 * dens + 0.4 * val_ratio\n    scores = np.clip(scores, 0, 1)\n\n    top_k = max(1, int(round(0.30 * len(pool))))\n    top_indices = np.argsort(-scores)[:top_k]\n    rng = np.random.default_rng(7)\n    chosen = rng.choice(top_indices)\n    return pool[chosen]\n\n",
  "density_times_remaining_fraction_aug_263": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = float(max(1, remaining_capacity))\n    if not remaining_items:\n        return None\n\n    # Convert to numpy arrays for vectorised processing\n    w_arr = np.array([it[0] for it in remaining_items], dtype=float)\n    v_arr = np.array([it[1] for it in remaining_items], dtype=float)\n    idx_arr = np.array([it[2] for it in remaining_items], dtype=int)\n\n    # Keep only items that fit\n    mask = w_arr <= cap\n    if not np.any(mask):\n        return None\n    w_filt = w_arr[mask]\n    v_filt = v_arr[mask]\n    idx_filt = idx_arr[mask]\n\n    # Special case: zero\u2011weight but positive value\n    zero_mask = (w_filt == 0) & (v_filt > 0)\n    if np.any(zero_mask):\n        z = np.where(zero_mask)[0][0]\n        return (int(w_filt[z]), int(v_filt[z]), int(idx_filt[z]))\n\n    # Density and score calculation\n    dens = np.divide(v_filt, w_filt + 1e-12)\n    dens = np.clip(dens, 0, 1e6)                     # keep values bounded\n    score = dens * (w_filt / cap) + 1e-12 * v_filt\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(len(score)) * 1e-12\n    score += noise\n\n    best = np.argmax(score)\n    return (int(w_filt[best]), int(v_filt[best]), int(idx_filt[best]))\n\n",
  "density_times_remaining_fraction_aug_264": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = float(max(1, remaining_capacity))\n    best_item = None\n    best_score = -np.inf\n\n    # Iterate in reverse order to vary control flow\n    for w, v, idx in reversed(remaining_items):\n        if w > cap:\n            continue\n        if w == 0:\n            if v > 0:\n                return (w, v, idx)\n            continue\n\n        dens = float(v) / (float(w) + 1e-12)\n        dens = np.clip(dens, 0, 1e6)                 # bound density\n        # Tuned weighting: give more emphasis to value\n        score = 0.4 * dens + 0.6 * (float(v) / cap)\n        score += 1e-12 * float(v) + 1e-13 * float(idx)   # deterministic noise\n\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n\n    return best_item\n\n",
  "density_times_remaining_fraction_aug_265": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = float(max(1, remaining_capacity))\n\n    # Compute median density as a proxy for typical efficiency\n    dens_list = []\n    for w, v, _ in remaining_items:\n        if w > 0:\n            dens_list.append(v / (w + 1e-12))\n    if not dens_list:\n        return None\n    median_dens = np.median(dens_list)\n    median_dens = np.clip(median_dens, 1e-12, None)\n\n    def recurse(items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n        if not items:\n            return None\n        w, v, idx = items[0]\n        if w > cap:\n            return recurse(items[1:])\n        if w == 0:\n            if v > 0:\n                return (w, v, idx)\n            return recurse(items[1:])\n\n        dens = v / (w + 1e-12)\n        dens = np.clip(dens, 0, 1e6)\n        score = (dens / median_dens) * np.clip(w / cap, 0, 1) + 1e-12 * v\n\n        rest_best = recurse(items[1:])\n        if rest_best is None:\n            return (w, v, idx)\n\n        w_b, v_b, idx_b = rest_best\n        dens_b = v_b / (w_b + 1e-12)\n        dens_b = np.clip(dens_b, 0, 1e6)\n        score_b = (dens_b / median_dens) * np.clip(w_b / cap, 0, 1) + 1e-12 * v_b\n\n        return (w, v, idx) if score > score_b else rest_best\n\n    return recurse(remaining_items)\n\n",
  "harmonic_mean_value_density_aug_266": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _hmean(a: float, b: float) -> float:\n    return 2.0 * a * b / (a + b + 1e-12)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # items that can fit into the remaining capacity\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    # if a zero\u2011weight item has positive value, pick it immediately\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # candidates with positive weight\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        # fallback: best value regardless of density\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    # normalise value and density to [0,1] with clipping\n    min_val, max_val = np.min(vals), np.max(vals)\n    min_den, max_den = np.min(dens), np.max(dens)\n    vN = np.clip((vals - min_val) / (max_val - min_val + 1e-12), 0.0, 1.0)\n    dN = np.clip((dens - min_den) / (max_den - min_den + 1e-12), 0.0, 1.0)\n\n    best_item, best_score = None, -np.inf\n    for (weight, value, item_id), a, b in zip(cand, vN, dN):\n        # deterministic tie\u2011breaking noise\n        noise = (item_id % 1000) * 1e-6\n        score = _hmean(float(a), float(b)) + noise\n        if score > best_score:\n            best_score, best_item = score, (weight, value, item_id)\n\n    return best_item\n\n",
  "harmonic_mean_value_density_aug_267": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _hmean(a: float, b: float) -> float:\n    return 2.0 * a * b / (a + b + 1e-12)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    # weighted sum of normalised metrics (0.6 value, 0.4 density)\n    v_min, v_max = np.min(vals), np.max(vals)\n    d_min, d_max = np.min(dens), np.max(dens)\n    vN = np.clip((vals - v_min) / (v_max - v_min + 1e-12), 0.0, 1.0)\n    dN = np.clip((dens - d_min) / (d_max - d_min + 1e-12), 0.0, 1.0)\n\n    scores = 0.6 * vN + 0.4 * dN\n\n    # deterministic noise to break ties\n    noise = np.array([(w_idx[2] % 1000) * 1e-7 for w_idx in cand], dtype=float)\n    scores += noise\n\n    best_idx = np.argmax(scores)\n    return cand[best_idx]\n\n",
  "harmonic_mean_value_density_aug_268": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _hmean(a: float, b: float) -> float:\n    return 2.0 * a * b / (a + b + 1e-12)\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    # median\u2011based normalisation\n    val_median = np.median(vals)\n    den_median = np.median(dens)\n    val_range = np.max(vals) - val_median + 1e-12\n    den_range = np.max(dens) - den_median + 1e-12\n    vN = np.clip((vals - val_median) / val_range, 0.0, 1.0)\n    dN = np.clip((dens - den_median) / den_range, 0.0, 1.0)\n\n    # softmin scoring with temperature\n    temp = 0.5\n    scores = np.exp(-(vN + dN) / temp)\n\n    # deterministic noise\n    noise = np.array([(w_idx[2] % 1000) * 1e-8 for w_idx in cand], dtype=float)\n    scores += noise\n\n    # top\u2011k selection (k=3) and deterministic tie\u2011break\n    top_k = 3\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    best_idx = min(top_indices, key=lambda i: cand[i][2])\n\n    return cand[best_idx]\n\n",
  "leftover_parity_match_aug_269": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = []\n    for item in remaining_items:\n        w, v, idx = item\n        if w <= remaining_capacity:\n            fit.append((w, v, idx))\n    if not fit:\n        return None\n\n    # Special case: zero\u2011weight item with positive value\n    for w, v, idx in fit:\n        if v > 0 and w == 0:\n            return (w, v, idx)\n\n    # Parity preference based on the proportion of even weights\n    pos_weights = [int(w) for (w, _, _) in remaining_items if int(w) > 0]\n    if not pos_weights:\n        # If no positive weights, pick the item with the largest value\n        return max(fit, key=lambda t: float(t[1]))\n\n    even_frac = sum(1 for w in pos_weights if w % 2 == 0) / (float(len(pos_weights)) + 1e-12)\n    preferred_even = even_frac >= 0.5\n\n    # Scoring\n    best_item = None\n    best_score = -np.inf\n    noise = np.arange(len(fit)) * 1e-6  # deterministic tie\u2011breaker\n    for i, (w, v, idx) in enumerate(fit):\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = remaining_capacity - ww\n        parity_match = 1.0 if ((leftover % 2 == 0) == preferred_even) else 0.0\n        dens = float(v) / (float(ww) + 1e-12)\n        dens = np.clip(dens, 0, 1e3)          # clip to avoid extreme values\n        score = dens + 0.15 * parity_match + noise[i]\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n    return best_item\n\n",
  "leftover_parity_match_aug_270": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight positive value shortcut\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Parity preference using the median of evenness\n    pos_weights = [int(w) for (w, _, _) in remaining_items if int(w) > 0]\n    if not pos_weights:\n        return max(fit, key=lambda t: float(t[1]))\n\n    even_frac = float(np.median([(w % 2 == 0) for w in pos_weights]))\n    preferred_even = even_frac >= 0.5\n\n    # Score each item, adding deterministic noise for tie\u2011breaking\n    scored = []\n    for i, (w, v, idx) in enumerate(fit):\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = remaining_capacity - ww\n        parity_match = 1.0 if ((leftover % 2 == 0) == preferred_even) else 0.0\n        dens = float(v) / (float(ww) + 1e-12)\n        dens = np.clip(dens, 0, 1e3)\n        score = dens + 0.10 * parity_match + i * 1e-6\n        scored.append((score, (w, v, idx)))\n\n    # Sort by score and randomly pick among the top\u2011k\n    scored.sort(key=lambda x: x[0], reverse=True)\n    top_k = min(5, len(scored))\n    top_items = [item for _, item in scored[:top_k]]\n    chosen_idx = np.random.choice(top_k)\n\n    return top_items[chosen_idx]\n\n",
  "leftover_parity_match_aug_271": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Create numpy arrays\n    weights = np.array([w for w, _, _ in remaining_items], dtype=np.int64)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=np.float64)\n    indices = np.array([idx for _, _, idx in remaining_items], dtype=np.int64)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    fit_w = weights[fit_mask]\n    fit_v = values[fit_mask]\n    fit_i = indices[fit_mask]\n\n    # Handle zero\u2011weight positive value\n    zero_mask = (fit_w == 0) & (fit_v > 0)\n    if np.any(zero_mask):\n        pos = np.where(zero_mask)[0][0]\n        return (int(fit_w[pos]), int(fit_v[pos]), int(fit_i[pos]))\n\n    # Parity preference using the sum of evenness\n    pos_w = weights[weights > 0]\n    if pos_w.size == 0:\n        idx = np.argmax(fit_v)\n        return (int(fit_w[idx]), int(fit_v[idx]), int(fit_i[idx]))\n\n    even_sum = np.sum((pos_w % 2 == 0).astype(np.int64))\n    preferred_even = even_sum >= (pos_w.size // 2)\n\n    # Compute densities and parity matches\n    densities = fit_v / (fit_w.astype(np.float64) + 1e-12)\n    densities = np.clip(densities, 0, 1e3)\n\n    leftovers = remaining_capacity - fit_w\n    parity_match = ((leftovers % 2 == 0) == preferred_even).astype(np.float64)\n\n    # Score with a small epsilon for tie\u2011breaking\n    scores = densities + 0.08 * parity_match\n    eps_noise = np.arange(len(scores)) * 1e-9\n    scores += eps_noise\n\n    best_idx = np.argmax(scores)\n    return (int(fit_w[best_idx]), int(fit_v[best_idx]), int(fit_i[best_idx]))\n\n",
  "small_weight_reserve_aug_272": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Items that can fit into the remaining capacity\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Prioritise zero\u2011weight items that have value\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Small\u2011item statistics\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        # All weights are zero or negative \u2013 just pick the best value\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    small_thr = float(np.quantile(ws, 0.25))\n    small_count = int(sum(1 for (w, _, _) in remaining_items if 0 < int(w) <= small_thr))\n    small_frac = float(small_count) / float(max(1, len(remaining_items)))\n\n    # Search for the best item using a while\u2011loop\n    best_item = None\n    best_score = -np.inf\n    i = 0\n    while i < len(fit_items):\n        w, v, idx = fit_items[i]\n        if w <= 0:\n            i += 1\n            continue\n        density = float(v) / (float(w) + 1e-12)          # epsilon to avoid div\u2011by\u2011zero\n        penalty  = 0.25 * small_frac * (float(w) / (float(remaining_capacity) + 1e-12))\n        penalty  = np.clip(penalty, 0, 1)                 # keep penalty sane\n        # Deterministic noise based on the hash of the index\n        noise = (hash(idx) % 1000) * 1e-9\n        score = density - penalty + noise\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n        i += 1\n\n    return best_item\n\n",
  "small_weight_reserve_aug_273": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Items that can fit\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Zero\u2011weight items with value\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Small\u2011item statistics using median\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    small_thr = float(np.median(ws))\n    small_count = int(np.sum((ws > 0) & (ws <= small_thr)))\n    small_frac = float(small_count) / float(max(1, len(remaining_items)))\n\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in fit_items:\n        if w <= 0:\n            continue\n        # Penalise large weights more\n        density = float(v) / ((float(w) ** 2) + 1e-12)\n        penalty = 0.25 * small_frac * (float(w) / (float(remaining_capacity) + 1e-12))\n        penalty = np.clip(penalty, 0, 1)\n        # Deterministic noise\n        noise = (idx * 13) % 1000 * 1e-9\n        score = density - penalty + noise\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    return best_item\n\n",
  "small_weight_reserve_aug_274": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Fit items\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Zero\u2011weight items with value\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Small\u2011item statistics\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    small_thr = float(np.quantile(ws, 0.25))\n    small_count = int(np.sum((ws > 0) & (ws <= small_thr)))\n    small_frac = float(small_count) / float(max(1, len(remaining_items)))\n\n    # Compute scores for all fit items\n    scores = []\n    for w, v, idx in fit_items:\n        if w <= 0:\n            continue\n        density = float(v) / (float(w) + 1e-12)\n        # Proxy penalty: uses sqrt of remaining capacity instead of linear ratio\n        penalty = 0.25 * small_frac * (float(w) / (np.sqrt(remaining_capacity + 1e-12) + 1e-12))\n        penalty = np.clip(penalty, 0, 1)\n        # Add a tiny deterministic noise\n        noise = (idx % 500) * 1e-8\n        scores.append((density - penalty + noise, (w, v, idx)))\n\n    if not scores:\n        return None\n\n    # Sort scores and pick top\u2011k\n    scores.sort(key=lambda x: x[0], reverse=True)\n    top_k = min(5, len(scores))\n    top_candidates = [item for _, item in scores[:top_k]]\n\n    # Randomly choose one from the top\u2011k\n    chosen = np.random.choice(top_candidates)\n    return chosen\n\n",
  "max_value_then_min_weight_aug_275": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Convert to numpy arrays for fast operations\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.arange(len(remaining_items))\n\n    # Items that fit in the remaining capacity\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    # Prefer zero\u2011weight items with positive value\n    zero_mask = (weights == 0) & (values > 0) & fit_mask\n    if np.any(zero_mask):\n        return remaining_items[np.argmax(zero_mask)]\n\n    # Scoring: value plus a small inverse\u2011weight bonus (avoid division by zero)\n    eps = 1e-12\n    weight_safe = np.clip(weights, eps, None)          # prevent 1/0\n    score = values + 1.0 / weight_safe\n\n    # Deterministic noise to break ties (index\u2011based)\n    noise = indices * 1e-6\n    score += noise\n\n    # Choose the best score among fitting items\n    best_fit_idx = np.argmax(score[fit_mask])\n    fit_indices = indices[fit_mask]\n    chosen = fit_indices[best_fit_idx]\n\n    return remaining_items[chosen]\n\n",
  "max_value_then_min_weight_aug_276": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    idxs    = np.array([i for _, _, i in remaining_items], dtype=int)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    # Zero\u2011weight positive\u2011value shortcut\n    zero_mask = (weights == 0) & (values > 0) & fit_mask\n    if np.any(zero_mask):\n        return remaining_items[np.argmax(zero_mask)]\n\n    eps = 1e-12\n    weight_safe = np.clip(weights, eps, None)\n\n    # Tuned scoring: 0.6*value + 0.4*(1/weight)\n    score = 0.6 * values + 0.4 * (1.0 / weight_safe)\n\n    # Choose top_k candidates\n    top_k = 7\n    fit_indices = np.where(fit_mask)[0]\n    fit_scores  = score[fit_mask]\n    if len(fit_scores) <= top_k:\n        top_indices = fit_indices\n    else:\n        partition = np.argpartition(-fit_scores, top_k - 1)[:top_k]\n        top_indices = fit_indices[partition]\n\n    # Among the top, pick the one with the smallest weight\n    top_weights = weights[top_indices]\n    min_w_idx = np.argmin(top_weights)\n    chosen = top_indices[min_w_idx]\n\n    return remaining_items[chosen]\n\n",
  "max_value_then_min_weight_aug_277": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    weights = np.array([w for w, _, _ in remaining_items], dtype=float)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    idxs    = np.array([i for _, _, i in remaining_items], dtype=int)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    # Zero\u2011weight positive\u2011value shortcut\n    zero_mask = (weights == 0) & (values > 0) & fit_mask\n    if np.any(zero_mask):\n        return remaining_items[np.argmax(zero_mask)]\n\n    # Add deterministic noise to the value to stabilise ties\n    noise = (np.arange(len(values)) % 100) * 1e-8\n    values_noisy = values + noise\n\n    # Find the maximum value among fitting items\n    fit_indices = np.where(fit_mask)[0]\n    best_vals = values_noisy[fit_mask]\n    max_val = np.max(best_vals)\n\n    # Candidates with the same maximal value\n    candidates = fit_indices[best_vals == max_val]\n    if len(candidates) == 1:\n        chosen = candidates[0]\n    else:\n        # Prefer the item with the smallest weight (use clipped weights for safety)\n        eps = 1e-12\n        weight_clip = np.clip(weights, eps, None)\n        chosen = candidates[np.argmin(weight_clip[candidates])]\n\n    return remaining_items[chosen]\n\n",
  "min_weight_then_max_density_aug_278": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Vectorise the items\n    items = np.array(remaining_items, dtype=np.int64)\n    weights, values, indices = items[:,0], items[:,1], items[:,2]\n\n    # Items that fit into the remaining capacity\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    fit_w, fit_v, fit_i = weights[fit_mask], values[fit_mask], indices[fit_mask]\n\n    # Prefer zero\u2011weight items with positive value\n    zero_mask = (fit_w == 0) & (fit_v > 0)\n    if np.any(zero_mask):\n        idx = np.argmax(zero_mask)          # first such item\n        return (int(fit_w[idx]), int(fit_v[idx]), int(fit_i[idx]))\n\n    # Keep only strictly positive weights\n    pos_mask = fit_w > 0\n    pos_w, pos_v, pos_i = fit_w[pos_mask], fit_v[pos_mask], fit_i[pos_mask]\n\n    # Minimum weight among the remaining candidates\n    min_w = int(np.min(pos_w))\n    min_mask = pos_w == min_w\n    light_w, light_v, light_i = pos_w[min_mask], pos_v[min_mask], pos_i[min_mask]\n\n    # Density with epsilon to avoid division by zero\n    epsilon = 1e-12\n    density = light_v / (light_w + epsilon)\n\n    # Deterministic tie\u2011breaking: add tiny noise and clip to [0,1]\n    noise = 1e-9 * np.arange(len(density))\n    density = np.clip(density + noise, 0.0, 1.0)\n\n    best_idx = int(np.argmax(density))\n    return (int(light_w[best_idx]), int(light_v[best_idx]), int(light_i[best_idx]))\n\n",
  "min_weight_then_max_density_aug_279": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Zero\u2011weight items with positive value are immediately chosen\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Minimum weight among candidates\n    min_w = min(w for w, _, _ in fit_items)\n    light_items = [(w, v, idx) for w, v, idx in fit_items if w == min_w]\n\n    # Compute densities with epsilon\n    densities = np.array([v / (w + 1e-12) for w, v, _ in light_items])\n    densities = np.clip(densities, 0.0, 1.0)   # bound to avoid extreme values\n\n    # Use the median density to break ties\n    median_density = np.median(densities)\n    mask = np.isclose(densities, median_density, atol=1e-9)\n\n    if np.any(mask):\n        chosen = light_items[np.argmax(mask)]\n    else:\n        chosen = light_items[0]                # fallback\n\n    return chosen\n\n",
  "min_weight_then_max_density_aug_280": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Prefer zero\u2011weight items with positive value\n    zero_items = [(w, v, idx) for w, v, idx in fit_items if w == 0 and v > 0]\n    if zero_items:\n        return zero_items[0]\n\n    # Weighted score: lower weight is penalised, higher value rewarded\n    # Tuned constants: 0.4 for weight, 0.6 for value\n    scores = [0.4 * w - 0.6 * v for w, v, _ in fit_items]\n    min_score = min(scores)\n\n    # Candidates with the best score\n    best_candidates = [item for item, s in zip(fit_items, scores) if s == min_score]\n\n    # If several, pick one with the highest proxy density (value/(weight+eps))\n    densities = [v / (w + 1e-12) for w, v, _ in best_candidates]\n    max_density = max(densities)\n    for item, d in zip(best_candidates, densities):\n        if d == max_density:\n            return item\n\n",
  "density_with_leftover_quadratic_penalty_aug_281": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    # Immediate return for zero\u2011weight items with positive value\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cap = float(max(1, remaining_capacity))\n    gamma = 0.6  # tuned penalty weight\n\n    # Vectorised computation\n    ws = np.array([c[0] for c in candidates], dtype=float)\n    vs = np.array([c[1] for c in candidates], dtype=float)\n    idxs = np.array([c[2] for c in candidates], dtype=int)\n\n    dens = vs / (ws + 1e-12)                         # avoid division by zero\n    leftover = np.clip((cap - ws) / cap, 0.0, 1.0)   # keep in [0,1]\n    scores = dens - gamma * np.square(leftover)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(scores)) * 1e-9\n    scores += noise\n\n    best_idx = np.argmax(scores)\n    return (int(ws[best_idx]), int(vs[best_idx]), int(idxs[best_idx]))\n\n",
  "density_with_leftover_quadratic_penalty_aug_282": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Immediate return for zero\u2011weight items with positive value\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    gamma = 0.5  # adjusted penalty\n\n    # Compute individual scores\n    scores = []\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / (float(w) + 1e-12)\n        leftover = (C - float(w)) / C\n        score = dens - gamma * (leftover ** 2)\n        scores.append(score)\n\n    if not scores:\n        return None\n\n    scores_arr = np.array(scores)\n    median_score = np.median(scores_arr)\n\n    # Select items with score above or equal to the median\n    top_indices = np.where(scores_arr >= median_score)[0]\n    if len(top_indices) == 0:\n        top_indices = np.arange(len(scores_arr))\n\n    # Randomly pick one of the top\u2011k items (k = 3 or fewer)\n    k = min(3, len(top_indices))\n    chosen_idx = np.random.choice(top_indices, 1, replace=False)[0]\n\n    w_sel, v_sel, idx_sel = fit[chosen_idx]\n    return (int(w_sel), int(v_sel), int(idx_sel))\n\n",
  "density_with_leftover_quadratic_penalty_aug_283": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    items = np.array(remaining_items, dtype=int)\n    w = items[:, 0]\n    v = items[:, 1]\n    idx = items[:, 2]\n\n    mask = w <= remaining_capacity\n    if not np.any(mask):\n        return None\n\n    w_fit = w[mask].astype(float)\n    v_fit = v[mask].astype(float)\n    idx_fit = idx[mask]\n\n    # Immediate return for zero\u2011weight items with positive value\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        pos = np.argmax(zero_mask)\n        return (int(w_fit[pos]), int(v_fit[pos]), int(idx_fit[pos]))\n\n    cap = float(max(1, remaining_capacity))\n    gamma = 0.4  # lower penalty weight\n\n    dens = v_fit / (w_fit + 1e-12)\n    leftover = np.clip((cap - w_fit) / cap, 0.0, 1.0)\n    scores = dens - gamma * np.square(leftover)\n\n    # Use np.max to pick the single best item\n    best_idx = np.argmax(scores)\n    return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(idx_fit[best_idx]))\n\n",
  "density_with_leftover_quadratic_penalty_aug_284": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    remaining = remaining_items[:]\n\n    while remaining:\n        # Find items that fit\n        fit = [(w, v, idx) for (w, v, idx) in remaining if w <= remaining_capacity]\n        if not fit:\n            break\n\n        # Immediate return for zero\u2011weight items with positive value\n        for w, v, idx in fit:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n\n        C = float(max(1, remaining_capacity))\n        gamma = 0.7  # heavier penalty\n\n        # Compute scores\n        scores = []\n        for w, v, idx in fit:\n            if w <= 0:\n                continue\n            dens = float(v) / (float(w) + 1e-12)\n            leftover = (C - float(w)) / C\n            scores.append(dens - gamma * (leftover ** 2))\n\n        if not scores:\n            break\n\n        scores = np.array(scores, dtype=float)\n\n        # Softmin: choose item with the smallest score but weighted by exp(-score)\n        weights = np.exp(-scores)\n        best_pos = np.argmax(weights)\n        w_sel, v_sel, idx_sel = fit[best_pos]\n        return (int(w_sel), int(v_sel), int(idx_sel))\n\n    return None\n\n",
  "local_density_slope_aug_285": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Build candidate list and filter by capacity\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Handle zero\u2011weight items first\n    i = 0\n    while i < len(fit):\n        w, v, idx = fit[i]\n        if w == 0 and v > 0:\n            return (0, int(v) if float(v).is_integer() else v, idx)\n        i += 1\n\n    # Keep only positive\u2011weight candidates\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        # All remaining items are zero\u2011weight but have zero value\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Sort by weight for local neighbourhoods\n    cand_sorted = sorted(cand, key=lambda t: t[0])\n    ws = np.array([w for (w, _, _) in cand_sorted], dtype=float)\n    vs = np.array([v for (_, v, _) in cand_sorted], dtype=float)\n\n    best_item = None\n    best_score = -np.inf\n    for i, (w, v, idx) in enumerate(cand_sorted):\n        lo = max(0, i - 3)\n        hi = min(len(cand_sorted), i + 4)\n        # Exclude the current item\n        wloc = np.delete(ws[lo:hi], i - lo)\n        vloc = np.delete(vs[lo:hi], i - lo)\n\n        # Local average density (median to reduce outlier influence)\n        if wloc.size == 0:\n            local_d = 0.0\n        else:\n            local_d = np.median(vloc / np.maximum(1e-12, wloc))\n\n        # Relative efficiency\n        rel = (v / w) - local_d\n\n        # Score: relative part + small density bonus\n        score = rel + 1e-3 * (v / w)\n\n        # Deterministic noise for tie\u2011breaking\n        score += 1e-9 * (i + 1)\n\n        if score > best_score:\n            best_score, best_item = score, (w, int(v) if float(v).is_integer() else v, idx)\n\n    w, v, idx = best_item\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n\n",
  "local_density_slope_aug_286": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items\n           if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight special case\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (0, int(v) if float(v).is_integer() else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    cand_sorted = sorted(cand, key=lambda t: t[0])\n    ws = np.array([w for (w, _, _) in cand_sorted], dtype=float)\n    vs = np.array([v for (_, v, _) in cand_sorted], dtype=float)\n\n    scores = []\n    for i, (w, v, idx) in enumerate(cand_sorted):\n        lo = max(0, i - 3)\n        hi = min(len(cand_sorted), i + 4)\n        wloc = np.delete(ws[lo:hi], i - lo)\n        vloc = np.delete(vs[lo:hi], i - lo)\n\n        if wloc.size == 0:\n            local_d = 0.0\n        else:\n            local_d = np.sum(vloc / np.maximum(1e-12, wloc)) / wloc.size\n\n        rel = (v / w) - local_d\n        score = 0.7 * rel + 0.3 * (v / w)  # tuned weights\n        scores.append(score)\n\n    scores = np.array(scores)\n    top_k = 5\n    if len(scores) <= top_k:\n        top_indices = np.arange(len(scores))\n    else:\n        top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n\n    # Soft\u2011min probabilities (higher score \u2192 lower probability)\n    softmin_vals = np.exp(-scores[top_indices])\n    probs = softmin_vals / softmin_vals.sum()\n\n    chosen = np.random.choice(top_indices, p=probs)\n    w, v, idx = cand_sorted[chosen]\n    return (int(w), int(v) if float(v).is_integer() else v, idx)\n\n",
  "local_density_slope_aug_287": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items\n           if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight handling\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (0, int(v) if float(v).is_integer() else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    cand_sorted = sorted(cand, key=lambda t: t[0])\n    ws = np.array([w for (w, _, _) in cand_sorted], dtype=float)\n    vs = np.array([v for (_, v, _) in cand_sorted], dtype=float)\n\n    best_item = None\n    best_score = -np.inf\n    k = 3\n    for i in range(len(cand_sorted)):\n        lo = max(0, i - k)\n        hi = min(len(cand_sorted), i + k + 1)\n        wloc = np.delete(ws[lo:hi], i - lo)\n        vloc = np.delete(vs[lo:hi], i - lo)\n\n        if wloc.size == 0:\n            local_d = 0.0\n        else:\n            local_d = np.max(vloc / np.maximum(1e-12, wloc))  # max instead of mean\n\n        rel = (vs[i] / ws[i]) - local_d\n        score = rel + 1e-3 * np.clip(vs[i] / ws[i], 0, 10)\n\n        # Deterministic tie\u2011break noise\n        score += 1e-8 * (i + 1)\n\n        if score > best_score:\n            best_score = score\n            best_item = cand_sorted[i]\n\n    w, v, idx = best_item\n    return (int(w), int(v) if float(v).is_integer() else v, idx)\n\n",
  "local_density_slope_aug_288": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    def _score(item, ws, vs, idx):\n        w, v = item\n        # Local neighbourhood indices\n        lo = max(0, idx - 2)\n        hi = min(len(ws), idx + 3)\n        wloc = np.delete(ws[lo:hi], idx - lo)\n        vloc = np.delete(vs[lo:hi], idx - lo)\n\n        if wloc.size == 0:\n            local_d = 0.0\n        else:\n            local_d = np.mean(vloc / np.maximum(1e-12, wloc))\n\n        rel = (v / w) - local_d\n        return 0.6 * rel + 0.4 * np.clip(v / w, 0, 5)\n\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items\n           if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight case\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (0, int(v) if float(v).is_integer() else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Compute scores\n    ws = np.array([w for (w, _, _) in cand], dtype=float)\n    vs = np.array([v for (_, v, _) in cand], dtype=float)\n    scores = np.array([_score((w, v), ws, vs, i) for i, (w, v, _) in enumerate(cand)])\n\n    # Pick top\u20113 and perform weighted random selection\n    top_k = min(3, len(scores))\n    top_idx = np.argpartition(-scores, top_k - 1)[:top_k]\n    probs = scores[top_idx] / scores[top_idx].sum()\n    chosen = np.random.choice(top_idx, p=probs)\n\n    w, v, idx = cand[chosen]\n    return (int(w), int(v) if float(v).is_integer() else v, idx)\n\n",
  "median_value_gate_then_fill_aug_289": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Build the list of items that fit using a while loop\n    fit = []\n    i = 0\n    while i < len(items):\n        w, v, idx = items[i]\n        if w <= cap:\n            fit.append((w, v, idx))\n        i += 1\n\n    if not fit:\n        return None\n\n    # Special case: zero weight but positive value\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Compute median value (clipped to avoid extreme outliers)\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    med = float(np.clip(np.median(vals), 0, np.inf))\n\n    # Gate: keep items with value >= median and positive weight\n    gated = [(w, v, idx) for (w, v, idx) in fit if float(v) >= med and w > 0]\n\n    # If no gated items, fallback to max value\n    if not gated:\n        # deterministic noise: add a tiny unique value based on index\n        best = max(fit, key=lambda t: (float(t[1]), float(t[2]) * 1e-6))\n        return best\n\n    # Choose the item with the largest weight; use deterministic noise for ties\n    best = max(gated, key=lambda t: (int(t[0]), float(t[1]), float(t[2]) * 1e-6))\n    return best\n\n",
  "median_value_gate_then_fill_aug_290": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Filter items that fit\n    fit = [(w, v, idx) for (w, v, idx) in items if w <= cap]\n    if not fit:\n        return None\n\n    # Zero\u2011weight positive\u2011value shortcut\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Compute a weighted score: value + 0.4*(max_weight - weight)\n    max_w = max(w for w, _, _ in fit)\n    scores = []\n    for w, v, idx in fit:\n        # epsilon added to denominator (max_w) to avoid division by zero\n        score = float(v) + 0.4 * (float(max_w - w) / (max_w + 1e-12))\n        scores.append((score, w, v, idx))\n\n    # Determine a dynamic threshold (mean + 0.5*std)\n    score_vals = np.array([s[0] for s in scores], dtype=float)\n    threshold = float(np.mean(score_vals) + 0.5 * np.std(score_vals))\n\n    # Gate items above threshold\n    gated = [(w, v, idx) for score, w, v, idx in scores if score >= threshold]\n\n    # If gated set is empty, fallback to top\u2011k (k=3) by score\n    if not gated:\n        top_k = 3\n        top_indices = np.argsort([-s[0] for s in scores])[:top_k]\n        best = max([fit[i] for i in top_indices], key=lambda t: (float(t[1]), float(t[2])))\n        return best\n\n    # Among gated items, pick the one with highest weight\n    best = max(gated, key=lambda t: (int(t[0]), float(t[1])))\n    return best\n\n",
  "median_value_gate_then_fill_aug_291": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cap = remaining_capacity\n    items = remaining_items\n\n    # Generator that yields items fitting the capacity\n    def fitting():\n        for w, v, idx in items:\n            if w <= cap:\n                yield (w, v, idx)\n\n    fit_list = list(fitting())\n    if not fit_list:\n        return None\n\n    # Immediate return for zero\u2011weight but valuable items\n    for w, v, idx in fit_list:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Compute weighted median (value * weight) and clip to avoid overflow\n    weighted_vals = np.array([float(v) * float(w) for (w, v, _) in fit_list], dtype=float)\n    weighted_median = float(np.clip(np.median(weighted_vals), 0, np.inf))\n\n    # Gate: items whose weighted value >= weighted median\n    gated = [(w, v, idx) for (w, v, idx) in fit_list if float(v) * float(w) >= weighted_median]\n\n    if not gated:\n        # Fallback: pick item with maximum (value + weight) using a small epsilon\n        scores = [(float(v) + float(w) + 1e-12, w, v, idx) for (w, v, idx) in fit_list]\n        best = max(scores, key=lambda t: (t[0], float(t[2]), float(t[1])))\n        return (int(best[1]), int(best[2]), int(best[3]))\n\n    # Among gated items, choose the one with highest weight; clip weight to positive range\n    best = max(gated, key=lambda t: (int(np.clip(t[0], 0, np.inf)), float(t[1])))\n    return best\n\n",
  "anti_greedy_smallest_positive_value_aug_292": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Items that fit the remaining capacity\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Handle zero\u2011weight items with positive value first\n    i = 0\n    while i < len(fit_items):\n        w, v, idx = fit_items[i]\n        if w == 0 and v > 0:\n            return (w, v, idx)\n        i += 1\n\n    # Candidates for density calculation (exclude zero weight)\n    cand_items = [(w, v, idx) for (w, v, idx) in fit_items if w > 0]\n    if not cand_items:\n        # All remaining items have zero weight \u2013 pick the one with the largest value\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    # Compute densities with a small epsilon and clip to avoid extreme ratios\n    densities = np.array([float(v) / (float(w) + 1e-12) for (w, v, _) in cand_items])\n    densities = np.clip(densities, a_min=0, a_max=np.inf)\n\n    # 60th percentile threshold\n    threshold = float(np.percentile(densities, 60))\n    # Items that satisfy the threshold\n    good_items = [(w, v, idx) for (w, v, idx), d in zip(cand_items, densities) if d >= threshold]\n    pool = good_items if good_items else cand_items\n\n    # Return the item with the smallest value; tie\u2011break by higher density\n    return min(pool, key=lambda t: (float(t[1]), -float(t[1]) / (float(t[0]) + 1e-12)))\n\n",
  "anti_greedy_smallest_positive_value_aug_293": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Convert to structured arrays for vectorised operations\n    items = np.array(remaining_items, dtype=object)\n    weights = items[:,0].astype(float)\n    values  = items[:,1].astype(float)\n    indices = items[:,2].astype(int)\n\n    # Mask of items that fit\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    fit_weights  = weights[fit_mask]\n    fit_values   = values[fit_mask]\n    fit_indices  = indices[fit_mask]\n\n    # Zero\u2011weight positive\u2011value items first\n    zero_mask = (fit_weights == 0) & (fit_values > 0)\n    if np.any(zero_mask):\n        z_idx = np.argmax(zero_mask)\n        return (int(fit_weights[z_idx]), int(fit_values[z_idx]), int(fit_indices[z_idx]))\n\n    # Candidates for density calculation\n    pos_mask = fit_weights > 0\n    if not np.any(pos_mask):\n        max_idx = np.argmax(fit_values)\n        return (int(fit_weights[max_idx]), int(fit_values[max_idx]), int(fit_indices[max_idx]))\n\n    pos_weights  = fit_weights[pos_mask]\n    pos_values   = fit_values[pos_mask]\n    pos_indices  = fit_indices[pos_mask]\n\n    densities = pos_values / (pos_weights + 1e-12)\n    densities = np.clip(densities, 0, np.inf)\n\n    # 70th percentile threshold\n    thr = float(np.percentile(densities, 70))\n    good_mask = densities >= thr\n    if np.any(good_mask):\n        good_weights = pos_weights[good_mask]\n        good_values  = pos_values[good_mask]\n        good_indices = pos_indices[good_mask]\n    else:\n        good_weights = pos_weights\n        good_values  = pos_values\n        good_indices = pos_indices\n\n    # Lexicographic ordering: minimal value, then maximal density\n    cand_dens = good_values / (good_weights + 1e-12)\n    order = np.lexsort((-cand_dens, good_values))\n    chosen = order[0]\n    return (int(good_weights[chosen]), int(good_values[chosen]), int(good_indices[chosen]))\n\n",
  "density_with_value_rank_bonus_aug_294": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # early return for zero\u2011weight positive value items\n    i = 0\n    while i < len(fit):\n        w, v, idx = fit[i]\n        if w == 0 and v > 0:\n            return (w, v, idx)\n        i += 1\n\n    # vectorised computation\n    w_arr = np.array([w for w, _, _ in fit], dtype=np.float64)\n    v_arr = np.array([v for _, v, _ in fit], dtype=np.float64)\n    idx_arr = np.array([idx for _, _, idx in fit], dtype=np.int64)\n\n    dens = v_arr / (w_arr + 1e-12)          # density, safe division\n    dens = np.clip(dens, 0, None)           # avoid negative values\n\n    # rank based on value\n    order = np.argsort(v_arr, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=np.float64)\n    ranks[order] = np.arange(1, len(v_arr)+1, dtype=np.float64)\n    rank_norm = ranks / float(len(v_arr))\n\n    # score = density + 0.3 * rank\n    score = dens + 0.3 * rank_norm\n    noise = 1e-9 * idx_arr                  # deterministic tie\u2011breaker\n    score += noise\n\n    best_idx = np.argmax(score)\n    return (int(w_arr[best_idx]), int(v_arr[best_idx]), int(idx_arr[best_idx]))\n\n",
  "density_with_value_rank_bonus_aug_295": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    w_arr = np.array([w for w, _, _ in fit], dtype=np.float64)\n    v_arr = np.array([v for _, v, _ in fit], dtype=np.float64)\n    idx_arr = np.array([idx for _, _, idx in fit], dtype=np.int64)\n\n    dens = v_arr / (w_arr + 1e-12)\n    dens = np.clip(dens, 0, 1e6)              # keep values bounded\n\n    order = np.argsort(v_arr, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=np.float64)\n    ranks[order] = np.arange(1, len(v_arr)+1, dtype=np.float64)\n    rank_norm = ranks / float(len(v_arr))\n\n    mean_dens = np.mean(dens)\n    score = dens + 0.5 * rank_norm + 0.1 * mean_dens\n    noise = 1e-8 * idx_arr\n    score += noise\n\n    best_idx = np.argmax(score)\n    return (int(w_arr[best_idx]), int(v_arr[best_idx]), int(idx_arr[best_idx]))\n\n",
  "density_with_value_rank_bonus_aug_296": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    w_arr = np.array([w for w, _, _ in fit], dtype=np.float64)\n    v_arr = np.array([v for _, v, _ in fit], dtype=np.float64)\n    idx_arr = np.array([idx for _, _, idx in fit], dtype=np.int64)\n\n    dens = v_arr / (w_arr + 1e-12)\n\n    order = np.argsort(v_arr, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=np.float64)\n    ranks[order] = np.arange(1, len(v_arr)+1, dtype=np.float64)\n    rank_norm = ranks / float(len(v_arr))\n\n    score = dens + 0.4 * rank_norm\n    noise = 1e-8 * idx_arr\n    score += noise\n\n    top_k = min(5, len(score))\n    top_indices = np.argpartition(-score, top_k-1)[:top_k]\n    rng = np.random.default_rng(42)\n    chosen = rng.choice(top_indices)\n\n    return (int(w_arr[chosen]), int(v_arr[chosen]), int(idx_arr[chosen]))\n\n",
  "density_with_value_rank_bonus_aug_297": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    w_arr = np.array([w for w, _, _ in fit], dtype=np.float64)\n    v_arr = np.array([v for _, v, _ in fit], dtype=np.float64)\n    idx_arr = np.array([idx for _, _, idx in fit], dtype=np.int64)\n\n    dens = v_arr / (w_arr + 1e-12)\n\n    order = np.argsort(v_arr, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=np.float64)\n    ranks[order] = np.arange(1, len(v_arr)+1, dtype=np.float64)\n    rank_norm = ranks / float(len(v_arr))\n\n    score = dens + 0.6 * rank_norm\n    noise = 1e-9 * idx_arr\n    score += noise\n\n    temp = 0.5\n    exp_scores = np.exp(score / temp - np.max(score / temp))\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n\n    rng = np.random.default_rng(99)\n    chosen = rng.choice(len(probs), p=probs)\n\n    return (int(w_arr[chosen]), int(v_arr[chosen]), int(idx_arr[chosen]))\n\n",
  "kbest_density_diversified_by_weight_bins_aug_298": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # --- 1. Filter items that fit in the remaining capacity ---------------------------------\n    fit = []\n    idx = 0\n    while idx < len(remaining_items):\n        wt, val, id_ = remaining_items[idx]\n        if wt <= remaining_capacity:\n            fit.append((wt, val, id_))\n        idx += 1\n    if not fit:\n        return None\n\n    # --- 2. Prioritise zero\u2011weight items with positive value --------------------------------\n    for wt, val, id_ in fit:\n        if wt == 0 and val > 0:\n            return (wt, val, id_)\n\n    # --- 3. Candidate pool (positive weight) -------------------------------------------------\n    cand = [(wt, val, id_) for wt, val, id_ in fit if wt > 0]\n    if not cand:\n        # All remaining items are zero\u2011weight; pick the one with the largest value\n        return max(fit, key=lambda t: float(t[1]))\n\n    # --- 4. Compute quantiles of all positive weights ----------------------------------------\n    ws_all = []\n    idx = 0\n    while idx < len(remaining_items):\n        wt, _, _ = remaining_items[idx]\n        if wt > 0:\n            ws_all.append(float(wt))\n        idx += 1\n    if not ws_all:\n        # Fallback to simple density ranking\n        return max(cand, key=lambda t: float(t[1]) / (float(t[0]) + 1e-12))\n\n    ws_arr = np.array(ws_all, dtype=float)\n    q1, q2 = np.quantile(ws_arr, [1 / 3.0, 2 / 3.0])\n\n    def bin_index(w: int) -> int:\n        if float(w) <= q1:\n            return 0\n        if float(w) <= q2:\n            return 1\n        return 2\n\n    # --- 5. Count items in each weight bin -----------------------------------------------\n    bin_counts = [0, 0, 0]\n    idx = 0\n    while idx < len(remaining_items):\n        wt, _, _ = remaining_items[idx]\n        if wt > 0:\n            bin_counts[bin_index(wt)] += 1\n        idx += 1\n\n    # --- 6. Rank candidates by density ------------------------------------------------------\n    cand2 = sorted(cand, key=lambda t: float(t[1]) / (float(t[0]) + 1e-12), reverse=True)\n\n    # --- 7. Select a top\u2011k subset -----------------------------------------------------------\n    top_k = max(1, int(round(np.sqrt(len(cand2)))))\n    top = cand2[:top_k]\n\n    # --- 8. Final tie\u2011breaking: least\u2011populated bin, then highest density, then id ----------\n    top.sort(key=lambda t: (\n        bin_counts[bin_index(t[0])],                # least populated bin\n        -float(t[1]) / (float(t[0]) + 1e-12),       # highest density\n        t[2]                                        # deterministic id tie\u2011breaker\n    ))\n    return top[0]\n\n",
  "kbest_density_diversified_by_weight_bins_aug_299": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # --- 1. Convert list to structured numpy arrays -----------------------------------------\n    if not remaining_items:\n        return None\n\n    arr = np.array(remaining_items, dtype=[('wt', np.int64), ('val', np.int64), ('id', np.int64)])\n    mask_fit = arr['wt'] <= remaining_capacity\n    if not np.any(mask_fit):\n        return None\n\n    fit = arr[mask_fit]\n\n    # --- 2. Prioritise zero\u2011weight items with positive value -------------------------------\n    zero_mask = (fit['wt'] == 0) & (fit['val'] > 0)\n    if np.any(zero_mask):\n        idx = np.argmax(zero_mask)  # deterministic pick\n        return tuple(fit[idx])\n\n    # --- 3. Candidate pool (positive weight) ------------------------------------------------\n    cand_mask = fit['wt'] > 0\n    cand = fit[cand_mask]\n    if cand.size == 0:\n        # All remaining items are zero\u2011weight; pick the one with the largest value\n        idx = np.argmax(fit['val'])\n        return tuple(fit[idx])\n\n    # --- 4. Compute weight quantiles -------------------------------------------------------\n    pos_weights = cand['wt'].astype(float)\n    if pos_weights.size == 0:\n        return tuple(cand[np.argmax(cand['val'] / (cand['wt'] + 1e-12))])\n\n    q1, q2 = np.quantile(pos_weights, [1/3.0, 2/3.0])\n\n    def bin_idx(w):\n        return np.where(w <= q1, 0, np.where(w <= q2, 1, 2))\n\n    # --- 5. Bin counts --------------------------------------------------------------------\n    all_weights = arr['wt'][arr['wt'] > 0].astype(float)\n    bin_ids = bin_idx(all_weights)\n    bin_counts = np.bincount(bin_ids, minlength=3)\n\n    # --- 6. Density ranking ---------------------------------------------------------------\n    densities = cand['val'].astype(float) / (cand['wt'].astype(float) + 1e-12)\n    densities = np.clip(densities, 0, None)  # guard against negative values\n\n    # --- 7. Top\u2011k selection ---------------------------------------------------------------\n    top_k = max(1, int(round(np.sqrt(cand.size))))\n    top_indices = np.argpartition(-densities, top_k - 1)[:top_k]\n    top = cand[top_indices]\n    top_densities = densities[top_indices]\n\n    # --- 8. Choose item from the least\u2011populated bin --------------------------------------\n    top_bins = bin_idx(top['wt'])\n    bin_counts_top = bin_counts[top_bins]\n    min_bin = np.min(bin_counts_top)\n    candidates = top[bin_counts_top == min_bin]\n    if candidates.size == 1:\n        return tuple(candidates[0])\n\n    # Random tie\u2011breaker among candidates with the same bin count\n    rng = np.random.default_rng(seed=42)  # deterministic for reproducibility\n    chosen = rng.choice(candidates)\n    return tuple(chosen)\n\n",
  "kbest_density_diversified_by_weight_bins_aug_300": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # --- 1. Filter items that fit ------------------------------------------\n    fit = [(w, v, i) for (w, v, i) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # --- 2. Zero\u2011weight priority -------------------------------------------\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # --- 3. Candidate pool -----------------------------------------------\n    cand = [(w, v, i) for (w, v, i) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # --- 4. Quantiles -----------------------------------------------------\n    ws_all = [float(w) for (w, _, _) in remaining_items if w > 0]\n    if not ws_all:\n        return max(cand, key=lambda t: float(t[1]) / (float(t[0]) + 1e-12))\n    ws_arr = np.array(ws_all, dtype=float)\n    q1, q2 = np.quantile(ws_arr, [1/3.0, 2/3.0])\n\n    def bin_id(w):\n        if float(w) <= q1:\n            return 0\n        if float(w) <= q2:\n            return 1\n        return 2\n\n    # --- 5. Bin counts using median ---------------------------------------\n    bin_counts = [0, 0, 0]\n    for w, _, _ in remaining_items:\n        if w > 0:\n            bin_counts[bin_id(w)] += 1\n    median_bin = np.median(bin_counts)\n\n    # --- 6. Density ranking with deterministic noise ---------------------\n    densities = [float(v) / (float(w) + 1e-12) for (w, v, _) in cand]\n    noise = [((i % 100) / 1e6) for _, _, i in cand]  # deterministic small noise\n    densities = [d + n for d, n in zip(densities, noise)]\n\n    # --- 7. Top\u2011k selection ------------------------------------------------\n    top_k = max(1, int(round(len(cand) ** 0.75)))\n    sorted_indices = np.argsort(-np.array(densities))\n    top_idx = sorted_indices[:top_k]\n    top = [cand[i] for i in top_idx]\n    top_dens = [densities[i] for i in top_idx]\n\n    # --- 8. Choose from least\u2011populated bin relative to median ------------\n    top_bins = [bin_id(w) for (w, _, _) in top]\n    # Select items whose bin count is below the median\n    below_median = [i for i, b in enumerate(top_bins) if bin_counts[b] < median_bin]\n    if below_median:\n        chosen_idx = below_median[0]\n    else:\n        chosen_idx = 0  # fallback\n\n    return top[chosen_idx]\n\n",
  "kbest_density_diversified_by_weight_bins_aug_301": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # --- 1. Fit items -----------------------------------------------\n    fit = [(w, v, i) for (w, v, i) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # --- 2. Zero\u2011weight with positive value -------------------------\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # --- 3. Candidate pool ------------------------------------------\n    cand = [(w, v, i) for (w, v, i) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # --- 4. Quantiles of all positive weights ------------------------\n    ws_all = [float(w) for (w, _, _) in remaining_items if w > 0]\n    if not ws_all:\n        return max(cand, key=lambda t: float(t[1]) / (float(t[0]) + 1e-12))\n    ws_arr = np.array(ws_all, dtype=float)\n    q1, q2 = np.quantile(ws_arr, [1/3.0, 2/3.0])\n\n    def bin_id(w):\n        if float(w) <= q1:\n            return 0\n        if float(w) <= q2:\n            return 1\n        return 2\n\n    # --- 5. Bin counts (mean\u2011based) --------------------------------\n    bin_counts = [0, 0, 0]\n    for w, _, _ in remaining_items:\n        if w > 0:\n            bin_counts[bin_id(w)] += 1\n    mean_count = np.mean(bin_counts)\n\n    # --- 6. Proxy density: log(value+1) / sqrt(weight) --------------------\n    densities = [np.log(v + 1.0) / (np.sqrt(w) + 1e-12) for (w, v, _) in cand]\n    densities = np.clip(densities, 0, None)  # ensure non\u2011negative\n\n    # --- 7. Top\u2011k selection ---------------------------------------\n    top_k = max(1, int(round(np.sqrt(len(cand)))))\n    top_indices = np.argpartition(-np.array(densities), top_k - 1)[:top_k]\n    top = [cand[i] for i in top_indices]\n    top_bins = [bin_id(w) for (w, _, _) in top]\n\n    # --- 8. Choose from bins with count below mean ----------------\n    candidates = [t for t, b in zip(top, top_bins) if bin_counts[b] < mean_count]\n    if not candidates:\n        candidates = top  # fallback to all top items\n\n    # --- 9. Random tie\u2011breaker among candidates --------------------\n    rng = np.random.default_rng(seed=123)  # deterministic\n    chosen = rng.choice(candidates)\n    return tuple(chosen)\n\n",
  "mini_dp_value_lookahead_128_aug_302": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _dp_best_value(items: List[Tuple[int, int, int]], cap: int) -> float:\n    dp = np.zeros(cap + 1, dtype=float)\n    idx = 0\n    n = len(items)\n    while idx < n:\n        w, v, _ = items[idx]\n        if 0 < int(w) <= cap and float(v) > 0:\n            ww = int(w)\n            vv = float(v)\n            dp[ww:] = np.maximum(dp[ww:], dp[:-ww] + vv)\n        idx += 1\n    return float(dp[cap])\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cap0 = int(min(128, max(0, remaining_capacity)))\n    small_items = [(int(w), int(v), idx) for (w, v, idx) in remaining_items if 0 < int(w) <= cap0]\n\n    best_item = None\n    best_score = -np.inf\n    j = 0\n    while j < len(fit):\n        w, v, idx = fit[j]\n        ww = int(w)\n        if ww <= 0:\n            j += 1\n            continue\n        leftover = int(remaining_capacity - ww)\n        capL = int(min(cap0, max(0, leftover)))\n        ub = _dp_best_value([(w2, v2, i2) for (w2, v2, i2) in small_items if i2 != idx], capL)\n        score = float(v) + ub\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n        j += 1\n    return best_item\n\n",
  "mini_dp_value_lookahead_128_aug_303": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _dp_best_value(items: List[Tuple[int, int, int]], cap: int) -> float:\n    dp = np.zeros(cap + 1, dtype=float)\n    for w, v, _ in items:\n        if 0 < int(w) <= cap and float(v) > 0:\n            dp[int(w):] = np.maximum(dp[int(w):], dp[:-int(w)] + float(v))\n    return float(dp[cap])\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cap0 = int(min(256, max(0, remaining_capacity)))\n    small_items = [(int(w), int(v), idx) for (w, v, idx) in remaining_items if 0 < int(w) <= cap0]\n\n    best_item = None\n    best_score = -np.inf\n    alpha = 0.8\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = int(remaining_capacity - ww)\n        capL = int(min(cap0, max(0, leftover)))\n        ub = _dp_best_value([(w2, v2, i2) for (w2, v2, i2) in small_items if i2 != idx], capL)\n        score = alpha * float(v) + ub\n        score += np.random.rand() * 1e-6   # deterministic noise for tie\u2011breaking\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n    return best_item\n\n",
  "mini_dp_value_lookahead_128_aug_304": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _dp_best_value(items: List[Tuple[int, int, int]], cap: int) -> float:\n    dp = np.zeros(cap + 1, dtype=float)\n    for w, v, _ in items:\n        if 0 < int(w) <= cap and float(v) > 0:\n            dp[int(w):] = np.maximum(dp[int(w):], dp[:-int(w)] + float(v))\n    dp = np.clip(dp, 0, np.inf)   # ensure no negative values\n    return float(dp[cap])\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cap0 = int(min(128, max(0, remaining_capacity)))\n    small_items = [(int(w), int(v), idx) for (w, v, idx) in remaining_items if 0 < int(w) <= cap0]\n\n    scores = []\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = int(remaining_capacity - ww)\n        capL = int(min(cap0, max(0, leftover)))\n        ub = _dp_best_value([(w2, v2, i2) for (w2, v2, i2) in small_items if i2 != idx], capL)\n        scores.append((float(v) + ub, (w, v, idx)))\n    if not scores:\n        return None\n\n    top_k = 3\n    scores.sort(key=lambda x: x[0], reverse=True)\n    top = scores[:top_k]\n    chosen = np.random.choice(len(top))\n    return top[chosen][1]\n\n",
  "mini_dp_value_lookahead_128_aug_305": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _dp_best_value(items: List[Tuple[int, int, int]], cap: int) -> float:\n    dp = np.zeros(cap + 1, dtype=float)\n    weights = np.array([int(w) for w, _, _ in items], dtype=int)\n    values = np.array([float(v) for _, v, _ in items], dtype=float)\n    for i in range(len(items)):\n        w = weights[i]\n        v = values[i]\n        if 0 < w <= cap and v > 0:\n            dp[w:] = np.maximum(dp[w:], dp[:-w] + v)\n    return float(dp[cap])\n\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cap0 = int(min(128, max(0, remaining_capacity)))\n    small_items = [(int(w), int(v), idx) for (w, v, idx) in remaining_items if 0 < int(w) <= cap0]\n\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = int(remaining_capacity - ww)\n        capL = int(min(cap0, max(0, leftover)))\n        ub = _dp_best_value([(w2, v2, i2) for (w2, v2, i2) in small_items if i2 != idx], capL)\n        score = float(v) + ub\n        if score > best_score:\n            best_score = score\n            best_item = (w, v, idx)\n    return best_item\n\n",
  "density_rank_then_value_rank_aug_306": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items: List[Tuple[int, int, int]] = []\n    i = 0\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity:\n            fit_items.append((w, v, idx))\n        i += 1\n    if not fit_items:\n        return None\n\n    # Prefer zero\u2011weight items with a positive value\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Candidates with positive weight\n    cand = [t for t in fit_items if t[0] > 0]\n    if not cand:\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    weights = np.array([t[0] for t in cand], dtype=float)\n    values  = np.array([t[1] for t in cand], dtype=float)\n\n    # Compute densities safely\n    densities = values / (weights + 1e-12)\n    densities = np.clip(densities, 0, np.inf)\n\n    # Rank densities and values in descending order\n    dens_rank = np.empty_like(densities, dtype=int)\n    val_rank  = np.empty_like(values, dtype=int)\n\n    dens_order = np.argsort(-densities)\n    val_order  = np.argsort(-values)\n\n    dens_rank[dens_order] = np.arange(len(cand))\n    val_rank[val_order]   = np.arange(len(cand))\n\n    # Choose item with smallest density rank; break ties by value rank\n    best = 0\n    for j in range(1, len(cand)):\n        if dens_rank[j] < dens_rank[best] or (dens_rank[j] == dens_rank[best] and val_rank[j] < val_rank[best]):\n            best = j\n    return cand[best]\n\n",
  "density_rank_then_value_rank_aug_307": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Zero\u2011weight items with positive value are immediately selected\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [t for t in fit_items if t[0] > 0]\n    if not cand:\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    weights = np.array([t[0] for t in cand], dtype=float)\n    values  = np.array([t[1] for t in cand], dtype=float)\n\n    densities = values / (weights + 1e-12)\n    densities = np.clip(densities, 0, np.inf)\n\n    # Weighted score: 0.6 * density + 0.4 * (normalised value)\n    max_val = np.max(values) if np.max(values) > 0 else 1.0\n    norm_vals = values / (max_val + 1e-12)\n    score = 0.6 * densities + 0.4 * norm_vals\n\n    # Deterministic tie\u2011breaking noise based on the item id\n    noise = np.array([t[2] for t in cand], dtype=float) * 1e-6\n    score += noise\n\n    best_idx = np.argmax(score)\n    return cand[best_idx]\n\n",
  "density_with_weight_log_bonus_aug_308": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eta = 0.06\n    best_score = -np.inf\n    best_item: Optional[Tuple[int, int, int]] = None\n\n    idx = 0\n    while idx < len(remaining_items):\n        w, v, i = remaining_items[idx]\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, i)\n            dens = v / (w + 1e-12)                     # epsilon added\n            score = dens + eta * np.log1p(w) + 1e-9 * i   # deterministic tie\u2011break\n            if score > best_score:\n                best_score, best_item = score, (w, v, i)\n        idx += 1\n\n    return best_item\n\n",
  "density_with_weight_log_bonus_aug_309": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eta = 0.08  # tuned weight for log term\n\n    weights  = np.array([itm[0] for itm in remaining_items], dtype=np.float64)\n    values   = np.array([itm[1] for itm in remaining_items], dtype=np.float64)\n    indices  = np.array([itm[2] for itm in remaining_items], dtype=np.int64)\n\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    zero_mask = (weights == 0) & (values > 0) & fit_mask\n    if np.any(zero_mask):\n        z_idx = np.argmax(zero_mask)\n        return (int(weights[z_idx]), int(values[z_idx]), int(indices[z_idx]))\n\n    dens   = values / (weights + 1e-12)                   # epsilon added\n    scores = dens + eta * np.log1p(weights)\n    scores = np.clip(scores, -1e10, 1e10)                 # prevent overflow\n\n    valid_scores = np.where(fit_mask, scores, -np.inf)\n    best_idx = np.argmax(valid_scores)\n\n    return (int(weights[best_idx]), int(values[best_idx]), int(indices[best_idx]))\n\n",
  "density_with_weight_log_bonus_aug_310": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    eta   = 0.06\n    top_k = 7  # hyper\u2011parameter\n\n    candidates = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    scores = []\n    for w, v, _ in candidates:\n        dens = v / (w + 1e-12)\n        scores.append(dens + eta * np.log1p(w))\n    scores = np.array(scores, dtype=np.float64)\n\n    if len(candidates) <= top_k:\n        top_indices = np.arange(len(candidates))\n    else:\n        top_indices = np.argpartition(scores, -top_k)[-top_k:]\n        top_indices = top_indices[np.argsort(-scores[top_indices])]\n\n    chosen = np.random.choice(top_indices)\n    w, v, idx = candidates[chosen]\n    return (w, v, idx)\n\n",
  "value_density_cosine_to_ideal_aug_311": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Filter items that fit into the remaining capacity\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Immediate win: weight zero but value positive\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Candidates with positive weight\n    cand_items = [(w, v, idx) for (w, v, idx) in fit_items if w > 0]\n    if not cand_items:\n        # All weights are zero \u2013 pick the item with the largest value\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    # Extract arrays\n    weights = np.array([w for w, _, _ in cand_items], dtype=float)\n    values  = np.array([v for _, v, _ in cand_items], dtype=float)\n\n    # Normalise value and density to [0,1]\n    v_min, v_max = np.min(values), np.max(values)\n    values_norm = (values - v_min) / (v_max - v_min + 1e-12)\n    densities   = values / weights\n    d_min, d_max = np.min(densities), np.max(densities)\n    dens_norm   = (densities - d_min) / (d_max - d_min + 1e-12)\n\n    # Deterministic noise (fixed seed) for tie\u2011breaking\n    rng = np.random.RandomState(42)\n    noise = 1e-6 * rng.randint(0, 1000, size=len(cand_items))\n\n    # Weighted sum: 0.6 * value + 0.4 * density\n    scores = 0.6 * values_norm + 0.4 * dens_norm + noise\n\n    # Find the best candidate\n    best_idx = int(np.argmax(scores))\n    return cand_items[best_idx]\n\n",
  "value_density_cosine_to_ideal_aug_312": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Fit items\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Inverted logic: check zero weight first\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Positive\u2011weight candidates\n    cand = [(w, v, idx) for (w, v, idx) in fit_items if w > 0]\n    if not cand:\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    # Convert to arrays\n    weights = np.array([w for w, _, _ in cand], dtype=float)\n    values  = np.array([v for _, v, _ in cand], dtype=float)\n\n    # Normalise using np.square for variance scaling\n    v_min, v_max = np.min(values), np.max(values)\n    values_norm = np.clip((values - v_min) / (v_max - v_min + 1e-12), 0, 1)\n    densities   = values / weights\n    d_min, d_max = np.min(densities), np.max(densities)\n    dens_norm   = np.clip((densities - d_min) / (d_max - d_min + 1e-12), 0, 1)\n\n    # Score: weighted sum with 0.5/0.5\n    scores = 0.5 * values_norm + 0.5 * dens_norm\n\n    # Compute cosine\u2011like similarity using np.linalg.norm\n    norms = np.linalg.norm(np.vstack((values_norm, dens_norm)).T, axis=1) + 1e-12\n    cos_sim = (values_norm + dens_norm) / (np.sqrt(2) * norms)\n\n    # Combine scores with cosine similarity\n    final_score = scores * cos_sim\n\n    # Randomly pick among top\u20113\n    k = min(3, len(cand))\n    top_k_idx = np.argsort(-final_score)[:k]\n    chosen = np.random.choice(top_k_idx)\n    return (int(cand[chosen][0]), int(cand[chosen][1]), int(cand[chosen][2]))\n\n",
  "value_density_cosine_to_ideal_aug_313": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Filter items that fit\n    fit_items = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n\n    # Immediate return for zero weight with positive value\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Positive\u2011weight candidates\n    cand = [(w, v, idx) for (w, v, idx) in fit_items if w > 0]\n    if not cand:\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    # Shuffle for deterministic randomness\n    rng = np.random.RandomState(123)\n    rng.shuffle(cand)\n\n    # Convert to arrays\n    weights = np.array([w for w, _, _ in cand], dtype=float)\n    values  = np.array([v for _, v, _ in cand], dtype=float)\n\n    # Normalise value and density\n    v_min, v_max = np.min(values), np.max(values)\n    values_norm = np.clip((values - v_min) / (v_max - v_min + 1e-12), 0, 1)\n    densities   = values / weights\n    d_min, d_max = np.min(densities), np.max(densities)\n    dens_norm   = np.clip((densities - d_min) / (d_max - d_min + 1e-12), 0, 1)\n\n    # Cosine similarity with target vector (1,1)\n    dot = values_norm + dens_norm\n    norm = np.sqrt(values_norm**2 + dens_norm**2) + 1e-12\n    cos_sim = dot / norm\n\n    # Final score: weighted combination of normalized value, density, and cosine similarity\n    final_score = 0.4 * values_norm + 0.4 * dens_norm + 0.2 * cos_sim\n\n    # Pick the best candidate\n    best_idx = int(np.argmax(final_score))\n    return (int(cand[best_idx][0]), int(cand[best_idx][1]), int(cand[best_idx][2]))\n\n",
  "bounded_knn_partner_value_aug_314": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Convert input to NumPy arrays\n    weights = np.array([w for w, _, _ in remaining_items], dtype=int)\n    values  = np.array([v for _, v, _ in remaining_items], dtype=float)\n    indices = np.array([idx for _, _, idx in remaining_items], dtype=int)\n\n    # Filter items that fit into the remaining capacity\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    w_fit = weights[fit_mask]\n    v_fit = values[fit_mask]\n    idx_fit = indices[fit_mask]\n\n    # Special case: zero\u2011weight items with positive value\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        i = np.argmax(zero_mask)\n        return (int(w_fit[i]), int(v_fit[i]), int(idx_fit[i]))\n\n    # Parameters\n    K = 5\n    eps = 1e-12\n\n    # Pre\u2011allocate arrays for scores\n    scores = np.empty_like(v_fit)\n\n    for i, (w, v, idx) in enumerate(zip(w_fit, v_fit, idx_fit)):\n        leftover = remaining_capacity - w\n        # Partner candidates (different index, weight <= leftover)\n        partner_mask = (w_fit <= leftover) & (np.arange(len(w_fit)) != i)\n        if np.any(partner_mask):\n            partner_values = v_fit[partner_mask]\n            best_p = np.max(partner_values)\n        else:\n            best_p = 0.0\n\n        density = v / (w + eps)\n        density = np.clip(density, 0, 1)          # keep density in [0,1]\n        noise   = idx * 1e-6                      # deterministic tie\u2011breaker\n        scores[i] = v + best_p + 1e-3 * density + noise\n\n    best_idx = np.argmax(scores)\n    w_res, v_res, idx_res = w_fit[best_idx], v_fit[best_idx], idx_fit[best_idx]\n    # Convert value to int if it is an integer\n    if np.isclose(v_res, np.round(v_res)):\n        v_res = int(np.round(v_res))\n    return (int(w_res), v_res, int(idx_res))\n\n",
  "bounded_knn_partner_value_aug_315": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    rng = np.random.default_rng(seed=0)          # deterministic randomness\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items\n           if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight items with positive value\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if np.isclose(v, round(v)) else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        # Return the item with the highest value\n        best = max(fit, key=lambda t: float(t[1]))\n        w, v, idx = best\n        return (w, int(v) if np.isclose(v, round(v)) else v, idx)\n\n    K = 7\n    best_item, best_score = None, -np.inf\n    for w, v, idx in cand:\n        leftover = remaining_capacity - w\n        partners = [(abs((remaining_capacity - w) - w2), v2)\n                    for (w2, v2, idx2) in cand\n                    if idx2 != idx and w2 <= leftover]\n        if partners:\n            partners.sort(key=lambda t: t[0])\n            best_p = max(pv for (_, pv) in partners[:K])\n        else:\n            best_p = 0.0\n\n        density = v / (w + 1e-12)\n        density = np.clip(density, 0, 1)\n        # Score is intentionally inverted density\n        score = v + best_p - 1e-3 * density\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    # Handle ties among top 3 candidates\n    scores = []\n    for w, v, idx in cand:\n        leftover = remaining_capacity - w\n        partners = [(abs((remaining_capacity - w) - w2), v2)\n                    for (w2, v2, idx2) in cand\n                    if idx2 != idx and w2 <= leftover]\n        best_p = max((pv for (_, pv) in partners[:K]), default=0.0)\n        density = v / (w + 1e-12)\n        density = np.clip(density, 0, 1)\n        scores.append(v + best_p - 1e-3 * density)\n\n    max_score = max(scores)\n    top_indices = [i for i, s in enumerate(scores) if np.isclose(s, max_score, atol=1e-6)]\n    if len(top_indices) > 3:\n        chosen = rng.choice(top_indices, size=3, replace=False)\n        chosen = rng.choice(chosen)\n    else:\n        chosen = top_indices[0]\n\n    w, v, idx = cand[chosen]\n    return (int(w), int(v) if np.isclose(v, round(v)) else v, int(idx))\n\n",
  "bounded_knn_partner_value_aug_316": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items\n           if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if np.isclose(v, round(v)) else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        best = max(fit, key=lambda t: float(t[1]))\n        w, v, idx = best\n        return (w, int(v) if np.isclose(v, round(v)) else v, idx)\n\n    K = 6\n    best_item, best_score = None, -np.inf\n    for w, v, idx in cand:\n        leftover = remaining_capacity - w\n        partners = [(abs((remaining_capacity - w) - w2), v2)\n                    for (w2, v2, idx2) in cand\n                    if idx2 != idx and w2 <= leftover]\n        if partners:\n            partners.sort(key=lambda t: t[0])\n            partner_vals = [pv for (_, pv) in partners[:K]]\n            best_p = np.median(partner_vals)\n        else:\n            best_p = 0.0\n\n        density = v / (w + 1e-12)\n        density = np.clip(density, 0, 1)\n        score = v + best_p + 1e-3 * density\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n\n    w, v, idx = best_item\n    return (int(w), int(v) if np.isclose(v, round(v)) else v, int(idx))\n\n",
  "bounded_knn_partner_value_aug_317": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items\n           if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if np.isclose(v, round(v)) else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        best = max(fit, key=lambda t: float(t[1]))\n        w, v, idx = best\n        return (w, int(v) if np.isclose(v, round(v)) else v, idx)\n\n    K = 5\n    scores = []\n    for w, v, idx in cand:\n        leftover = remaining_capacity - w\n        partners = [(abs((remaining_capacity - w) - w2), v2)\n                    for (w2, v2, idx2) in cand\n                    if idx2 != idx and w2 <= leftover]\n        if partners:\n            partners.sort(key=lambda t: t[0])\n            best_p = max(pv for (_, pv) in partners[:K])\n        else:\n            best_p = 0.0\n\n        density = v / (w + 1e-12)\n        density = np.clip(density, 0, 1)\n        score = v + best_p + 1e-3 * density\n        scores.append(score)\n\n    scores = np.array(scores, dtype=float)\n    # Soft\u2011max transformation\n    exp_scores = np.exp(scores - np.max(scores))          # numerical stability\n    probs = exp_scores / np.clip(np.sum(exp_scores), 1e-12, None)\n\n    chosen_idx = np.argmax(probs)\n    w, v, idx = cand[chosen_idx]\n    return (int(w), int(v) if np.isclose(v, round(v)) else v, int(idx))\n\n",
  "residue_mode_alignment_base10_aug_318": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    # Immediate zero\u2011weight positive value\n    i = 0\n    while i < len(candidates):\n        w, v, id_ = candidates[i]\n        if w == 0 and v > 0:\n            return (w, v, id_)\n        i += 1\n\n    # Compute mode of residues\n    residues = np.array([int(w) % 10 for (w, _, _) in remaining_items if int(w) > 0], dtype=int)\n    if residues.size == 0:\n        return max(candidates, key=lambda t: float(t[1]))\n    mode_res = int(np.bincount(residues).argmax())\n\n    best_item, best_score = None, -np.inf\n    i = 0\n    while i < len(candidates):\n        w, v, id_ = candidates[i]\n        ww = int(w)\n        if ww <= 0:\n            i += 1\n            continue\n        leftover = (remaining_capacity - ww) % 10\n        bonus = 1.0 if leftover == mode_res else 0.0\n        dens = float(v) / (float(ww) + 1e-12)\n        score = dens + 0.10 * bonus\n        # deterministic noise to break ties\n        score += 1e-9 * id_\n        if score > best_score:\n            best_score, best_item = score, (w, v, id_)\n        i += 1\n    return best_item\n\n",
  "residue_mode_alignment_base10_aug_319": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    residues = np.array([int(w) % 10 for (w, _, _) in remaining_items if int(w) > 0], dtype=int)\n    if residues.size == 0:\n        return max(candidates, key=lambda t: float(t[1]))\n    mode_res = int(np.bincount(residues).argmax())\n\n    scores = []\n    for w, v, idx in candidates:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = (remaining_capacity - ww) % 10\n        bonus = 1.0 if leftover == mode_res else 0.0\n        dens = float(v) / (float(ww) + 1e-12)\n        dens = np.clip(dens, 0, 1)          # bound density\n        score = dens + 0.20 * bonus         # tuned weight\n        scores.append((score, (w, v, idx)))\n    if not scores:\n        return None\n\n    # top\u2011k selection\n    top_k = 5\n    scores.sort(key=lambda x: x[0], reverse=True)\n    top_items = scores[:top_k]\n    return top_items[0][1]\n\n",
  "residue_mode_alignment_base10_aug_320": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    residues = np.array([int(w) % 10 for (w, _, _) in remaining_items if int(w) > 0], dtype=int)\n    if residues.size == 0:\n        return max(candidates, key=lambda t: float(t[1]))\n    mode_res = int(np.median(residues))          # median as proxy for mode\n\n    scores = []\n    for w, v, idx in candidates:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = (remaining_capacity - ww) % 10\n        bonus = 1.0 if leftover == mode_res else 0.0\n        dens = float(v) / (float(ww) + 1e-12)\n        score = dens + 0.15 * bonus\n        scores.append(score)\n\n    if not scores:\n        return None\n\n    # softmin weighting: lower scores get higher probability\n    min_score = np.min(scores)\n    max_score = np.max(scores)\n    range_score = max_score - min_score + 1e-12\n    probs = np.exp(-(np.array(scores) - min_score) / range_score)\n    probs /= np.sum(probs)\n    chosen_idx = np.random.choice(len(candidates), p=probs)\n    return candidates[chosen_idx]\n\n",
  "residue_mode_alignment_base10_aug_321": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    residues = [int(w) % 10 for (w, _, _) in remaining_items if int(w) > 0]\n    if not residues:\n        return max(candidates, key=lambda t: float(t[1]))\n    mode_res = Counter(residues).most_common(1)[0][0]\n\n    ws = np.array([w for (w, _, _) in candidates], dtype=float)\n    vs = np.array([v for (_, v, _) in candidates], dtype=float)\n    idxs = np.array([idx for (_, _, idx) in candidates], dtype=int)\n\n    dens = vs / (ws + 1e-12)\n    dens = np.clip(dens, 0, None)                      # ensure non\u2011negative\n\n    leftover = (remaining_capacity - ws).astype(int) % 10\n    bonus = np.where(leftover == mode_res, 1.0, 0.0)\n\n    scores = dens + 0.12 * bonus\n    scores = np.clip(scores, 0, 1e6)                    # avoid extreme values\n\n    best_idx = int(np.argmax(scores))\n    return (candidates[best_idx][0], candidates[best_idx][1], candidates[best_idx][2])\n\n",
  "min_variance_weight_pick_aug_322": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Build list of items that fit into the remaining capacity\n    fit = []\n    i = 0\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity:\n            fit.append((w, v, idx))\n        i += 1\n\n    if not fit:\n        return None\n\n    # Prefer a zero\u2011weight item with positive value\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Items with positive weight\n    cand = []\n    j = 0\n    while j < len(fit):\n        w, v, idx = fit[j]\n        if w > 0:\n            cand.append((w, v, idx))\n        j += 1\n\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Median weight of all remaining items with positive weight\n    pos_weights = [w for w, _, _ in remaining_items if w > 0]\n    mean_w = float(np.median(pos_weights)) if pos_weights else 0.0\n    mean_w = np.clip(mean_w, 0, remaining_capacity)\n\n    # Density of each candidate (value/weight) with epsilon to avoid div\u2011by\u2011zero\n    densities = np.array([float(v) / (w + 1e-12) for w, v, _ in cand], dtype=float)\n\n    # Keep only items above the 60\u2011th percentile density\n    thr = float(np.quantile(densities, 0.60))\n    pool = [(w, v, idx) for (w, v, idx), d in zip(cand, densities) if d >= thr]\n    pool = pool if pool else cand\n\n    # Deterministic tie\u2011breaker: add a tiny noise proportional to the index\n    def key_func(t):\n        w, v, idx = t\n        noise = 1e-6 * idx\n        return (abs(float(w) - mean_w) + noise, -(float(v) / (w + 1e-12)))\n\n    return min(pool, key=key_func)\n\n",
  "min_variance_weight_pick_aug_323": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Convert to numpy array for vectorised operations\n    arr = np.array(remaining_items, dtype=object)\n    weights = arr[:, 0].astype(float)\n    values = arr[:, 1].astype(float)\n    indices = arr[:, 2].astype(int)\n\n    # Items that fit\n    fit_mask = weights <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n\n    fit_w = weights[fit_mask]\n    fit_v = values[fit_mask]\n    fit_i = indices[fit_mask]\n\n    # Prefer zero\u2011weight, positive\u2011value item\n    zero_mask = (fit_w == 0) & (fit_v > 0)\n    if np.any(zero_mask):\n        k = np.argmax(zero_mask)\n        return (int(fit_w[k]), int(fit_v[k]), int(fit_i[k]))\n\n    # Positive\u2011weight candidates\n    pos_mask = fit_w > 0\n    if not np.any(pos_mask):\n        max_k = np.argmax(fit_v)\n        return (int(fit_w[max_k]), int(fit_v[max_k]), int(fit_i[max_k]))\n\n    cand_w = fit_w[pos_mask]\n    cand_v = fit_v[pos_mask]\n    cand_i = fit_i[pos_mask]\n\n    # Mean weight using simple sum\n    mean_w = float(np.sum(cand_w) / len(cand_w))\n\n    # Density with epsilon\n    densities = cand_v / (cand_w + 1e-12)\n    densities = np.clip(densities, 0, None)\n\n    # Keep items above the median density\n    thr = float(np.quantile(densities, 0.50))\n    pool_mask = densities >= thr\n    if not np.any(pool_mask):\n        pool_mask = np.ones_like(densities, dtype=bool)\n\n    pool_w = cand_w[pool_mask]\n    pool_v = cand_v[pool_mask]\n    pool_i = cand_i[pool_mask]\n    pool_dens = densities[pool_mask]\n\n    # Randomly select one of the top\u2011k densities\n    sorted_idx = np.argsort(-pool_dens)          # descending order\n    top_k = min(7, len(sorted_idx))\n    rng = np.random.default_rng(0)              # deterministic seed\n    chosen = rng.choice(sorted_idx[:top_k])\n\n    return (int(pool_w[chosen]), int(pool_v[chosen]), int(pool_i[chosen]))\n\n",
  "min_variance_weight_pick_aug_324": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Fit items\n    fit = [t for t in remaining_items if t[0] <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight, positive\u2011value preference\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [t for t in fit if t[0] > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Mean weight via simple sum\n    total_w = sum(t[0] for t in cand)\n    mean_w = float(total_w / len(cand))\n\n    # Densities with epsilon\n    densities = np.array([float(v) / (w + 1e-12) for w, v, _ in cand], dtype=float)\n    densities = np.clip(densities, 0, 1.0)\n\n    # 70\u2011th percentile density threshold\n    thr = float(np.quantile(densities, 0.70))\n    pool = [(w, v, idx) for (w, v, idx), d in zip(cand, densities) if d >= thr]\n    pool = pool if pool else cand\n\n    # Soft\u2011min score: combine weight deviation and inverse density\n    def score(t):\n        w, v, idx = t\n        d = float(v) / (w + 1e-12)\n        return abs(float(w) - mean_w) * 0.6 + (1 / (d + 1e-12)) * 0.4\n\n    return min(pool, key=score)\n\n",
  "min_variance_weight_pick_aug_325": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Fit items\n    fit = [t for t in remaining_items if t[0] <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight, positive\u2011value preference\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [t for t in fit if t[0] > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Mean weight via maximum of all positive weights\n    max_w = max(t[0] for t in remaining_items if t[0] > 0)\n    mean_w = float(max_w)\n\n    # Densities with epsilon\n    densities = np.array([float(v) / (w + 1e-12) for w, v, _ in cand], dtype=float)\n    densities = np.clip(densities, 0, None)\n\n    # 40\u2011th percentile density threshold\n    thr = float(np.quantile(densities, 0.40))\n\n    # Build pool using while loop\n    pool = []\n    i = 0\n    while i < len(cand):\n        w, v, idx = cand[i]\n        d = densities[i]\n        if d >= thr:\n            pool.append((w, v, idx))\n        i += 1\n    pool = pool if pool else cand\n\n    # Choose item with maximum density; tie\u2011break by closeness to mean weight\n    def key_func(t):\n        w, v, idx = t\n        d = float(v) / (w + 1e-12)\n        return (-d, abs(float(w) - mean_w))\n\n    return max(pool, key=key_func)\n\n",
  "density_gap_to_next_heavier_aug_326": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Items that fit\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight items with positive value are taken immediately\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if v.is_integer() else v, idx)\n\n    # Non\u2011zero\u2011weight candidates\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        best = max(fit, key=lambda t: float(t[1]))\n        return (int(best[0]), int(best[1]) if isinstance(best[1], float) and best[1].is_integer() else best[1], best[2])\n\n    # Sort by weight for a local comparison\n    cand.sort(key=lambda t: t[0])\n\n    # Vectorised density calculation with epsilon\n    weights = np.array([w for w, _, _ in cand], dtype=np.float64)\n    values = np.array([v for _, v, _ in cand], dtype=np.float64)\n    densities = np.divide(values, weights + 1e-12)\n    densities = np.clip(densities, 0, 1)\n\n    # Gaps to the next heavier item\n    gaps = np.concatenate([densities[1:] - densities[:-1], [densities[-1]]])\n    gaps = np.maximum(gaps, 0)\n\n    # Scoring: gap + 0.5*density + tiny deterministic noise\n    noise = np.arange(len(cand)) * 1e-6\n    scores = gaps + 0.5 * densities + noise\n    best_idx = int(np.argmax(scores))\n\n    w, v, idx = cand[best_idx]\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n\n",
  "density_gap_to_next_heavier_aug_327": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if v.is_integer() else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        best = max(fit, key=lambda t: float(t[1]))\n        return (int(best[0]), int(best[1]) if isinstance(best[1], float) and best[1].is_integer() else best[1], best[2])\n\n    cand.sort(key=lambda t: t[0])\n\n    weights = np.array([w for w, _, _ in cand], dtype=np.float64)\n    values = np.array([v for _, v, _ in cand], dtype=np.float64)\n    densities = np.divide(values, weights + 1e-12)\n    densities = np.clip(densities, 0, 2)\n\n    gaps = np.concatenate([densities[1:] - densities[:-1], [densities[-1]]])\n    gaps = np.maximum(gaps, 0)\n\n    scores = 0.8 * gaps + 0.2 * densities\n    max_score = np.max(scores)\n    # Randomly pick among near\u2011maxima\n    candidates_idx = np.where(np.abs(scores - max_score) <= 1e-6)[0]\n    chosen_idx = int(np.random.choice(candidates_idx))\n    w, v, idx = cand[chosen_idx]\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n\n",
  "density_gap_to_next_heavier_aug_328": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if v.is_integer() else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        best = max(fit, key=lambda t: float(t[1]))\n        return (int(best[0]), int(best[1]) if isinstance(best[1], float) and best[1].is_integer() else best[1], best[2])\n\n    cand.sort(key=lambda t: t[0])\n\n    weights = np.array([w for w, _, _ in cand], dtype=np.float64)\n    values = np.array([v for _, v, _ in cand], dtype=np.float64)\n    densities = np.divide(values, weights + 1e-12)\n    densities = np.clip(densities, 0, 5)\n\n    # Compute gaps to next heavier item\n    diffs = np.diff(densities)\n    gaps = np.concatenate([diffs, [densities[-1]]])\n    gaps = np.maximum(gaps, 0)\n\n    # Median adjustment to reduce bias\n    median_gap = np.median(gaps)\n    gaps_adj = gaps - median_gap\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(cand)) * 1e-7\n    scores = gaps_adj + 0.001 * densities + noise\n    best_idx = int(np.argmax(scores))\n\n    w, v, idx = cand[best_idx]\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n\n",
  "density_gap_to_next_heavier_aug_329": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if v.is_integer() else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        best = max(fit, key=lambda t: float(t[1]))\n        return (int(best[0]), int(best[1]) if isinstance(best[1], float) and best[1].is_integer() else best[1], best[2])\n\n    cand.sort(key=lambda t: t[0])\n\n    weights = np.array([w for w, _, _ in cand], dtype=np.float64)\n    values = np.array([v for _, v, _ in cand], dtype=np.float64)\n    densities = np.divide(values, weights + 1e-12)\n    densities = np.clip(densities, 0, 10)\n\n    # Gap to next heavier (higher weight) item\n    next_dens = np.pad(densities[1:], (0, 1), 'constant', constant_values=0)\n    gaps = np.maximum(densities - next_dens, 0)\n    gaps = np.clip(gaps, 0, 1)\n\n    # Scoring with tiny deterministic noise\n    noise = np.arange(len(cand)) * 1e-6\n    scores = gaps + 1e-4 * densities + noise\n    best_idx = int(np.argmax(scores))\n\n    w, v, idx = cand[best_idx]\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n\n",
  "value_density_product_normalized_aug_330": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_items: List[Tuple[int, int, int]] = []\n    idx = 0\n    while idx < len(remaining_items):\n        weight, value, idx_id = remaining_items[idx]\n        if weight <= remaining_capacity:\n            fit_items.append((weight, value, idx_id))\n        idx += 1\n    if not fit_items:\n        return None\n\n    # ---- 2. Immediate return if a zero\u2011weight, positive\u2011value item exists ----\n    for weight, value, idx_id in fit_items:\n        if weight == 0 and value > 0:\n            return (weight, value, idx_id)\n\n    # ---- 3. Build candidate list (positive weight) ----\n    cand: List[Tuple[int, int, int]] = []\n    idx = 0\n    while idx < len(fit_items):\n        weight, value, idx_id = fit_items[idx]\n        if weight > 0:\n            cand.append((weight, value, idx_id))\n        idx += 1\n    if not cand:\n        # All remaining items have zero weight \u2013 pick the one with highest value\n        return max(fit_items, key=lambda t: float(t[1]))\n\n    # ---- 4. Normalise value and density ----\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    v_min, v_max = np.min(vals), np.max(vals)\n    d_min, d_max = np.min(dens), np.max(dens)\n\n    v_norm = (vals - v_min) / (v_max - v_min + 1e-12)\n    d_norm = (dens - d_min) / (d_max - d_min + 1e-12)\n\n    # Clip to keep values in a safe range\n    v_norm = np.clip(v_norm, 0.0, 1.0)\n    d_norm = np.clip(d_norm, 0.0, 1.0)\n\n    # ---- 5. Score and pick the best ----\n    score = v_norm * d_norm\n    best_idx = int(np.argmax(score))\n    return cand[best_idx]\n\n",
  "value_density_product_normalized_aug_331": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, i) for (w, v, i) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Zero\u2011weight positive\u2011value shortcut\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # Keep only items with positive weight\n    cand = [(w, v, i) for (w, v, i) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    v_min, v_max = np.min(vals), np.max(vals)\n    d_min, d_max = np.min(dens), np.max(dens)\n\n    v_norm = (vals - v_min) / (v_max - v_min + 1e-12)\n    d_norm = (dens - d_min) / (d_max - d_min + 1e-12)\n\n    # Clip to avoid out\u2011of\u2011range values\n    v_norm = np.clip(v_norm, 0.0, 1.0)\n    d_norm = np.clip(d_norm, 0.0, 1.0)\n\n    # Weighted\u2011sum scoring (60% value, 40% density)\n    score = 0.6 * v_norm + 0.4 * d_norm\n\n    # Deterministic tie\u2011breaker: add a tiny increasing offset\n    score += np.arange(len(score)) * 1e-9\n\n    best_idx = int(np.argmax(score))\n    return cand[best_idx]\n\n",
  "value_density_product_normalized_aug_332": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, i) for (w, v, i) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Handle zero\u2011weight, positive\u2011value items\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # Candidates with positive weight\n    cand = [(w, v, i) for (w, v, i) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    v_min, v_max = np.min(vals), np.max(vals)\n    d_min, d_max = np.min(dens), np.max(dens)\n\n    v_norm = (vals - v_min) / (v_max - v_min + 1e-12)\n    d_norm = (dens - d_min) / (d_max - d_min + 1e-12)\n\n    v_norm = np.clip(v_norm, 0.0, 1.0)\n    d_norm = np.clip(d_norm, 0.0, 1.0)\n\n    # Exponential preference (softmax\u2011style)\n    exp_score = np.exp((v_norm + d_norm) * 10.0)\n    # Pick top\u20113 candidates\n    top_k = min(3, len(exp_score))\n    top_indices = np.argpartition(-exp_score, top_k - 1)[:top_k]\n    # Randomly select one among the top\u20113\n    chosen_idx = int(np.random.choice(top_indices))\n    return cand[chosen_idx]\n\n",
  "value_density_product_normalized_aug_333": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, i) for (w, v, i) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n\n    # Quick return for zero\u2011weight, positive\u2011value items\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n\n    # Keep only positive\u2011weight items\n    cand = [(w, v, i) for (w, v, i) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    # Normalise using medians to reduce influence of outliers\n    v_med = np.median(vals)\n    d_med = np.median(dens)\n    v_range = np.max(vals) - np.min(vals) + 1e-12\n    d_range = np.max(dens) - np.min(dens) + 1e-12\n\n    v_norm = (vals - v_med) / (v_range + 1e-12)\n    d_norm = (dens - d_med) / (d_range + 1e-12)\n\n    v_norm = np.clip(v_norm, 0.0, 1.0)\n    d_norm = np.clip(d_norm, 0.0, 1.0)\n\n    # Use the maximum of the two normalised metrics as score\n    score = np.maximum(v_norm, d_norm)\n\n    best_idx = int(np.argmax(score))\n    return cand[best_idx]\n\n",
  "fill_first_then_density_threshold_aug_334": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Filter items that fit\n    fit = []\n    idx = 0\n    while idx < len(remaining_items):\n        w, v, i = remaining_items[idx]\n        if w <= remaining_capacity:\n            fit.append((w, v, i))\n        idx += 1\n    if not fit:\n        return None\n    # Handle zero weight, positive value\n    for w, v, i in fit:\n        if w == 0 and v > 0:\n            return (w, v, i)\n    # Candidate items with positive weight\n    cand = [(w, v, i) for w, v, i in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n    # Compute densities with epsilon\n    densities = np.array([float(v) / (float(w) + 1e-12) for w, v, _ in cand], dtype=float)\n    # Clip densities between 0 and 1\n    densities = np.clip(densities, 0, 1)\n    # Median density\n    med = float(np.median(densities))\n    # Items that occupy >=85% capacity and density >= median\n    big = [(w, v, i) for w, v, i in cand if float(w) >= 0.85 * float(remaining_capacity) and (float(v) / (float(w) + 1e-12)) >= med]\n    if big:\n        # deterministic tie-breaking using small noise\n        return max(big, key=lambda t: float(t[1]) + 1e-9 * t[2])\n    # Otherwise pick best density\n    return max(cand, key=lambda t: (float(t[1]) / (float(t[0]) + 1e-12)) + 1e-9 * t[2])\n\n",
  "fill_first_then_density_threshold_aug_335": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Items that fit\n    candidates = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not candidates:\n        return None\n    # Zero weight, positive value\n    for w, v, idx in candidates:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    # Positive weight items\n    pos = [(w, v, idx) for w, v, idx in candidates if w > 0]\n    if not pos:\n        return max(candidates, key=lambda t: float(t[1]))\n    # Compute densities\n    dens = np.array([float(v) / (float(w) + 1e-12) for w, v, _ in pos], dtype=float)\n    dens = np.clip(dens, 0, 1)\n    mean_dens = float(np.mean(dens))\n    # Items occupying >=80% capacity and density >= mean\n    large = [(w, v, idx) for w, v, idx in pos if float(w) >= 0.80 * float(remaining_capacity) and (float(v) / (float(w) + 1e-12)) >= mean_dens]\n    if large:\n        # deterministic tie-breaking with small noise\n        return max(large, key=lambda t: float(t[1]) + 1e-9 * t[2])\n    # Otherwise pick best density\n    return max(pos, key=lambda t: (float(t[1]) / (float(t[0]) + 1e-12)) + 1e-9 * t[2])\n\n",
  "fill_first_then_density_threshold_aug_336": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Filter fitting items\n    fit_items = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit_items:\n        return None\n    # Immediate return for zero\u2011weight, positive\u2011value items\n    for w, v, idx in fit_items:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    # Positive weight items\n    pos_items = [(w, v, idx) for w, v, idx in fit_items if w > 0]\n    if not pos_items:\n        return max(fit_items, key=lambda t: float(t[1]))\n    # Compute densities\n    dens = np.array([float(v) / (float(w) + 1e-12) for w, v, _ in pos_items], dtype=float)\n    dens = np.clip(dens, 0, 1)\n    # Get indices sorted by density descending\n    sorted_idx = np.argsort(-dens)\n    top_k = min(5, len(pos_items))\n    top_indices = sorted_idx[:top_k]\n    # Select among top_k the one with highest value\n    top_candidates = [pos_items[i] for i in top_indices]\n    # Randomly choose among top candidates with highest value\n    max_val = max(top_candidates, key=lambda t: float(t[1]))[1]\n    bests = [t for t in top_candidates if float(t[1]) == max_val]\n    rng = np.random.default_rng(seed=42)\n    chosen = rng.choice(bests, replace=False)\n    return chosen\n\n",
  "fill_first_then_density_threshold_aug_337": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Fit items\n    fit = [(w, v, idx) for w, v, idx in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    # Zero weight case\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n    # Positive weight subset\n    pos = [(w, v, idx) for w, v, idx in fit if w > 0]\n    if not pos:\n        return max(fit, key=lambda t: float(t[1]))\n    # Convert to arrays\n    weights = np.array([w for w, _, _ in pos], dtype=float)\n    values = np.array([v for _, v, _ in pos], dtype=float)\n    indices = np.array([idx for _, _, idx in pos], dtype=int)\n    # Densities with epsilon\n    densities = np.divide(values, weights + 1e-12)\n    densities = np.clip(densities, 0, 1)\n    # Normalized values\n    max_val = float(np.max(values) + 1e-12)\n    norm_vals = np.divide(values, max_val)\n    # Weighted score\n    scores = 0.6 * densities + 0.4 * norm_vals\n    # Items that occupy >=90% capacity\n    big_mask = weights >= 0.90 * float(remaining_capacity)\n    if np.any(big_mask):\n        big_scores = np.where(big_mask, scores, -np.inf)\n        best_idx = np.argmax(big_scores)\n        return (pos[best_idx][0], pos[best_idx][1], pos[best_idx][2])\n    # Otherwise best score\n    best_idx = np.argmax(scores)\n    return (pos[best_idx][0], pos[best_idx][1], pos[best_idx][2])\n\n",
  "density_with_rare_value_bonus_aug_338": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    # Convert list to numpy array for vectorised processing\n    items = np.array(remaining_items, dtype=np.int64)\n    w, v, idx = items[:, 0], items[:, 1], items[:, 2]\n\n    # Keep only items that fit\n    fit_mask = w <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n    w_fit, v_fit, idx_fit = w[fit_mask], v[fit_mask], idx[fit_mask]\n\n    # Special case: zero weight but positive value\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        return (int(w_fit[zero_mask][0]), int(v_fit[zero_mask][0]), int(idx_fit[zero_mask][0]))\n\n    # Frequency of values among the remaining items\n    freq = Counter(v_fit.tolist())\n\n    # Compute score: density + rarity bonus + deterministic noise\n    density = v_fit.astype(np.float64) / (w_fit.astype(np.float64) + 1e-12)\n    rarity = 1.0 / np.sqrt(np.array([freq.get(val, 1) for val in v_fit], dtype=np.float64) + 1e-12)\n    score = density + 0.12 * rarity\n\n    # Deterministic tie\u2011breaker: small noise proportional to index\n    noise = np.arange(len(score), dtype=np.float64) * 1e-9\n    score += noise\n\n    best_idx = np.argmax(score)\n    return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(idx_fit[best_idx]))\n\n",
  "density_with_rare_value_bonus_aug_339": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    items = np.array(remaining_items, dtype=np.int64)\n    w, v, idx = items[:, 0], items[:, 1], items[:, 2]\n\n    fit_mask = w <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n    w_fit, v_fit, idx_fit = w[fit_mask], v[fit_mask], idx[fit_mask]\n\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        return (int(w_fit[zero_mask][0]), int(v_fit[zero_mask][0]), int(idx_fit[zero_mask][0]))\n\n    freq = Counter(v_fit.tolist())\n\n    density = v_fit.astype(np.float64) / (w_fit.astype(np.float64) + 1e-12)\n    density = np.clip(density, 0, 1e3)  # prevent extreme values\n\n    rarity = 1.0 / np.sqrt(np.array([freq.get(val, 1) for val in v_fit], dtype=np.float64) + 1e-12)\n\n    # Soft\u2011min weighting: exp(-density) * rarity\n    exp_neg = np.exp(-density)\n    weight = exp_neg * rarity\n    weight = weight / (np.sum(weight) + 1e-12)\n\n    best_idx = np.argmax(weight)\n    return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(idx_fit[best_idx]))\n\n",
  "density_with_rare_value_bonus_aug_340": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    items = np.array(remaining_items, dtype=np.int64)\n    w, v, idx = items[:, 0], items[:, 1], items[:, 2]\n\n    fit_mask = w <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n    w_fit, v_fit, idx_fit = w[fit_mask], v[fit_mask], idx[fit_mask]\n\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        return (int(w_fit[zero_mask][0]), int(v_fit[zero_mask][0]), int(idx_fit[zero_mask][0]))\n\n    freq = Counter(v_fit.tolist())\n\n    density = v_fit.astype(np.float64) / (w_fit.astype(np.float64) + 1e-12)\n    density = np.clip(density, 0, 1e3)\n\n    rarity = 1.0 / np.sqrt(np.array([freq.get(val, 1) for val in v_fit], dtype=np.float64) + 1e-12)\n\n    score = density + 0.08 * rarity\n\n    top_k = min(5, len(score))\n    top_indices = np.argpartition(-score, top_k - 1)[:top_k]\n    top_scores = score[top_indices]\n\n    probs = top_scores / (np.sum(top_scores) + 1e-12)\n\n    rng = np.random.default_rng(12345)  # fixed seed for reproducibility\n    chosen = rng.choice(len(top_indices), p=probs)\n    chosen_idx = top_indices[chosen]\n\n    return (int(w_fit[chosen_idx]), int(v_fit[chosen_idx]), int(idx_fit[chosen_idx]))\n\n",
  "density_with_rare_value_bonus_aug_341": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    if not remaining_items:\n        return None\n\n    items = np.array(remaining_items, dtype=np.int64)\n    w, v, idx = items[:, 0], items[:, 1], items[:, 2]\n\n    fit_mask = w <= remaining_capacity\n    if not np.any(fit_mask):\n        return None\n    w_fit, v_fit, idx_fit = w[fit_mask], v[fit_mask], idx[fit_mask]\n\n    zero_mask = (w_fit == 0) & (v_fit > 0)\n    if np.any(zero_mask):\n        return (int(w_fit[zero_mask][0]), int(v_fit[zero_mask][0]), int(idx_fit[zero_mask][0]))\n\n    freq = Counter(v_fit.tolist())\n\n    density = v_fit.astype(np.float64) / (w_fit.astype(np.float64) + 1e-12)\n    density_median = np.median(density)\n\n    rarity = 1.0 / np.sqrt(np.array([freq.get(val, 1) for val in v_fit], dtype=np.float64) + 1e-12)\n    rarity_max = np.max(rarity)\n\n    # Normalise by median density and max rarity, then blend\n    norm_density = density / (density_median + 1e-12)\n    norm_rarity = rarity / (rarity_max + 1e-12)\n    score = 0.7 * norm_density + 0.3 * norm_rarity\n\n    score = np.clip(score, 0, 1)  # keep within a safe range\n\n    best_idx = np.argmax(score)\n    return (int(w_fit[best_idx]), int(v_fit[best_idx]), int(idx_fit[best_idx]))\n\n",
  "density_then_closest_to_capacity_endgame_aug_342": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Build the list of feasible items with a while\u2011loop\n    fit: List[Tuple[int, int, int]] = []\n    i = 0\n    while i < len(remaining_items):\n        w, v, idx = remaining_items[i]\n        if w <= remaining_capacity:\n            fit.append((w, v, idx))\n        i += 1\n    if not fit:\n        return None\n\n    # Prefer any zero\u2011weight, positive\u2011value item\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # All weights for quantile calculation\n    ws = np.array([float(w) for w, _, _ in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # 25\u202f% quantile instead of 30\u202f%\n    q25 = float(np.quantile(ws, 0.25))\n\n    # Candidates with positive weight\n    cand = [(w, v, idx) for w, v, idx in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Fill mode when capacity is below the 25\u202f% quantile\n    if float(remaining_capacity) <= q25:\n        # Largest weight; tie\u2011break by value and a tiny deterministic noise\n        return max(cand, key=lambda t: (int(t[0]), float(t[1]) + 1e-6 * t[2]))\n\n    # Normal mode \u2013 best density with an epsilon in the denominator\n    return max(cand,\n               key=lambda t: (float(t[1]) / (float(t[0]) + 1e-12), float(t[1])))\n\n",
  "density_then_closest_to_capacity_endgame_aug_343": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Build fit list with a for\u2011loop\n    fit: List[Tuple[int, int, int]] = []\n    for item in remaining_items:\n        w, v, idx = item\n        if w <= remaining_capacity:\n            fit.append(item)\n    if not fit:\n        return None\n\n    # Zero\u2011weight, positive\u2011value shortcut\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Median of positive weights\n    ws = np.array([float(w) for w, _, _ in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    q50 = float(np.median(ws))\n\n    # Candidates with positive weight\n    cand = [(w, v, idx) for w, v, idx in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Fill mode when capacity is below the median\n    if float(remaining_capacity) <= q50:\n        # Use np.max to pick the heaviest; tie\u2011break by value and a small noise\n        return max(cand,\n                   key=lambda t: (int(t[0]), float(t[1]), 1e-7 * t[2]))\n\n    # Normal mode \u2013 best density with epsilon\n    return max(cand,\n               key=lambda t: (float(t[1]) / (float(t[0]) + 1e-12), float(t[1])))\n\n",
  "density_then_closest_to_capacity_endgame_aug_344": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    # Build fit list via a generator\n    fit = list((w, v, idx)\n               for w, v, idx in remaining_items\n               if w <= remaining_capacity)\n    if not fit:\n        return None\n\n    # Prefer zero\u2011weight, positive\u2011value items\n    zero_item = next(((w, v, idx) for w, v, idx in fit if w == 0 and v > 0),\n                     None)\n    if zero_item:\n        return zero_item\n\n    # Positive weights for threshold calculation\n    ws = np.array([float(w) for w, _, _ in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # 35\u202f% quantile threshold\n    q35 = float(np.quantile(ws, 0.35))\n\n    # Positive\u2011weight candidates\n    cand = [(w, v, idx) for w, v, idx in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    # Fill mode\n    if float(remaining_capacity) <= q35:\n        # Largest weight; tie\u2011break by value and a tiny deterministic noise\n        return max(cand,\n                   key=lambda t: (int(t[0]), float(t[1]), 1e-8 * t[2]))\n\n    # Density mode \u2013 top\u20117 selection\n    density = np.array([float(v) / (float(w) + 1e-12) for w, v, _ in cand])\n    density = np.clip(density, 0, 1)  # keep ratios bounded\n\n    top_k = min(7, density.size)\n    top_idx = np.argpartition(-density, top_k - 1)[:top_k]\n    top_dens = density[top_idx]\n\n    # Simple deterministic tie\u2011break: add a small noise proportional to index\n    noise = 1e-6 * np.arange(top_k, dtype=float)\n    top_dens += noise\n\n    chosen = top_idx[np.argmax(top_dens)]\n    w, v, idx = cand[chosen]\n    return (int(w), int(v), int(idx))\n\n"
}
