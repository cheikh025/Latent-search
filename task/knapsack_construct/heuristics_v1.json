{
  "density_ratio_classic": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in remaining_items:\n      if w <= remaining_capacity and w > 0:\n        score = v / w\n        if score > best_score:\n          best_score, best_item = score, (w, v, idx)\n      elif w == 0 and v > 0:\n        return (w, v, idx)\n    return best_item\n",
  "highest_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "lightest_weight_tiebreak_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            dens = (v / w) if w > 0 else (np.inf if v > 0 else -np.inf)\n            score = -float(w) + 1e-6 * float(dens)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "heaviest_that_fits": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(w) + 1e-6 * float(v)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "closest_to_capacity_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = C - float(w)\n            dens = (v / w) if w > 0 else (np.inf if v > 0 else -np.inf)\n            score = -leftover + 1e-6 * dens\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "capacity_scaled_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            score = (v / w) * (float(w) / C)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "log_weight_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            denom = np.log1p(max(0, w))\n            score = float(v) / (denom if denom > 0 else 1e-12)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "sqrt_weight_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) / (np.sqrt(max(1e-12, float(w))))\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_over_weight_squared": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            ww = max(1e-12, float(w))\n            score = float(v) / (ww * ww)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "adaptive_value_vs_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    weights = np.array([w for (w, _, _) in remaining_items], dtype=float)\n    wmax = float(np.max(weights)) if weights.size else 1.0\n    progress = 1.0 - (C / max(1.0, wmax))\n    alpha = float(np.clip(0.15 + 0.7 * progress, 0.15, 0.85))\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            score = alpha * dens + (1.0 - alpha) * float(v)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "median_value_filtered_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit_vals = [v for (w, v, _) in remaining_items if w <= remaining_capacity]\n    if not fit_vals:\n        return None\n    medv = float(np.median(np.array(fit_vals, dtype=float)))\n    best_item = None\n    best_score = -np.inf\n    found_strict = False\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            dens = float(v) / max(1e-12, float(w))\n            strict = float(v) >= medv\n            score = dens + (1e6 if strict else 0.0)\n            if (strict and not found_strict) or score > best_score:\n                best_score, best_item = score, (w, v, idx)\n                found_strict = found_strict or strict\n    return best_item\n",
  "deterministic_jitter_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            jitter = 1e-9 * np.sin((idx + 1.0) * (dens + 0.12345))\n            score = dens + jitter\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "regret_density_gap": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    candidates = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            candidates.append((float(v) / float(w), w, v, idx))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not candidates:\n        return None\n    densities = np.array([d for (d, _, _, _) in candidates], dtype=float)\n    best_item = None\n    best_score = -np.inf\n    for d, w, v, idx in candidates:\n        other = densities[densities != d]\n        second = float(np.max(other)) if other.size else -np.inf\n        score = d + 0.25 * (d - second)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "one_step_fractional_lookahead": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    cap = int(cap)\n    if cap <= 0 or not items:\n        return 0.0\n    arr = []\n    for w, v, _ in items:\n        if w <= 0:\n            if v > 0:\n                return float('inf')\n            continue\n        arr.append((float(v) / float(w), int(w), float(v)))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    val = 0.0\n    rem = cap\n    for d, w, v in arr:\n        if w <= rem:\n            val += v\n            rem -= w\n        else:\n            val += d * rem\n            break\n    return val\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            rest = [it for it in remaining_items if it[2] != idx]\n            bound = _fractional_upper_bound(leftover, rest)\n            score = float(v) + bound\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "two_candidate_fractional_lookahead_topk": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound_topk(cap: int, items: List[Tuple[int, int, int]], k: int = 25) -> float:\n    cap = int(cap)\n    if cap <= 0 or not items:\n        return 0.0\n    arr = []\n    for w, v, _ in items:\n        if w <= 0:\n            if v > 0:\n                return float('inf')\n            continue\n        arr.append((float(v) / float(w), int(w), float(v)))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    arr = arr[:max(1, int(k))]\n    val = 0.0\n    rem = cap\n    for d, w, v in arr:\n        if w <= rem:\n            val += v\n            rem -= w\n        else:\n            val += d * rem\n            break\n    return val\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            rest = [it for it in remaining_items if it[2] != idx]\n            bound = _fractional_upper_bound_topk(leftover, rest, k=25)\n            score = float(v) + bound\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "avoid_dead_end_min_weight_guard": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    weights_fit = [w for (w, _, _) in remaining_items if w > 0 and w <= remaining_capacity]\n    if not weights_fit:\n        return None\n    wmin = int(min(weights_fit))\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            dens = float(v) / max(1e-12, float(w))\n            leftover = remaining_capacity - w\n            penalty = 0.0\n            if leftover > 0 and leftover < wmin:\n                penalty = (wmin - leftover) / max(1.0, wmin)\n            score = dens - 0.5 * penalty\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "tight_then_high_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_leftover = None\n    best_value = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            leftover = remaining_capacity - w\n            if best_leftover is None or leftover < best_leftover or (leftover == best_leftover and v > best_value):\n                best_leftover = leftover\n                best_value = v\n                best_item = (w, v, idx)\n    return best_item\n",
  "density_with_leftover_gaussian_target": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    target = 0.1 * C\n    sigma = 0.25 * C + 1e-12\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            leftover = C - float(w)\n            shape = np.exp(-((leftover - target) ** 2) / (2.0 * sigma * sigma))\n            score = dens * shape\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "zscore_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    dens_list = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens_list.append(float(v) / float(w))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not dens_list:\n        return None\n    dens_arr = np.array(dens_list, dtype=float)\n    mu = float(np.mean(dens_arr))\n    sd = float(np.std(dens_arr)) + 1e-12\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            d = float(v) / float(w)\n            score = (d - mu) / sd\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "rank_density_cdf": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            cand.append((float(v) / float(w), w, v, idx))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not cand:\n        return None\n    ds = np.array([d for d, _, _, _ in cand], dtype=float)\n    order = np.argsort(ds)\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.arange(order.size, dtype=float)\n    best_i = int(np.argmax(ranks))\n    d, w, v, idx = cand[best_i]\n    return (w, v, idx)\n",
  "lagrangian_surrogate_lambda_from_fractional": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _estimate_lambda(cap: int, items: List[Tuple[int, int, int]]) -> float:\n    arr = []\n    for w, v, idx in items:\n        if w > 0:\n            arr.append((float(v) / float(w), int(w)))\n    if not arr:\n        return 0.0\n    arr.sort(key=lambda x: x[0], reverse=True)\n    rem = int(cap)\n    lam = arr[-1][0]\n    for d, w in arr:\n        if w <= rem:\n            rem -= w\n            lam = d\n        else:\n            lam = d\n            break\n    return float(lam)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    lam = _estimate_lambda(remaining_capacity, remaining_items)\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) - lam * float(w)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "lagrangian_value_minus_mu_weight_mu_mean_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    dens = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens.append(float(v) / float(w))\n    mu = float(np.mean(dens)) if dens else 0.0\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) - mu * float(w)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "defensive_greedy_max_of_all": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    vals = np.array([v for (w, v, _) in fit], dtype=float)\n    wts = np.array([w for (w, _, _) in fit], dtype=float)\n    dens = np.array([(v / w) if w > 0 else (np.inf if v > 0 else -np.inf) for (w, v, _) in fit], dtype=float)\n    def norm(x):\n        lo, hi = float(np.nanmin(x)), float(np.nanmax(x))\n        return (x - lo) / (hi - lo + 1e-12)\n    vN = norm(vals)\n    dN = norm(np.nan_to_num(dens, nan=-1e18, posinf=1e18, neginf=-1e18))\n    fN = norm(wts / max(1.0, float(remaining_capacity)))\n    scores = np.maximum.reduce([vN, dN, fN])\n    j = int(np.nanargmax(scores))\n    return fit[j]\n",
  "max_of_two_density_or_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    vals = np.array([v for (w, v, _) in fit], dtype=float)\n    dens = np.array([(v / w) if w > 0 else (np.inf if v > 0 else -np.inf) for (w, v, _) in fit], dtype=float)\n    def norm(x):\n        lo, hi = float(np.nanmin(x)), float(np.nanmax(x))\n        return (x - lo) / (hi - lo + 1e-12)\n    vN = norm(vals)\n    dN = norm(np.nan_to_num(dens, nan=-1e18, posinf=1e18, neginf=-1e18))\n    scores = np.maximum(vN, dN)\n    j = int(np.nanargmax(scores))\n    return fit[j]\n",
  "heavy_if_high_value_quantile": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    vals = np.array([v for (_, v, _) in fit], dtype=float)\n    q75 = float(np.quantile(vals, 0.75))\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    for w, v, idx in fit:\n        if float(v) >= q75:\n            score = float(v) + 0.25 * (float(w) / C) * float(v)\n        else:\n            score = float(v) / max(1e-12, float(w))\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "small_item_packability_bias": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    wmed = float(np.median(np.array([w for (w, _, _) in fit], dtype=float))) + 1e-12\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in fit:\n        dens = float(v) / max(1e-12, float(w))\n        pack = 1.0 / (1.0 + float(w) / wmed)\n        score = dens * pack\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "expected_fill_probability": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    all_w = np.array([w for (w, _, _) in remaining_items if w > 0], dtype=float)\n    mu = float(np.mean(all_w)) if all_w.size else 0.0\n    sd = float(np.std(all_w)) + 1e-12\n    best_item = None\n    best_score = -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in fit:\n        leftover = C - float(w)\n        closeness = np.exp(-((leftover - mu) ** 2) / (2.0 * sd * sd))\n        dens = float(v) / max(1e-12, float(w))\n        score = dens * (0.5 + 0.5 * closeness)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "maximize_value_then_density_tie": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_v = -np.inf\n    best_d = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            d = float(v) / max(1e-12, float(w))\n            if float(v) > best_v or (float(v) == best_v and d > best_d):\n                best_v = float(v)\n                best_d = d\n                best_item = (w, v, idx)\n    return best_item\n",
  "knapsack_core_bias_midweight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    target = 0.5 * C\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            clos = 1.0 - min(1.0, abs(float(w) - target) / target)\n            score = dens * (0.5 + 0.5 * clos)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "bounded_ratio_with_beta_mean_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    weights = np.array([w for (w, _, _) in remaining_items if w > 0], dtype=float)\n    beta = float(np.mean(weights)) if weights.size else 1.0\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            score = float(v) / (float(w) + beta)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "sigmoid_density_softcap": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    dens_fit = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens_fit.append(float(v) / float(w))\n    mu = float(np.mean(dens_fit)) if dens_fit else 0.0\n    sd = float(np.std(dens_fit)) + 1e-12\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            d = float(v) / float(w)\n            z = (d - mu) / sd\n            sig = 1.0 / (1.0 + np.exp(-z))\n            score = sig * (float(w) / C)\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "minimize_slack_then_max_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_left = None\n    best_d = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            left = remaining_capacity - w\n            d = float(v) / max(1e-12, float(w))\n            if best_left is None or left < best_left or (left == best_left and d > best_d):\n                best_left = left\n                best_d = d\n                best_item = (w, v, idx)\n    return best_item\n",
  "density_minus_leftover_fraction_penalty": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    gamma = 0.5\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            leftover = (C - float(w)) / C\n            score = dens - gamma * leftover\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "value_plus_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    C = float(max(1, remaining_capacity))\n    k = 0.1 * C\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            score = float(v) + k * dens\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "density_with_small_gap_penalty_relative_item": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item = None\n    best_score = -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            dens = float(v) / float(w)\n            leftover = remaining_capacity - w\n            penalty = 0.0\n            if leftover > 0 and leftover < 0.25 * w:\n                penalty = (0.25 * w - leftover) / max(1.0, w)\n            score = dens - 0.75 * penalty\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    return best_item\n",
  "top_density_then_maximize_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity and w > 0:\n            cand.append((float(v) / float(w), w, v, idx))\n        elif w == 0 and v > 0:\n            return (w, v, idx)\n    if not cand:\n        return None\n    ds = np.array([d for d, _, _, _ in cand], dtype=float)\n    thr = float(np.quantile(ds, 0.80))\n    best = None\n    best_w = -1\n    best_d = -np.inf\n    for d, w, v, idx in cand:\n        if d >= thr:\n            if w > best_w or (w == best_w and d > best_d):\n                best_w = w\n                best_d = d\n                best = (w, v, idx)\n    return best\n",
  "pareto_frontier_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    # Zero-weight positive value is always best.\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Compute non-dominated set (w lower is better, v higher is better).\n    # Sort by weight asc, value desc; then keep items that improve best value seen.\n    fit2 = [(int(w), float(v), idx) for (w, v, idx) in fit if w > 0]\n    fit2.sort(key=lambda x: (x[0], -x[1], x[2]))\n    frontier = []\n    best_v = -np.inf\n    for w, v, idx in fit2:\n        if v > best_v + 1e-12:\n            frontier.append((w, v, idx))\n            best_v = v\n\n    best_item = None\n    best_score = -np.inf\n    best_v = -np.inf\n    for w, v, idx in frontier:\n        d = v / max(1e-12, float(w))\n        if d > best_score or (abs(d - best_score) <= 1e-12 and v > best_v):\n            best_score = d\n            best_v = v\n            best_item = (w, int(v) if float(v).is_integer() else v, idx)\n    # Ensure original v type (int) is preserved if possible; but output accepts int/float.\n    return (best_item[0], int(best_item[1]) if isinstance(best_item[1], float) and best_item[1].is_integer() else best_item[1], best_item[2])\n",
  "inverse_rank_aggregation": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _inv_rank_scores(arr: np.ndarray) -> np.ndarray:\n    # Highest value gets rank 1 => inv_rank 1.0; stable under ties.\n    order = np.argsort(-arr, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.arange(1, order.size + 1, dtype=float)\n    return 1.0 / ranks\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    vals = np.array([float(v) for (w, v, _) in fit], dtype=float)\n    wts = np.array([float(w) for (w, _, _) in fit], dtype=float)\n    dens = vals / np.maximum(1e-12, wts)\n    fill = wts / float(max(1, remaining_capacity))\n\n    score = _inv_rank_scores(vals) + _inv_rank_scores(dens) + 0.75 * _inv_rank_scores(fill)\n    j = int(np.argmax(score))\n    return fit[j]\n",
  "exponential_tradeoff_value_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    # Estimate tightness by fraction of items that fit.\n    frac_fit = float(len(fit)) / float(max(1, len(remaining_items)))\n    lam = float(np.clip(2.0 - 1.5 * frac_fit, 0.5, 2.0))  # tighter => larger lambda\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        score = float(v) * np.exp(-lam * (float(w) / C))\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "weight_rarity_bonus_density": "import numpy as np\nfrom typing import List, Tuple, Optional, Dict\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    freq: Dict[int, int] = {}\n    for w, _, _ in remaining_items:\n        ww = int(w)\n        freq[ww] = freq.get(ww, 0) + 1\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        w0 = int(w)\n        dens = float(v) / max(1e-12, float(w0))\n        rarity = 1.0 / np.sqrt(float(freq.get(w0, 1)))\n        score = dens * (0.85 + 0.15 * rarity) + 1e-9 * float(v)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "gcd_leftover_alignment": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom math import gcd\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    pos_w = [int(w) for (w, _, _) in remaining_items if int(w) > 0]\n    g = 0\n    for w in pos_w:\n        g = w if g == 0 else gcd(g, w)\n    g = int(g) if g > 0 else 1\n\n    best_item, best_score = None, -np.inf\n    C = float(max(1, remaining_capacity))\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / float(w)\n        leftover = int(remaining_capacity - w)\n        mod = leftover % g\n        # normalized distance to nearest multiple of g\n        dist = min(mod, g - mod) / max(1.0, float(g))\n        score = dens - 0.75 * dist + 1e-6 * (float(w) / C)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "mini_bitset_reachability_lookahead": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _reachable_bitset(weights: List[int], cap: int) -> int:\n    bits = 1  # weight 0 reachable\n    for w in weights:\n        if 0 < w <= cap:\n            bits |= (bits << w)\n            # Keep only up to cap bits\n            bits &= (1 << (cap + 1)) - 1\n            if bits == (1 << (cap + 1)) - 1:\n                break\n    return bits\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cap_dp = int(min(2048, max(0, remaining_capacity)))\n    # Use a limited set of lightest weights to keep DP fast and relevant for fill.\n    cand_w = sorted([int(w) for (w, _, _) in remaining_items if 0 < int(w) <= cap_dp])[:80]\n    base_bits = _reachable_bitset(cand_w, cap_dp)\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = int(remaining_capacity - ww)\n        if leftover < 0:\n            continue\n        l = min(leftover, cap_dp)\n        reachable = 1.0 if ((base_bits >> l) & 1) else 0.0\n        dens = float(v) / float(ww)\n        score = dens * (0.7 + 0.3 * reachable) + 0.05 * float(v) * reachable\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "two_step_best_pair_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    # Precompute best partner value by weight threshold using scanning.\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        leftover = remaining_capacity - int(w)\n        best_partner_v = 0.0\n        for w2, v2, idx2 in fit:\n            if idx2 == idx:\n                continue\n            if int(w2) <= leftover:\n                best_partner_v = max(best_partner_v, float(v2))\n        dens = float(v) / max(1e-12, float(w))\n        score = float(v) + best_partner_v + 1e-3 * dens\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "deterministic_gumbel_softmax_density": "import numpy as np\nfrom typing import List, Tuple, Optional\nimport math\n\ndef _hash01(x: float) -> float:\n    # deterministic pseudo-random in (0,1) from float input\n    s = math.sin(x) * 43758.5453123\n    return s - math.floor(s)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    best_item, best_score = None, -np.inf\n    C = float(max(1, remaining_capacity))\n    # Higher temp early (large capacity), lower temp when tight.\n    temp = float(np.clip(0.35 * (C / (C + 50.0)), 0.05, 0.35))\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w <= 0:\n                continue\n            dens = float(v) / float(w)\n            u = _hash01((idx + 1.0) * 0.987 + C * 0.013)\n            u = min(1.0 - 1e-12, max(1e-12, u))\n            g = -math.log(-math.log(u))\n            score = dens + temp * g\n            if score > best_score:\n                best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_quantile_gate_then_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    q = float(np.quantile(vals, 0.60))  # slightly above median\n    gated = [(w, v, idx) for (w, v, idx) in fit if float(v) >= q and w > 0]\n    pool = gated if len(gated) >= max(2, len(fit) // 5) else [(w, v, idx) for (w, v, idx) in fit if w > 0]\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in pool:\n        d = float(v) / float(w)\n        score = d + 1e-6 * float(v)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "interquartile_leftover_preference": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))  # degenerate\n    q1, q3 = float(np.quantile(ws, 0.25)), float(np.quantile(ws, 0.75))\n    iqr = max(1e-12, q3 - q1)\n\n    best_item, best_score = None, -np.inf\n    C = float(remaining_capacity)\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / float(w)\n        leftover = C - float(w)\n        # Penalty is 0 if leftover in [q1,q3], else proportional to distance to interval.\n        dist = 0.0\n        if leftover < q1:\n            dist = (q1 - leftover) / iqr\n        elif leftover > q3:\n            dist = (leftover - q3) / iqr\n        score = dens - 0.4 * dist\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "bimodal_light_or_heavy_switch": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    wmed = float(np.median(ws)) if ws.size else 1.0\n    # If we can fit ~3+ median items, start with heavy-ish; else favor light.\n    heavy_mode = float(remaining_capacity) >= 3.0 * wmed\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / float(w)\n        if heavy_mode:\n            score = dens + 0.15 * float(w)  # pushes heavier among good densities\n        else:\n            score = dens - 0.15 * float(w)  # pushes lighter among good densities\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "robust_mad_z_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _mad(x: np.ndarray) -> float:\n    med = float(np.median(x))\n    return float(np.median(np.abs(x - med))) + 1e-12\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                cand.append((float(v) / float(w), w, v, idx))\n    if not cand:\n        return None\n    ds = np.array([d for (d, _, _, _) in cand], dtype=float)\n    med = float(np.median(ds))\n    mad = _mad(ds)\n    best_item, best_score = None, -np.inf\n    for d, w, v, idx in cand:\n        z = (float(d) - med) / (1.4826 * mad)  # approx std for normal\n        score = z + 1e-6 * float(v)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "density_plus_value_share": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    total_v = float(np.sum([float(v) for (_, v, _) in fit])) + 1e-12\n    alpha = 0.75\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / float(w)\n        share = float(v) / total_v\n        score = dens + alpha * share\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "mod_bucket_leftover_favor_small_base": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    bases = list(range(2, 10))\n    # For each base, compute histogram of residues among remaining weights (positive only).\n    res_hist = {b: np.zeros(b, dtype=float) for b in bases}\n    for w, _, _ in remaining_items:\n        ww = int(w)\n        if ww > 0:\n            for b in bases:\n                res_hist[b][ww % b] += 1.0\n    # Normalize histograms.\n    for b in bases:\n        s = float(np.sum(res_hist[b])) + 1e-12\n        res_hist[b] /= s\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = int(remaining_capacity - ww)\n        # Average residue popularity across bases.\n        pop = 0.0\n        for b in bases:\n            pop += float(res_hist[b][leftover % b])\n        pop /= float(len(bases))\n        dens = float(v) / float(ww)\n        score = dens * (0.75 + 0.25 * pop)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "threshold_accept_then_best_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                cand.append((float(v) / float(w), w, v, idx))\n    if not cand:\n        return None\n\n    ds = np.array([d for (d, _, _, _) in cand], dtype=float)\n    mu = float(np.mean(ds))\n    sd = float(np.std(ds)) + 1e-12\n    # Tighter capacity -> higher k (be pickier).\n    tight = float(np.clip(1.0 - (float(remaining_capacity) / (float(remaining_capacity) + 100.0)), 0.0, 1.0))\n    k = 0.25 + 0.75 * tight\n    thr = mu + k * sd\n\n    above = [(d, w, v, idx) for (d, w, v, idx) in cand if d >= thr]\n    pool = above if above else cand\n\n    # Choose maximum fill among pool; tie-break by density.\n    best_item, best_w, best_d = None, -1, -np.inf\n    for d, w, v, idx in pool:\n        if int(w) > best_w or (int(w) == best_w and float(d) > best_d):\n            best_w, best_d = int(w), float(d)\n            best_item = (w, v, idx)\n    return best_item\n",
  "maximin_normalized_value_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _norm(x: np.ndarray) -> np.ndarray:\n    lo, hi = float(np.min(x)), float(np.max(x))\n    return (x - lo) / (hi - lo + 1e-12)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    wts = np.array([float(w) for (w, _, _) in fit], dtype=float)\n    dens = vals / np.maximum(1e-12, wts)\n\n    vN = _norm(vals)\n    dN = _norm(dens)\n    scores = np.minimum(vN, dN)\n    j = int(np.argmax(scores))\n    return fit[j]\n",
  "multiplicative_power_score": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    tight = float(np.clip(1.0 - (C / (C + 200.0)), 0.0, 1.0))\n    a = 0.9 - 0.4 * tight\n    b = 0.6 + 0.3 * tight\n    c = 0.2 + 0.4 * tight\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        val = max(1e-12, float(v))\n        dens = max(1e-12, float(v) / float(w))\n        fill = max(1e-12, float(w) / C)\n        score = (val ** a) * (dens ** b) * (fill ** c)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "dominance_count_heuristic": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dom = 0\n        for w2, v2, idx2 in fit:\n            if idx2 == idx:\n                continue\n            if int(w) <= int(w2) and float(v) >= float(v2) and (int(w) < int(w2) or float(v) > float(v2)):\n                dom += 1\n        dens = float(v) / float(w)\n        score = dens + 0.05 * float(dom)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "quantile_cluster_total_value_pick": "import numpy as np\nfrom typing import List, Tuple, Optional, Dict\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    wpos = np.array([float(w) for (w, _, _) in fit if w > 0], dtype=float)\n    if wpos.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n    q1, q2 = float(np.quantile(wpos, 1/3)), float(np.quantile(wpos, 2/3))\n\n    def bin_id(w: float) -> int:\n        if w <= q1: return 0\n        if w <= q2: return 1\n        return 2\n\n    bins: Dict[int, List[Tuple[int, int, int]]] = {0: [], 1: [], 2: []}\n    bin_value = {0: 0.0, 1: 0.0, 2: 0.0}\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        b = bin_id(float(w))\n        bins[b].append((w, v, idx))\n        bin_value[b] += float(v)\n\n    chosen_bin = int(max(bin_value.keys(), key=lambda b: bin_value[b]))\n    pool = bins[chosen_bin] if bins[chosen_bin] else [(w, v, idx) for (w, v, idx) in fit if w > 0]\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in pool:\n        d = float(v) / max(1e-12, float(w))\n        if d > best_score:\n            best_score, best_item = d, (w, v, idx)\n    return best_item\n",
  "topk_density_then_best_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    cand = []\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                cand.append((float(v) / float(w), w, v, idx))\n    if not cand:\n        return None\n    cand.sort(key=lambda x: x[0], reverse=True)\n    k = int(max(1, round(np.sqrt(len(cand)))))\n    top = cand[:k]\n    best = max(top, key=lambda t: (float(t[2]), float(t[0])))\n    _, w, v, idx = best\n    return (w, v, idx)\n",
  "fractional_bound_lookahead": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _fractional_upper_bound(cap: int, items: List[Tuple[int,int,int]]) -> float:\n    if cap <= 0:\n        return 0.0\n    cand = [(w, v) for (w, v, _) in items if w > 0 and w <= cap and v > 0]\n    if not cand:\n        return 0.0\n    cand.sort(key=lambda t: float(t[1]) / float(t[0]), reverse=True)\n    rem = float(cap)\n    ub = 0.0\n    for w, v in cand:\n        if rem <= 0:\n            break\n        if float(w) <= rem:\n            ub += float(v)\n            rem -= float(w)\n        else:\n            ub += float(v) * (rem / float(w))\n            rem = 0.0\n    return ub\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        leftover = remaining_capacity - int(w)\n        ub = _fractional_upper_bound(leftover, [(w2, v2, i2) for (w2, v2, i2) in remaining_items if i2 != idx])\n        score = float(v) + ub + 1e-6 * (float(v) / float(w))\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "closest_complement_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    weights = sorted({int(w) for (w, _, _) in remaining_items if int(w) > 0})\n    if not weights:\n        return max(fit, key=lambda t: float(t[1]))\n\n    def nearest_dist(x: int) -> int:\n        # binary search\n        lo, hi = 0, len(weights)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if weights[mid] < x:\n                lo = mid + 1\n            else:\n                hi = mid\n        best = abs(weights[min(lo, len(weights)-1)] - x)\n        if lo > 0:\n            best = min(best, abs(weights[lo-1] - x))\n        return best\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = remaining_capacity - ww\n        dist = float(nearest_dist(leftover))\n        dens = float(v) / float(ww)\n        score = dens - 0.02 * dist + 1e-9 * float(v)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_minus_slack_penalty": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    tight = float(np.clip(1.0 - (C / (C + 150.0)), 0.0, 1.0))\n    beta = 0.15 + 0.55 * tight\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        slack = float(remaining_capacity - int(w))\n        score = float(v) - beta * slack\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "log_value_over_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    best_item, best_score = None, -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                score = float(np.log1p(max(0.0, float(v)))) / float(w)\n                if score > best_score:\n                    best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_per_sqrt_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    best_item, best_score = None, -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                score = float(v) / float(np.sqrt(float(w)))\n                if score > best_score:\n                    best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "power_density_p_tightness": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    C = float(max(1, remaining_capacity))\n    tight = float(np.clip(1.0 - (C / (C + 120.0)), 0.0, 1.0))\n    p = 1.0 + 0.75 * tight\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                score = float(v) / float((float(w) ** p))\n                if score > best_score:\n                    best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "target_fill_fraction": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    phase = float(C / (C + 200.0))\n    target = 0.70 - 0.35 * phase\n    tw = target * C\n\n    # allow a band around target weight\n    band = 0.18 * C\n    near = [(w, v, idx) for (w, v, idx) in fit if w > 0 and abs(float(w) - tw) <= band]\n    pool = near if near else [(w, v, idx) for (w, v, idx) in fit if w > 0]\n\n    best = max(pool, key=lambda t: (float(t[1]), float(t[1]) / max(1e-12, float(t[0]))))\n    return best\n",
  "three_champion_runoff": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _best_by(items, key_fn):\n    best = None\n    bestk = -np.inf\n    for it in items:\n        k = key_fn(it)\n        if k > bestk:\n            bestk, best = k, it\n    return best\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    c1 = _best_by(cand, lambda t: float(t[1]))\n    c2 = _best_by(cand, lambda t: float(t[1]) / float(t[0]))\n    c3 = _best_by(cand, lambda t: float(t[0]))\n\n    champs = [c for c in [c1, c2, c3] if c is not None]\n    # Deduplicate\n    uniq = []\n    seen = set()\n    for w, v, idx in champs:\n        if idx not in seen:\n            uniq.append((w, v, idx))\n            seen.add(idx)\n\n    vals = np.array([float(v) for (_, v, _) in uniq], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in uniq], dtype=float)\n    fill = np.array([float(w) / float(max(1, remaining_capacity)) for (w, _, _) in uniq], dtype=float)\n\n    def norm(x):\n        return (x - float(np.min(x))) / (float(np.max(x)) - float(np.min(x)) + 1e-12)\n\n    score = norm(vals) + norm(dens) + 0.5 * norm(fill)\n    j = int(np.argmax(score))\n    return uniq[j]\n",
  "deterministic_softmax_roulette": "import numpy as np\nfrom typing import List, Tuple, Optional\nimport math\n\ndef _hashu(x: float) -> float:\n    s = math.sin(x) * 100000.12345\n    return s - math.floor(s)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    cand = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not cand:\n        return None\n    for w, v, idx in cand:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in cand if w > 0]\n    if not cand:\n        return max([(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity], key=lambda t: float(t[1]))\n\n    C = float(max(1, remaining_capacity))\n    T = float(np.clip(0.35 * (C / (C + 80.0)), 0.06, 0.35))\n\n    scores = np.array([float(v) / float(w) + 0.02 * float(v) for (w, v, _) in cand], dtype=float)\n    mx = float(np.max(scores))\n    probs = np.exp((scores - mx) / T)\n    probs = probs / (float(np.sum(probs)) + 1e-12)\n\n    u = _hashu(C * 0.031 + len(cand) * 0.17)\n    cdf = 0.0\n    for (w, v, idx), p in zip(cand, probs):\n        cdf += float(p)\n        if u <= cdf:\n            return (w, v, idx)\n    return cand[-1]\n",
  "winsorized_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    dens = np.array([float(v) / float(w) for (w, v, _) in fit if w > 0], dtype=float)\n    if dens.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n    cap = float(np.quantile(dens, 0.90))\n\n    best_item = None\n    best_score = -np.inf\n    best_v = -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        d = float(v) / float(w)\n        d2 = min(d, cap)\n        if d2 > best_score or (abs(d2 - best_score) <= 1e-12 and float(v) > best_v):\n            best_score = d2\n            best_v = float(v)\n            best_item = (w, v, idx)\n    return best_item\n",
  "cv_adaptive_linear_combo": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    ds = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    mu = float(np.mean(ds))\n    sd = float(np.std(ds))\n    cv = float(sd / (abs(mu) + 1e-12))\n    alpha = float(np.clip(cv / (cv + 1.0), 0.15, 0.85))  # weight on density\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    # normalize\n    dN = (ds - float(np.min(ds))) / (float(np.max(ds)) - float(np.min(ds)) + 1e-12)\n    vN = (vals - float(np.min(vals))) / (float(np.max(vals)) - float(np.min(vals)) + 1e-12)\n\n    score = alpha * dN + (1.0 - alpha) * vN\n    j = int(np.argmax(score))\n    return cand[j]\n",
  "regret_based_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    best_d = float(np.max(dens))\n\n    best_item, best_score = None, -np.inf\n    for (w, v, idx), d in zip(cand, dens):\n        regret = best_d - float(d)\n        score = -regret + 1e-3 * float(v)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "top_density_band_best_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    ds = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    thr = float(np.quantile(ds, 0.75))\n    band = [(w, v, idx) for (w, v, idx) in cand if float(v) / float(w) >= thr]\n    if not band:\n        return max(cand, key=lambda t: float(t[1]) / float(t[0]))\n    return max(band, key=lambda t: (int(t[0]), float(t[1]) / float(t[0])))\n",
  "nearest_weight_cluster_center": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n    center = float(np.median(ws))\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    # Keep closest 30% to center\n    cand.sort(key=lambda t: abs(float(t[0]) - center))\n    k = max(1, int(round(0.30 * len(cand))))\n    pool = cand[:k]\n\n    return max(pool, key=lambda t: (float(t[1]) / float(t[0]), float(t[1])))\n",
  "density_times_remaining_fraction": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    C = float(max(1, remaining_capacity))\n    best_item, best_score = None, -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                dens = float(v) / float(w)\n                score = dens * (float(w) / C) + 1e-9 * float(v)\n                if score > best_score:\n                    best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "harmonic_mean_value_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _hmean(a: float, b: float) -> float:\n    return 2.0 * a * b / (a + b + 1e-12)\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    vN = (vals - float(np.min(vals))) / (float(np.max(vals)) - float(np.min(vals)) + 1e-12)\n    dN = (dens - float(np.min(dens))) / (float(np.max(dens)) - float(np.min(dens)) + 1e-12)\n\n    best_item, best_score = None, -np.inf\n    for (w, v, idx), a, b in zip(cand, vN, dN):\n        score = _hmean(float(a), float(b))\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "leftover_parity_match": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    pos = [int(w) for (w, _, _) in remaining_items if int(w) > 0]\n    if not pos:\n        return max(fit, key=lambda t: float(t[1]))\n    even_frac = sum(1 for w in pos if w % 2 == 0) / float(len(pos))\n    preferred_even = even_frac >= 0.5\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = (remaining_capacity - ww)\n        parity_match = 1.0 if ((leftover % 2 == 0) == preferred_even) else 0.0\n        dens = float(v) / float(ww)\n        score = dens + 0.12 * parity_match\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "small_weight_reserve": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n    small_thr = float(np.quantile(ws, 0.25))\n    small_count = sum(1 for (w, _, _) in remaining_items if 0 < int(w) <= small_thr)\n    small_frac = float(small_count) / float(max(1, len(remaining_items)))\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        dens = float(v) / float(ww)\n        # Penalize large weights more if many small items exist.\n        penalty = 0.25 * small_frac * (float(ww) / float(max(1, remaining_capacity)))\n        score = dens - penalty\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "max_value_then_min_weight": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    # Always take zero-weight positive value.\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    best = None\n    for w, v, idx in fit:\n        if best is None:\n            best = (w, v, idx)\n        else:\n            bw, bv, _ = best\n            if float(v) > float(bv) or (float(v) == float(bv) and int(w) < int(bw)):\n                best = (w, v, idx)\n    return best\n",
  "min_weight_then_max_density": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    min_w = min(int(w) for (w, _, _) in cand)\n    light = [(w, v, idx) for (w, v, idx) in cand if int(w) == min_w]\n    return max(light, key=lambda t: float(t[1]) / float(t[0]))\n",
  "density_with_leftover_quadratic_penalty": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    C = float(max(1, remaining_capacity))\n    gamma = 0.55\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        dens = float(v) / float(w)\n        leftover = (C - float(w)) / C\n        score = dens - gamma * (leftover ** 2)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "local_density_slope": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max([(w, v, idx) for (w, v, idx) in fit], key=lambda t: float(t[1]))\n\n    cand_sorted = sorted(cand, key=lambda t: t[0])\n    ws = np.array([w for (w, _, _) in cand_sorted], dtype=float)\n    vs = np.array([v for (_, v, _) in cand_sorted], dtype=float)\n\n    best_item, best_score = None, -np.inf\n    k = 3\n    for i, (w, v, idx) in enumerate(cand_sorted):\n        lo = max(0, i - k)\n        hi = min(len(cand_sorted), i + k + 1)\n        # local average density excluding self\n        wloc = np.delete(ws[lo:hi], i - lo)\n        vloc = np.delete(vs[lo:hi], i - lo)\n        if wloc.size == 0:\n            rel = 0.0\n        else:\n            local_d = float(np.mean(vloc / np.maximum(1e-12, wloc)))\n            rel = (float(v) / float(w)) - local_d\n        score = rel + 1e-3 * (float(v) / float(w))\n        if score > best_score:\n            best_score, best_item = score, (w, int(v) if float(v).is_integer() else v, idx)\n    # Return with original-ish types\n    w, v, idx = best_item\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n",
  "median_value_gate_then_fill": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    vals = np.array([float(v) for (_, v, _) in fit], dtype=float)\n    med = float(np.median(vals))\n    gated = [(w, v, idx) for (w, v, idx) in fit if float(v) >= med and w > 0]\n    if not gated:\n        return max(fit, key=lambda t: float(t[1]))\n    return max(gated, key=lambda t: (int(t[0]), float(t[1])))\n",
  "anti_greedy_smallest_positive_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    ds = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    thr = float(np.quantile(ds, 0.60))\n    good = [(w, v, idx) for (w, v, idx) in cand if (float(v) / float(w)) >= thr]\n    pool = good if good else cand\n    return min(pool, key=lambda t: (float(t[1]), -float(t[1]) / float(t[0])))\n",
  "density_with_value_rank_bonus": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    order = np.argsort(vals, kind=\"mergesort\")\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.arange(1, len(cand) + 1, dtype=float)  # 1..n\n    rankN = ranks / float(len(cand))\n\n    best_item, best_score = None, -np.inf\n    for (w, v, idx), r in zip(cand, rankN):\n        dens = float(v) / float(w)\n        score = dens + 0.25 * float(r)\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "kbest_density_diversified_by_weight_bins": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    ws_all = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws_all.size == 0:\n        return max(cand, key=lambda t: float(t[1]) / float(t[0]))\n    q1, q2 = float(np.quantile(ws_all, 1/3)), float(np.quantile(ws_all, 2/3))\n\n    def b(w):\n        if float(w) <= q1:\n            return 0\n        if float(w) <= q2:\n            return 1\n        return 2\n\n    bin_counts = [0, 0, 0]\n    for w, _, _ in remaining_items:\n        if w > 0:\n            bin_counts[b(w)] += 1\n\n    cand2 = sorted(cand, key=lambda t: float(t[1]) / float(t[0]), reverse=True)\n    k = max(1, int(round(np.sqrt(len(cand2)))))\n    top = cand2[:k]\n\n    # Choose from least-populated bin among top-k\n    top.sort(key=lambda t: (bin_counts[b(t[0])], -(float(t[1]) / float(t[0]))))\n    return top[0]\n",
  "mini_dp_value_lookahead_128": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _dp_best_value(items: List[Tuple[int,int,int]], cap: int) -> float:\n    dp = np.zeros(cap + 1, dtype=float)\n    for w, v, _ in items:\n        if 0 < int(w) <= cap and float(v) > 0:\n            ww = int(w)\n            vv = float(v)\n            dp[ww:] = np.maximum(dp[ww:], dp[:-ww] + vv)\n    return float(dp[cap])\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cap0 = int(min(128, max(0, remaining_capacity)))\n    # Use only items that could matter for this cap.\n    small_items = [(int(w), int(v), idx) for (w, v, idx) in remaining_items if 0 < int(w) <= cap0]\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = int(remaining_capacity - ww)\n        capL = int(min(cap0, max(0, leftover)))\n        ub = _dp_best_value([(w2, v2, i2) for (w2, v2, i2) in small_items if i2 != idx], capL)\n        score = float(v) + ub\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "density_rank_then_value_rank": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef _rank_desc(x: np.ndarray) -> np.ndarray:\n    order = np.argsort(-x, kind=\"mergesort\")\n    r = np.empty_like(order, dtype=float)\n    r[order] = np.arange(1, len(x) + 1, dtype=float)\n    return r\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n\n    dr = _rank_desc(dens)\n    vr = _rank_desc(vals)\n\n    # Choose smallest density rank; if tie, smallest value rank (i.e., higher value)\n    best_i = 0\n    for i in range(1, len(cand)):\n        if dr[i] < dr[best_i] or (dr[i] == dr[best_i] and vr[i] < vr[best_i]):\n            best_i = i\n    return cand[int(best_i)]\n",
  "density_with_weight_log_bonus": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    eta = 0.06\n    best_item, best_score = None, -np.inf\n    for w, v, idx in remaining_items:\n        if w <= remaining_capacity:\n            if w == 0 and v > 0:\n                return (w, v, idx)\n            if w > 0:\n                dens = float(v) / float(w)\n                score = dens + eta * float(np.log1p(float(w)))\n                if score > best_score:\n                    best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "value_density_cosine_to_ideal": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    vN = (vals - float(np.min(vals))) / (float(np.max(vals)) - float(np.min(vals)) + 1e-12)\n    dN = (dens - float(np.min(dens))) / (float(np.max(dens)) - float(np.min(dens)) + 1e-12)\n\n    best_item, best_score = None, -np.inf\n    for (w, v, idx), a, b in zip(cand, vN, dN):\n        a, b = float(a), float(b)\n        num = a + b\n        den = float(np.sqrt(a*a + b*b)) + 1e-12\n        score = num / den\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "bounded_knn_partner_value": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if v.is_integer() else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max([(w, v, idx) for (w, v, idx) in fit], key=lambda t: float(t[1]))\n\n    K = 8\n    best_item, best_score = None, -np.inf\n    for w, v, idx in cand:\n        leftover = remaining_capacity - w\n        partners = [(abs((remaining_capacity - w) - w2), v2) for (w2, v2, idx2) in cand if idx2 != idx and w2 <= leftover]\n        if partners:\n            partners.sort(key=lambda t: t[0])\n            best_p = max(pv for (_, pv) in partners[:K])\n        else:\n            best_p = 0.0\n        dens = float(v) / float(w)\n        score = float(v) + float(best_p) + 1e-3 * dens\n        if score > best_score:\n            best_score, best_item = score, (w, int(v) if v.is_integer() else v, idx)\n    w, v, idx = best_item\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n",
  "residue_mode_alignment_base10": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    residues = [int(w) % 10 for (w, _, _) in remaining_items if int(w) > 0]\n    if not residues:\n        return max(fit, key=lambda t: float(t[1]))\n    mode_res = Counter(residues).most_common(1)[0][0]\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        ww = int(w)\n        if ww <= 0:\n            continue\n        leftover = (remaining_capacity - ww) % 10\n        bonus = 1.0 if leftover == mode_res else 0.0\n        dens = float(v) / float(ww)\n        score = dens + 0.10 * bonus\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "min_variance_weight_pick": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    mean_w = float(np.mean([float(w) for (w, _, _) in remaining_items if w > 0]))\n    ds = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    thr = float(np.quantile(ds, 0.50))\n    pool = [(w, v, idx) for (w, v, idx), d in zip(cand, ds) if d >= thr]\n    pool = pool if pool else cand\n\n    # Closest to mean weight; tie-break by density\n    return min(pool, key=lambda t: (abs(float(t[0]) - mean_w), -(float(t[1]) / float(t[0]))))\n",
  "density_gap_to_next_heavier": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(int(w), float(v), idx) for (w, v, idx) in remaining_items if int(w) <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, int(v) if v.is_integer() else v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max([(w, v, idx) for (w, v, idx) in fit], key=lambda t: float(t[1]))\n\n    cand.sort(key=lambda t: t[0])\n    dens = [v / w for (w, v, _) in cand]\n\n    best_item, best_score = None, -np.inf\n    for i, (w, v, idx) in enumerate(cand):\n        d = float(dens[i])\n        # find next heavier\n        if i < len(cand) - 1:\n            d2 = float(dens[i + 1])\n            gap = d - d2\n        else:\n            gap = d\n        score = gap + 1e-3 * d\n        if score > best_score:\n            best_score, best_item = score, (w, int(v) if v.is_integer() else v, idx)\n    w, v, idx = best_item\n    return (int(w), int(v) if isinstance(v, float) and v.is_integer() else v, idx)\n",
  "value_density_product_normalized": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    vals = np.array([float(v) for (_, v, _) in cand], dtype=float)\n    dens = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n\n    vN = (vals - float(np.min(vals))) / (float(np.max(vals)) - float(np.min(vals)) + 1e-12)\n    dN = (dens - float(np.min(dens))) / (float(np.max(dens)) - float(np.min(dens)) + 1e-12)\n\n    score = vN * dN\n    j = int(np.argmax(score))\n    return cand[j]\n",
  "fill_first_then_density_threshold": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    ds = np.array([float(v) / float(w) for (w, v, _) in cand], dtype=float)\n    med = float(np.median(ds))\n    big = [(w, v, idx) for (w, v, idx) in cand if float(w) >= 0.90 * float(remaining_capacity) and (float(v) / float(w)) >= med]\n    if big:\n        return max(big, key=lambda t: float(t[1]))\n    return max(cand, key=lambda t: float(t[1]) / float(t[0]))\n",
  "density_with_rare_value_bonus": "import numpy as np\nfrom typing import List, Tuple, Optional\nfrom collections import Counter\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    freq = Counter([int(v) for (_, v, _) in remaining_items])\n\n    best_item, best_score = None, -np.inf\n    for w, v, idx in fit:\n        if w <= 0:\n            continue\n        d = float(v) / float(w)\n        rarity = 1.0 / float(np.sqrt(float(freq.get(int(v), 1))))\n        score = d + 0.10 * rarity\n        if score > best_score:\n            best_score, best_item = score, (w, v, idx)\n    return best_item\n",
  "density_then_closest_to_capacity_endgame": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int,int,int]]) -> Optional[Tuple[int,int,int]]:\n    fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n    if not fit:\n        return None\n    for w, v, idx in fit:\n        if w == 0 and v > 0:\n            return (w, v, idx)\n\n    ws = np.array([float(w) for (w, _, _) in remaining_items if w > 0], dtype=float)\n    if ws.size == 0:\n        return max(fit, key=lambda t: float(t[1]))\n    q30 = float(np.quantile(ws, 0.30))\n\n    cand = [(w, v, idx) for (w, v, idx) in fit if w > 0]\n    if not cand:\n        return max(fit, key=lambda t: float(t[1]))\n\n    if float(remaining_capacity) <= q30:\n        # Fill mode: choose maximum weight; tie-break by value\n        return max(cand, key=lambda t: (int(t[0]), float(t[1])))\n    # Normal mode: best density\n    return max(cand, key=lambda t: float(t[1]) / float(t[0]))\n"
}
