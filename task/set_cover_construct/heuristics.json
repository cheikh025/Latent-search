{
  "max_cover_greedy": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Pick the subset that covers the most currently-uncovered elements.\"\"\"\n    rem = set(remaining_elements)\n    best = None\n    best_gain = 0\n    for s in remaining_subsets:\n        gain = len(rem.intersection(s))\n        if gain > best_gain:\n            best_gain = gain\n            best = s\n    return best if best_gain > 0 else None\n",
  "max_cover_min_size_tiebreak": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Max uncovered coverage; break ties by smaller subset size.\"\"\"\n    rem = set(remaining_elements)\n    best = None\n    best_gain = -1\n    best_size = 10**18\n    for s in remaining_subsets:\n        gain = len(rem.intersection(s))\n        if gain > best_gain or (gain == best_gain and gain > 0 and len(s) < best_size):\n            best_gain = gain\n            best_size = len(s)\n            best = s\n    return best if best_gain > 0 else None\n",
  "cost_effectiveness": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Pick max (new_covered / subset_size).\"\"\"\n    rem = set(remaining_elements)\n    best = None\n    best_score = -1.0\n    for s in remaining_subsets:\n        new = len(rem.intersection(s))\n        if new <= 0:\n            continue\n        score = new / max(1, len(s))\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "rarity_weighted_gain": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Weight each newly covered element by 1/frequency across remaining subsets.\"\"\"\n    rem = set(remaining_elements)\n    freq: Dict[int,int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best = None\n    best_score = -1.0\n    for s in remaining_subsets:\n        sc = 0.0\n        for e in set(s):\n            if e in rem:\n                sc += 1.0 / max(1, freq.get(e, 1))\n        if sc > best_score and sc > 0:\n            best_score = sc\n            best = s\n    return best\n",
  "rarity_squared_gain": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"More aggressive rare-element preference using 1/freq^2 weights.\"\"\"\n    rem = set(remaining_elements)\n    freq: Dict[int,int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best = None\n    best_score = -1.0\n    for s in remaining_subsets:\n        sc = 0.0\n        for e in set(s):\n            if e in rem:\n                f = max(1, freq.get(e, 1))\n                sc += 1.0 / (f * f)\n        if sc > best_score and sc > 0:\n            best_score = sc\n            best = s\n    return best\n",
  "overlap_penalized_gain": "import numpy as np\nfrom typing import List, Optional, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"New coverage minus a penalty for overlapping already-selected elements.\"\"\"\n    rem = set(remaining_elements)\n    covered_selected: Set[int] = set()\n    for s in selected_subsets:\n        covered_selected.update(s)\n\n    lam = 0.25  # overlap penalty strength\n    best = None\n    best_score = -1e18\n    for s in remaining_subsets:\n        sset = set(s)\n        new = len(rem.intersection(sset))\n        if new <= 0:\n            continue\n        overlap = len(sset.intersection(covered_selected))\n        score = new - lam * overlap\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "diversity_bonus_jaccard": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets that both cover new elements and are dissimilar to selected (high Jaccard distance).\"\"\"\n    rem = set(remaining_elements)\n    selected_sets = [set(s) for s in selected_subsets] if selected_subsets else []\n\n    best = None\n    best_score = -1e18\n    for s in remaining_subsets:\n        sset = set(s)\n        new = len(rem.intersection(sset))\n        if new <= 0:\n            continue\n        if not selected_sets:\n            diversity = 1.0\n        else:\n            # average Jaccard distance to selected sets\n            dsum = 0.0\n            for t in selected_sets:\n                inter = len(sset.intersection(t))\n                uni = len(sset.union(t))\n                jac = inter / max(1, uni)\n                dsum += (1.0 - jac)\n            diversity = dsum / len(selected_sets)\n        score = new * (1.0 + 0.5 * diversity)\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "two_step_lookahead": "import numpy as np\nfrom typing import List, Optional, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Score = immediate gain + gamma * best next-step gain after taking this set.\"\"\"\n    rem0 = set(remaining_elements)\n    gamma = 0.6\n    best = None\n    best_score = -1e18\n\n    # Precompute sets\n    sets = [set(s) for s in remaining_subsets]\n\n    for i, sset in enumerate(sets):\n        gain1 = len(rem0.intersection(sset))\n        if gain1 <= 0:\n            continue\n        rem1 = rem0 - sset\n        best_gain2 = 0\n        for j, tset in enumerate(sets):\n            if j == i:\n                continue\n            g2 = len(rem1.intersection(tset))\n            if g2 > best_gain2:\n                best_gain2 = g2\n        score = gain1 + gamma * best_gain2\n        if score > best_score:\n            best_score = score\n            best = remaining_subsets[i]\n    return best\n",
  "unique_element_bonus": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets containing elements that appear in only one remaining subset.\"\"\"\n    rem = set(remaining_elements)\n    freq: Dict[int,int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best = None\n    best_score = -1e18\n    for s in remaining_subsets:\n        sset = set(s)\n        new = rem.intersection(sset)\n        if not new:\n            continue\n        unique = sum(1 for e in new if freq.get(e, 0) == 1)\n        score = len(new) + 2.0 * unique\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "rarest_element_pivot": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Pick the rarest uncovered element, then choose best set containing it (max new cover, then min size).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    freq: Dict[int,int] = {e:0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in freq:\n                freq[e] += 1\n\n    # element with minimum positive frequency\n    pivot = None\n    pivot_f = 10**18\n    for e, f in freq.items():\n        if 0 < f < pivot_f:\n            pivot_f = f\n            pivot = e\n    if pivot is None:\n        return None\n\n    best = None\n    best_gain = -1\n    best_size = 10**18\n    for s in remaining_subsets:\n        if pivot not in s:\n            continue\n        gain = len(rem.intersection(s))\n        if gain > best_gain or (gain == best_gain and len(s) < best_size):\n            best_gain = gain\n            best_size = len(s)\n            best = s\n    return best if best_gain > 0 else None\n",
  "maximin_rarity": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Choose set that best improves the worst-case rarity among elements it newly covers.\"\"\"\n    rem = set(remaining_elements)\n    freq: Dict[int,int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best = None\n    best_tuple = None  # (min_rarity, total_gain, -size)\n    for s in remaining_subsets:\n        new = [e for e in set(s) if e in rem]\n        if not new:\n            continue\n        rarities = [1.0 / max(1, freq.get(e, 1)) for e in new]\n        t = (min(rarities), len(new), -len(s))\n        if best_tuple is None or t > best_tuple:\n            best_tuple = t\n            best = s\n    return best\n",
  "random_among_topk_gain": "import numpy as np\nimport random\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Randomly pick among the top-k sets by uncovered gain (adds diversification).\"\"\"\n    rem = set(remaining_elements)\n    scored = []\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > 0:\n            scored.append((g, s))\n    if not scored:\n        return None\n    scored.sort(key=lambda x: x[0], reverse=True)\n    k = max(1, int(np.ceil(0.10 * len(scored))))\n    top = [s for _, s in scored[:k]]\n    return random.choice(top)\n",
  "softmax_sampling_gain": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Sample a set with probability proportional to exp(gain / temp).\"\"\"\n    rem = set(remaining_elements)\n    gains = []\n    cand = []\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > 0:\n            gains.append(g)\n            cand.append(s)\n    if not cand:\n        return None\n\n    temp = max(1e-6, np.median(gains))  # scale temperature to instance\n    w = np.exp(np.array(gains, dtype=float) / temp)\n    w = w / w.sum()\n    idx = int(np.random.choice(len(cand), p=w))\n    return cand[idx]\n",
  "annealed_softmax_gain": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Softmax sampling with temperature decreasing as coverage progresses.\"\"\"\n    rem = set(remaining_elements)\n    gains = []\n    cand = []\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > 0:\n            gains.append(g)\n            cand.append(s)\n    if not cand:\n        return None\n\n    # estimate progress by fraction of already-covered universe proxy\n    n_rem = max(1, len(rem))\n    n_total = n_rem + len({e for ss in selected_subsets for e in ss})\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    base = max(1e-6, np.mean(gains))\n    temp = base * (1.5 - 1.3 * progress)  # cool down over time\n    w = np.exp(np.array(gains, dtype=float) / max(1e-6, temp))\n    w = w / w.sum()\n    idx = int(np.random.choice(len(cand), p=w))\n    return cand[idx]\n",
  "progressive_size_penalty": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Early: cover aggressively; late: penalize large sets to reduce redundancy.\"\"\"\n    rem = set(remaining_elements)\n    n_rem = max(1, len(rem))\n    n_total = n_rem + len({e for ss in selected_subsets for e in ss})\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    best = None\n    best_score = -1e18\n    for s in remaining_subsets:\n        new = len(rem.intersection(s))\n        if new <= 0:\n            continue\n        alpha = 0.2 + 1.8 * progress  # size penalty grows late\n        score = new / (len(s) ** alpha if len(s) > 0 else 1.0)\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "mean_size_balancing": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets with strong gain but size close to mean remaining-set size.\"\"\"\n    rem = set(remaining_elements)\n    if not remaining_subsets:\n        return None\n    mean_size = float(np.mean([len(s) for s in remaining_subsets]))\n\n    best = None\n    best_score = -1e18\n    for s in remaining_subsets:\n        new = len(rem.intersection(s))\n        if new <= 0:\n            continue\n        size = len(s)\n        size_pen = abs(size - mean_size) / max(1.0, mean_size)\n        score = new - 0.5 * size_pen\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "harmonic_rarity_gain": "import numpy as np\nfrom typing import List, Optional, Dict\nimport math\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Weight new elements by 1/(1+ln(freq)) to temper extreme rarity bias.\"\"\"\n    rem = set(remaining_elements)\n    freq: Dict[int,int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best = None\n    best_score = -1.0\n    for s in remaining_subsets:\n        sc = 0.0\n        for e in set(s):\n            if e in rem:\n                f = max(1, freq.get(e, 1))\n                sc += 1.0 / (1.0 + math.log(f))\n        if sc > best_score and sc > 0:\n            best_score = sc\n            best = s\n    return best\n",
  "avoid_unique_leftovers": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prioritize covering elements that currently have only one remaining covering set.\"\"\"\n    rem = set(remaining_elements)\n    freq: Dict[int,int] = {e:0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in freq:\n                freq[e] += 1\n\n    best = None\n    best_tuple = None  # (unique_covered, total_covered, -size)\n    for s in remaining_subsets:\n        new = [e for e in set(s) if e in rem]\n        if not new:\n            continue\n        unique_cov = sum(1 for e in new if freq.get(e, 0) == 1)\n        t = (unique_cov, len(new), -len(s))\n        if best_tuple is None or t > best_tuple:\n            best_tuple = t\n            best = s\n    return best\n",
  "redundancy_elimination_probe": "import numpy as np\nfrom typing import List, Optional, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets that could make a currently-selected set redundant while still covering new elements.\"\"\"\n    rem = set(remaining_elements)\n    sel_sets = [set(s) for s in selected_subsets]\n\n    best = None\n    best_score = -1e18\n    for s in remaining_subsets:\n        sset = set(s)\n        new = len(rem.intersection(sset))\n        if new <= 0:\n            continue\n\n        # redundancy score: how many selected sets are (almost) contained in this candidate\n        red = 0\n        for t in sel_sets:\n            if len(t) > 0 and len(t - sset) == 0:\n                red += 1\n        score = new + 1.5 * red\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "low_overlap_with_remaining": "import numpy as np\nfrom typing import List, Optional, Dict, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"High gain, but penalize overlap with other remaining sets (to keep options diverse).\"\"\"\n    rem = set(remaining_elements)\n    sets = [set(s) for s in remaining_subsets]\n\n    # element -> how many remaining sets contain it (restricted to remaining elements)\n    freq: Dict[int,int] = {}\n    for sset in sets:\n        for e in sset:\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best = None\n    best_score = -1e18\n    for s, sset in zip(remaining_subsets, sets):\n        new_elems = [e for e in sset if e in rem]\n        if not new_elems:\n            continue\n        gain = len(new_elems)\n        # elements with high freq mean more overlap potential\n        overlap_pen = sum((freq[e] - 1) for e in new_elems)\n        score = gain - 0.15 * overlap_pen\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "conflict_then_rarity_switch": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Early: cover high-frequency elements (reduce branching); late: cover rare ones.\"\"\"\n    rem = set(remaining_elements)\n    freq: Dict[int,int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    n_rem = max(1, len(rem))\n    n_total = n_rem + len({e for ss in selected_subsets for e in ss})\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    best = None\n    best_score = -1e18\n    for s in remaining_subsets:\n        new = [e for e in set(s) if e in rem]\n        if not new:\n            continue\n        if progress < 0.5:\n            sc = sum(freq.get(e, 1) for e in new)  # high-degree focus\n        else:\n            sc = sum(1.0 / max(1, freq.get(e, 1)) for e in new)  # rarity focus\n        if sc > best_score:\n            best_score = sc\n            best = s\n    return best\n",
  "frequency_spread_bonus": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets covering elements across a wide range of frequencies (hedges uncertainty).\"\"\"\n    rem = set(remaining_elements)\n    freq: Dict[int,int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best = None\n    best_score = -1e18\n    for s in remaining_subsets:\n        new = [e for e in set(s) if e in rem]\n        if not new:\n            continue\n        fvals = np.array([freq.get(e, 1) for e in new], dtype=float)\n        spread = float(fvals.std())  # 0 if all similar\n        score = len(new) + 0.4 * spread\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "rare_pair_bonus": "import numpy as np\nfrom typing import List, Optional, Dict\nimport itertools\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Bonus for covering pairs of uncovered elements that are individually rare (proxy for hard structure).\"\"\"\n    rem = set(remaining_elements)\n    freq: Dict[int,int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best = None\n    best_score = -1e18\n    for s in remaining_subsets:\n        elems = [e for e in set(s) if e in rem]\n        if not elems:\n            continue\n        base = len(elems)\n        # compute a cheap pair bonus (cap work)\n        elems_sorted = sorted(elems, key=lambda e: freq.get(e, 1))[:12]  # focus on rarest few\n        bonus = 0.0\n        for a, b in itertools.combinations(elems_sorted, 2):\n            bonus += 1.0 / (max(1, freq.get(a, 1)) * max(1, freq.get(b, 1)))\n        score = base + 3.0 * bonus\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "maximize_remaining_support": "import numpy as np\nfrom typing import List, Optional, Dict, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Choose set that, after removing its covered elements, leaves uncovered elements with higher total support.\"\"\"\n    rem0 = set(remaining_elements)\n    sets = [set(s) for s in remaining_subsets]\n\n    # current support counts for each remaining element\n    support0: Dict[int,int] = {e:0 for e in rem0}\n    for sset in sets:\n        for e in sset:\n            if e in support0:\n                support0[e] += 1\n\n    best = None\n    best_score = -1e18\n    for i, sset in enumerate(sets):\n        gain = len(rem0.intersection(sset))\n        if gain <= 0:\n            continue\n        rem1 = rem0 - sset\n        if not rem1:\n            return remaining_subsets[i]\n        # proxy: minimize number of elements left with support==1 (fragile)\n        fragile = sum(1 for e in rem1 if support0.get(e, 0) == 1)\n        score = gain - 0.8 * fragile\n        if score > best_score:\n            best_score = score\n            best = remaining_subsets[i]\n    return best\n",
  "adaptive_density_by_overlap": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Adapt size-penalty based on how overlapping the remaining family is.\"\"\"\n    rem = set(remaining_elements)\n    if not remaining_subsets:\n        return None\n\n    # estimate overlap: average Jaccard among a small sample of remaining sets\n    sets = [set(s) for s in remaining_subsets]\n    m = len(sets)\n    idx = np.random.choice(m, size=min(m, 25), replace=False)\n    sample = [sets[i] for i in idx]\n    jac_vals = []\n    for a in range(len(sample)):\n        for b in range(a+1, len(sample)):\n            inter = len(sample[a].intersection(sample[b]))\n            uni = len(sample[a].union(sample[b]))\n            jac_vals.append(inter / max(1, uni))\n    overlap = float(np.mean(jac_vals)) if jac_vals else 0.0\n\n    # higher overlap => stronger size penalty (prefer compact discriminative sets)\n    alpha = 0.6 + 1.6 * overlap\n\n    best = None\n    best_score = -1e18\n    for s in remaining_subsets:\n        new = len(rem.intersection(s))\n        if new <= 0:\n            continue\n        score = new / (len(s) ** alpha if len(s) > 0 else 1.0)\n        if score > best_score:\n            best_score = score\n            best = s\n    return best\n",
  "highest_degree_weighted_gain": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Weight newly covered elements by their current frequency (covers 'hard-to-separate' common elements).\"\"\"\n    rem = set(remaining_elements)\n    freq: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best, best_score = None, -1.0\n    for s in remaining_subsets:\n        new = [e for e in set(s) if e in rem]\n        if not new:\n            continue\n        score = float(sum(freq.get(e, 0) for e in new))\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "tfidf_blend_gain": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Blend common+rare via TF (gain) + IDF-like weights on newly covered elements.\"\"\"\n    rem = set(remaining_elements)\n    m = max(1, len(remaining_subsets))\n\n    freq: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        new = [e for e in set(s) if e in rem]\n        if not new:\n            continue\n        tf = len(new)\n        idf = 0.0\n        for e in new:\n            f = max(1, freq.get(e, 1))\n            idf += np.log((m + 1.0) / f)\n        score = tf + 0.35 * idf\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "minimize_fragile_support_after_pick": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets that, after removal, leave few uncovered elements with support==1 (fragile).\"\"\"\n    rem0 = set(remaining_elements)\n    if not rem0:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem0}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        sset = set(s)\n        gain = len(rem0.intersection(sset))\n        if gain <= 0:\n            continue\n        rem1 = rem0 - sset\n        fragile = sum(1 for e in rem1 if support.get(e, 0) == 1)\n        score = gain - 0.9 * fragile\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "minimax_support_leftover": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Maximize gain, but prefer moves that minimize the maximum support among leftover elements (balances future choices).\"\"\"\n    rem0 = set(remaining_elements)\n    if not rem0:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem0}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    best, best_tuple = None, None  # (gain, -max_support_left, -size)\n    for s in remaining_subsets:\n        sset = set(s)\n        gain = len(rem0.intersection(sset))\n        if gain <= 0:\n            continue\n        rem1 = rem0 - sset\n        max_sup = max((support.get(e, 0) for e in rem1), default=0)\n        t = (gain, -max_sup, -len(s))\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n    return best\n",
  "gain_minus_log_size": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Score = gain - lambda*log(1+|S|) to gently discourage very large sets.\"\"\"\n    rem = set(remaining_elements)\n    lam = 0.8\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        gain = len(rem.intersection(s))\n        if gain <= 0:\n            continue\n        score = gain - lam * np.log1p(len(s))\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "sqrt_diminishing_returns": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Use diminishing returns: score = sqrt(gain) / (1+|S|^0.5).\"\"\"\n    rem = set(remaining_elements)\n    best, best_score = None, -1.0\n    for s in remaining_subsets:\n        gain = len(rem.intersection(s))\n        if gain <= 0:\n            continue\n        denom = 1.0 + (len(s) ** 0.5)\n        score = (gain ** 0.5) / denom\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "log_diminishing_returns": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Diminishing returns with log: score = log(1+gain) / (1+log(1+|S|)).\"\"\"\n    rem = set(remaining_elements)\n    best, best_score = None, -1.0\n    for s in remaining_subsets:\n        gain = len(rem.intersection(s))\n        if gain <= 0:\n            continue\n        score = np.log1p(gain) / (1.0 + np.log1p(len(s)))\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "future_topq_mean_gain": "import numpy as np\nfrom typing import List, Optional, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Score = immediate gain + gamma * mean(top-q future gains) after taking this set.\"\"\"\n    rem0 = set(remaining_elements)\n    if not rem0:\n        return None\n\n    gamma = 0.5\n    q = 0.2\n\n    sets = [set(s) for s in remaining_subsets]\n    best_i, best_score = None, -1e18\n\n    for i, sset in enumerate(sets):\n        gain1 = len(rem0.intersection(sset))\n        if gain1 <= 0:\n            continue\n        rem1 = rem0 - sset\n        if not rem1:\n            return remaining_subsets[i]\n\n        gains2 = []\n        for j, tset in enumerate(sets):\n            if j == i:\n                continue\n            g2 = len(rem1.intersection(tset))\n            if g2 > 0:\n                gains2.append(g2)\n        if not gains2:\n            score = gain1\n        else:\n            gains2.sort(reverse=True)\n            k = max(1, int(np.ceil(q * len(gains2))))\n            score = gain1 + gamma * float(np.mean(gains2[:k]))\n\n        if score > best_score:\n            best_score, best_i = score, i\n\n    return remaining_subsets[best_i] if best_i is not None else None\n",
  "future_best3_lookahead": "import numpy as np\nfrom typing import List, Optional, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Score = gain1 + a*best2 + b*best3 (cheap 3-step proxy without branching).\"\"\"\n    rem0 = set(remaining_elements)\n    if not rem0:\n        return None\n\n    a, b = 0.55, 0.25\n    sets = [set(s) for s in remaining_subsets]\n\n    best_i, best_score = None, -1e18\n    for i, sset in enumerate(sets):\n        gain1 = len(rem0.intersection(sset))\n        if gain1 <= 0:\n            continue\n        rem1 = rem0 - sset\n        if not rem1:\n            return remaining_subsets[i]\n\n        g2_list = []\n        for j, tset in enumerate(sets):\n            if j == i:\n                continue\n            g2 = len(rem1.intersection(tset))\n            if g2 > 0:\n                g2_list.append(g2)\n        g2_list.sort(reverse=True)\n        best2 = g2_list[0] if len(g2_list) > 0 else 0\n        best3 = g2_list[1] if len(g2_list) > 1 else 0\n\n        score = gain1 + a * best2 + b * best3\n        if score > best_score:\n            best_score, best_i = score, i\n\n    return remaining_subsets[best_i] if best_i is not None else None\n",
  "maximize_support_entropy_leftover": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef _entropy(counts: np.ndarray) -> float:\n    s = float(counts.sum())\n    if s <= 0:\n        return 0.0\n    p = counts / s\n    p = p[p > 0]\n    return float(-(p * np.log(p)).sum())\n\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer moves that keep support distribution diverse (higher entropy) among leftovers.\"\"\"\n    rem0 = set(remaining_elements)\n    if not rem0:\n        return None\n\n    support0: Dict[int, int] = {e: 0 for e in rem0}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support0:\n                support0[e] += 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        sset = set(s)\n        gain = len(rem0.intersection(sset))\n        if gain <= 0:\n            continue\n        rem1 = rem0 - sset\n        if not rem1:\n            return s\n        counts = np.array([support0.get(e, 0) for e in rem1], dtype=float)\n        ent = _entropy(counts)\n        score = gain + 0.35 * ent\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "lexicographic_cover_rarest_first": "import numpy as np\nfrom typing import List, Optional, Dict, Tuple\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Lexicographically maximize coverage of rarest elements first (vector dominance heuristic).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    freq: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in freq:\n                freq[e] += 1\n\n    # bucket elements by frequency (small freq = higher priority)\n    uniq_freqs = sorted({f for f in freq.values() if f > 0})\n    if not uniq_freqs:\n        return None\n\n    best, best_vec = None, None\n    for s in remaining_subsets:\n        sset = set(s)\n        cov = [e for e in sset if e in rem]\n        if not cov:\n            continue\n        # build vector: counts covered at each frequency level\n        vec = []\n        for f in uniq_freqs:\n            vec.append(sum(1 for e in cov if freq.get(e, 0) == f))\n        vec.append(-len(s))\n        t = tuple(vec)\n        if best_vec is None or t > best_vec:\n            best_vec, best = t, s\n    return best\n",
  "rare_to_common_ratio": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Maximize (rare_covered / (1+common_covered)) with a gain floor.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    freq: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    # define rare/common by median frequency\n    fvals = np.array(list(freq.values()), dtype=float)\n    med = float(np.median(fvals)) if fvals.size else 1.0\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        cov = [e for e in set(s) if e in rem]\n        if not cov:\n            continue\n        rare = sum(1 for e in cov if freq.get(e, 0) <= med)\n        common = len(cov) - rare\n        if len(cov) < 2:\n            continue\n        score = rare / (1.0 + common)\n        # lightly prefer more absolute coverage too\n        score = score + 0.05 * len(cov)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "intersection_graph_centrality": "import numpy as np\nfrom typing import List, Optional, Dict, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets that touch many other sets via remaining elements (central in the intersection graph).\"\"\"\n    rem = set(remaining_elements)\n    sets = [set(s) for s in remaining_subsets]\n\n    # element -> how many sets contain it (restricted to remaining elements)\n    ef: Dict[int, int] = {}\n    for sset in sets:\n        for e in sset:\n            if e in rem:\n                ef[e] = ef.get(e, 0) + 1\n\n    best, best_score = None, -1e18\n    for s, sset in zip(remaining_subsets, sets):\n        new = [e for e in sset if e in rem]\n        if not new:\n            continue\n        gain = len(new)\n        # centrality proxy: sum of (ef[e]-1) over newly covered elements\n        touch = float(sum(max(0, ef[e] - 1) for e in new))\n        score = gain + 0.15 * touch\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "intersection_graph_sparsity": "import numpy as np\nfrom typing import List, Optional, Dict, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets that cover well but intersect few others via remaining elements (keeps future choices distinct).\"\"\"\n    rem = set(remaining_elements)\n    sets = [set(s) for s in remaining_subsets]\n\n    ef: Dict[int, int] = {}\n    for sset in sets:\n        for e in sset:\n            if e in rem:\n                ef[e] = ef.get(e, 0) + 1\n\n    best, best_score = None, -1e18\n    for s, sset in zip(remaining_subsets, sets):\n        new = [e for e in sset if e in rem]\n        if not new:\n            continue\n        gain = len(new)\n        intersect_pressure = float(sum(max(0, ef[e] - 1) for e in new))\n        score = gain - 0.20 * intersect_pressure\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "two_rarest_pivot_pair": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Pick two rarest uncovered elements; if possible choose a set covering both; else fallback to rarest pivot.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    freq: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in freq:\n                freq[e] += 1\n\n    candidates = [(f, e) for e, f in freq.items() if f > 0]\n    if not candidates:\n        return None\n    candidates.sort()\n\n    e1 = candidates[0][1]\n    e2 = candidates[1][1] if len(candidates) > 1 else None\n\n    best = None\n    best_gain = -1\n\n    if e2 is not None:\n        for s in remaining_subsets:\n            if e1 in s and e2 in s:\n                g = len(rem.intersection(s))\n                if g > best_gain or (g == best_gain and best is not None and len(s) < len(best)):\n                    best_gain = g\n                    best = s\n        if best is not None:\n            return best\n\n    # fallback: pick best set that contains e1\n    for s in remaining_subsets:\n        if e1 in s:\n            g = len(rem.intersection(s))\n            if g > best_gain or (g == best_gain and best is not None and len(s) < len(best)):\n                best_gain = g\n                best = s\n    return best if best_gain > 0 else None\n",
  "pairwise_synergy_low_cooccurrence": "import numpy as np\nfrom typing import List, Optional, Dict, Tuple\nimport itertools\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Bonus for covering pairs of uncovered elements that rarely co-occur across remaining subsets.\"\"\"\n    rem = set(remaining_elements)\n    sets = [set(s) for s in remaining_subsets]\n\n    # pair frequency computed on a small element sample for speed\n    elem_freq: Dict[int, int] = {}\n    for sset in sets:\n        for e in sset:\n            if e in rem:\n                elem_freq[e] = elem_freq.get(e, 0) + 1\n\n    # focus on up to K rare elements to define pair stats\n    K = 40\n    rare_elems = sorted(elem_freq.keys(), key=lambda e: elem_freq[e])[:K]\n    rare_set = set(rare_elems)\n\n    pair_freq: Dict[Tuple[int, int], int] = {}\n    for sset in sets:\n        elems = sorted([e for e in sset if e in rare_set])\n        for a, b in itertools.combinations(elems, 2):\n            pair_freq[(a, b)] = pair_freq.get((a, b), 0) + 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        elems = sorted([e for e in set(s) if e in rem])\n        if not elems:\n            continue\n        base = len(elems)\n        # synergy bonus: sum 1/(1+pair_freq)\n        bonus = 0.0\n        elems2 = [e for e in elems if e in rare_set][:18]\n        for a, b in itertools.combinations(sorted(elems2), 2):\n            bonus += 1.0 / (1.0 + pair_freq.get((a, b), 0))\n        score = base + 0.9 * bonus\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "top_gain_smallest_size_percentile": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Among the top p by gain, pick the smallest set (robust tie-breaking).\"\"\"\n    rem = set(remaining_elements)\n    scored = []\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > 0:\n            scored.append((g, len(s), s))\n    if not scored:\n        return None\n\n    scored.sort(key=lambda x: x[0], reverse=True)\n    p = 0.15\n    k = max(1, int(np.ceil(p * len(scored))))\n    top = scored[:k]\n    top.sort(key=lambda x: (x[1], -x[0]))\n    return top[0][2]\n",
  "smallest_percentile_then_max_gain": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Among the smallest p by size, pick the one with maximum uncovered gain.\"\"\"\n    rem = set(remaining_elements)\n    cand = []\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > 0:\n            cand.append((len(s), g, s))\n    if not cand:\n        return None\n\n    cand.sort(key=lambda x: x[0])\n    p = 0.20\n    k = max(1, int(np.ceil(p * len(cand))))\n    small = cand[:k]\n    small.sort(key=lambda x: (-x[1], x[0]))\n    return small[0][2]\n",
  "adaptive_quantile_explore_exploit": "import numpy as np\nimport random\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Explore early by sampling from a wider quantile of gains; exploit late by narrowing to top gains.\"\"\"\n    rem = set(remaining_elements)\n    scored = []\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > 0:\n            scored.append((g, s))\n    if not scored:\n        return None\n\n    n_rem = max(1, len(rem))\n    n_total = n_rem + len({e for ss in selected_subsets for e in ss})\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    scored.sort(key=lambda x: x[0], reverse=True)\n    # quantile shrinks from 40% early to 10% late\n    q = 0.40 - 0.30 * progress\n    k = max(1, int(np.ceil(q * len(scored))))\n    return random.choice([s for _, s in scored[:k]])\n",
  "three_phase_core_middle_fringe": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"3-phase strategy: early target high-frequency core, mid maximize gain, late target rare fringe.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    freq: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    n_rem = max(1, len(rem))\n    n_total = n_rem + len({e for ss in selected_subsets for e in ss})\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    fvals = np.array(list(freq.values()), dtype=float)\n    q1 = float(np.quantile(fvals, 0.33)) if fvals.size else 1.0\n    q2 = float(np.quantile(fvals, 0.66)) if fvals.size else 1.0\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        new = [e for e in set(s) if e in rem]\n        if not new:\n            continue\n        if progress < 0.33:\n            # core: emphasize high frequency\n            sc = sum(1 for e in new if freq.get(e, 0) >= q2)\n            score = 2.0 * sc + 0.1 * len(new)\n        elif progress < 0.66:\n            # middle: plain gain\n            score = float(len(new))\n        else:\n            # fringe: emphasize rare\n            sc = sum(1 for e in new if freq.get(e, 0) <= q1)\n            score = 2.0 * sc + 0.1 * len(new)\n\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "criticality_by_min_set_size": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Weight elements by 1/min_size_of_set_that_can_cover_it (harder elements get higher weight).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    min_sz: Dict[int, int] = {e: 10**18 for e in rem}\n    for s in remaining_subsets:\n        ss = set(s)\n        sz = len(ss)\n        for e in ss:\n            if e in min_sz and sz < min_sz[e]:\n                min_sz[e] = sz\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        score = 0.0\n        for e in new:\n            ms = min_sz.get(e, 10**18)\n            if ms < 10**18:\n                score += 1.0 / max(1, ms)\n        # small nudge toward more coverage\n        score += 0.05 * len(new)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "reserve_index_weighting": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Weight new elements by (1/support) * (1/avg_set_size_covering_element): prefer scarce + 'tight' elements.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    size_sum: Dict[int, int] = {e: 0 for e in rem}\n\n    for s in remaining_subsets:\n        ss = set(s)\n        sz = len(ss)\n        for e in ss:\n            if e in support:\n                support[e] += 1\n                size_sum[e] += sz\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        score = 0.0\n        for e in new:\n            sup = max(1, support.get(e, 1))\n            avg_sz = size_sum.get(e, 0) / sup\n            score += (1.0 / sup) * (1.0 / max(1.0, avg_sz))\n        score += 0.02 * len(new)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "maximize_gain_to_remaining_ratio": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Score = gain / |remaining_elements| (helps normalize across instances / phases).\"\"\"\n    rem = set(remaining_elements)\n    denom = float(max(1, len(rem)))\n\n    best, best_score = None, -1.0\n    for s in remaining_subsets:\n        gain = len(rem.intersection(s))\n        if gain <= 0:\n            continue\n        score = gain / denom\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "expected_steps_proxy_minimize": "import numpy as np\nfrom typing import List, Optional, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Minimize a proxy of steps left: steps ~= 1 + ceil(|rem1| / best_future_gain).\"\"\"\n    rem0 = set(remaining_elements)\n    if not rem0:\n        return None\n\n    sets = [set(s) for s in remaining_subsets]\n    best_i, best_score = None, -1e18\n\n    for i, sset in enumerate(sets):\n        gain1 = len(rem0.intersection(sset))\n        if gain1 <= 0:\n            continue\n        rem1 = rem0 - sset\n        if not rem1:\n            return remaining_subsets[i]\n\n        best_future = 0\n        for j, tset in enumerate(sets):\n            if j == i:\n                continue\n            g2 = len(rem1.intersection(tset))\n            if g2 > best_future:\n                best_future = g2\n        steps_proxy = 1.0 + np.ceil(len(rem1) / max(1, best_future))\n        # maximize negative steps_proxy, with gain as tie-break\n        score = -steps_proxy + 0.05 * gain1\n        if score > best_score:\n            best_score, best_i = score, i\n\n    return remaining_subsets[best_i] if best_i is not None else None\n",
  "gain_squared_soft_sampling": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Stochastic choice: sample proportional to gain^2 (more greedy than softmax, still diverse).\"\"\"\n    rem = set(remaining_elements)\n    gains = []\n    cand = []\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > 0:\n            cand.append(s)\n            gains.append(float(g * g))\n    if not cand:\n        return None\n    w = np.array(gains, dtype=float)\n    w = w / w.sum()\n    idx = int(np.random.choice(len(cand), p=w))\n    return cand[idx]\n",
  "selected_overlap_dynamic_penalty": "import numpy as np\nfrom typing import List, Optional, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Penalize overlap with selected sets; penalty increases as progress increases (late-stage cleanup).\"\"\"\n    rem = set(remaining_elements)\n    covered_selected: Set[int] = set()\n    for s in selected_subsets:\n        covered_selected.update(s)\n\n    n_rem = max(1, len(rem))\n    n_total = n_rem + len(covered_selected)\n    progress = 1.0 - (n_rem / max(1, n_total))\n    lam = 0.1 + 0.9 * progress\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n        overlap = len(ss.intersection(covered_selected))\n        score = gain - lam * overlap\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "boundary_elements_first": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prioritize covering 'boundary' elements with low support (<=2), then maximize total gain.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    boundary = {e for e, c in support.items() if 0 < c <= 2}\n\n    best, best_tuple = None, None  # (boundary_covered, total_gain, -size)\n    for s in remaining_subsets:\n        ss = set(s)\n        new = rem.intersection(ss)\n        if not new:\n            continue\n        b = len(boundary.intersection(ss))\n        t = (b, len(new), -len(s))\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n    return best\n",
  "boundary_ratio": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Maximize (boundary_covered / (1+size)) with a minimum total gain safeguard.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    boundary = {e for e, c in support.items() if 0 < c <= 2}\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n        b = len(boundary.intersection(ss))\n        score = b / (1.0 + len(ss)) + 0.03 * gain\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "progress_blend_gain_rarity_overlap": "import numpy as np\nfrom typing import List, Optional, Dict, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Blend gain + rarity bonus - overlap penalty, with weights shifting over progress.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    covered_selected: Set[int] = set()\n    for s in selected_subsets:\n        covered_selected.update(s)\n\n    n_rem = max(1, len(rem))\n    n_total = n_rem + len(covered_selected)\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    freq: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    w_gain = 1.2 - 0.6 * progress\n    w_rare = 0.3 + 1.1 * progress\n    w_ov  = 0.1 + 0.9 * progress\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        gain = len(new)\n        rare = sum(1.0 / max(1, freq.get(e, 1)) for e in new)\n        ov = len(ss.intersection(covered_selected))\n        score = w_gain * gain + w_rare * rare - w_ov * ov\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "exp_rarity_weighted_gain": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Weight uncovered elements by exp(-freq/scale) (smooth rarity emphasis).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    freq: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    if not freq:\n        return None\n\n    fvals = np.array(list(freq.values()), dtype=float)\n    scale = max(1.0, float(np.median(fvals)))\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        sc = 0.0\n        for e in ss:\n            if e in rem:\n                sc += float(np.exp(-freq.get(e, 1) / scale))\n        if sc > best_score and sc > 0:\n            best_score, best = sc, s\n    return best\n",
  "element_cover_count_penalty": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets that avoid repeatedly covering elements already covered many times by selected sets.\"\"\"\n    rem = set(remaining_elements)\n\n    covered_times: Dict[int, int] = {}\n    for s in selected_subsets:\n        for e in set(s):\n            covered_times[e] = covered_times.get(e, 0) + 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        penalty = sum(covered_times.get(e, 0) for e in ss)  # discourage redundant hits\n        score = len(new) - 0.25 * penalty\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "replacement_potential": "import numpy as np\nfrom typing import List, Optional, Dict, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Favor candidates that might make some selected subsets redundant (while still covering new elements).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    sel_sets = [set(s) for s in selected_subsets]\n    union_sel: Set[int] = set().union(*sel_sets) if sel_sets else set()\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        cand = set(s)\n        gain = len(rem.intersection(cand))\n        if gain <= 0:\n            continue\n\n        # After adding cand, check how many selected sets are redundant w.r.t (union_sel  cand)\n        union_new = union_sel.union(cand)\n        redundant = 0\n        for t in sel_sets:\n            if len(t) > 0 and (t.issubset(union_new)):\n                redundant += 1\n\n        score = gain + 0.8 * redundant - 0.05 * len(cand)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "minimize_new_support_variance": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Max gain, but prefer sets whose newly covered elements have low support variance (more predictable impact).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        ss = set(s)\n        for e in ss:\n            if e in support:\n                support[e] += 1\n\n    best, best_tuple = None, None  # (gain, -var_support, -size)\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        gain = len(new)\n        vals = np.array([support.get(e, 0) for e in new], dtype=float)\n        var = float(vals.var()) if vals.size else 0.0\n        t = (gain, -var, -len(ss))\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n    return best\n",
  "minimax_remaining_support_drop": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Choose set that maximizes gain while minimizing the worst support drop among remaining elements.\"\"\"\n    rem0 = set(remaining_elements)\n    if not rem0:\n        return None\n\n    # support per element in remaining family\n    support0: Dict[int, int] = {e: 0 for e in rem0}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support0:\n                support0[e] += 1\n\n    best, best_tuple = None, None  # (gain, -worst_drop, -size)\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(rem0.intersection(ss))\n        if gain <= 0:\n            continue\n\n        rem1 = rem0 - ss\n        if not rem1:\n            return s\n\n        # drop for an element = how many sets containing it are removed? (proxy: 1 if element is in ss else 0)\n        # worst drop among remaining elements = max(0) here; refine by counting how many remaining sets contain it & are removed\n        worst_drop = 0\n        for e in rem1:\n            worst_drop = max(worst_drop, 0)\n\n        t = (gain, -worst_drop, -len(ss))\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n    return best\n",
  "gain_under_adaptive_size_cap": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Only consider sets below a progress-adaptive size cap; within cap, maximize uncovered gain.\"\"\"\n    rem = set(remaining_elements)\n    if not rem or not remaining_subsets:\n        return None\n\n    sizes = np.array([len(s) for s in remaining_subsets], dtype=float)\n    n_rem = max(1, len(rem))\n    n_total = n_rem + len({e for ss in selected_subsets for e in ss})\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    # cap tightens late: from 80th percentile early to 40th percentile late\n    q = 0.80 - 0.40 * progress\n    cap = float(np.quantile(sizes, q))\n\n    best, best_gain = None, 0\n    fallback_best, fallback_gain = None, 0\n\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g <= 0:\n            continue\n        if len(s) <= cap and g > best_gain:\n            best_gain, best = g, s\n        if g > fallback_gain:\n            fallback_gain, fallback_best = g, s\n\n    return best if best is not None else fallback_best\n",
  "gain_per_new_element_support_sum": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Score = gain / (1 + sum_support_of_new_elements) to avoid consuming high-support items too early.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    best, best_score = None, -1.0\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        gain = len(new)\n        denom = 1.0 + float(sum(support.get(e, 0) for e in new))\n        score = gain / denom\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "maximize_new_element_support_sum": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Score = sum support(e) over newly covered elements (targets high-degree core first).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        score = float(sum(support.get(e, 0) for e in new))\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "minhash_dissimilarity_bonus": "import numpy as np\nfrom typing import List, Optional, Set\n\ndef _minhash_signature(s: Set[int], seeds: np.ndarray) -> np.ndarray:\n    if not s:\n        return np.full(seeds.shape[0], 2**31 - 1, dtype=np.int64)\n    arr = np.fromiter(s, dtype=np.int64)\n    # (a*x + b) mod large prime, take min per seed\n    p = np.int64(2147483647)\n    a = seeds[:, 0]\n    b = seeds[:, 1]\n    vals = (a[:, None] * arr[None, :] + b[:, None]) % p\n    return vals.min(axis=1)\n\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Gain plus a MinHash-based dissimilarity bonus vs. selected subsets (cheap diversity).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    rng = np.random.RandomState(7)\n    seeds = rng.randint(1, 2**31 - 1, size=(16, 2), dtype=np.int64)\n\n    selected_sets = [set(s) for s in selected_subsets] if selected_subsets else []\n    sel_sigs = [_minhash_signature(t, seeds) for t in selected_sets]\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = rem.intersection(ss)\n        if not new:\n            continue\n        gain = len(new)\n\n        if not sel_sigs:\n            dissim = 1.0\n        else:\n            sig = _minhash_signature(ss, seeds)\n            # approximate Jaccard similarity by signature match rate\n            sims = [float((sig == tsig).mean()) for tsig in sel_sigs]\n            dissim = 1.0 - float(np.mean(sims))\n\n        score = gain * (1.0 + 0.6 * dissim) - 0.03 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "hypergraph_core_peel": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Peel heuristic: focus on elements with highest remaining-set support (core), then pick best set covering many core elements.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    if not support:\n        return None\n\n    vals = np.array(list(support.values()), dtype=float)\n    thr = float(np.quantile(vals, 0.75))\n    core = {e for e, c in support.items() if c >= thr and c > 0}\n\n    best, best_tuple = None, None  # (core_cov, total_gain, -size)\n    for s in remaining_subsets:\n        ss = set(s)\n        new = rem.intersection(ss)\n        if not new:\n            continue\n        cc = len(core.intersection(ss))\n        t = (cc, len(new), -len(ss))\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n    return best\n",
  "rare_fringe_peel": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Peel heuristic: define a 'fringe' of low-support elements (<=25th pct) and prioritize covering it.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    vals = np.array([c for c in support.values() if c > 0], dtype=float)\n    if vals.size == 0:\n        return None\n    thr = float(np.quantile(vals, 0.25))\n    fringe = {e for e, c in support.items() if 0 < c <= thr}\n\n    best, best_tuple = None, None  # (fringe_cov, total_gain, -size)\n    for s in remaining_subsets:\n        ss = set(s)\n        new = rem.intersection(ss)\n        if not new:\n            continue\n        fc = len(fringe.intersection(ss))\n        t = (fc, len(new), -len(ss))\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n    return best\n",
  "support_geometric_mean_bonus": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Gain plus bonus for higher geometric mean of supports among newly covered elements.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        gain = len(new)\n        vals = np.array([max(1, support.get(e, 1)) for e in new], dtype=float)\n        gmean = float(np.exp(np.mean(np.log(vals)))) if vals.size else 1.0\n        score = gain + 0.12 * gmean - 0.02 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "support_geometric_mean_penalty": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Gain minus penalty for higher geometric mean support among newly covered elements (preserve flexible items).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        gain = len(new)\n        vals = np.array([max(1, support.get(e, 1)) for e in new], dtype=float)\n        gmean = float(np.exp(np.mean(np.log(vals)))) if vals.size else 1.0\n        score = gain - 0.10 * gmean - 0.01 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "adaptive_lambda_overlap_by_density": "import numpy as np\nfrom typing import List, Optional, Dict, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Adjust overlap penalty based on remaining-family density (avg element support).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    covered_selected: Set[int] = set()\n    for s in selected_subsets:\n        covered_selected.update(s)\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    avg_sup = float(np.mean([c for c in support.values()])) if support else 0.0\n    lam = 0.15 + 0.08 * avg_sup  # denser => penalize overlap more\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n        ov = len(ss.intersection(covered_selected))\n        score = gain - lam * ov - 0.01 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "cover_median_support_elements": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets that cover many 'middle-support' elements (avoids extremes).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                support[e] = support.get(e, 0) + 1\n\n    if not support:\n        return None\n\n    vals = np.array(list(support.values()), dtype=float)\n    lo = float(np.quantile(vals, 0.35))\n    hi = float(np.quantile(vals, 0.65))\n    mid = {e for e, c in support.items() if lo <= c <= hi}\n\n    best, best_tuple = None, None  # (mid_cov, total_gain, -size)\n    for s in remaining_subsets:\n        ss = set(s)\n        new = rem.intersection(ss)\n        if not new:\n            continue\n        mc = len(mid.intersection(ss))\n        t = (mc, len(new), -len(ss))\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n    return best\n",
  "quantile_rarity_bucket_vector": "import numpy as np\nfrom typing import List, Optional, Dict, Tuple\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Bucket uncovered elements by support quantiles; lexicographically maximize coverage from rarest bucket to commonest.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                support[e] = support.get(e, 0) + 1\n\n    vals = np.array([c for c in support.values() if c > 0], dtype=float)\n    if vals.size == 0:\n        return None\n\n    q1 = float(np.quantile(vals, 0.25))\n    q2 = float(np.quantile(vals, 0.50))\n    q3 = float(np.quantile(vals, 0.75))\n\n    def bucket(c: int) -> int:\n        if c <= q1:\n            return 0\n        if c <= q2:\n            return 1\n        if c <= q3:\n            return 2\n        return 3\n\n    best, best_vec = None, None\n    for s in remaining_subsets:\n        ss = set(s)\n        cov = [e for e in ss if e in rem]\n        if not cov:\n            continue\n        counts = [0, 0, 0, 0]\n        for e in cov:\n            counts[bucket(support.get(e, 0))] += 1\n        vec = (counts[0], counts[1], counts[2], counts[3], -len(ss))\n        if best_vec is None or vec > best_vec:\n            best_vec, best = vec, s\n    return best\n",
  "stochastic_two_arm_bandit_gain_vs_rarity": "import numpy as np\nimport random\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Randomly choose between (max gain) and (max rarity-weighted) using a progress-based mixing probability.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    n_rem = max(1, len(rem))\n    n_total = n_rem + len({e for ss in selected_subsets for e in ss})\n    progress = 1.0 - (n_rem / max(1, n_total))\n\n    p_rarity = 0.20 + 0.60 * progress\n\n    if random.random() > p_rarity:\n        # max gain\n        best, best_gain = None, 0\n        for s in remaining_subsets:\n            g = len(rem.intersection(s))\n            if g > best_gain:\n                best_gain, best = g, s\n        return best if best_gain > 0 else None\n\n    # rarity-weighted\n    freq: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        sc = 0.0\n        for e in set(s):\n            if e in rem:\n                sc += 1.0 / max(1, freq.get(e, 1))\n        if sc > best_score and sc > 0:\n            best_score, best = sc, s\n    return best\n",
  "topk_then_best_rarity": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Filter to top-k by gain, then pick the one with the best rarity-weighted score.\"\"\"\n    rem = set(remaining_elements)\n\n    scored_gain = []\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > 0:\n            scored_gain.append((g, s))\n    if not scored_gain:\n        return None\n\n    scored_gain.sort(key=lambda x: x[0], reverse=True)\n    k = max(1, int(np.ceil(0.15 * len(scored_gain))))\n    top = [s for _, s in scored_gain[:k]]\n\n    freq: Dict[int, int] = {}\n    for s in top:\n        for e in set(s):\n            if e in rem:\n                freq[e] = freq.get(e, 0) + 1\n\n    best, best_score = None, -1e18\n    for s in top:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        score = sum(1.0 / max(1, freq.get(e, 1)) for e in new)\n        score += 0.05 * len(new)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "topk_then_best_diversity": "import numpy as np\nfrom typing import List, Optional, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Filter to top-k by gain, then maximize dissimilarity to selected (avg Jaccard distance).\"\"\"\n    rem = set(remaining_elements)\n\n    scored_gain = []\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > 0:\n            scored_gain.append((g, s))\n    if not scored_gain:\n        return None\n\n    scored_gain.sort(key=lambda x: x[0], reverse=True)\n    k = max(1, int(np.ceil(0.20 * len(scored_gain))))\n    top = [s for _, s in scored_gain[:k]]\n\n    sel = [set(s) for s in selected_subsets] if selected_subsets else []\n\n    best, best_score = None, -1e18\n    for s in top:\n        ss = set(s)\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n        if not sel:\n            dist = 1.0\n        else:\n            dsum = 0.0\n            for t in sel:\n                inter = len(ss.intersection(t))\n                uni = len(ss.union(t))\n                dsum += 1.0 - (inter / max(1, uni))\n            dist = dsum / len(sel)\n        score = gain + 0.9 * dist - 0.02 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "cover_last_uncovered_cluster": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Late-stage bias: if few elements remain, choose set that maximizes gain but minimizes extra (covers mostly what's left).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    # if near the end, minimize waste\n    if len(rem) <= 10:\n        best, best_tuple = None, None  # (gain, -waste)\n        for s in remaining_subsets:\n            ss = set(s)\n            gain = len(rem.intersection(ss))\n            if gain <= 0:\n                continue\n            waste = len(ss - rem)\n            t = (gain, -waste)\n            if best_tuple is None or t > best_tuple:\n                best_tuple, best = t, s\n        return best\n\n    # otherwise normal max gain\n    best, best_gain = None, 0\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > best_gain:\n            best_gain, best = g, s\n    return best if best_gain > 0 else None\n",
  "min_waste_per_gain": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Minimize (waste / gain) where waste = elements in set that are not remaining.\"\"\"\n    rem = set(remaining_elements)\n    best, best_score = None, 1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n        waste = len(ss - rem)\n        score = waste / float(gain)\n        if score < best_score:\n            best_score, best = score, s\n    return best\n",
  "gain_minus_waste": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Score = gain - alpha*waste (waste = non-remaining elements inside the set).\"\"\"\n    rem = set(remaining_elements)\n    alpha = 0.35\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n        waste = len(ss - rem)\n        score = gain - alpha * waste\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "coverage_balance_to_target": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets whose uncovered gain is close to a target fraction of remaining elements (stabilizes step sizes).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    target = max(1, int(np.ceil(0.12 * len(rem))))\n\n    best, best_tuple = None, None  # (-|gain-target|, gain)\n    for s in remaining_subsets:\n        gain = len(rem.intersection(s))\n        if gain <= 0:\n            continue\n        t = (-abs(gain - target), gain)\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n    return best\n",
  "multiplicative_weights_element_importance": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Assign element weights via a multiplicative-weights style rule from support; pick set with max weighted gain.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    # weights: larger when support is small; smooth via exp\n    vals = np.array([c for c in support.values() if c > 0], dtype=float)\n    if vals.size == 0:\n        return None\n    scale = max(1.0, float(np.mean(vals)))\n    w: Dict[int, float] = {}\n    for e, c in support.items():\n        if c > 0:\n            w[e] = float(np.exp(-c / scale))\n        else:\n            w[e] = 0.0\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        sc = 0.0\n        for e in ss:\n            if e in rem:\n                sc += w.get(e, 0.0)\n        if sc > best_score and sc > 0:\n            best_score, best = sc, s\n    return best\n",
  "greedy_dual_fitting_proxy": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Dual-fitting inspired proxy: weight elements inversely by (1+support) and select max weighted gain / size.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        weighted = float(sum(1.0 / (1.0 + support.get(e, 0)) for e in new))\n        score = weighted / max(1.0, float(len(ss)))\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "random_projection_signature_diversity": "import numpy as np\nfrom typing import List, Optional\n\ndef _sig(vec: np.ndarray) -> np.ndarray:\n    return (vec > 0).astype(np.int8)\n\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Use random sign projections to build cheap signatures and favor candidates far from selected signatures.\"\"\"\n    rem_list = list(set(remaining_elements))\n    rem = set(rem_list)\n    if not rem:\n        return None\n\n    rng = np.random.RandomState(11)\n    d = len(rem_list)\n    k = min(24, d)\n    P = rng.randn(k, d)\n\n    # build selected signatures\n    sel_sigs = []\n    for s in selected_subsets:\n        v = np.zeros(d, dtype=float)\n        ss = set(s)\n        for i, e in enumerate(rem_list):\n            if e in ss:\n                v[i] = 1.0\n        sel_sigs.append(_sig(P @ v))\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n\n        v = np.zeros(d, dtype=float)\n        for i, e in enumerate(rem_list):\n            if e in ss:\n                v[i] = 1.0\n        sig = _sig(P @ v)\n\n        if not sel_sigs:\n            dist = 1.0\n        else:\n            # Hamming distance normalized\n            dists = [float(np.mean(sig != t)) for t in sel_sigs]\n            dist = float(np.mean(dists))\n\n        score = gain * (1.0 + 0.5 * dist) - 0.02 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "kcenter_on_elements_then_pick": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Pick an uncovered pivot element with median support, then choose the set containing it with best gain/size.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in support:\n                support[e] += 1\n\n    vals = sorted([(c, e) for e, c in support.items() if c > 0])\n    if not vals:\n        return None\n    pivot = vals[len(vals) // 2][1]\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        if pivot not in ss:\n            continue\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n        score = gain / max(1.0, float(len(ss)))\n        if score > best_score:\n            best_score, best = score, s\n\n    if best is not None:\n        return best\n\n    # fallback to max gain\n    best, best_gain = None, 0\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > best_gain:\n            best_gain, best = g, s\n    return best if best_gain > 0 else None\n",
  "min_remaining_support_ones_after_pick": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets that reduce the number of uncovered elements with support==1 (single-option elements).\"\"\"\n    rem0 = set(remaining_elements)\n    if not rem0:\n        return None\n\n    support0: Dict[int, int] = {e: 0 for e in rem0}\n    sets = [set(s) for s in remaining_subsets]\n    for ss in sets:\n        for e in ss:\n            if e in support0:\n                support0[e] += 1\n\n    best, best_score = None, -1e18\n    for s, ss in zip(remaining_subsets, sets):\n        gain = len(rem0.intersection(ss))\n        if gain <= 0:\n            continue\n        rem1 = rem0 - ss\n        ones = sum(1 for e in rem1 if support0.get(e, 0) == 1)\n        score = gain - 1.1 * ones - 0.01 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "maximize_coverage_of_support_one": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Maximize the number of uncovered elements with support==1 covered by the chosen set.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        ss = set(s)\n        for e in ss:\n            if e in support:\n                support[e] += 1\n\n    must = {e for e, c in support.items() if c == 1}\n\n    best, best_tuple = None, None  # (must_covered, total_gain, -size)\n    for s in remaining_subsets:\n        ss = set(s)\n        new = rem.intersection(ss)\n        if not new:\n            continue\n        mc = len(must.intersection(ss))\n        t = (mc, len(new), -len(ss))\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n    return best\n",
  "entropy_of_new_supports": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef _entropy_from_counts(x: np.ndarray) -> float:\n    s = float(x.sum())\n    if s <= 0:\n        return 0.0\n    p = x / s\n    p = p[p > 0]\n    return float(-(p * np.log(p)).sum())\n\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Gain plus entropy of supports of newly covered elements (prefers covering a mix of difficulty levels).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                support[e] = support.get(e, 0) + 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        gain = len(new)\n        vals = np.array([support.get(e, 0) for e in new], dtype=float)\n        ent = _entropy_from_counts(vals)\n        score = gain + 0.35 * ent - 0.02 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "maximize_jaccard_to_remaining_elements": "import numpy as np\nfrom typing import List, Optional, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Pick the set with maximum Jaccard similarity to the remaining element set (i.e., 'fits' what's left).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    best, best_score = None, -1.0\n    for s in remaining_subsets:\n        ss = set(s)\n        inter = len(ss.intersection(rem))\n        if inter <= 0:\n            continue\n        uni = len(ss.union(rem))\n        score = inter / max(1.0, float(uni))\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "maximize_f1_to_remaining": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Maximize F1 between candidate set and remaining elements (balances precision vs recall of remaining).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        tp = len(ss.intersection(rem))\n        if tp <= 0:\n            continue\n        prec = tp / max(1.0, float(len(ss)))\n        rec = tp / max(1.0, float(len(rem)))\n        f1 = (2.0 * prec * rec) / max(1e-12, (prec + rec))\n        score = f1 + 0.02 * tp\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "gain_times_precision": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Score = gain * precision, where precision = gain/|S| (prefers high-gain, low-waste sets).\"\"\"\n    rem = set(remaining_elements)\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(ss.intersection(rem))\n        if gain <= 0:\n            continue\n        precision = gain / max(1.0, float(len(ss)))\n        score = gain * precision\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "roulette_on_gain_and_precision": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Sample with probability proportional to (gain * precision)^2 (stochastic but focused).\"\"\"\n    rem = set(remaining_elements)\n    cand = []\n    w = []\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(ss.intersection(rem))\n        if gain <= 0:\n            continue\n        precision = gain / max(1.0, float(len(ss)))\n        score = (gain * precision) ** 2\n        cand.append(s)\n        w.append(score)\n    if not cand:\n        return None\n    w = np.array(w, dtype=float)\n    w = w / w.sum()\n    idx = int(np.random.choice(len(cand), p=w))\n    return cand[idx]\n",
  "pick_set_covering_max_support_span": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets whose newly covered elements span a wide support range (max - min).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                support[e] = support.get(e, 0) + 1\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        vals = [support.get(e, 0) for e in new]\n        span = max(vals) - min(vals) if vals else 0\n        score = len(new) + 0.25 * float(span) - 0.02 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "balanced_cover_by_support_bins": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets that cover at least one element from each support bin (rare/mid/common), then maximize gain.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    support: Dict[int, int] = {}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in rem:\n                support[e] = support.get(e, 0) + 1\n\n    vals = np.array([c for c in support.values() if c > 0], dtype=float)\n    if vals.size == 0:\n        return None\n\n    q1 = float(np.quantile(vals, 0.33))\n    q2 = float(np.quantile(vals, 0.66))\n\n    def bin_of(c: int) -> int:\n        if c <= q1:\n            return 0\n        if c <= q2:\n            return 1\n        return 2\n\n    best, best_tuple = None, None  # (bins_hit, gain, -size)\n    for s in remaining_subsets:\n        ss = set(s)\n        new = [e for e in ss if e in rem]\n        if not new:\n            continue\n        bins = {bin_of(support.get(e, 0)) for e in new}\n        t = (len(bins), len(new), -len(ss))\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n    return best\n",
  "two_stage_pivot_then_diversify": "import numpy as np\nfrom typing import List, Optional, Dict, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Pick rarest pivot element; among sets containing it, choose one most dissimilar to selected (Jaccard distance).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    freq: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in freq:\n                freq[e] += 1\n\n    piv = None\n    piv_f = 10**18\n    for e, f in freq.items():\n        if 0 < f < piv_f:\n            piv_f = f\n            piv = e\n    if piv is None:\n        return None\n\n    sel_sets = [set(s) for s in selected_subsets] if selected_subsets else []\n\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        if piv not in ss:\n            continue\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n        if not sel_sets:\n            dist = 1.0\n        else:\n            dsum = 0.0\n            for t in sel_sets:\n                inter = len(ss.intersection(t))\n                uni = len(ss.union(t))\n                dsum += 1.0 - (inter / max(1, uni))\n            dist = dsum / len(sel_sets)\n        score = gain + 0.8 * dist - 0.02 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n\n    if best is not None:\n        return best\n\n    # fallback: best set by gain\n    best, best_gain = None, 0\n    for s in remaining_subsets:\n        g = len(rem.intersection(s))\n        if g > best_gain:\n            best_gain, best = g, s\n    return best if best_gain > 0 else None\n",
  "singleton_completion_bias": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"If any uncovered element appears in exactly one remaining set, pick the set that satisfies the most such singletons; else fallback to max gain.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    # element -> count of sets containing it\n    freq: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        ss = set(s)\n        for e in ss:\n            if e in freq:\n                freq[e] += 1\n\n    singletons = {e for e, c in freq.items() if c == 1}\n\n    best, best_tuple = None, None  # (singletons_covered, gain, -size)\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n        sc = len(singletons.intersection(ss))\n        t = (sc, gain, -len(ss))\n        if best_tuple is None or t > best_tuple:\n            best_tuple, best = t, s\n\n    # If no singleton is coverable (rare but possible if freq map empty), fallback to max gain\n    if best is None:\n        best_gain, best = 0, None\n        for s in remaining_subsets:\n            g = len(rem.intersection(s))\n            if g > best_gain:\n                best_gain, best = g, s\n        return best if best_gain > 0 else None\n\n    return best\n",
  "anti_deadend_guard": "import numpy as np\nfrom typing import List, Optional, Dict, Set\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Prefer sets that reduce the count of uncovered elements with low remaining support (<=2), guarding against dead-ends.\"\"\"\n    rem0 = set(remaining_elements)\n    if not rem0:\n        return None\n\n    # support among remaining subsets\n    support0: Dict[int, int] = {e: 0 for e in rem0}\n    sets = [set(s) for s in remaining_subsets]\n    for ss in sets:\n        for e in ss:\n            if e in support0:\n                support0[e] += 1\n\n    low = {e for e, c in support0.items() if 0 < c <= 2}\n\n    best, best_score = None, -1e18\n    for s, ss in zip(remaining_subsets, sets):\n        gain = len(rem0.intersection(ss))\n        if gain <= 0:\n            continue\n        rem1 = rem0 - ss\n        # count low-support elements left (computed with support0 proxy)\n        low_left = sum(1 for e in rem1 if e in low)\n        score = gain - 1.0 * low_left - 0.01 * len(ss)\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "weighted_waste_f1_hybrid": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Hybrid: maximize F1 with remaining elements, then subtract weighted waste (elements outside remaining).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    alpha = 0.25\n    best, best_score = None, -1e18\n    for s in remaining_subsets:\n        ss = set(s)\n        tp = len(ss.intersection(rem))\n        if tp <= 0:\n            continue\n        prec = tp / max(1.0, float(len(ss)))\n        rec = tp / max(1.0, float(len(rem)))\n        f1 = (2.0 * prec * rec) / max(1e-12, (prec + rec))\n        waste = len(ss - rem)\n        score = f1 + 0.02 * tp - alpha * (waste / max(1.0, float(len(ss))))\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "rare_then_pack_dense": "import numpy as np\nfrom typing import List, Optional, Dict\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Two-mode: if any uncovered element has support==1 or 2, prioritize covering those; otherwise choose best gain/size (dense pack).\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    freq: Dict[int, int] = {e: 0 for e in rem}\n    for s in remaining_subsets:\n        for e in set(s):\n            if e in freq:\n                freq[e] += 1\n\n    critical = {e for e, c in freq.items() if 0 < c <= 2}\n\n    best, best_score = None, -1e18\n    if critical:\n        for s in remaining_subsets:\n            ss = set(s)\n            gain = len(rem.intersection(ss))\n            if gain <= 0:\n                continue\n            crit_cov = len(critical.intersection(ss))\n            score = 2.5 * crit_cov + 0.1 * gain - 0.02 * len(ss)\n            if score > best_score:\n                best_score, best = score, s\n        return best\n\n    # dense pack fallback: maximize gain/size\n    for s in remaining_subsets:\n        ss = set(s)\n        gain = len(rem.intersection(ss))\n        if gain <= 0:\n            continue\n        score = gain / max(1.0, float(len(ss)))\n        if score > best_score:\n            best_score, best = score, s\n    return best\n",
  "regret_minimization_proxy": "import numpy as np\nfrom typing import List, Optional\n\ndef select_next_subset(selected_subsets: List[List[int]],\n                       remaining_subsets: List[List[int]],\n                       remaining_elements: List[int]) -> Optional[List[int]]:\n    \"\"\"Choose set minimizing regret: regret = (best_possible_gain_now - gain(set)) + beta*waste.\"\"\"\n    rem = set(remaining_elements)\n    if not rem:\n        return None\n\n    gains = []\n    cand = []\n    for s in remaining_subsets:\n        ss = set(s)\n        g = len(ss.intersection(rem))\n        if g > 0:\n            gains.append(g)\n            cand.append(s)\n    if not cand:\n        return None\n\n    best_gain = max(gains)\n    beta = 0.15\n\n    best, best_regret = None, 1e18\n    for s, g in zip(cand, gains):\n        ss = set(s)\n        waste = len(ss - rem)\n        regret = (best_gain - g) + beta * waste\n        if regret < best_regret:\n            best_regret, best = regret, s\n    return best\n"
}




