{
  "greedy_max_coverage": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Standard Greedy: Pick the subset covering the most remaining elements.\"\"\"\n    rem_set = set(remaining_elements)\n    best_subset = None\n    max_cover = -1\n    \n    for subset in remaining_subsets:\n        cover = len(rem_set.intersection(subset))\n        if cover > max_cover:\n            max_cover = cover\n            best_subset = subset\n            \n    return best_subset\n",
  
  "rarity_weighted_coverage": "import numpy as np\nfrom typing import List\nfrom collections import Counter\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Weight elements by rarity (1/frequency). Pick subset with highest total weight.\"\"\"\n    rem_set = set(remaining_elements)\n    if not rem_set: return None\n    \n    # Calculate frequency of each remaining element across all available subsets\n    freq = Counter()\n    for subset in remaining_subsets:\n        for elem in subset:\n            if elem in rem_set:\n                freq[elem] += 1\n                \n    best_subset = None\n    max_score = -1.0\n    \n    for subset in remaining_subsets:\n        score = 0.0\n        for elem in subset:\n            if elem in rem_set:\n                # Rare elements (low freq) give higher score\n                score += 1.0 / (freq[elem] + 1e-5)\n        \n        if score > max_score:\n            max_score = score\n            best_subset = subset\n            \n    return best_subset\n",

  "penalized_overlap_greedy": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Greedy coverage minus a penalty for elements already covered (redundancy).\"\"\"\n    rem_set = set(remaining_elements)\n    best_subset = None\n    max_score = -float('inf')\n    \n    for subset in remaining_subsets:\n        s_set = set(subset)\n        fresh = len(s_set.intersection(rem_set))\n        redundant = len(s_set) - fresh\n        \n        # High reward for fresh, slight penalty for waste\n        score = fresh - 0.1 * redundant\n        \n        if score > max_score:\n            max_score = score\n            best_subset = subset\n            \n    return best_subset\n",

  "normalized_density": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Score = Coverage / Subset_Size (Efficiency). Favor compact effective subsets.\"\"\"\n    rem_set = set(remaining_elements)\n    best_subset = None\n    max_score = -1.0\n    \n    for subset in remaining_subsets:\n        if not subset: continue\n        cover = len(rem_set.intersection(subset))\n        if cover == 0: continue\n        \n        # Efficiency density\n        score = float(cover) / float(len(subset))\n        \n        if score > max_score:\n            max_score = score\n            best_subset = subset\n            \n    # Fallback to greedy if no efficient move found\n    if best_subset is None and remaining_subsets:\n        return max(remaining_subsets, key=lambda s: len(rem_set.intersection(s)))\n        \n    return best_subset\n",

  "critical_element_priority": "import numpy as np\nfrom typing import List\nfrom collections import Counter\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"If a subset covers a 'critical' element (freq=1), pick it immediately. Else Greedy.\"\"\"\n    rem_set = set(remaining_elements)\n    if not rem_set: return None\n\n    freq = Counter()\n    for subset in remaining_subsets:\n        for elem in subset:\n            if elem in rem_set:\n                freq[elem] += 1\n    \n    # Identify critical subsets\n    for subset in remaining_subsets:\n        for elem in subset:\n            if elem in rem_set and freq[elem] == 1:\n                return subset\n                \n    # Fallback: Greedy\n    return max(remaining_subsets, key=lambda s: len(rem_set.intersection(s)))\n",

  "randomized_top_k_greedy": "import numpy as np\nfrom typing import List\nimport random\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Select randomly from the top K subsets by coverage (Diversification).\"\"\"\n    rem_set = set(remaining_elements)\n    candidates = []\n    \n    for subset in remaining_subsets:\n        cover = len(rem_set.intersection(subset))\n        candidates.append((cover, subset))\n        \n    # Sort descending by coverage\n    candidates.sort(key=lambda x: x[0], reverse=True)\n    \n    if not candidates or candidates[0][0] == 0:\n        return candidates[0][1] if candidates else None\n        \n    # Top K\n    k = min(5, len(candidates))\n    top_k = candidates[:k]\n    \n    # Pick random\n    return random.choice(top_k)[1]\n",

  "softmax_sampling_coverage": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Probabilistic selection proportional to exp(coverage).\"\"\"\n    rem_set = set(remaining_elements)\n    scores = []\n    valid_subsets = []\n    \n    for subset in remaining_subsets:\n        cover = len(rem_set.intersection(subset))\n        if cover > 0:\n            scores.append(float(cover))\n            valid_subsets.append(subset)\n            \n    if not valid_subsets:\n        return remaining_subsets[0] if remaining_subsets else None\n        \n    scores = np.array(scores)\n    # Temperature scaling\n    exp_scores = np.exp(scores * 2.0) \n    probs = exp_scores / np.sum(exp_scores)\n    \n    idx = np.random.choice(len(valid_subsets), p=probs)\n    return valid_subsets[idx]\n",

  "one_step_lookahead_max": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Pick S that maximizes max_coverage of next step (greedy lookahead).\"\"\"\n    rem_set = set(remaining_elements)\n    best_subset = None\n    max_combined = -1\n    \n    # Only evaluate top candidates to save time\n    candidates = sorted(remaining_subsets, key=lambda s: len(rem_set.intersection(s)), reverse=True)[:10]\n    \n    for s1 in candidates:\n        cover1 = rem_set.intersection(s1)\n        rem_after = rem_set - cover1\n        \n        # Estimate next best\n        max_next = 0\n        for s2 in remaining_subsets:\n            if s2 is s1: continue\n            max_next = max(max_next, len(rem_after.intersection(s2)))\n            \n        total = len(cover1) + max_next\n        if total > max_combined:\n            max_combined = total\n            best_subset = s1\n            \n    return best_subset\n",

  "exponential_decay_weighting": "import numpy as np\nfrom typing import List\nfrom collections import defaultdict\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Elements that appear in many subsets get exponentially lower weight.\"\"\"\n    rem_set = set(remaining_elements)\n    counts = defaultdict(int)\n    \n    for s in remaining_subsets:\n        for e in s:\n            if e in rem_set: counts[e] += 1\n            \n    best_subset = None\n    max_val = -1.0\n    \n    for subset in remaining_subsets:\n        val = 0.0\n        for e in subset:\n            if e in rem_set:\n                # Heavily favor elements that are in very few subsets\n                val += np.exp(-0.5 * counts[e])\n        \n        if val > max_val:\n            max_val = val\n            best_subset = subset\n            \n    return best_subset\n",

  "jaccard_similarity_heuristic": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Maximize Jaccard Index (Intersection / Union) with the remaining set.\"\"\"\n    rem_set = set(remaining_elements)\n    best_subset = None\n    max_jaccard = -1.0\n    \n    for subset in remaining_subsets:\n        s_set = set(subset)\n        inter = len(s_set.intersection(rem_set))\n        union = len(s_set.union(rem_set))\n        \n        if union == 0: continue\n        \n        jaccard = inter / union\n        if jaccard > max_jaccard:\n            max_jaccard = jaccard\n            best_subset = subset\n            \n    return best_subset\n",

  "squared_coverage_bonus": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Maximize Coverage^2 / Size. Non-linear reward for big chunks.\"\"\"\n    rem_set = set(remaining_elements)\n    best_subset = None\n    max_score = -1.0\n    \n    for subset in remaining_subsets:\n        if not subset: continue\n        cover = len(rem_set.intersection(subset))\n        # Non-linear scaling\n        score = (cover ** 2) / len(subset)\n        \n        if score > max_score:\n            max_score = score\n            best_subset = subset\n            \n    return best_subset\n",

  "dynamic_threshold_greedy": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Calculate average coverage of all candidates. Pick the smallest subset that exceeds average coverage * 1.5.\"\"\"\n    rem_set = set(remaining_elements)\n    coverages = []\n    for s in remaining_subsets:\n        coverages.append(len(rem_set.intersection(s)))\n        \n    if not coverages or max(coverages) == 0:\n        return remaining_subsets[0] if remaining_subsets else None\n        \n    threshold = np.mean(coverages) * 1.5\n    \n    # Find candidates above threshold\n    candidates = []\n    for i, s in enumerate(remaining_subsets):\n        if coverages[i] >= threshold:\n            candidates.append(s)\n            \n    if not candidates:\n        # Fallback to max greedy\n        return remaining_subsets[np.argmax(coverages)]\n    \n    # Tie-break: Smallest size (most efficient among the big covers)\n    candidates.sort(key=len)\n    return candidates[0]\n",

  "uncovered_element_degree_variance": "import numpy as np\nfrom typing import List\nfrom collections import Counter\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Try to reduce the variance of remaining element frequencies (degree). Target elements that have low redundancy first.\"\"\"\n    rem_set = set(remaining_elements)\n    \n    # Count current degrees\n    counts = Counter()\n    for s in remaining_subsets:\n        for e in s:\n            if e in rem_set: counts[e] += 1\n            \n    best_subset = None\n    best_score = float('inf')\n    \n    for subset in remaining_subsets:\n        relevant = [e for e in subset if e in rem_set]\n        if not relevant: continue\n        \n        # Score is sum of degrees of covered elements. \n        # Lower score = we are covering elements that don't appear often (hard to cover).\n        score = sum(counts[e] for e in relevant)\n        \n        if score < best_score:\n            best_score = score\n            best_subset = subset\n            \n    if best_subset is None and remaining_subsets:\n        return remaining_subsets[0]\n    return best_subset\n",

  "hybrid_greedy_random_switch": "import numpy as np\nfrom typing import List\nimport random\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Alternating strategy: 70% greedy, 30% random valid move.\"\"\"\n    rem_set = set(remaining_elements)\n    \n    valid_subsets = [s for s in remaining_subsets if not rem_set.isdisjoint(s)]\n    if not valid_subsets: return None\n    \n    if random.random() < 0.3:\n        return random.choice(valid_subsets)\n    else:\n        # Greedy\n        return max(valid_subsets, key=lambda s: len(rem_set.intersection(s)))\n",

  "log_frequency_weighting": "import numpy as np\nfrom typing import List\nfrom collections import Counter\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Score = Sum( -log(freq/total) ) for elements covered. Shannon information content proxy.\"\"\"\n    rem_set = set(remaining_elements)\n    total_subsets = len(remaining_subsets)\n    freq = Counter()\n    for s in remaining_subsets:\n        for e in s:\n            if e in rem_set: freq[e] += 1\n            \n    best_subset = None\n    max_info = -1.0\n    \n    for subset in remaining_subsets:\n        info = 0.0\n        for e in subset:\n            if e in rem_set:\n                prob = freq[e] / max(1, total_subsets)\n                info += -np.log(prob + 1e-9)\n        \n        if info > max_info:\n            max_info = info\n            best_subset = subset\n            \n    return best_subset\n",

  "residual_cover_maximization": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Maximize coverage relative to how much is left. (Cover / Remaining_Count).\"\"\"\n    rem_set = set(remaining_elements)\n    rem_count = len(rem_set)\n    if rem_count == 0: return None\n    \n    best_subset = None\n    max_ratio = -1.0\n    \n    for subset in remaining_subsets:\n        cover = len(rem_set.intersection(subset))\n        # Ratio of progress\n        ratio = cover / rem_count\n        if ratio > max_ratio:\n            max_ratio = ratio\n            best_subset = subset\n            \n    return best_subset\n",

  "iterative_reduction": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Pick subset that reduces the problem size (elements * subsets) the most.\"\"\"\n    rem_set = set(remaining_elements)\n    \n    best_subset = None\n    max_reduction = -1\n    \n    for subset in remaining_subsets:\n        cover_set = rem_set.intersection(subset)\n        cover_count = len(cover_set)\n        if cover_count == 0: continue\n        \n        # Heuristic: covering these elements effectively removes them from all other subsets\n        # Estimate reduction as: cover_count + (sum of degrees of covered elements)\n        # But calculating degrees is slow, so we approximate with cover_count * 2\n        reduction = cover_count\n        \n        if reduction > max_reduction:\n            max_reduction = reduction\n            best_subset = subset\n            \n    return best_subset\n",

  "anti_cluster_heuristic": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Prefer subsets that cover elements that are 'far apart' in index (spread out).\"\"\"\n    rem_set = set(remaining_elements)\n    best_subset = None\n    max_score = -1.0\n    \n    for subset in remaining_subsets:\n        covered = [e for e in subset if e in rem_set]\n        if not covered:\n            continue\n            \n        count = len(covered)\n        if count > 1:\n            # Calculate spread (std dev of indices)\n            indices = np.array(covered)\n            spread = np.std(indices)\n            score = count + 0.1 * spread\n        else:\n            score = count\n            \n        if score > max_score:\n            max_score = score\n            best_subset = subset\n            \n    return best_subset\n",

  "late_stage_tailoring": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"If < 5 elements remain, find exact match or smallest subset covering them. Else Greedy.\"\"\"\n    rem_set = set(remaining_elements)\n    \n    if len(rem_set) < 5:\n        # Late stage: try to find subset that covers exactly what's left, or close to it, minimal waste\n        best_subset = None\n        min_waste = float('inf')\n        \n        for subset in remaining_subsets:\n            s_set = set(subset)\n            cover = len(s_set.intersection(rem_set))\n            if cover > 0:\n                waste = len(s_set) - cover\n                if waste < min_waste:\n                    min_waste = waste\n                    best_subset = subset\n        return best_subset\n    \n    # Early stage: Greedy\n    best = None\n    max_c = -1\n    for subset in remaining_subsets:\n        c = len(rem_set.intersection(subset))\n        if c > max_c:\n            max_c = c\n            best = subset\n    return best\n",

  "balanced_size_coverage": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Maximize Geometric Mean of (Coverage, 1/Size). Balances big coverage with small footprints.\"\"\"\n    rem_set = set(remaining_elements)\n    best_subset = None\n    max_score = -1.0\n    \n    for subset in remaining_subsets:\n        cover = len(rem_set.intersection(subset))\n        if cover == 0: continue\n        \n        size = len(subset)\n        # sqrt(Coverage * (1/Size))\n        score = np.sqrt(cover * (1.0/size))\n        \n        if score > max_score:\n            max_score = score\n            best_subset = subset\n            \n    return best_subset\n",

  "min_max_frequency_heuristic": "import numpy as np\nfrom typing import List\nfrom collections import Counter\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Select subset that maximizes coverage, tie-break by minimizing the max frequency of contained elements (avoiding hubs).\"\"\"\n    rem_set = set(remaining_elements)\n    freq = Counter()\n    for s in remaining_subsets:\n        for e in s:\n            if e in rem_set: freq[e] += 1\n            \n    best_subset = None\n    # Tuple comparison: (coverage, -max_freq)\n    best_metric = (-1, -float('inf'))\n    \n    for subset in remaining_subsets:\n        relevant = [e for e in subset if e in rem_set]\n        if not relevant: continue\n        \n        cover = len(relevant)\n        max_f = max(freq[e] for e in relevant)\n        \n        metric = (cover, -max_f)\n        if metric > best_metric:\n            best_metric = metric\n            best_subset = subset\n            \n    return best_subset\n",

  "sum_of_squares_frequency": "import numpy as np\nfrom typing import List\nfrom collections import Counter\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Score = Sum( (1/freq)^2 ). Higher power emphasizes rarity even more than standard rarity.\"\"\"\n    rem_set = set(remaining_elements)\n    freq = Counter()\n    for s in remaining_subsets:\n        for e in s:\n            if e in rem_set: freq[e] += 1\n            \n    best_subset = None\n    max_score = -1.0\n    \n    for subset in remaining_subsets:\n        score = 0.0\n        for e in subset:\n            if e in rem_set:\n                f = freq[e]\n                score += (1.0 / f)**2\n        \n        if score > max_score:\n            max_score = score\n            best_subset = subset\n            \n    return best_subset\n",

  "distinct_element_lookahead": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Choose subset that leaves the most 'distinct' options open for the remaining elements.\"\"\"\n    rem_set = set(remaining_elements)\n    \n    # Greedy base\n    candidates = sorted(remaining_subsets, key=lambda s: len(rem_set.intersection(s)), reverse=True)[:5]\n    if not candidates: return None\n    \n    best_subset = candidates[0]\n    max_unique = -1\n    \n    for s in candidates:\n        leftover = rem_set - set(s)\n        # Count how many subsets cover the leftovers\n        # Just a simplified proxy: count total available slots for leftovers\n        options = 0\n        for other in remaining_subsets:\n            if other is s: continue\n            if not leftover.isdisjoint(other):\n                options += 1\n        \n        if options > max_unique:\n            max_unique = options\n            best_subset = s\n            \n    return best_subset\n",

  "weighted_greedy_parameterized": "import numpy as np\nfrom typing import List\n\ndef select_next_subset(selected_subsets: List[List[int]], remaining_subsets: List[List[int]], remaining_elements: List[int]) -> List[int] | None:\n    \"\"\"Parameterized Greedy: Score = Coverage - alpha * (SubsetSize). alpha=0.5.\"\"\"\n    rem_set = set(remaining_elements)\n    alpha = 0.5\n    \n    best_subset = None\n    max_score = -float('inf')\n    \n    for subset in remaining_subsets:\n        cover = len(rem_set.intersection(subset))\n        if cover == 0: continue\n        \n        score = cover - alpha * len(subset)\n        if score > max_score:\n            max_score = score\n            best_subset = subset\n            \n    return best_subset\n"
}