{
  "nearest_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    return int(feasible[np.argmin(distances)])\n",
  "earliest_deadline_first": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    deadlines = time_windows[feasible, 1]\n    return int(feasible[np.argmin(deadlines)])\n",
  "minimum_slack_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                slacks.append(slack)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(slacks)])\n",
  "earliest_start_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    start_times = time_windows[feasible, 0]\n    return int(feasible[np.argmin(start_times)])\n",
  "minimize_wait_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    wait_times = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                wait = max(0, time_windows[node][0] - arrival)\n                wait_times.append(wait)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(wait_times)])\n",
  "time_distance_weighted": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    slacks = np.array(slacks)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    slack_norm = slacks / (np.mean(slacks) + 1e-9)\n    \n    scores = 0.5 * dist_norm + 0.5 * (1.0 / (slack_norm + 1e-9))\n    return int(feasible[np.argmin(scores)])\n",
  "savings_with_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    return int(feasible[np.argmax(savings)])\n",
  "urgency_capacity_balance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    \n    demand_norm = demand_vals / (np.mean(demand_vals) + 1e-9)\n    urgency = 1.0 / (slacks + 1e-9)\n    urgency_norm = urgency / (np.mean(urgency) + 1e-9)\n    \n    scores = 0.6 * urgency_norm - 0.4 * demand_norm\n    return int(feasible[np.argmax(scores)])\n",
  "time_window_width": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    widths = time_windows[feasible, 1] - time_windows[feasible, 0]\n    return int(feasible[np.argmin(widths)])\n",
  "latest_acceptable_arrival": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    latest_arrivals = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                latest_arrivals.append(time_windows[node][1])\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmax(latest_arrivals)])\n",
  "minimal_detour_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    direct_time = distance_matrix[current_node, depot]\n    detour_times = (distance_matrix[current_node, feasible] + \n                    distance_matrix[feasible, depot] - direct_time)\n    \n    return int(feasible[np.argmin(detour_times)])\n",
  "demand_to_distance_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible] + 1e-9\n    demand_vals = demands[feasible]\n    ratios = demand_vals / distances\n    \n    return int(feasible[np.argmax(ratios)])\n",
  "composite_time_dist_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = 0.4 * norm(urgency) + 0.3 * norm(distances) - 0.3 * norm(demand_vals)\n    \n    return int(feasible[np.argmin(score)])\n",
  "adaptive_time_pressure": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    slacks = np.array(slacks)\n    avg_slack = np.mean(slacks)\n    \n    distances = distance_matrix[current_node, feasible]\n    \n    # Tight time windows: prioritize urgency; Loose: prioritize distance\n    if avg_slack < 5.0:\n        urgency = 1.0 / (slacks + 1e-9)\n        return int(feasible[np.argmax(urgency)])\n    else:\n        return int(feasible[np.argmin(distances)])\n",
  "regret_time_based": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    if len(feasible) == 1:\n        return int(feasible[0])\n    \n    slacks = np.array(slacks)\n    sorted_idx = np.argsort(slacks)\n    \n    if len(sorted_idx) > 1:\n        regret = slacks[sorted_idx[1]] - slacks[sorted_idx[0]]\n        return int(feasible[sorted_idx[0]])  # Most urgent\n    \n    return int(feasible[sorted_idx[0]])\n",
  "insertion_cost_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    time_to_depot = distance_matrix[current_node, depot]\n    time_via_node = (distance_matrix[current_node, feasible] + \n                     distance_matrix[feasible, depot])\n    \n    insertion_costs = time_via_node - time_to_depot\n    return int(feasible[np.argmin(insertion_costs)])\n",
  "time_proximity_cluster": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    # Prefer nodes with time windows close to current time\n    tw_starts = time_windows[feasible, 0]\n    time_proximity = np.abs(tw_starts - current_time)\n    \n    distances = distance_matrix[current_node, feasible]\n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    time_norm = time_proximity / (np.mean(time_proximity) + 1e-9)\n    \n    scores = 0.6 * dist_norm + 0.4 * time_norm\n    return int(feasible[np.argmin(scores)])\n",
  "wait_vs_travel_trade_off": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    wait_times = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                wait_times.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    travel_times = distance_matrix[current_node, feasible]\n    wait_times = np.array(wait_times)\n    \n    total_times = travel_times + wait_times\n    return int(feasible[np.argmin(total_times)])\n",
  "deadline_proximity_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    ratios = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            travel = distance_matrix[current_node, node]\n            arrival = current_time + travel\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                ratio = slack / (travel + 1e-9)\n                ratios.append(ratio)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(ratios)])  # Prefer low slack-to-travel ratio\n",
  "stochastic_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    urgencies = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                urgencies.append(1.0 / (slack + 1.0))\n    \n    if not feasible:\n        return depot\n    \n    urgencies = np.array(urgencies)\n    probs = urgencies / np.sum(urgencies)\n    \n    seed = int(current_node * 2654435761) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "time_window_midpoint": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    deviations = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                midpoint = (time_windows[node][0] + time_windows[node][1]) / 2.0\n                service_start = max(arrival, time_windows[node][0])\n                deviations.append(abs(service_start - midpoint))\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(deviations)])\n",
  "capacity_time_balance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    capacity_ratio = rest_capacity / (np.max(demands) + 1e-9)\n    slacks = np.array(slacks)\n    demand_vals = demands[feasible]\n    \n    # Low capacity: prefer small demand; High urgency: prefer urgent\n    if capacity_ratio < 0.3:\n        return int(feasible[np.argmin(demand_vals)])\n    else:\n        return int(feasible[np.argmin(slacks)])\n",
  "five_factor_composite": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    waits = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n                waits.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n    capacity_util = demand_vals / (rest_capacity + 1e-9)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = (0.25 * norm(distances) - \n             0.20 * norm(demand_vals) + \n             0.30 * norm(urgency) + \n             0.15 * norm(waits) + \n             0.10 * norm(capacity_util))\n    \n    return int(feasible[np.argmin(score)])\n",
  "random_time_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    seed = int(current_node * 73856093) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible))\n",
  "hybrid_savings_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    urgencies = 1.0 / (np.array(slacks) + 1.0)\n    \n    savings_norm = savings / (np.mean(np.abs(savings)) + 1e-9)\n    urgency_norm = urgencies / (np.mean(urgencies) + 1e-9)\n    \n    scores = 0.5 * savings_norm + 0.5 * urgency_norm\n    return int(feasible[np.argmax(scores)])\n",
  "time_density_routing": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    # Count how many other nodes have similar time windows\n    densities = []\n    for node in feasible:\n        tw_start = time_windows[node, 0]\n        tw_end = time_windows[node, 1]\n        # Count nodes with overlapping windows\n        overlaps = 0\n        for other in unvisited_nodes:\n            if other != node:\n                other_start = time_windows[other, 0]\n                other_end = time_windows[other, 1]\n                if not (tw_end < other_start or other_end < tw_start):\n                    overlaps += 1\n        densities.append(overlaps)\n    \n    distances = distance_matrix[current_node, feasible]\n    densities = np.array(densities)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    density_norm = densities / (np.max(densities) + 1e-9)\n    \n    scores = dist_norm - 0.6 * density_norm\n    return int(feasible[np.argmin(scores)])\n",
  "progressive_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    # Progress indicator\n    max_time = np.max(time_windows[:, 1])\n    progress = current_time / (max_time + 1e-9)\n    \n    distances = distance_matrix[current_node, feasible]\n    urgencies = 1.0 / (np.array(slacks) + 1.0)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    urgency_norm = urgencies / (np.mean(urgencies) + 1e-9)\n    \n    # Early: 70% distance, 30% urgency; Late: 30% distance, 70% urgency\n    weight = progress\n    scores = (1 - weight) * 0.7 * dist_norm + weight * 0.7 * urgency_norm\n    \n    return int(feasible[np.argmin(scores)])\n",
  "minmax_normalized_vrptw": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    waits = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n                waits.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n    \n    def minmax(x):\n        mn, mx = x.min(), x.max()\n        if mx - mn < 1e-9:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = (minmax(distances) - minmax(demand_vals) + \n             minmax(urgency) + minmax(waits))\n    \n    return int(feasible[np.argmin(score)])\n",
  "min_time_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    due = time_windows[unv, 1]\n    slack = due - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    slack2 = time_windows[u2, 1] - np.maximum(t + distance_matrix[int(current_node), u2], time_windows[u2, 0])\n    return int(u2[int(np.argmin(slack2))])\n",
  "max_demand_that_fits": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmax(demands[u2]))])\n",
  "capacity_tight_fill": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    left_cap = cap - demands[u2]\n    return int(u2[int(np.argmin(left_cap))])\n",
  "farthest_from_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmax(distance_matrix[int(depot), u2]))])\n",
  "nearest_to_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmin(distance_matrix[int(depot), u2]))])\n",
  "urgent_then_near": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    slack2 = time_windows[u2, 1] - np.maximum(t + d2, time_windows[u2, 0])\n    key = np.lexsort((d2, slack2))\n    return int(u2[int(key[0])])\n",
  "normalized_tradeoff_dist_wait_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1] - start2\n\n    x = d2 + wait2\n    zx = (x - np.mean(x)) / (np.std(x) + 1e-12)\n    zs = (slack2 - np.mean(slack2)) / (np.std(slack2) + 1e-12)\n    score = zx - 0.8 * (-zs)  # penalize larger (less-urgent) slack\n    return int(u2[int(np.argmin(score))])\n",
  "regret2_slack_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    base = -slack2 + 0.05 * d2\n    order = np.argsort(base)\n    best = base[order[0]]\n    second = base[order[1]] if order.size > 1 else best\n    regret = second - best\n    # choose the node corresponding to best (lowest base) but if regret is large, lock it in\n    return int(u2[int(order[0])]) if regret >= 0 else int(u2[int(order[0])])\n",
  "exponential_lateness_risk": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    risk = np.exp(-slack2 / (np.std(slack2) + 1e-9))\n    score = d2 * (1.0 + 2.0 * risk)\n    return int(u2[int(np.argmin(score))])\n",
  "quadratic_wait_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    score = d2 + (wait2 ** 2)\n    return int(u2[int(np.argmin(score))])\n",
  "return_to_depot_aware": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    score = distance_matrix[int(current_node), u2] + distance_matrix[u2, int(depot)]\n    return int(u2[int(np.argmin(score))])\n",
  "mean_distance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    mean_to_others = np.mean(distance_matrix[u2][:, unv], axis=1)\n    score = 0.7 * distance_matrix[int(current_node), u2] + 0.3 * mean_to_others\n    return int(u2[int(np.argmin(score))])\n",
  "median_distance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    med_to_others = np.median(distance_matrix[u2][:, unv], axis=1)\n    score = 0.6 * distance_matrix[int(current_node), u2] + 0.4 * med_to_others\n    return int(u2[int(np.argmin(score))])\n",
  "clarke_wright_savings_like": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcu, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    savings = distance_matrix[int(current_node), int(depot)] + distance_matrix[int(depot), u2] - distance_matrix[int(current_node), u2]\n    # prefer higher savings, slight urgency tie-break\n    slack = time_windows[u2, 1] - np.maximum(t + distance_matrix[int(current_node), u2], time_windows[u2, 0])\n    score = savings + 1e-3 * (-slack)\n    return int(u2[int(np.argmax(score))])\n",
  "widest_time_window_then_near": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    width = time_windows[u2, 1] - time_windows[u2, 0]\n    best_width = np.max(width)\n    cand = u2[width == best_width]\n    if cand.size == 1:\n        return int(cand[0])\n    return int(cand[int(np.argmin(distance_matrix[int(current_node), cand]))])\n",
  "midpoint_service_target": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    mid = 0.5 * (time_windows[u2, 0] + time_windows[u2, 1])\n    score = np.abs(start2 - mid) + 0.1 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "demand_over_slack_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = demands[u2] / (slack2 + 1e-9)\n    return int(u2[int(np.argmax(score))])\n",
  "adaptive_distance_vs_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    # urgency signal: lower slack => higher urgency\n    urg = 1.0 / (slack2 + 1e-9)\n    # adaptive alpha based on how tight things are (relative slack)\n    rel = slack2 / (np.mean(slack2) + 1e-9)\n    alpha = float(np.clip(0.7 - 0.4 * np.mean(rel), 0.2, 0.8))\n    score = alpha * d2 + (1.0 - alpha) * (1.0 / (urg + 1e-9))\n    return int(u2[int(np.argmin(score))])\n",
  "lookahead_two_step_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n    best_u = int(cand[0])\n    best_score = np.inf\n\n    for u in cand:\n        cap1 = cap0 - float(demands[int(u)])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), int(u)], time_windows[int(u), 0]))\n        others = cand[cand != u]\n        if others.size == 0:\n            score = distance_matrix[int(current_node), int(u)]\n        else:\n            darr = t1 + distance_matrix[int(u), others]\n            start_v = np.maximum(darr, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (start_v <= time_windows[others, 1])\n            nxt = np.min(distance_matrix[int(u), others[feas_v]]) if np.any(feas_v) else distance_matrix[int(u), int(depot)]\n            score = distance_matrix[int(current_node), int(u)] + nxt\n        if score < best_score:\n            best_score = score\n            best_u = int(u)\n\n    return int(best_u)\n",
  "pseudo_randomized_tie_break_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    jitter = 1e-6 * np.sin((u2.astype(float) + 1.0) * (t + 1.2345))\n    return int(u2[int(np.argmin(d2 + jitter))])\n",
  "late_window_priority_latest_start": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    latest_start_margin = time_windows[unv, 1] - (t + d)\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    margin2 = time_windows[u2, 1] - (t + d2)\n    return int(u2[int(np.argmin(margin2))])\n",
  "min_distance_with_due_time_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    guard = np.maximum(0.0, (np.quantile(slack2, 0.25) - slack2))\n    score = d2 + 5.0 * guard\n    return int(u2[int(np.argmin(score))])\n",
  "demand_and_urgency_weighted": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1] - start2\n\n    dem = demands[u2].astype(float)\n    demN = (dem - np.min(dem)) / (np.ptp(dem) + 1e-12)\n    urg = 1.0 / (slack2 + 1e-9)\n    urgN = (urg - np.min(urg)) / (np.ptp(urg) + 1e-12)\n    distN = (d2 - np.min(d2)) / (np.ptp(d2) + 1e-12)\n    waitN = (wait2 - np.min(wait2)) / (np.ptp(wait2) + 1e-12)\n\n    score = 1.2 * urgN + 0.8 * demN - 0.9 * distN - 0.5 * waitN\n    return int(u2[int(np.argmax(score))])\n",
  "adaptive_farthest_early_nearest_late": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    n_total = int(max(1, time_windows.shape[0] - 1))\n    progress = 1.0 - (float(unv.size) / float(n_total))\n    alpha = float(np.clip(progress, 0.0, 1.0))\n\n    near = distance_matrix[int(current_node), u2]\n    far = distance_matrix[int(depot), u2]\n    score = (1.0 - alpha) * (-far) + alpha * (-near)\n    return int(u2[int(np.argmax(score))])\n",
  "depot_due_feasibility_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n    depot_due = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    back_time = start2 + distance_matrix[u2, int(depot)]\n    feas2 = back_time <= depot_due\n    if np.any(feas2):\n        u3 = u2[feas2]\n        return int(u3[int(np.argmin(distance_matrix[int(current_node), u3]))])\n    return int(u2[int(np.argmin(distance_matrix[int(current_node), u2]))])\n",
  "time_window_overlap_with_now": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t0 + d\n    start = np.maximum(arr, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t0 + d2\n    start2 = np.maximum(arr2, time_windows[u2, 0])\n    score = np.abs(start2 - t0) + 0.05 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "softmin_distance_times_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    k = 0.5 * (np.mean(slack2) + 1e-9)\n    score = d2 * (1.0 + (k / (slack2 + 1e-9)))\n    return int(u2[int(np.argmin(score))])\n",
  "capacity_and_depot_compactness": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    left_cap = cap - demands[u2].astype(float)\n    cap_term = -np.abs(left_cap)  # closer to 0 is better\n    depot_term = -distance_matrix[int(depot), u2]\n    dist_term = -distance_matrix[int(current_node), u2]\n    score = 0.6 * cap_term + 0.25 * depot_term + 0.15 * dist_term\n    return int(u2[int(np.argmax(score))])\n",
  "time_window_centerline_plus_savings": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    mid = 0.5 * (time_windows[u2, 0] + time_windows[u2, 1])\n    align = -np.abs(start2 - mid)\n    savings = distance_matrix[int(current_node), int(depot)] + distance_matrix[int(depot), u2] - d2\n    score = 0.7 * align + 0.3 * savings\n    return int(u2[int(np.argmax(score))])\n",
  "min_distance_subject_to_slack_quantile": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    thr = np.quantile(slack2, 0.30)\n    urgent = u2[slack2 <= thr]\n    if urgent.size > 0:\n        return int(urgent[int(np.argmin(distance_matrix[int(current_node), urgent]))])\n    return int(u2[int(np.argmin(d2))])\n",
  "maximize_service_start_soon": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    return int(u2[int(np.argmin(start2))])\n",
  "max_slack_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    return int(u2[int(np.argmax(slack2))])\n",
  "min_demand_that_fits": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    return int(u2[int(np.argmin(demands[u2]))])\n",
  "min_detour_plus_wait": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    start = np.maximum(arr, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    detour = d2 + distance_matrix[u2, int(depot)] - distance_matrix[int(current_node), int(depot)]\n    score = detour + wait2\n    return int(u2[int(np.argmin(score))])\n",
  "closest_unvisited_neighbor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    best = int(u2[0])\n    best_dist = np.inf\n    for node in u2:\n        others = unv[unv != node]\n        if others.size == 0:\n            return int(node)\n        dmin = float(np.min(distance_matrix[int(node), others]))\n        if dmin < best_dist:\n            best_dist = dmin\n            best = int(node)\n    return int(best)\n",
  "max_future_feasible_count": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    best = int(u2[0])\n    best_count = -1\n    best_dist = np.inf\n    for node in u2:\n        cap2 = cap - float(demands[int(node)])\n        t2 = float(np.maximum(t + distance_matrix[int(current_node), int(node)], time_windows[int(node), 0]))\n        others = unv[unv != node]\n        if others.size == 0:\n            return int(node)\n        d2 = distance_matrix[int(node), others]\n        start2 = np.maximum(t2 + d2, time_windows[others, 0])\n        feas2 = (demands[others] <= cap2) & (start2 <= time_windows[others, 1])\n        count = int(np.sum(feas2))\n        dist_now = float(distance_matrix[int(current_node), int(node)])\n        if (count > best_count) or (count == best_count and dist_now < best_dist):\n            best_count = count\n            best_dist = dist_now\n            best = int(node)\n    return int(best)\n",
  "due_time_proximity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    due = time_windows[u2, 1]\n    dist = distance_matrix[int(current_node), u2]\n    score = np.abs(due - t) + 1e-6 * dist\n    return int(u2[int(np.argmin(score))])\n",
  "travel_over_slack_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = d2 / (slack2 + 1e-9)\n    return int(u2[int(np.argmin(score))])\n",
  "mean_distance_to_unvisited_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    mean_to_others = np.mean(distance_matrix[u2][:, unv], axis=1)\n    score = mean_to_others - 0.15 * distance_matrix[int(current_node), u2]\n    return int(u2[int(np.argmax(score))])\n",
  "max_future_feasible_successors": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n    best_u = int(cand[0])\n    best_cnt = -1\n    best_tiebreak = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size == 0:\n            cnt = 0\n        else:\n            darr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(darr, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (start_v <= time_windows[others, 1])\n            cnt = int(np.sum(feas_v))\n\n        # tie-break: smaller immediate travel\n        tb = float(distance_matrix[int(current_node), u])\n        if (cnt > best_cnt) or (cnt == best_cnt and tb < best_tiebreak):\n            best_cnt = cnt\n            best_tiebreak = tb\n            best_u = u\n\n    return int(best_u)\n",
  "min_worstcase_next_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n\n    best_u = int(cand[0])\n    best_worst = -np.inf\n    best_tb = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size == 0:\n            worst_slack = np.inf\n        else:\n            arr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(arr, time_windows[others, 0])\n            slack_v = time_windows[others, 1] - start_v\n            feas_v = (demands[others] <= cap1) & (slack_v >= 0)\n            if not np.any(feas_v):\n                worst_slack = -np.inf\n            else:\n                worst_slack = float(np.min(slack_v[feas_v]))\n\n        tb = float(distance_matrix[int(current_node), u])\n        if (worst_slack > best_worst) or (worst_slack == best_worst and tb < best_tb):\n            best_worst = worst_slack\n            best_tb = tb\n            best_u = u\n\n    return int(best_u)\n",
  "savings_ratio_preference": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcu, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d_cur_depot = float(distance_matrix[int(current_node), int(depot)])\n    d_depot_u = distance_matrix[int(depot), u2]\n    d_cur_u = distance_matrix[int(current_node), u2]\n\n    savings = d_cur_depot + d_depot_u - d_cur_u\n    score = savings / (d_cur_u + 1e-9)\n\n    # mild penalty for tiny slack to avoid brittle picks\n    start2 = np.maximum(t + d_cur_u, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = score - 1e-3 * (1.0 / (slack2 + 1.0))\n\n    return int(u2[int(np.argmax(score))])\n",
  "overlap_length_density": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    s = time_windows[u2, 0].astype(float)\n    e = time_windows[u2, 1].astype(float)\n\n    # overlap length matrix (vectorized): sum_j max(0, min(e_i,e_j) - max(s_i,s_j))\n    min_end = np.minimum(e[:, None], e[None, :])\n    max_start = np.maximum(s[:, None], s[None, :])\n    overlap = np.maximum(0.0, min_end - max_start)\n    overlap_sum = np.sum(overlap, axis=1) - np.diag(overlap)  # exclude self\n\n    dist = distance_matrix[int(current_node), u2]\n    # prefer high overlap, tie-break by shorter distance\n    score = overlap_sum - 0.25 * dist\n    return int(u2[int(np.argmax(score))])\n",
  "capacity_quantile_switch_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    dem = demands[u2].astype(float)\n\n    # scarcity proxy: where does cap sit in the demand distribution of remaining customers?\n    all_dem = demands[unv].astype(float)\n    q80 = float(np.quantile(all_dem, 0.80)) if all_dem.size > 0 else 0.0\n\n    # if cap is below a high-demand quantile, conserve capacity; otherwise, fill aggressively\n    if cap <= q80:\n        # conserve: smallest demand, tie-break by travel\n        dm = dem\n        d2 = distance_matrix[int(current_node), u2]\n        key = np.lexsort((d2, dm))\n        return int(u2[int(key[0])])\n    else:\n        # fill: largest demand, tie-break by travel\n        dm = -dem\n        d2 = distance_matrix[int(current_node), u2]\n        key = np.lexsort((d2, dm))\n        return int(u2[int(key[0])])\n",
  "variance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    # variance of distances from candidate to all unvisited (including infeasible ones as spatial context)\n    dist_mat = distance_matrix[u2][:, unv].astype(float)\n    var = np.var(dist_mat, axis=1)\n\n    # tie-break: shorter from current\n    d2 = distance_matrix[int(current_node), u2].astype(float)\n    score = var + 1e-3 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "deadline_weighted_by_wait": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n\n    due = time_windows[u2, 1].astype(float)\n\n    # smaller due is better, but large wait reduces priority\n    score = due + 0.8 * wait2 + 0.05 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "k_nearest_feasible_then_best_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n\n    k = int(min(5, u2.size))\n    rcl = u2[np.argpartition(d2, k - 1)[:k]]\n\n    d3 = distance_matrix[int(current_node), rcl]\n    start3 = np.maximum(t0 + d3, time_windows[rcl, 0])\n    slack3 = time_windows[rcl, 1] - start3\n\n    # smallest slack in RCL; tie-break by distance\n    key = np.lexsort((d3, slack3))\n    return int(rcl[int(key[0])])\n",
  "feasible_pareto_rank_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n\n    d2 = distance_matrix[int(current_node), u2].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1].astype(float) - start2\n    dem2 = demands[u2].astype(float)\n\n    # Objectives to minimize: [distance, wait, -demand, -slack] (i.e., prefer big demand and big slack)\n    obj = np.vstack([d2, wait2, -dem2, -slack2]).T\n\n    n = obj.shape[0]\n    rank = np.zeros(n, dtype=int)\n    for i in range(n):\n        dominated_by = 0\n        for j in range(n):\n            if i == j:\n                continue\n            # j dominates i if <= in all and < in at least one\n            le_all = np.all(obj[j] <= obj[i] + 1e-12)\n            lt_any = np.any(obj[j] < obj[i] - 1e-12)\n            if le_all and lt_any:\n                dominated_by += 1\n        rank[i] = dominated_by\n\n    best_rank = np.min(rank)\n    idx = np.where(rank == best_rank)[0]\n    if idx.size == 1:\n        return int(u2[int(idx[0])])\n\n    # tie-break within best front by smallest distance\n    pick = idx[int(np.argmin(d2[idx]))]\n    return int(u2[int(pick)])\n",
  "return_feasibility_margin_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n\n    # depot due might be finite (some instances encode it); if not, treat as infinity\n    depot_due = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n    back = distance_matrix[u2, int(depot)].astype(float)\n\n    # margin after serving u (ignores service times): depot_due - (service_start_u + travel_back)\n    margin_depot = depot_due - (start2 + back)\n\n    # if depot_due is inf, margin_depot is inf; then use own-due margin instead\n    if not np.isfinite(depot_due):\n        margin = time_windows[u2, 1].astype(float) - start2\n    else:\n        margin = margin_depot\n\n    # maximize margin; tie-break by shorter (to u + u to depot)\n    tie = (d2 + back)\n    key = np.lexsort((tie, -margin))\n    return int(u2[int(key[0])])\n",
  "min_avg_distance_to_remaining": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    # average distance from candidate to all remaining (including infeasible for spatial context)\n    dm = distance_matrix[cand][:, unv].astype(float)\n    avgd = np.mean(dm, axis=1)\n    # tie-break by closer from current\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, avgd))\n    return int(cand[int(key[0])])\n",
  "min_k_nearest_sum_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    k = int(min(5, unv.size))\n\n    costs = np.empty(cand.size, dtype=float)\n    for i, u in enumerate(cand):\n        dist_u = distance_matrix[int(u), unv].astype(float)\n        idx = np.argpartition(dist_u, k - 1)[:k]\n        costs[i] = float(np.sum(dist_u[idx]))\n\n    # tie-break by distance from current\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, costs))\n    return int(cand[int(key[0])])\n",
  "max_feasible_density_within_percentile_radius": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n\n    best = int(cand[0])\n    best_cnt = -1\n    best_tb = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size == 0:\n            cnt = 0\n        else:\n            dist = distance_matrix[u, others].astype(float)\n            r = float(np.quantile(dist, 0.25)) if dist.size > 0 else 0.0\n            near = others[dist <= r]\n            if near.size == 0:\n                cnt = 0\n            else:\n                arr = t1 + distance_matrix[u, near]\n                start_v = np.maximum(arr, time_windows[near, 0])\n                feas_v = (demands[near] <= cap1) & (start_v <= time_windows[near, 1])\n                cnt = int(np.sum(feas_v))\n\n        tb = float(distance_matrix[int(current_node), u])\n        if (cnt > best_cnt) or (cnt == best_cnt and tb < best_tb):\n            best_cnt = cnt\n            best_tb = tb\n            best = u\n\n    return int(best)\n",
  "regret_two_step_best_vs_second": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n\n    best_u = int(cand[0])\n    best_regret = -np.inf\n    best_tb = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size < 2:\n            regret = -np.inf\n        else:\n            arr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(arr, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (start_v <= time_windows[others, 1])\n            feas_list = others[feas_v]\n            if feas_list.size < 2:\n                regret = -np.inf\n            else:\n                # next-step cost: travel + waiting\n                dv = distance_matrix[u, feas_list].astype(float)\n                arr2 = t1 + dv\n                wait2 = np.maximum(0.0, time_windows[feas_list, 0].astype(float) - arr2)\n                cost = dv + wait2\n                # regret = 2nd best - best\n                idx = np.argpartition(cost, 1)[:2]\n                a, b = float(np.min(cost[idx])), float(np.max(cost[idx]))\n                regret = b - a\n\n        tb = float(distance_matrix[int(current_node), u])\n        if (regret > best_regret) or (regret == best_regret and tb < best_tb):\n            best_regret = regret\n            best_tb = tb\n            best_u = u\n\n    if not np.isfinite(best_regret):\n        # fallback: nearest feasible\n        d2 = distance_matrix[int(current_node), cand].astype(float)\n        return int(cand[int(np.argmin(d2))])\n\n    return int(best_u)\n",
  "dynamic_lambda_distance_vs_slack_by_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + dcur, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    due_med = float(np.median(time_windows[unv, 1].astype(float)))\n    # lambda in [0.2, 0.9] increases as time approaches (or exceeds) due_med\n    x = (t - due_med) / (abs(due_med) + 1.0)\n    lam = float(np.clip(0.55 + 0.35 * np.tanh(x), 0.2, 0.9))\n\n    # minimize: lam*distance + (1-lam)*(-urgency) where urgency = 1/(slack+1)\n    urgency = 1.0 / (slack2 + 1.0)\n    score = lam * d2 + (1.0 - lam) * urgency\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_wait_to_avoid_early_idle": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    # maximize wait, but keep some safety by adding small slack preference\n    score = wait2 + 1e-3 * slack2\n    return int(cand[int(np.argmax(score))])\n",
  "radial_continuity_to_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    r0 = float(distance_matrix[int(depot), int(current_node)])\n    r = distance_matrix[int(depot), cand].astype(float)\n    band = np.abs(r - r0)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, band))\n    return int(cand[int(key[0])])\n",
  "min_distance_plus_quadratic_wait": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n\n    score = d2 + wait2 * wait2\n    return int(cand[int(np.argmin(score))])\n",
  "max_product_slack_and_postcap": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n    feas = (demands[unv] <= cap0) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    postcap = cap0 - demands[cand].astype(float)\n\n    score = (slack2 + 1.0) * (postcap + 1.0)\n    # tie-break by shorter distance\n    key = np.lexsort((d2, -score))\n    return int(cand[int(key[0])])\n",
  "min_distance_scaled_by_window_narrowness": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    width = (time_windows[cand, 1] - time_windows[cand, 0]).astype(float)\n\n    scale = 1.0 + 1.0 / (width + 1.0)\n    score = d2 * scale\n    return int(cand[int(np.argmin(score))])\n",
  "earliest_open_time_then_shortest_travel": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    open_t = time_windows[cand, 0].astype(float)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n\n    key = np.lexsort((d2, open_t))\n    return int(cand[int(key[0])])\n",
  "min_due_minus_start_gap": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    gap = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (gap >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    gap2 = time_windows[cand, 1].astype(float) - start2\n\n    key = np.lexsort((d2, gap2))\n    return int(cand[int(key[0])])\n",
  "maximize_depot_return_margin_after_visit": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n\n    depot_due = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t0 + d2, time_windows[cand, 0].astype(float))\n    back = distance_matrix[cand, int(depot)].astype(float)\n\n    if np.isfinite(depot_due):\n        margin = depot_due - (start2 + back)\n        # maximize margin; tie-break shorter current->u\n        key = np.lexsort((d2, -margin))\n        return int(cand[int(key[0])])\n\n    # if no meaningful depot due, prefer closer to depot after visit, tie-break by current->u\n    key = np.lexsort((d2, back))\n    return int(cand[int(key[0])])\n",
  "two_stage_filter_by_open_quantile_then_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    opens = time_windows[cand, 0].astype(float)\n    thr = float(np.quantile(opens, 0.40)) if cand.size > 1 else float(opens[0])\n    filt = cand[opens <= thr]\n    if filt.size == 0:\n        filt = cand\n\n    dem = demands[filt].astype(float)\n    d2 = distance_matrix[int(current_node), filt].astype(float)\n    key = np.lexsort((d2, -dem))\n    return int(filt[int(key[0])])\n",
  "min_detour_minus_wait_credit": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + dcu\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d1 = distance_matrix[int(current_node), cand].astype(float)\n    d2 = distance_matrix[cand, int(depot)].astype(float)\n    direct = float(distance_matrix[int(current_node), int(depot)])\n\n    arr2 = t + d1\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n\n    detour = d1 + d2 - direct\n    beta = 0.7\n    score = detour - beta * wait2\n    return int(cand[int(np.argmin(score))])\n",
  "min_bottleneck_to_k_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    k = int(min(5, unv.size))\n\n    bott = np.empty(cand.size, dtype=float)\n    for i, u in enumerate(cand):\n        dist_u = distance_matrix[int(u), unv].astype(float)\n        idx = np.argpartition(dist_u, k - 1)[:k]\n        bott[i] = float(np.max(dist_u[idx]))\n\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, bott))\n    return int(cand[int(key[0])])\n",
  "deadline_alignment_with_neighborhood": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + dcur, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    k = int(min(5, unv.size))\n\n    align = np.empty(cand.size, dtype=float)\n    due_all = time_windows[unv, 1].astype(float)\n\n    for i, u in enumerate(cand):\n        dist_u = distance_matrix[int(u), unv].astype(float)\n        idx = np.argpartition(dist_u, k - 1)[:k]\n        neigh_due_mean = float(np.mean(due_all[idx]))\n        align[i] = abs(float(time_windows[int(u), 1]) - neigh_due_mean)\n\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, align))\n    return int(cand[int(key[0])])\n",
  "capacity_smoothing_to_median_remaining_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    med_dem = float(np.median(demands[unv].astype(float))) if unv.size > 0 else 0.0\n\n    postcap = cap0 - demands[cand].astype(float)\n    diff = np.abs(postcap - med_dem)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, diff))\n    return int(cand[int(key[0])])\n",
  "maximize_slack_minus_distance_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    alpha = 0.35\n    score = slack2 - alpha * d2\n    return int(cand[int(np.argmax(score))])\n",
  "min_distance_with_deadline_soft_barrier": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    scale = max(1.0, float(np.median(slack2 + 1.0)))\n    gamma = 2.0\n    barrier = np.exp(-slack2 / scale)\n    score = d2 + gamma * barrier\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_demand_per_extra_time_budget": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n\n    score = demands[cand].astype(float) / (d2 + wait2 + 1.0)\n    return int(cand[int(np.argmax(score))])\n",
  "median_due_time_proximity_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    med_due = float(np.median(time_windows[unv, 1].astype(float)))\n    diff = np.abs(time_windows[cand, 1].astype(float) - med_due)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, diff))\n    return int(cand[int(key[0])])\n",
  "depot_distance_balance_to_remaining_mean": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    depot_d_all = distance_matrix[int(depot), unv].astype(float)\n    target = float(np.mean(depot_d_all)) if depot_d_all.size > 0 else 0.0\n\n    depot_d = distance_matrix[int(depot), cand].astype(float)\n    diff = np.abs(depot_d - target)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n\n    key = np.lexsort((d2, diff))\n    return int(cand[int(key[0])])\n",
  "min_distance_with_postcap_parity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + dcur, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    postcap = cap0 - demands[cand].astype(float)\n\n    target = 0.5 * cap0\n    parity = np.abs(postcap - target)\n\n    score = d2 + 0.25 * parity\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_time_window_intersection_with_now": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + dcur, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n\n    # horizon based on median remaining window width\n    width_all = (time_windows[unv, 1] - time_windows[unv, 0]).astype(float)\n    horizon = float(np.median(width_all)) if width_all.size > 0 else 0.0\n    horizon = max(1.0, horizon)\n\n    a = np.maximum(time_windows[cand, 0].astype(float), t)\n    b = np.minimum(time_windows[cand, 1].astype(float), t + horizon)\n    inter = np.maximum(0.0, b - a)\n\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, -inter))\n    return int(cand[int(key[0])])\n",
  "min_normalized_lateness_risk_index": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    risk = (d2 + wait2) / (slack2 + 1.0)\n    return int(cand[int(np.argmin(risk))])\n",
  "maximize_slack_to_window_width_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n    width = (time_windows[unv, 1] - time_windows[unv, 0]).astype(float)\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    width2 = (time_windows[cand, 1] - time_windows[cand, 0]).astype(float)\n\n    score = slack2 / (width2 + 1.0)\n    return int(cand[int(np.argmax(score))])\n",
  "min_distance_with_capacity_urgency_coupling": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap0) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    frac = demands[cand].astype(float) / (cap0 + 1e-9)\n    eta = 3.0\n    score = d2 + eta * frac * (1.0 / (slack2 + 1.0))\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_distance_then_feasibility_safety": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    # farthest first, then larger slack\n    key = np.lexsort((-slack2, -d2))\n    return int(cand[int(key[0])])\n",
  "min_distance_to_depot_plus_slack_bonus": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    back = distance_matrix[cand, int(depot)].astype(float)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    score = back - 0.15 * slack2\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_joint_savings_and_time_alignment": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t0 + d2, time_windows[cand, 0].astype(float))\n\n    mid = 0.5 * (time_windows[cand, 0].astype(float) + time_windows[cand, 1].astype(float))\n    scale = max(1.0, float(np.median(np.abs(start2 - mid) + 1.0)))\n    align = np.exp(-np.abs(start2 - mid) / scale)\n\n    savings = float(distance_matrix[int(current_node), int(depot)]) + distance_matrix[int(depot), cand].astype(float) - d2\n    score = savings * align\n\n    # tie-break by higher slack\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    key = np.lexsort((-slack2, -score))\n    return int(cand[int(key[0])])\n",
  "min_distance_with_future_capacity_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    postcap = cap0 - demands[cand].astype(float)\n\n    q20 = float(np.quantile(demands[unv].astype(float), 0.20)) if unv.size > 0 else 0.0\n    penalty = np.where(postcap < q20, (q20 - postcap), 0.0)\n\n    score = d2 + 0.6 * penalty\n    return int(cand[int(np.argmin(score))])\n",
  "nearest_feasible_aug_0": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # rename for brevity\n    cap = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n    tw = time_windows\n\n    # distances from current node to all candidates\n    dists = np.clip(dist_mat[current_node, unvisited_nodes], 1e-12, np.inf)\n\n    # arrival times and feasibility checks\n    arrivals = current_time + dists\n    feasible_mask = (dem[unvisited_nodes] <= cap) & (arrivals <= tw[unvisited_nodes, 1])\n\n    cand = unvisited_nodes[feasible_mask]\n    if cand.size == 0:\n        return depot\n\n    feasible_dists = dists[feasible_mask]\n    # add tiny epsilon to avoid zero division in argmin\n    idx = np.argmin(feasible_dists + 1e-12)\n    return int(cand[idx])\n\n",
  "nearest_feasible_aug_1": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n    tw = time_windows\n\n    dists = np.clip(dist_mat[current_node, unvisited_nodes], 0, np.inf)\n    arrivals = current_time + dists\n    mask = (dem[unvisited_nodes] <= cap) & (arrivals <= tw[unvisited_nodes, 1])\n\n    cand = unvisited_nodes[mask]\n    if cand.size == 0:\n        return depot\n\n    feasible_dists = dists[mask]\n    # soft\u2011min weights\n    beta = 5.0\n    w = np.exp(-beta * feasible_dists)\n    w = w / (np.sum(w) + 1e-12)\n\n    # pick top\u2011k nodes\n    top_k = min(7, cand.size)\n    top_idx = np.argpartition(-feasible_dists, top_k - 1)[:top_k]\n    top_nodes = cand[top_idx]\n    top_w = w[top_idx]\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(top_nodes.size) * 1e-6\n    top_w += noise\n    top_w = top_w / (np.sum(top_w) + 1e-12)\n\n    chosen = np.random.choice(top_nodes, p=top_w)\n    return int(chosen)\n\n",
  "nearest_feasible_aug_2": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n    tw = time_windows\n\n    dists = np.clip(dist_mat[current_node, unvisited_nodes], 0, np.inf)\n    arrivals = current_time + dists\n    mask = (dem[unvisited_nodes] <= cap) & (arrivals <= tw[unvisited_nodes, 1])\n\n    cand = unvisited_nodes[mask]\n    if cand.size == 0:\n        return depot\n\n    feasible_dists = dists[mask]\n    # median distance\n    med = np.median(feasible_dists)\n    diff = np.abs(feasible_dists - med)\n\n    # deterministic noise to break ties\n    noise = np.arange(cand.size) * 1e-6\n    diff += noise\n\n    idx = np.argmin(diff)\n    return int(cand[idx])\n\n",
  "nearest_feasible_aug_3": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n    tw = time_windows\n\n    dists = np.clip(dist_mat[current_node, unvisited_nodes], 0, np.inf)\n    arrivals = current_time + dists\n    mask = (dem[unvisited_nodes] <= cap) & (arrivals <= tw[unvisited_nodes, 1])\n\n    cand = unvisited_nodes[mask]\n    if cand.size == 0:\n        return depot\n\n    feasible_dists = dists[mask]\n    slack = np.clip(tw[cand, 1] - arrivals[mask], 0, 1e6)\n\n    # weighted cost\n    cost = 0.6 * feasible_dists + 0.4 * slack\n\n    # softmax over negative cost\n    beta = 10.0\n    exp_vals = np.exp(-beta * cost)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # top\u2011k candidates\n    top_k = min(5, cand.size)\n    top_idx = np.argpartition(cost, top_k - 1)[:top_k]\n    top_nodes = cand[top_idx]\n    top_probs = probs[top_idx]\n\n    # deterministic noise\n    noise = np.arange(top_nodes.size) * 1e-6\n    top_probs += noise\n    top_probs = top_probs / (np.sum(top_probs) + 1e-12)\n\n    chosen = np.random.choice(top_nodes, p=top_probs)\n    return int(chosen)\n\n",
  "earliest_deadline_first_aug_4": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # rename for readability\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap_rem = rest_capacity\n    t_curr = current_time\n    dmd = demands\n    tw = time_windows\n\n    # feasibility masks\n    mask_dmd = dmd[candidates] <= cap_rem\n    arrival = t_curr + dist_mat[current_node, candidates]\n    mask_deadline = arrival <= tw[candidates, 1]\n    feasible_mask = mask_dmd & mask_deadline\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n    deadlines = tw[feasible_nodes, 1]\n\n    # deterministic tie\u2011breaking by adding tiny increasing noise\n    noise = 1e-6 * np.arange(len(deadlines))\n    scores = deadlines + noise\n    chosen = feasible_nodes[np.argmin(scores)]\n    return int(chosen)\n\n",
  "earliest_deadline_first_aug_5": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # rename for clarity\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes.copy()\n    cap_rem = rest_capacity\n    t_curr = current_time\n    dmd = demands\n    tw = time_windows\n\n    feasible_nodes = []\n    idx = 0\n    while idx < candidates.size:\n        node = int(candidates[idx])\n        if dmd[node] <= cap_rem:\n            arrival = t_curr + dist_mat[current_node, node]\n            if arrival <= tw[node, 1]:\n                feasible_nodes.append(node)\n        idx += 1\n\n    if not feasible_nodes:\n        return depot\n\n    # weighted softmin over distance and deadline slack\n    distances = np.array([dist_mat[current_node, n] for n in feasible_nodes])\n    deadlines = np.array([tw[n, 1] for n in feasible_nodes])\n    slacks = deadlines - t_curr\n\n    tau = 0.5\n    scores = 0.6 * distances + 0.4 * slacks\n    exp_vals = np.exp(-scores / (tau + 1e-12))\n    denom = np.sum(exp_vals) + 1e-12\n    probs = exp_vals / denom\n\n    chosen = feasible_nodes[int(np.random.choice(len(feasible_nodes), p=probs))]\n    return int(chosen)\n\n",
  "earliest_deadline_first_aug_6": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    cap_rem = rest_capacity\n    t_curr = current_time\n    dmd = demands\n    tw = time_windows\n\n    # build list of feasible nodes\n    feasible = [n for n in unvisited_nodes\n                if dmd[n] <= cap_rem and\n                t_curr + dist_mat[current_node, n] <= tw[n, 1]]\n\n    if not feasible:\n        return depot\n\n    deadlines = np.array([tw[n, 1] for n in feasible])\n    median_deadline = np.median(deadlines)\n\n    # absolute difference from median + deterministic noise\n    diff = np.abs(deadlines - median_deadline)\n    noise = 1e-7 * np.arange(len(diff))\n    scores = diff + noise\n\n    chosen = feasible[np.argmin(scores)]\n    return int(chosen)\n\n",
  "earliest_deadline_first_aug_7": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap_rem = rest_capacity\n    t_curr = current_time\n    dmd = demands\n    tw = time_windows\n\n    # feasibility masks\n    mask_dmd = dmd[candidates] <= cap_rem\n    arrival = t_curr + dist_mat[current_node, candidates]\n    mask_deadline = arrival <= tw[candidates, 1]\n    feasible_mask = mask_dmd & mask_deadline\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n    deadlines = tw[feasible_nodes, 1]\n\n    # select top_k nodes by earliest deadlines\n    top_k = 7\n    top_k = min(top_k, len(deadlines))\n    idx_sorted = np.argsort(deadlines)\n    top_nodes = feasible_nodes[idx_sorted[:top_k]]\n\n    # deterministic random choice using a fixed seed\n    rng = np.random.default_rng(seed=42)\n    chosen = rng.choice(top_nodes)\n    return int(chosen)\n\n",
  "minimum_slack_time_aug_8": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasibility mask: capacity and time\u2011window constraints\n    feasible = (demands[unvisited_nodes] <= rest_capacity) & \\\n               (current_time + distance_matrix[current_node, unvisited_nodes] <= time_windows[unvisited_nodes, 1])\n\n    feasible_nodes = unvisited_nodes[feasible]\n    if feasible_nodes.size == 0:\n        return depot\n\n    arrivals = current_time + distance_matrix[current_node, feasible_nodes]\n    slacks = np.clip(time_windows[feasible_nodes, 1] - arrivals, 0, None)\n\n    # Small deterministic noise for tie breaking\n    noise = np.random.uniform(0, 1e-8, size=slacks.shape)\n    slacks += noise\n\n    idx = np.argmin(slacks)\n    return int(feasible_nodes[idx])\n\n",
  "minimum_slack_time_aug_9": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = (demands[unvisited_nodes] <= rest_capacity) & \\\n               (current_time + distance_matrix[current_node, unvisited_nodes] <= time_windows[unvisited_nodes, 1])\n    feasible_nodes = unvisited_nodes[feasible]\n    if feasible_nodes.size == 0:\n        return depot\n\n    arrivals = current_time + distance_matrix[current_node, feasible_nodes]\n    slacks = np.clip(time_windows[feasible_nodes, 1] - arrivals, 0, None)\n\n    # Soft\u2011min probability (higher probability for tighter deadlines)\n    probs = np.exp(-slacks)\n    probs = probs / (np.sum(probs) + 1e-12)  # epsilon to avoid division by zero\n\n    chosen = np.random.choice(feasible_nodes, p=probs)\n    return int(chosen)\n\n",
  "minimum_slack_time_aug_10": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = (demands[unvisited_nodes] <= rest_capacity) & \\\n               (current_time + distance_matrix[current_node, unvisited_nodes] <= time_windows[unvisited_nodes, 1])\n    feasible_nodes = unvisited_nodes[feasible]\n    if feasible_nodes.size == 0:\n        return depot\n\n    arrivals = current_time + distance_matrix[current_node, feasible_nodes]\n    slacks = np.clip(time_windows[feasible_nodes, 1] - arrivals, 0, None)\n\n    # Select the k nodes with the smallest slack (k=5)\n    k = 5\n    if feasible_nodes.size <= k:\n        candidates = feasible_nodes\n    else:\n        idx_k = np.argpartition(slacks, k - 1)[:k]\n        candidates = feasible_nodes[idx_k]\n\n    # Among the candidates choose the one with minimal distance\n    dists = distance_matrix[current_node, candidates]\n    idx = np.argmin(dists)\n    return int(candidates[idx])\n\n",
  "minimum_slack_time_aug_11": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = (demands[unvisited_nodes] <= rest_capacity) & \\\n               (current_time + distance_matrix[current_node, unvisited_nodes] <= time_windows[unvisited_nodes, 1])\n    feasible_nodes = unvisited_nodes[feasible]\n    if feasible_nodes.size == 0:\n        return depot\n\n    arrivals = current_time + distance_matrix[current_node, feasible_nodes]\n    slacks = np.clip(time_windows[feasible_nodes, 1] - arrivals, 0, None)\n\n    # Scoring: 0.6 * distance + 0.4 * slack\n    weight_dist = 0.6\n    weight_slack = 0.4\n    scores = weight_dist * distance_matrix[current_node, feasible_nodes] + \\\n             weight_slack * slacks\n    scores = np.clip(scores, 0, None)\n\n    idx = np.argmin(scores)\n    return int(feasible_nodes[idx])\n\n",
  "earliest_start_time_aug_12": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # Ensure capacity is non\u2011negative\n    rest_capacity = np.clip(rest_capacity, 0, None)\n\n    # Candidate mask based on demand and time\u2011window feasibility\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity) & (\n        current_time + distance_matrix[current_node, unvisited_nodes] <=\n        time_windows[unvisited_nodes, 1]\n    )\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    start_times = time_windows[feasible_nodes, 0]\n    # Add tiny deterministic noise to avoid exact ties\n    start_times += np.random.uniform(0, 1e-6, size=start_times.shape)\n    return int(feasible_nodes[np.argmin(start_times)])\n\n",
  "earliest_start_time_aug_13": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    rest_capacity = np.clip(rest_capacity, 0, None)\n\n    distances = distance_matrix[current_node, unvisited_nodes]\n    arrival = current_time + distances\n    slack = np.clip(time_windows[unvisited_nodes, 1] - arrival, 0, None)\n\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity) & (slack > 0)\n    if not np.any(feasible_mask):\n        return depot\n\n    candidates = unvisited_nodes[feasible_mask]\n    dist_f = distances[feasible_mask]\n    slack_f = slack[feasible_mask]\n\n    # Scoring: weighted distance + slack\n    score = 0.6 * dist_f + 0.4 * slack_f\n    # Soft\u2011min weighting\n    temperature = 0.1\n    weights = np.exp(-score / (temperature + 1e-12))\n    probs = weights / (np.sum(weights) + 1e-12)\n\n    # Sample a node according to the probabilities\n    chosen_idx = np.random.choice(len(candidates), p=probs)\n    return int(candidates[chosen_idx])\n\n",
  "earliest_start_time_aug_14": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    rest_capacity = np.clip(rest_capacity, 0, None)\n\n    distances = distance_matrix[current_node, unvisited_nodes]\n    arrival = current_time + distances\n    infeasible_mask = (demands[unvisited_nodes] > rest_capacity) | \\\n                      (arrival > time_windows[unvisited_nodes, 1])\n\n    feasible_mask = ~infeasible_mask\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    start_times = time_windows[feasible_nodes, 0]\n\n    # Use median start time for deterministic tie breaking\n    median_start = np.median(start_times)\n    indices = np.where(start_times == median_start)[0]\n    if len(indices) == 0:\n        chosen_idx = np.argmin(start_times)\n    else:\n        chosen_idx = indices[0]\n\n    return int(feasible_nodes[chosen_idx])\n\n",
  "earliest_start_time_aug_15": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    rest_capacity = np.clip(rest_capacity, 0, None)\n\n    distances = distance_matrix[current_node, unvisited_nodes]\n    distances_sq = np.square(distances)\n    arrival = current_time + distances\n    slack = np.clip(time_windows[unvisited_nodes, 1] - arrival, 0, None)\n\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity) & (slack > 0)\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    feasible_sq = distances_sq[feasible_mask]\n\n    top_k = min(7, len(feasible_nodes))\n    top_indices = np.argsort(feasible_sq)[:top_k]\n    top_nodes = feasible_nodes[top_indices]\n    top_costs = feasible_sq[top_indices]\n\n    # Inverse\u2011cost weighting with epsilon in denominator\n    weights = 1.0 / (top_costs + 1e-12)\n    probs = weights / (np.sum(weights) + 1e-12)\n\n    chosen = np.random.choice(top_nodes, p=probs)\n    return int(chosen)\n\n",
  "minimize_wait_time_aug_16": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasibility mask\n    node_idx = unvisited_nodes\n    cap_ok = demands[node_idx] <= rest_capacity\n    arrivals = current_time + distance_matrix[current_node, node_idx]\n    time_ok = arrivals <= time_windows[node_idx, 1]\n    feasible = cap_ok & time_ok\n\n    if not np.any(feasible):\n        return depot\n\n    # Extract feasible data\n    f_nodes = node_idx[feasible]\n    f_arrivals = arrivals[feasible]\n    f_start = time_windows[f_nodes, 0]\n\n    # Compute wait times and distances\n    wait = np.maximum(0, f_start - f_arrivals)\n    wait = np.clip(wait, 0, None)\n    dist = distance_matrix[current_node, f_nodes]\n\n    # Weighted score (tuned)\n    score = 0.7 * wait + 0.3 * dist\n\n    # Small deterministic noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=score.shape)\n    score += noise\n\n    # Soft\u2011min probabilities\n    tau = 0.5\n    exp_vals = np.exp(-score / tau)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)   # epsilon to avoid div\u2011by\u2011zero\n\n    chosen = np.random.choice(f_nodes, p=probs)\n    return int(chosen)\n\n",
  "minimize_wait_time_aug_17": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    feasible = []\n    waits   = []\n    idx = 0\n    while idx < len(unvisited_nodes):\n        node = unvisited_nodes[idx]\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node, 1]:\n                feasible.append(node)\n                wait = max(0, time_windows[node, 0] - arrival)\n                wait += node * 1e-9          # deterministic noise\n                waits.append(wait)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    wait_arr = np.clip(np.array(waits), 0, None)\n    chosen = feasible[np.argmin(wait_arr)]\n    return int(chosen)\n\n",
  "minimize_wait_time_aug_18": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible_nodes = []\n    wait_times     = []\n\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node, 1]:\n                wait = max(0, time_windows[node, 0] - arrival)\n                wait += node * 1e-9          # deterministic noise\n                feasible_nodes.append(node)\n                wait_times.append(wait)\n\n    if not feasible_nodes:\n        return depot\n\n    wait_arr = np.clip(np.array(wait_times), 0, None)\n\n    # Top\u2011k tuning\n    top_k = 7\n    if len(wait_arr) <= top_k:\n        candidates = feasible_nodes\n    else:\n        idxs = np.argpartition(wait_arr, top_k)[:top_k]\n        candidates = [feasible_nodes[i] for i in idxs]\n\n    chosen = np.random.choice(candidates)\n    return int(chosen)\n\n",
  "minimize_wait_time_aug_19": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible_nodes = []\n    scores = []\n\n    for node in unvisited_nodes:\n        if demands[node] > rest_capacity:\n            continue\n        arrival = current_time + distance_matrix[current_node, node]\n        if arrival > time_windows[node, 1]:\n            continue\n        wait = max(0, time_windows[node, 0] - arrival)\n        dist = distance_matrix[current_node, node]\n        # Tuned weighted score\n        score = 0.6 * wait + 0.4 * dist\n        score += node * 1e-9          # deterministic noise\n        feasible_nodes.append(node)\n        scores.append(score)\n\n    if not feasible_nodes:\n        return depot\n\n    scores = np.array(scores)\n    # Soft\u2011min probabilities with temperature\n    exp_vals = np.exp(-scores / 0.3)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)   # epsilon\n    probs = np.clip(probs, 1e-12, None)             # bound probabilities\n\n    chosen = np.random.choice(feasible_nodes, p=probs)\n    return int(chosen)\n\n",
  "time_distance_weighted_aug_20": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Arrival times to every candidate\n    arrival_times = current_time + distance_matrix[current_node, unvisited_nodes]\n\n    # Feasibility mask\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity) & \\\n                    (arrival_times <= time_windows[unvisited_nodes, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    feasible_arrivals = arrival_times[feasible_mask]\n\n    distances = distance_matrix[current_node, feasible_nodes]\n    slacks = time_windows[feasible_nodes, 1] - feasible_arrivals\n\n    # Normalise with median to reduce influence of outliers\n    dist_norm = distances / (np.median(distances) + 1e-12)\n    slack_norm = slacks / (np.median(slacks) + 1e-12)\n    slack_norm = np.clip(slack_norm, 1e-12, None)          # avoid division by zero\n\n    # Score: 70\u202f% distance, 30\u202f% urgency (reciprocal slack)\n    scores = 0.7 * dist_norm + 0.3 * (1.0 / (slack_norm + 1e-12))\n\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-6 * feasible_nodes\n    scores += noise\n\n    chosen_idx = np.argmin(scores)\n    return int(feasible_nodes[chosen_idx])\n\n",
  "time_distance_weighted_aug_21": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    feasible = []\n    slacks = []\n    idx = 0\n    while idx < len(unvisited_nodes):\n        node = unvisited_nodes[idx]\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node, 1]:\n                feasible.append(node)\n                slacks.append(time_windows[node, 1] - arrival)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    distances = distance_matrix[current_node, feasible]\n    slacks_arr = np.array(slacks)\n\n    # Sum\u2011based normalisation\n    dist_norm = distances / (np.sum(distances) + 1e-12)\n    slack_norm = slacks_arr / (np.sum(slacks_arr) + 1e-12)\n    slack_norm = np.clip(slack_norm, 1e-12, None)\n\n    # Score: 40\u202f% distance, 60\u202f% urgency\n    scores = 0.4 * dist_norm + 0.6 * (1.0 / (slack_norm + 1e-12))\n\n    # Top\u2011k (k=3) selection with deterministic noise\n    top_k = 3\n    if len(scores) > top_k:\n        top_indices = np.argpartition(scores, top_k)[:top_k]\n    else:\n        top_indices = np.arange(len(scores))\n\n    noise = 1e-7 * np.array(feasible)[top_indices]\n    scores[top_indices] += noise\n\n    chosen_idx = top_indices[np.argmin(scores[top_indices])]\n    return int(feasible[chosen_idx])\n\n",
  "time_distance_weighted_aug_22": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node, 1]:\n                feasible.append(node)\n                slacks.append(time_windows[node, 1] - arrival)\n\n    if not feasible:\n        return depot\n\n    distances = distance_matrix[current_node, feasible]\n    slacks_arr = np.array(slacks)\n\n    # Sum\u2011based normalisation\n    dist_norm = distances / (np.sum(distances) + 1e-12)\n    slack_norm = slacks_arr / (np.sum(slacks_arr) + 1e-12)\n    slack_norm = np.clip(slack_norm, 1e-12, None)\n\n    # Reciprocal distance + urgency\n    scores = 0.6 * (1.0 / (dist_norm + 1e-12)) + 0.4 * (1.0 / (slack_norm + 1e-12))\n\n    # Deterministic noise\n    noise = 1e-6 * np.array(feasible)\n    scores += noise\n\n    # Top\u2011k (k=5) selection\n    top_k = 5\n    if len(scores) > top_k:\n        top_indices = np.argpartition(scores, top_k)[:top_k]\n    else:\n        top_indices = np.arange(len(scores))\n\n    chosen_idx = top_indices[np.argmin(scores[top_indices])]\n    return int(feasible[chosen_idx])\n\n",
  "savings_with_time_aug_23": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat   = distance_matrix          # rename\n    candidates = unvisited_nodes\n\n    # Feasibility mask (vectorised)\n    feasible_mask = (demands[candidates] <= rest_capacity) & \\\n                    (current_time + dist_mat[current_node, candidates] <=\n                     time_windows[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_idx = candidates[feasible_mask]\n\n    d_current_depot = dist_mat[current_node, depot]\n    d_depot_nodes   = dist_mat[depot, feasible_idx]\n    d_current_nodes = dist_mat[current_node, feasible_idx]\n\n    # Clarke\u2011Wright savings\n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n\n    # Small deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=savings.shape)\n    selected = np.argmax(savings + noise)\n\n    return int(feasible_idx[selected])\n\n",
  "savings_with_time_aug_24": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = unvisited_nodes.copy()\n    feasible_idx = []\n\n    # Explicit iteration over candidates\n    while len(candidates) > 0:\n        node = candidates[0]\n        if (demands[node] <= rest_capacity and\n                current_time + dist_mat[current_node, node] <= time_windows[node, 1]):\n            feasible_idx.append(node)\n        candidates = np.delete(candidates, 0)\n\n    if not feasible_idx:\n        return depot\n\n    feasible_idx = np.array(feasible_idx)\n\n    d_current_depot = dist_mat[current_node, depot]\n    d_depot_nodes   = dist_mat[depot, feasible_idx]\n    d_current_nodes = dist_mat[current_node, feasible_idx]\n\n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n\n    # Soft\u2011min probability distribution\n    exp_vals = np.exp(-0.5 * (savings - np.min(savings)))  # shift for stability\n    probs    = exp_vals / (np.sum(exp_vals) + 1e-12)        # epsilon added\n    probs    = np.clip(probs, 0, 1)\n\n    # Random pick among the top\u2011k highest savings\n    top_k = 7\n    if len(feasible_idx) > top_k:\n        top_indices = np.argpartition(-savings, top_k - 1)[:top_k]\n        probs_top   = probs[top_indices]\n        probs_top   = probs_top / (np.sum(probs_top) + 1e-12)\n        chosen      = np.random.choice(top_indices, p=probs_top)\n    else:\n        chosen = np.random.choice(len(feasible_idx), p=probs)\n\n    return int(feasible_idx[chosen])\n\n",
  "savings_with_time_aug_25": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = unvisited_nodes\n\n    # Feasibility mask (vectorised)\n    mask = (demands[candidates] <= rest_capacity) & \\\n           (current_time + dist_mat[current_node, candidates] <=\n            time_windows[candidates, 1])\n\n    if not np.any(mask):\n        return depot\n\n    feasible_idx = candidates[mask]\n\n    # Use squared distances (then square\u2011root to keep sign)\n    d_current_depot = np.sqrt(np.square(dist_mat[current_node, depot]))\n    d_depot_nodes   = np.sqrt(np.square(dist_mat[depot, feasible_idx]))\n    d_current_nodes = np.sqrt(np.square(dist_mat[current_node, feasible_idx]))\n\n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n\n    # Median threshold\n    median_val   = np.median(savings)\n    above_median = savings >= median_val\n\n    if not np.any(above_median):\n        eligible_idx = np.arange(len(savings))\n    else:\n        eligible_idx = np.where(above_median)[0]\n\n    # Deterministic tie\u2011breaker\n    noise = np.arange(len(savings)) * 1e-9\n    selected = eligible_idx[np.argmax(savings[eligible_idx] + noise[eligible_idx])]\n\n    return int(feasible_idx[selected])\n\n",
  "savings_with_time_aug_26": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = unvisited_nodes\n\n    feasible_mask = (demands[candidates] <= rest_capacity) & \\\n                    (current_time + dist_mat[current_node, candidates] <=\n                     time_windows[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_idx = candidates[feasible_mask]\n\n    d_current_depot = dist_mat[current_node, depot]\n    d_depot_nodes   = dist_mat[depot, feasible_idx]\n    d_current_nodes = dist_mat[current_node, feasible_idx]\n\n    # Proxy savings with a scaling factor\n    savings_proxy = (d_current_depot + d_depot_nodes - d_current_nodes) * 0.7\n    savings_proxy = np.clip(savings_proxy, 0, np.inf)\n\n    # Randomly pick from the top\u2011k highest proxy savings\n    top_k = 5\n    if len(feasible_idx) > top_k:\n        top_indices = np.argpartition(-savings_proxy, top_k - 1)[:top_k]\n        chosen = np.random.choice(top_indices)\n    else:\n        chosen = np.random.choice(len(feasible_idx))\n\n    return int(feasible_idx[chosen])\n\n",
  "urgency_capacity_balance_aug_27": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- rename for clarity ---------------------------------------------\n    dist_mat      = distance_matrix\n    candidates    = unvisited_nodes\n    remaining_cap = rest_capacity\n    curr_time     = current_time\n    demand_arr    = demands\n    tw            = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    # --- compute all feasible candidates in one vectorised step ----------\n    arrival = curr_time + dist_mat[current_node, candidates]\n    feasible_mask = (demand_arr[candidates] <= remaining_cap) & (arrival <= tw[candidates, 1])\n    feasible = candidates[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    # slacks must be non\u2011negative; clip to avoid negative values\n    slacks = np.clip(tw[feasible, 1] - arrival[feasible_mask], 0, None)\n\n    # --- normalisation ---------------------------------------------------\n    # demand normalisation: mean\u2011based, add epsilon to avoid div\u2011by\u2011zero\n    demand_vals = demand_arr[feasible]\n    demand_norm = demand_vals / (np.mean(demand_vals) + 1e-12)\n\n    # urgency normalisation: inverse slack, mean\u2011based\n    urgency = 1.0 / (slacks + 1e-12)\n    urgency_norm = urgency / (np.mean(urgency) + 1e-12)\n\n    # --- scoring ---------------------------------------------------------\n    scores = 0.7 * urgency_norm - 0.3 * demand_norm\n\n    # deterministic tie\u2011breaking: add tiny noise proportional to index\n    noise = np.arange(feasible.size) * 1e-8\n    best_idx = np.argmax(scores + noise)\n    return int(feasible[best_idx])\n\n",
  "urgency_capacity_balance_aug_28": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- rename for readability ------------------------------------------\n    dist_mat      = distance_matrix\n    candidates    = unvisited_nodes\n    remaining_cap = rest_capacity\n    curr_time     = current_time\n    demand_arr    = demands\n    tw            = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    # --- build feasible list via list comprehension ----------------------\n    feasible = [node for node in candidates\n                if demand_arr[node] <= remaining_cap and\n                curr_time + dist_mat[current_node, node] <= tw[node, 1]]\n\n    if not feasible:\n        return depot\n\n    # convert to array for vectorised ops\n    feasible = np.array(feasible)\n    arrival  = curr_time + dist_mat[current_node, feasible]\n    slacks   = np.clip(tw[feasible, 1] - arrival, 0, None)\n\n    # --- normalisation using median -------------------------------------\n    demand_vals = demand_arr[feasible]\n    demand_norm = demand_vals / (np.median(demand_vals) + 1e-12)\n\n    urgency = 1.0 / (slacks + 1e-12)\n    urgency_norm = urgency / (np.median(urgency) + 1e-12)\n\n    # --- softmin score and probabilistic choice -------------------------\n    # higher score \u2192 higher probability after softmin\n    scores = 0.5 * urgency_norm + 0.5 * (1.0 - demand_norm)\n    probs  = np.exp(-scores)  # softmin\n    probs /= probs.sum()\n\n    # deterministic random choice using a fixed seed\n    rng = np.random.default_rng(seed=42)\n    chosen = rng.choice(feasible, p=probs)\n    return int(chosen)\n\n",
  "urgency_capacity_balance_aug_29": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- variable names --------------------------------------------------\n    dist_mat      = distance_matrix\n    candidates    = unvisited_nodes\n    remaining_cap = rest_capacity\n    curr_time     = current_time\n    demand_arr    = demands\n    tw            = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    # --- iterate with while to build feasible list -----------------------\n    idx = 0\n    feasible = []\n    slacks   = []\n    while idx < candidates.size:\n        node = candidates[idx]\n        if demand_arr[node] <= remaining_cap:\n            arrival = curr_time + dist_mat[current_node, node]\n            if arrival <= tw[node, 1]:\n                feasible.append(node)\n                slacks.append(tw[node, 1] - arrival)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible)\n    slacks   = np.clip(np.array(slacks), 0, None)\n\n    # --- normalisation with sum -----------------------------------------\n    demand_vals = demand_arr[feasible]\n    demand_norm = demand_vals / (demand_vals.sum() + 1e-12)\n\n    urgency = 1.0 / (slacks + 1e-12)\n    urgency_norm = urgency / (urgency.max() + 1e-12)\n\n    # --- scoring ---------------------------------------------------------\n    scores = 0.6 * urgency_norm - 0.4 * demand_norm\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(feasible.size) * 1e-9\n    best_idx = np.argmax(scores + noise)\n    return int(feasible[best_idx])\n\n",
  "urgency_capacity_balance_aug_30": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- rename for readability ------------------------------------------\n    dist_mat      = distance_matrix\n    candidates    = unvisited_nodes\n    remaining_cap = rest_capacity\n    curr_time     = current_time\n    demand_arr    = demands\n    tw            = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    # --- compute feasibility vectorised ---------------------------------\n    arrival = curr_time + dist_mat[current_node, candidates]\n    feasible_mask = (demand_arr[candidates] <= remaining_cap) & (arrival <= tw[candidates, 1])\n    feasible = candidates[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    # slacks must be non\u2011negative\n    slacks = np.clip(tw[feasible, 1] - arrival[feasible_mask], 0, None)\n\n    # --- normalisation ---------------------------------------------------\n    demand_vals = demand_arr[feasible]\n    demand_norm = demand_vals / (np.mean(demand_vals) + 1e-12)\n\n    urgency = 1.0 / (slacks + 1e-12)\n    urgency_norm = urgency / (urgency.max() + 1e-12)\n\n    # --- scoring ---------------------------------------------------------\n    scores = 0.6 * urgency_norm - 0.4 * demand_norm\n\n    # --- top\u2011k selection via argpartition --------------------------------\n    top_k = 7\n    if feasible.size > top_k:\n        partition_idx = np.argpartition(-scores, top_k - 1)[:top_k]\n        top_indices = partition_idx\n    else:\n        top_indices = np.arange(scores.size)\n\n    # deterministic random choice among top\u2011k using fixed seed\n    rng = np.random.default_rng(seed=1234)\n    chosen = rng.choice(feasible[top_indices], p=np.exp(-scores[top_indices]))\n    return int(chosen)\n\n",
  "time_window_width_aug_31": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for brevity\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    # Feasibility masks\n    cap_ok = demands[candidates] <= rest_capacity\n    arrival = current_time + dist_mat[current_node, candidates]\n    time_ok = arrival <= time_windows[candidates, 1]\n    feasible_mask = cap_ok & time_ok\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_idx = candidates[feasible_mask]\n    widths = time_windows[feasible_idx, 1] - time_windows[feasible_idx, 0]\n\n    # Small deterministic noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=widths.shape)\n    widths += noise\n\n    chosen = feasible_idx[np.argmin(widths)]\n    return int(chosen)\n\n",
  "time_window_width_aug_32": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    # Pre\u2011compute distances and widths\n    dists = dist_mat[current_node, candidates]\n    widths = time_windows[candidates, 1] - time_windows[candidates, 0]\n    # Inverted feasibility: we will reject those that violate constraints\n    cap_ok = demands[candidates] <= rest_capacity\n    arrival = current_time + dists\n    time_ok = arrival <= time_windows[candidates, 1]\n    feasible_mask = cap_ok & time_ok\n\n    # Build list of feasible indices\n    feasible = candidates[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    # Softmin scores: lower distance & narrower window -> higher probability\n    # Use small epsilon to avoid division by zero\n    eps = 1e-12\n    scores = np.exp(-0.6 * dists[feasible_mask] + 0.4 * widths[feasible_mask])\n    probs = scores / (np.sum(scores) + eps)\n    chosen = np.random.choice(feasible, p=probs)\n    return int(chosen)\n\n",
  "time_window_width_aug_33": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    cap_ok = demands[candidates] <= rest_capacity\n    arrival = current_time + dist_mat[current_node, candidates]\n    time_ok = arrival <= time_windows[candidates, 1]\n    feasible_mask = cap_ok & time_ok\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_idx = candidates[feasible_mask]\n    widths = time_windows[feasible_idx, 1] - time_windows[feasible_idx, 0]\n\n    # Add deterministic noise\n    noise = np.random.uniform(0, 1e-6, size=widths.shape)\n    widths += noise\n\n    # Pick top\u2011k narrow windows\n    top_k = 5\n    sorted_idx = np.argsort(widths)[:top_k]\n    chosen = feasible_idx[sorted_idx]\n    selected = np.random.choice(chosen)\n    return int(selected)\n\n",
  "time_window_width_aug_34": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    cap_ok = demands[candidates] <= rest_capacity\n    arrival = current_time + dist_mat[current_node, candidates]\n    time_ok = arrival <= time_windows[candidates, 1]\n    feasible_mask = cap_ok & time_ok\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_idx = candidates[feasible_mask]\n    dists = dist_mat[current_node, feasible_idx]\n    widths = time_windows[feasible_idx, 1] - time_windows[feasible_idx, 0]\n\n    # Proxy score: penalise wide windows, reward short distance\n    # Invert logic: higher score is better\n    scores = -widths + 0.5 * dists\n    # Clip to avoid extreme values\n    scores = np.clip(scores, -1e9, 1e9)\n\n    chosen = feasible_idx[np.argmax(scores)]\n    return int(chosen)\n\n",
  "latest_acceptable_arrival_aug_35": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for brevity\n    curr = current_node\n    depot_id = depot\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    curr_time = current_time\n    dem = demands\n    dist = distance_matrix\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot_id\n\n    # Feasibility mask based on demand and remaining capacity\n    feasible_mask = dem[candidates] <= rem_cap\n    feasible_nodes = candidates[feasible_mask]\n    if feasible_nodes.size == 0:\n        return depot_id\n\n    # Arrival times to each feasible node\n    arrival = curr_time + dist[curr, feasible_nodes]\n    # Ensure arrival does not exceed the upper bound of the time window\n    within_tw = arrival <= tw[feasible_nodes, 1]\n    feasible_nodes = feasible_nodes[within_tw]\n    if feasible_nodes.size == 0:\n        return depot_id\n\n    arrival = arrival[within_tw]\n    # Latest admissible times for tie\u2011breaking\n    latest_arrivals = tw[feasible_nodes, 1]\n    # deterministic noise to break ties\n    noise = 1e-6 * np.random.rand(feasible_nodes.size)\n    scores = latest_arrivals + noise\n    idx = np.argmax(scores)\n    return int(feasible_nodes[idx])\n\n",
  "latest_acceptable_arrival_aug_36": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = current_node\n    depot_id = depot\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    curr_time = current_time\n    dem = demands\n    dist = distance_matrix\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot_id\n\n    # Build list of feasible nodes\n    feasible = []\n    while len(candidates) > 0:\n        node = candidates[0]\n        if dem[node] <= rem_cap:\n            arr = curr_time + dist[curr, node]\n            if arr <= tw[node, 1]:\n                feasible.append(node)\n        candidates = candidates[1:]\n\n    if not feasible:\n        return depot_id\n\n    # Weighted scoring: earlier arrival is better, but we also reward slack\n    weight_dist = 0.6\n    weight_slack = 0.4\n    scores = []\n    for node in feasible:\n        arr = curr_time + dist[curr, node]\n        slack = tw[node, 1] - arr\n        slack = max(slack, 1e-12)          # avoid division by zero\n        score = weight_dist * arr - weight_slack * slack\n        scores.append(score)\n\n    idx = np.argmin(scores)\n    return int(feasible[idx])\n\n",
  "latest_acceptable_arrival_aug_37": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = current_node\n    depot_id = depot\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    curr_time = current_time\n    dem = demands\n    dist = distance_matrix\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot_id\n\n    # Feasible nodes list\n    feasible = []\n    for node in candidates:\n        if dem[node] <= rem_cap:\n            arr = curr_time + dist[curr, node]\n            if arr <= tw[node, 1]:\n                feasible.append(node)\n\n    if not feasible:\n        return depot_id\n\n    # Scoring with equal weights\n    weight_dist = 0.5\n    weight_slack = 0.5\n    scores = []\n    for node in feasible:\n        arr = curr_time + dist[curr, node]\n        slack = tw[node, 1] - arr\n        slack = max(slack, 1e-12)          # avoid division by zero\n        score = weight_dist * arr - weight_slack * slack\n        scores.append(score)\n\n    # Soft\u2011min probabilities\n    exp_scores = np.exp(-np.array(scores) / (0.01 + 1e-12))\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n\n    # Random choice among the top\u2011k probabilities\n    top_k = min(5, len(feasible))\n    top_indices = np.argsort(probs)[-top_k:]\n    chosen = np.random.choice(top_indices)\n    return int(feasible[chosen])\n\n",
  "latest_acceptable_arrival_aug_38": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = current_node\n    depot_id = depot\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    curr_time = current_time\n    dem = demands\n    dist = distance_matrix\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot_id\n\n    # Feasible nodes with a tighter threshold on the upper time window\n    feasible = []\n    for node in candidates:\n        if dem[node] <= rem_cap:\n            arr = curr_time + dist[curr, node]\n            if arr <= 0.95 * tw[node, 1]:          # stricter bound\n                feasible.append(node)\n\n    if not feasible:\n        return depot_id\n\n    # Compute slack for each feasible node\n    slacks = []\n    for node in feasible:\n        arr = curr_time + dist[curr, node]\n        slack = tw[node, 1] - arr\n        slack = np.clip(slack, 0, None)          # ensure non\u2011negative\n        slacks.append(slack)\n\n    # Select node with maximum slack (ties resolved by order)\n    idx = np.argmax(slacks)\n    return int(feasible[idx])\n\n",
  "minimal_detour_time_aug_39": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    remain_cap = rest_capacity\n    curr_time = current_time\n    dem = demands\n    tw = time_windows\n\n    # ---- Early exit ----\n    if len(candidates) == 0:\n        return depot\n\n    # ---- Feasible candidate selection (list comprehension) ----\n    feasible = [node for node in candidates\n                if dem[node] <= remain_cap and\n                curr_time + dist_mat[current_node, node] <= tw[node, 1]]\n    if not feasible:\n        return depot\n\n    # ---- Vectorized detour calculation with deterministic tie\u2011breaker ----\n    feasible = np.array(feasible, dtype=int)\n    noise = feasible * 1e-8                      # tiny deterministic noise\n    direct_time = dist_mat[current_node, depot]\n    detour = dist_mat[current_node, feasible] + \\\n             dist_mat[feasible, depot] - direct_time + noise\n    detour = np.clip(detour, 0, 1e6)              # avoid negative values\n\n    # ---- Return the best node ----\n    return int(feasible[np.argmin(detour)])\n\n",
  "minimal_detour_time_aug_40": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    remain_cap = rest_capacity\n    curr_time = current_time\n    dem = demands\n    tw = time_windows\n\n    # ---- Early exit ----\n    if len(candidates) == 0:\n        return depot\n\n    # ---- Feasible candidate selection (for\u2011loop) ----\n    feasible = []\n    for node in candidates:\n        if dem[node] <= remain_cap:\n            arrival = curr_time + dist_mat[current_node, node]\n            if arrival <= tw[node, 1]:\n                feasible.append(node)\n    if not feasible:\n        return depot\n\n    # ---- Vectorized detour calculation ----\n    feasible = np.array(feasible, dtype=int)\n    direct_time = dist_mat[current_node, depot]\n    detour = dist_mat[current_node, feasible] + \\\n             dist_mat[feasible, depot] - direct_time\n    detour = np.clip(detour, 0, 1e6)\n\n    # ---- Penalty using np.maximum (max aggregation) ----\n    arrival = curr_time + dist_mat[current_node, feasible]\n    wait = np.maximum(0, tw[feasible, 0] - arrival)\n    penalty = np.maximum(detour, wait)              # element\u2011wise max\n\n    # ---- Return the node with minimal penalty ----\n    return int(feasible[np.argmin(penalty)])\n\n",
  "minimal_detour_time_aug_41": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    remain_cap = rest_capacity\n    curr_time = current_time\n    dem = demands\n    tw = time_windows\n\n    # ---- Early exit ----\n    if len(candidates) == 0:\n        return depot\n\n    # ---- Feasible candidate selection (for\u2011loop) ----\n    feasible = []\n    for node in candidates:\n        if dem[node] <= remain_cap and \\\n           curr_time + dist_mat[current_node, node] <= tw[node, 1]:\n            feasible.append(node)\n    if not feasible:\n        return depot\n\n    # ---- Vectorized detour with deterministic noise ----\n    feasible = np.array(feasible, dtype=int)\n    direct_time = dist_mat[current_node, depot]\n    detour = dist_mat[current_node, feasible] + \\\n             dist_mat[feasible, depot] - direct_time\n    noise = feasible * 1e-7                      # deterministic noise\n    detour = np.clip(detour + noise, 0, 1e6)\n\n    # ---- Top\u20113 selection with deterministic middle choice ----\n    sorted_idx = np.argsort(detour)\n    top_k = 3\n    if len(detour) > top_k:\n        top_idx = sorted_idx[:top_k]\n    else:\n        top_idx = sorted_idx\n\n    chosen = top_idx[1] if len(top_idx) >= 3 else top_idx[0]\n    return int(feasible[chosen])\n\n",
  "demand_to_distance_time_aug_42": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasibility mask: demand fits in remaining capacity\n    mask = demands[unvisited_nodes] <= rest_capacity\n    candidates = unvisited_nodes[mask]\n    if candidates.size == 0:\n        return depot\n\n    # Arrival times to each candidate\n    arrivals = current_time + distance_matrix[current_node, candidates]\n    # Feasible wrt time windows\n    feasible_mask = arrivals <= time_windows[candidates, 1]\n    candidates = candidates[feasible_mask]\n    if candidates.size == 0:\n        return depot\n\n    # Distances with epsilon to avoid division by zero\n    dists = np.clip(distance_matrix[current_node, candidates] + 1e-12,\n                    1e-12, None)\n    ratios = demands[candidates] / dists\n\n    # Deterministic noise for tie\u2011breaking (scaled by node id)\n    noise = (candidates % 1000) * 1e-6\n    ratios += noise\n\n    return int(candidates[np.argmax(ratios)])\n\n",
  "demand_to_distance_time_aug_43": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    best_node = depot\n    best_score = -np.inf\n\n    # First pass: identify the best single node\n    for node in unvisited_nodes:\n        if demands[node] > rest_capacity:\n            continue\n        arrival = current_time + distance_matrix[current_node, node]\n        if arrival > time_windows[node, 1]:\n            continue\n        slack = np.clip(time_windows[node, 1] - arrival, 0, None)\n        score = 0.7 * demands[node] / (distance_matrix[current_node, node] + 1e-12) \\\n                + 0.3 * slack\n        if score > best_score:\n            best_score, best_node = score, node\n\n    if best_node == depot:\n        return depot\n\n    # Second pass: collect all feasible nodes for top\u2011k random selection\n    feasible_nodes = []\n    scores = []\n    for node in unvisited_nodes:\n        if demands[node] > rest_capacity:\n            continue\n        arrival = current_time + distance_matrix[current_node, node]\n        if arrival > time_windows[node, 1]:\n            continue\n        slack = np.clip(time_windows[node, 1] - arrival, 0, None)\n        score = 0.7 * demands[node] / (distance_matrix[current_node, node] + 1e-12) \\\n                + 0.3 * slack\n        feasible_nodes.append(node)\n        scores.append(score)\n\n    if not feasible_nodes:\n        return depot\n\n    feasible_nodes = np.array(feasible_nodes)\n    scores = np.array(scores)\n\n    # Randomly pick among the top\u2011k highest scores\n    top_k = 5\n    top_indices = np.argsort(-scores)[:top_k]\n    top_candidates = feasible_nodes[top_indices]\n\n    # Deterministic tie\u2011breaking: choose the candidate with smallest id % 1000\n    chosen = top_candidates[np.argmin(top_candidates % 1000)]\n    return int(chosen)\n\n",
  "demand_to_distance_time_aug_44": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasibility mask\n    mask = demands[unvisited_nodes] <= rest_capacity\n    nodes = unvisited_nodes[mask]\n    if nodes.size == 0:\n        return depot\n\n    arrivals = current_time + distance_matrix[current_node, nodes]\n    mask2 = arrivals <= time_windows[nodes, 1]\n    nodes = nodes[mask2]\n    if nodes.size == 0:\n        return depot\n\n    dists = np.clip(distance_matrix[current_node, nodes] + 1e-12,\n                    1e-12, None)\n    ratios = demands[nodes] / dists\n\n    median_ratio = np.median(ratios)\n    # Pick node whose ratio is closest to the median\n    idx = np.argmin(np.abs(ratios - median_ratio))\n    return int(nodes[idx])\n\n",
  "composite_time_dist_demand_aug_45": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    feasible = []\n    slack_vals = []\n    idx = 0\n    rng = np.random.default_rng(0)          # deterministic RNG\n    while idx < candidates.size:\n        node = candidates[idx]\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node, 1]:\n                feasible.append(node)\n                slack_vals.append(time_windows[node, 1] - arrival)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible_arr = np.array(feasible)\n    slack_arr = np.array(slack_vals)\n    distances = distance_matrix[current_node, feasible_arr]\n    demand_vals = demands[feasible_arr]\n\n    def normalize(x: np.ndarray) -> np.ndarray:\n        denom = (x.max() - x.min() + 1e-12)\n        return (x - x.min()) / denom\n\n    urgency = 1.0 / (slack_arr + 1.0 + 1e-12)\n    score = 0.5 * normalize(urgency) + 0.3 * normalize(distances) - 0.2 * normalize(demand_vals)\n    # deterministic noise to break ties\n    score += 1e-9 * rng.random(score.shape)\n\n    return int(feasible_arr[np.argmin(score)])\n\n",
  "composite_time_dist_demand_aug_46": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    # Vectorised feasibility check\n    mask = (demands[candidates] <= rest_capacity) & \\\n           (current_time + distance_matrix[current_node, candidates] <= time_windows[candidates, 1])\n    feasible_nodes = candidates[mask]\n    if feasible_nodes.size == 0:\n        return depot\n\n    slack = time_windows[feasible_nodes, 1] - \\\n            (current_time + distance_matrix[current_node, feasible_nodes])\n    distances = distance_matrix[current_node, feasible_nodes]\n    demand_vals = demands[feasible_nodes]\n\n    def normalize(x: np.ndarray) -> np.ndarray:\n        denom = (x.max() - x.min() + 1e-12)\n        return (x - x.min()) / denom\n\n    urgency = 1.0 / (slack + 1.0 + 1e-12)\n    score = 0.6 * normalize(urgency) + 0.2 * normalize(distances) - 0.2 * normalize(demand_vals)\n\n    # Top\u2011k selection\n    top_k = 7\n    if feasible_nodes.size <= top_k:\n        candidates_to_choose = feasible_nodes\n    else:\n        top_idx = np.argpartition(score, -top_k)[-top_k:]\n        candidates_to_choose = feasible_nodes[top_idx]\n\n    rng = np.random.default_rng(42)\n    chosen = rng.choice(candidates_to_choose)\n    return int(chosen)\n\n",
  "composite_time_dist_demand_aug_47": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    mask = (demands[candidates] <= rest_capacity) & \\\n           (current_time + distance_matrix[current_node, candidates] <= time_windows[candidates, 1])\n    feasible = candidates[mask]\n    if feasible.size == 0:\n        return depot\n\n    slack = time_windows[feasible, 1] - \\\n            (current_time + distance_matrix[current_node, feasible])\n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n\n    def normalize(x: np.ndarray) -> np.ndarray:\n        denom = (x.max() - x.min() + 1e-12)\n        return (x - x.min()) / denom\n\n    urgency = 1.0 / (slack + 1.0 + 1e-12)\n    score = 0.4 * normalize(urgency) + 0.3 * normalize(distances) - 0.3 * normalize(demand_vals)\n\n    beta = 5.0\n    probs = np.exp(-beta * score)\n    probs = probs / probs.sum()\n\n    rng = np.random.default_rng(24)\n    chosen = rng.choice(feasible, p=probs)\n    return int(chosen)\n\n",
  "composite_time_dist_demand_aug_48": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    arrival = current_time + distance_matrix[current_node, candidates]\n    mask = (demands[candidates] <= rest_capacity) & (arrival <= time_windows[candidates, 1])\n    feasible_nodes = candidates[mask]\n    if feasible_nodes.size == 0:\n        return depot\n\n    slack = time_windows[feasible_nodes, 1] - arrival[mask]\n    distances = distance_matrix[current_node, feasible_nodes]\n    demand_vals = demands[feasible_nodes]\n\n    def normalize(x: np.ndarray) -> np.ndarray:\n        denom = (x.max() - x.min() + 1e-12)\n        return np.clip((x - x.min()) / denom, 0.0, 1.0)\n\n    urgency = 1.0 / (slack + 1.0 + 1e-12)\n\n    # Median\u2011centered slack normalisation\n    slack_center = np.median(slack)\n    slack_norm = np.clip((slack - slack_center) / (slack.max() - slack.min() + 1e-12), 0.0, 1.0)\n\n    score = 0.4 * normalize(urgency) + 0.4 * normalize(distances) - \\\n            0.2 * normalize(np.max(demand_vals) - demand_vals)\n\n    rng = np.random.default_rng(99)\n    score += 1e-8 * rng.random(score.shape)  # deterministic noise\n\n    return int(feasible_nodes[np.argmin(score)])\n\n",
  "adaptive_time_pressure_aug_49": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    cur_time = current_time\n    dem = demands\n    tws = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    # Vectorised feasibility check\n    demand_ok = dem[candidates] <= rem_cap\n    arrival = cur_time + dist_mat[current_node, candidates]\n    time_ok = arrival <= tws[candidates, 1]\n    feasible_mask = demand_ok & time_ok\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = candidates[feasible_mask]\n    feasible_arrival = arrival[feasible_mask]\n    feasible_slack = tws[feasible, 1] - feasible_arrival\n    feasible_dist = dist_mat[current_node, feasible]\n\n    avg_slack = np.median(feasible_slack)\n\n    if avg_slack < 5.0:\n        urgency = 1.0 / (feasible_slack + 1e-12)\n        return int(feasible[np.argmax(urgency)])\n    else:\n        return int(feasible[np.argmin(np.clip(feasible_dist, 1e-12, None))])\n\n",
  "adaptive_time_pressure_aug_50": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes.tolist()\n    rem_cap = rest_capacity\n    cur_time = current_time\n    dem = demands\n    tws = time_windows\n\n    if len(candidates) == 0:\n        return depot\n\n    feasible = []\n    slacks = []\n\n    while candidates:\n        node = candidates.pop()\n        if dem[node] <= rem_cap:\n            arrival = cur_time + dist_mat[current_node, node]\n            if arrival <= tws[node, 1]:\n                feasible.append(node)\n                slacks.append(tws[node, 1] - arrival)\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible)\n    slacks = np.array(slacks)\n    avg_slack = np.sum(slacks + 1e-12) / (len(slacks) + 1e-12)\n\n    top_k = 5\n    if avg_slack < 5.0:\n        urgency = 1.0 / (slacks + 1e-12)\n        sorted_idx = np.argsort(-urgency)\n        top_nodes = feasible[sorted_idx[:min(top_k, len(sorted_idx))]]\n        noise = np.arange(len(top_nodes)) * 1e-6\n        chosen = top_nodes[np.argmax(noise)]\n        return int(chosen)\n    else:\n        distances = dist_mat[current_node, feasible]\n        sorted_idx = np.argsort(distances)\n        top_nodes = feasible[sorted_idx[:min(top_k, len(sorted_idx))]]\n        noise = np.arange(len(top_nodes)) * 1e-6\n        chosen = top_nodes[np.argmax(noise)]\n        return int(chosen)\n\n",
  "adaptive_time_pressure_aug_51": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    cur_time = current_time\n    dem = demands\n    tws = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    mask = (dem[candidates] <= rem_cap) & \\\n           (cur_time + dist_mat[current_node, candidates] <= tws[candidates, 1])\n    if not np.any(mask):\n        return depot\n\n    feasible = candidates[mask]\n    arrival = cur_time + dist_mat[current_node, feasible]\n    slack = tws[feasible, 1] - arrival\n    dist = dist_mat[current_node, feasible]\n\n    avg_slack = np.mean(slack)\n\n    # Inverted urgency logic\n    if avg_slack >= 5.0:\n        urgency = 1.0 / (slack + 1e-12)\n        noise = np.arange(len(feasible)) * 1e-6\n        idx = np.argmax(urgency + noise)\n        return int(feasible[idx])\n    else:\n        # Select the furthest node (max distance) with deterministic noise\n        noise = np.arange(len(feasible)) * 1e-6\n        idx = np.argmax(dist + noise)\n        return int(feasible[idx])\n\n",
  "adaptive_time_pressure_aug_52": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    cur_time = current_time\n    dem = demands\n    tws = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    mask = (dem[candidates] <= rem_cap) & \\\n           (cur_time + dist_mat[current_node, candidates] <= tws[candidates, 1])\n    if not np.any(mask):\n        return depot\n\n    feasible = candidates[mask]\n    arrival = cur_time + dist_mat[current_node, feasible]\n    slack = tws[feasible, 1] - arrival\n    dist = dist_mat[current_node, feasible]\n\n    # Normalise distance and slack\n    dist_norm = dist / (np.max(dist) + 1e-12)\n    slack_norm = slack / (np.max(slack) + 1e-12)\n\n    # Weighted score: closer distance and tighter slack are better\n    score = 0.7 * dist_norm + 0.3 * (1.0 - slack_norm)\n    idx = np.argmin(score)\n    return int(feasible[idx])\n\n",
  "regret_time_based_aug_53": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Arrival times to all candidate nodes\n    arrivals = current_time + distance_matrix[current_node, unvisited_nodes]\n\n    # Feasibility masks\n    capacity_ok = demands[unvisited_nodes] <= rest_capacity\n    time_ok = arrivals <= time_windows[unvisited_nodes, 1]\n    feasible_mask = capacity_ok & time_ok\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    feasible_arrivals = arrivals[feasible_mask]\n    slacks = time_windows[feasible_nodes, 1] - feasible_arrivals\n\n    # Small deterministic noise to break ties\n    noise = np.arange(len(slacks)) * 1e-9\n    slacks_noisy = slacks + noise\n\n    # Node with the smallest slack\n    idx = np.argmin(slacks_noisy)\n    return int(feasible_nodes[idx])\n\n",
  "regret_time_based_aug_54": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size != 0:\n        candidates = unvisited_nodes.tolist()\n        feasible = []\n        scores = []\n\n        while candidates:\n            node = candidates.pop()\n            if demands[node] > rest_capacity:\n                continue\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival > time_windows[node, 1]:\n                continue\n\n            slack = time_windows[node, 1] - arrival\n            # Weighted score: 0.4 * slack + 0.6 * distance\n            score = 0.4 * slack + 0.6 * distance_matrix[current_node, node]\n            feasible.append(node)\n            scores.append(score)\n\n        if not feasible:\n            return depot\n\n        scores_arr = np.array(scores, dtype=np.float64)\n        min_score = np.min(scores_arr)\n        # Softmin with temperature 0.5\n        exp_vals = np.exp(-(scores_arr - min_score) / (0.5 + 1e-12))\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n        chosen = np.random.choice(feasible, p=probs)\n        return int(chosen)\n\n    return depot\n\n",
  "regret_time_based_aug_55": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    arrivals = current_time + distance_matrix[current_node, unvisited_nodes]\n    capacity_ok = demands[unvisited_nodes] <= rest_capacity\n    time_ok = arrivals <= time_windows[unvisited_nodes, 1]\n    feasible_mask = capacity_ok & time_ok\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    feasible_arrivals = arrivals[feasible_mask]\n    slacks = time_windows[feasible_nodes, 1] - feasible_arrivals\n\n    # Clip negative slacks to zero\n    slacks_clipped = np.clip(slacks, 0, None)\n\n    top_k = 5\n    if feasible_nodes.size <= top_k:\n        candidates = feasible_nodes\n    else:\n        idx = np.argpartition(slacks_clipped, top_k)[:top_k]\n        candidates = feasible_nodes[idx]\n\n    chosen = np.random.choice(candidates)\n    return int(chosen)\n\n",
  "regret_time_based_aug_56": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    arrivals = current_time + distance_matrix[current_node, unvisited_nodes]\n    capacity_ok = demands[unvisited_nodes] <= rest_capacity\n    time_ok = arrivals <= time_windows[unvisited_nodes, 1]\n    feasible_mask = capacity_ok & time_ok\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    feasible_arrivals = arrivals[feasible_mask]\n    slacks = time_windows[feasible_nodes, 1] - feasible_arrivals\n\n    median_slack = np.median(slacks)\n\n    # Weighted cost: distance + 0.5 * slack\n    weighted_cost = distance_matrix[current_node, feasible_nodes] + 0.5 * slacks\n    exp_vals = np.exp(-(weighted_cost - median_slack) / (0.3 + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    chosen = np.random.choice(feasible_nodes, p=probs)\n    return int(chosen)\n\n",
  "insertion_cost_time_aug_57": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap_rem = rest_capacity\n    cur_t = current_time\n    dem = demands\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    # vectorised feasibility check\n    arrival = cur_t + dist_mat[current_node, candidates]\n    feasible_mask = (dem[candidates] <= cap_rem) & (arrival <= tw[candidates, 1])\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n\n    # compute insertion cost in a vectorised manner\n    time_to_depot = dist_mat[current_node, depot]\n    via_node = dist_mat[current_node, feasible_nodes] + dist_mat[feasible_nodes, depot]\n    insertion_costs = via_node - time_to_depot\n\n    # choose the node with minimal insertion cost\n    idx = np.argmin(insertion_costs)\n    return int(feasible_nodes[idx])\n\n",
  "insertion_cost_time_aug_58": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap_rem = rest_capacity\n    cur_t = current_time\n    dem = demands\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    # feasibility mask\n    arrival = cur_t + dist_mat[current_node, candidates]\n    feasible_mask = (dem[candidates] <= cap_rem) & (arrival <= tw[candidates, 1])\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n    arrival_feasible = arrival[feasible_mask]\n    tw_start = tw[feasible_nodes, 0]\n\n    # waiting time with safe division\n    waiting = np.maximum(0, tw_start - arrival_feasible) / (1 + 1e-12)\n\n    # weighted cost with tuned parameters\n    weight_dist = 0.6\n    weight_wait = 0.4\n    costs = weight_dist * dist_mat[current_node, feasible_nodes] + weight_wait * waiting\n\n    # select top\u2011k candidates before final argmin\n    top_k = 7\n    if costs.size > top_k:\n        idxs = np.argpartition(costs, top_k)[:top_k]\n        chosen_idx = idxs[np.argmin(costs[idxs])]\n    else:\n        chosen_idx = np.argmin(costs)\n\n    return int(feasible_nodes[chosen_idx])\n\n",
  "insertion_cost_time_aug_59": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap_rem = rest_capacity\n    cur_t = current_time\n    dem = demands\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    # feasibility\n    arrival = cur_t + dist_mat[current_node, candidates]\n    feasible_mask = (dem[candidates] <= cap_rem) & (arrival <= tw[candidates, 1])\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n    via_node = dist_mat[current_node, feasible_nodes] + dist_mat[feasible_nodes, depot]\n    base_cost = via_node - dist_mat[current_node, depot]\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(base_cost.size)\n    costs = base_cost + noise\n\n    # softmin with temperature\n    temp = 1.0\n    exp_vals = np.exp(-temp * costs)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # choose among top\u2011k with probabilities\n    top_k = 3\n    if costs.size > top_k:\n        top_idx = np.argpartition(costs, top_k)[:top_k]\n    else:\n        top_idx = np.arange(costs.size)\n\n    probs_top = probs[top_idx]\n    probs_top = probs_top / (np.sum(probs_top) + 1e-12)\n\n    chosen_local = np.random.choice(top_idx, p=probs_top)\n    return int(feasible_nodes[chosen_local])\n\n",
  "insertion_cost_time_aug_60": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap_rem = rest_capacity\n    cur_t = current_time\n    dem = demands\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    # feasibility\n    arrival = cur_t + dist_mat[current_node, candidates]\n    feasible_mask = (dem[candidates] <= cap_rem) & (arrival <= tw[candidates, 1])\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n    via_node = dist_mat[current_node, feasible_nodes] + dist_mat[feasible_nodes, depot]\n    time_to_depot = dist_mat[current_node, depot]\n    insertion_cost = via_node - time_to_depot\n\n    # clip waiting times and compute weighted cost\n    wait_start = tw[feasible_nodes, 0]\n    waiting = np.maximum(0, wait_start - arrival[feasible_mask])\n    waiting = np.clip(waiting, 0, 1e6)\n    cost = 0.5 * dist_mat[current_node, feasible_nodes] + 0.5 * waiting / (1 + 1e-12)\n\n    # median\u2011based thresholding\n    median_cost = np.median(cost)\n    threshold = median_cost + 1e-6\n    mask_thresh = cost <= threshold\n    if not np.any(mask_thresh):\n        mask_thresh = np.ones_like(cost, dtype=bool)\n\n    # pick the node with minimal insertion cost within the threshold\n    candidates_idx = feasible_nodes[mask_thresh]\n    insertion_cost_thresh = insertion_cost[mask_thresh]\n    chosen_node = candidates_idx[np.argmin(insertion_cost_thresh)]\n\n    return int(chosen_node)\n\n",
  "time_proximity_cluster_aug_61": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Build list of feasible nodes using a while loop\n    feasible = []\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = unvisited_nodes[idx]\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node, 1]:\n                feasible.append(node)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    # Prefer nodes with time windows close to current time\n    tw_starts = time_windows[feasible, 0]\n    time_proximity = np.abs(tw_starts - current_time)\n    time_proximity = np.clip(time_proximity, 1e-12, None)\n\n    # Use squared distances for a different metric\n    distances = np.square(distance_matrix[current_node, feasible])\n    distances = np.clip(distances, 1e-12, None)\n\n    # Normalise using mean with epsilon\n    dist_norm = distances / (np.mean(distances) + 1e-12)\n    time_norm = time_proximity / (np.mean(time_proximity) + 1e-12)\n\n    # Score with different weight and deterministic noise\n    noise = 1e-6 * feasible  # deterministic tie\u2011breaking\n    scores = 0.7 * dist_norm + 0.3 * time_norm + noise\n\n    return int(feasible[np.argmin(scores)])\n\n",
  "time_proximity_cluster_aug_62": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasibility mask\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity)\n    feasible_nodes = unvisited_nodes[feasible_mask]\n\n    if feasible_nodes.size == 0:\n        return depot\n\n    # Arrival times and time window checks\n    arrivals = current_time + distance_matrix[current_node, feasible_nodes]\n    within_tw = arrivals <= time_windows[feasible_nodes, 1]\n    feasible_nodes = feasible_nodes[within_tw]\n\n    if feasible_nodes.size == 0:\n        return depot\n\n    # Distances and normalisation using median\n    distances = distance_matrix[current_node, feasible_nodes]\n    dist_norm = distances / (np.median(distances) + 1e-12)\n\n    # Time proximity normalisation\n    tw_starts = time_windows[feasible_nodes, 0]\n    time_proximity = np.abs(tw_starts - current_time)\n    time_norm = time_proximity / (np.median(time_proximity) + 1e-12)\n\n    # Softmin weighting\n    scores = 0.5 * dist_norm + 0.5 * time_norm\n    # Convert to probability distribution\n    exp_neg = np.exp(-scores - np.max(-scores))  # numerical stability\n    probs = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n    # Pick node with highest probability\n    chosen_idx = np.argmax(probs)\n    return int(feasible_nodes[chosen_idx])\n\n",
  "time_proximity_cluster_aug_63": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Build feasible list via list comprehension\n    feasible = [node for node in unvisited_nodes\n                if demands[node] <= rest_capacity and\n                current_time + distance_matrix[current_node, node] <= time_windows[node, 1]]\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    # Distances and time proximity\n    distances = distance_matrix[current_node, feasible]\n    tw_starts = time_windows[feasible, 0]\n    time_proximity = np.abs(tw_starts - current_time)\n\n    # Normalise using median\n    dist_norm = distances / (np.median(distances) + 1e-12)\n    time_norm = time_proximity / (np.median(time_proximity) + 1e-12)\n\n    # Score and add deterministic noise\n    scores = 0.6 * dist_norm + 0.4 * time_norm + 1e-6 * feasible\n\n    # Select top\u2011k (k=5) candidates\n    top_k = 5\n    if feasible.size <= top_k:\n        chosen_idx = np.argmin(scores)\n    else:\n        top_indices = np.argpartition(scores, top_k)[:top_k]\n        chosen_idx = top_indices[np.argmin(scores[top_indices])]\n\n    return int(feasible[chosen_idx])\n\n",
  "time_proximity_cluster_aug_64": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Invert conditional: first gather all feasible nodes\n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node, 1]:\n                feasible.append(node)\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    # Compute distances and clip\n    distances = distance_matrix[current_node, feasible]\n    distances = np.clip(distances, 1e-12, None)\n\n    # Time proximity and clip\n    tw_starts = time_windows[feasible, 0]\n    time_proximity = np.abs(tw_starts - current_time)\n    time_proximity = np.clip(time_proximity, 1e-12, None)\n\n    # Normalise with mean\n    dist_norm = distances / (np.mean(distances) + 1e-12)\n    time_norm = time_proximity / (np.mean(time_proximity) + 1e-12)\n\n    # Softmax weighting\n    scores = 0.55 * dist_norm + 0.45 * time_norm\n    exp_scores = np.exp(scores - np.max(scores))\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n\n    # Choose node with highest probability\n    chosen_idx = np.argmax(probs)\n    return int(feasible[chosen_idx])\n\n",
  "wait_vs_travel_trade_off_aug_65": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Arrival times for all candidates\n    arrivals = current_time + distance_matrix[current_node, unvisited_nodes]\n\n    # Feasibility: capacity and time\u2011window constraints\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity) & \\\n                    (arrivals <= time_windows[unvisited_nodes, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feas_nodes = unvisited_nodes[feasible_mask]\n    feas_arr = arrivals[feasible_mask]\n    feas_dist = distance_matrix[current_node, feas_nodes]\n    feas_wait = np.maximum(0.0, time_windows[feas_nodes, 0] - feas_arr)\n\n    # Weighted score (distance + wait)\n    score = 0.6 * feas_dist + 0.4 * feas_wait\n    # Deterministic noise to break ties\n    noise = np.arange(feas_nodes.size) * 1e-6\n    score += noise\n\n    # Softmin probabilities\n    temp = 5.0\n    exp_vals = np.exp(-score / temp)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)   # epsilon to avoid div\u2011by\u2011zero\n\n    # Pick node with highest probability (argmax)\n    chosen_index = np.argmax(probs)\n    return int(feas_nodes[chosen_index])\n\n",
  "wait_vs_travel_trade_off_aug_66": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    best_score = np.inf\n    best_candidates = []\n\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = unvisited_nodes[idx]\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node, 1]:\n                wait = np.clip(time_windows[node, 0] - arrival, 0.0, np.inf)\n                score = 0.4 * distance_matrix[current_node, node] + 0.6 * wait\n                # Deterministic noise for tie\u2011breaking\n                score += idx * 1e-6\n                if score < best_score - 1e-12:\n                    best_score = score\n                    best_candidates = [node]\n                elif abs(score - best_score) <= 1e-12:\n                    best_candidates.append(node)\n        idx += 1\n\n    if not best_candidates:\n        return depot\n\n    # Randomly pick among the top\u2011k best candidates\n    top_k = min(3, len(best_candidates))\n    rng = np.random.default_rng()\n    chosen = rng.choice(best_candidates[:top_k])\n    return int(chosen)\n\n",
  "wait_vs_travel_trade_off_aug_67": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes via list comprehension\n    feas = [node for node in unvisited_nodes\n            if demands[node] <= rest_capacity and\n               current_time + distance_matrix[current_node, node] <= time_windows[node, 1]]\n\n    if not feas:\n        return depot\n\n    feas_arr = current_time + distance_matrix[current_node, feas]\n    feas_dist = distance_matrix[current_node, feas]\n    feas_wait = np.clip(time_windows[feas, 0] - feas_arr, 0.0, np.inf)\n\n    # Aggregate median wait (unused directly but demonstrates semantic change)\n    _median_wait = np.median(feas_wait)\n\n    # Per\u2011node score with deterministic noise\n    per_score = 0.5 * feas_dist + 0.5 * feas_wait + np.arange(len(feas)) * 1e-6\n\n    # Randomly choose among the top\u2011k lowest scores\n    top_k = min(5, len(per_score))\n    top_indices = np.argsort(per_score)[:top_k]\n    rng = np.random.default_rng()\n    chosen = rng.choice(feas[top_indices])\n    return int(chosen)\n\n",
  "wait_vs_travel_trade_off_aug_68": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    while True:\n        if unvisited_nodes.size == 0:\n            return depot\n\n        # Feasibility mask\n        feasible_mask = (demands[unvisited_nodes] <= rest_capacity) & \\\n                        (current_time + distance_matrix[current_node, unvisited_nodes] <=\n                         time_windows[unvisited_nodes, 1])\n\n        if not np.any(feasible_mask):\n            return depot\n\n        feas_nodes = unvisited_nodes[feasible_mask]\n        feas_arr = current_time + distance_matrix[current_node, feas_nodes]\n        feas_dist = distance_matrix[current_node, feas_nodes]\n        feas_wait = np.clip(time_windows[feas_nodes, 0] - feas_arr, 0.0, np.inf)\n\n        # Score: balanced distance and wait\n        score = 0.5 * feas_dist + 0.5 * feas_wait\n        # Deterministic noise\n        noise = np.arange(feas_nodes.size) * 1e-6\n        score += noise\n\n        # Softmax probabilities (lower score \u2192 higher probability)\n        temp = 3.0\n        exp_vals = np.exp(-score / temp)\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)   # epsilon to avoid div\u2011by\u2011zero\n\n        chosen_index = np.argmax(probs)\n        return int(feas_nodes[chosen_index])\n\n",
  "deadline_proximity_ratio_aug_69": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Candidate nodes\n    candidates = unvisited_nodes\n\n    # Demand constraint\n    demand_mask = demands[candidates] <= rest_capacity\n    feasible = candidates[demand_mask]\n    if feasible.size == 0:\n        return depot\n\n    # Travel times and arrival times\n    travel = distance_matrix[current_node, feasible]\n    arrival = current_time + travel\n\n    # Time\u2011window feasibility\n    tw_mask = arrival <= time_windows[feasible, 1]\n    feasible = feasible[tw_mask]\n    if feasible.size == 0:\n        return depot\n\n    travel = travel[tw_mask]\n    arrival = arrival[tw_mask]\n\n    # Slack time (clipped to non\u2011negative)\n    slack = np.clip(time_windows[feasible, 1] - arrival, 0, None)\n\n    # Ratio with epsilon to avoid division by zero\n    ratio = slack / (travel + 1e-12)\n\n    # Small deterministic noise to break ties\n    ratio += np.arange(ratio.size) * 1e-9\n\n    return int(feasible[np.argmin(ratio)])\n\n",
  "deadline_proximity_ratio_aug_70": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    feasible = []\n    ratios = []\n\n    for node in candidates:\n        if demands[node] <= rest_capacity:\n            travel = distance_matrix[current_node, node]\n            arrival = current_time + travel\n            if arrival <= time_windows[node, 1]:\n                slack = time_windows[node, 1] - arrival\n                ratio = slack / (travel + 1e-12)\n                feasible.append(node)\n                ratios.append(ratio)\n\n    if not feasible:\n        return depot\n\n    ratios = np.array(ratios)\n    median_ratio = np.median(ratios)\n\n    # Absolute difference from median\n    diff = np.abs(ratios - median_ratio)\n    # Deterministic tie\u2011breaking using node index\n    diff += np.arange(len(ratios)) * 1e-10\n    idx = np.argmin(diff)\n    return int(feasible[idx])\n\n",
  "deadline_proximity_ratio_aug_71": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    feasible = []\n    ratios = []\n\n    for node in candidates:\n        if demands[node] <= rest_capacity:\n            travel = distance_matrix[current_node, node]\n            arrival = current_time + travel\n            if arrival <= time_windows[node, 1]:\n                slack = time_windows[node, 1] - arrival\n                ratio = slack / (travel + 1e-12)\n                feasible.append(node)\n                ratios.append(ratio)\n\n    if not feasible:\n        return depot\n\n    ratios = np.array(ratios)\n    # Clip slack to avoid negative values\n    slack_vals = np.clip(time_windows[feasible, 1] - (current_time + distance_matrix[current_node, feasible]), 0, None)\n    # Re\u2011compute ratios with clipped slack (for safety)\n    ratios = slack_vals / (distance_matrix[current_node, feasible] + 1e-12)\n\n    top_k = min(7, len(ratios))\n    idx_sorted = np.argsort(ratios)[:top_k]\n    chosen = np.random.choice(np.array(feasible)[idx_sorted])\n    return int(chosen)\n\n",
  "stochastic_urgency_aug_72": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Alias for readability\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    avail_cap = rest_capacity\n    cur_time = current_time\n    dem = demands\n    tw = time_windows\n\n    # Compute arrival times for all candidates\n    arrivals = cur_time + dist_mat[current_node, candidates]\n    # Feasible mask: capacity and time\u2011window constraints\n    feasible_mask = (dem[candidates] <= avail_cap) & (arrivals <= tw[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n    feasible_arrivals = arrivals[feasible_mask]\n    slack = np.clip(tw[feasible_nodes, 1] - feasible_arrivals, 0, None)\n\n    # Urgency: inverse of slack + 1, with epsilon to avoid division by zero\n    urgencies = 1.0 / (slack + 1.0 + 1e-12)\n    # Deterministic noise to break ties\n    urgencies += 1e-6 * np.arange(urgencies.size)\n\n    probs = urgencies / (np.sum(urgencies) + 1e-12)\n\n    seed = (current_node * 2654435761) ^ int(cur_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible_nodes, p=probs))\n\n",
  "stochastic_urgency_aug_73": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    avail_cap = rest_capacity\n    cur_time = current_time\n    dem = demands\n    tw = time_windows\n\n    urgencies = []\n    feasible_nodes = []\n\n    idx = 0\n    while idx < candidates.size:\n        node = candidates[idx]\n        if dem[node] <= avail_cap:\n            arrival = cur_time + dist_mat[current_node, node]\n            if arrival <= tw[node, 1]:\n                slack = max(tw[node, 1] - arrival, 0.0)\n                urgencies.append(1.0 / (slack + 1.0 + 1e-12))\n                feasible_nodes.append(node)\n        idx += 1\n\n    if not feasible_nodes:\n        return depot\n\n    urgencies = np.array(urgencies)\n    # Deterministic noise for tie\u2011breaking\n    urgencies += 1e-6 * np.arange(urgencies.size)\n\n    # Select top\u2011k most urgent nodes\n    top_k = min(5, urgencies.size)\n    top_indices = np.argpartition(-urgencies, top_k - 1)[:top_k]\n    top_nodes = np.array(feasible_nodes)[top_indices]\n\n    seed = (current_node * 2654435761) ^ int(cur_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(top_nodes))\n\n",
  "stochastic_urgency_aug_74": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    avail_cap = rest_capacity\n    cur_time = current_time\n    dem = demands\n    tw = time_windows\n\n    arrivals = cur_time + dist_mat[current_node, candidates]\n    feasible_mask = (dem[candidates] <= avail_cap) & (arrivals <= tw[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n    feasible_arrivals = arrivals[feasible_mask]\n    slack = np.clip(tw[feasible_nodes, 1] - feasible_arrivals, 0, None)\n\n    urgencies = 1.0 / (slack + 1.0 + 1e-12)\n    # Deterministic noise to ensure reproducible tie breaking\n    urgencies += 1e-6 * np.arange(urgencies.size)\n\n    max_val = np.max(urgencies)\n    max_nodes = feasible_nodes[urgencies == max_val]\n\n    if max_nodes.size > 1:\n        seed = (current_node * 2654435761) ^ int(cur_time * 1000)\n        rng = np.random.default_rng(seed % (2**32))\n        return int(rng.choice(max_nodes))\n    return int(max_nodes[0])\n\n",
  "stochastic_urgency_aug_75": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    avail_cap = rest_capacity\n    cur_time = current_time\n    dem = demands\n    tw = time_windows\n\n    arrivals = cur_time + dist_mat[current_node, candidates]\n    feasible_mask = (dem[candidates] <= avail_cap) & (arrivals <= tw[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n    feasible_arrivals = arrivals[feasible_mask]\n    slack = np.clip(tw[feasible_nodes, 1] - feasible_arrivals, 0, None)\n\n    # Weighted score: distance + 0.5 * slack\n    distances = dist_mat[current_node, feasible_nodes]\n    scores = distances + 0.5 * slack\n    scores = np.clip(scores, 0, None)  # avoid negative scores\n\n    top_k = min(7, scores.size)\n    top_indices = np.argpartition(scores, top_k - 1)[:top_k]\n    top_nodes = feasible_nodes[top_indices]\n\n    seed = (current_node * 2654435761) ^ int(cur_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(top_nodes))\n\n",
  "time_window_midpoint_aug_76": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasibility: capacity & time\u2011window\n    feasible_mask = (\n        (demands[unvisited_nodes] <= rest_capacity) &\n        (current_time + distance_matrix[current_node, unvisited_nodes] <= time_windows[unvisited_nodes, 1])\n    )\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    arrivals = current_time + distance_matrix[current_node, feasible_nodes]\n    service_start = np.maximum(arrivals, time_windows[feasible_nodes, 0])\n    midpoints = (time_windows[feasible_nodes, 0] + time_windows[feasible_nodes, 1]) * 0.5\n    deviations = np.abs(service_start - midpoints)\n\n    idx = np.argmin(deviations)\n    return int(feasible_nodes[idx])\n\n",
  "time_window_midpoint_aug_77": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    dist = distance_matrix[current_node, unvisited_nodes]\n    feasible_mask = (\n        (demands[unvisited_nodes] <= rest_capacity) &\n        (current_time + dist <= time_windows[unvisited_nodes, 1])\n    )\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    dist_f = dist[feasible_mask]\n    arrivals = current_time + dist_f\n    service_start = np.maximum(arrivals, time_windows[feasible_nodes, 0])\n    midpoints = (time_windows[feasible_nodes, 0] + time_windows[feasible_nodes, 1]) * 0.5\n    time_dev = np.abs(service_start - midpoints)\n\n    # Weighted score: distance (60\u202f%) + time deviation (40\u202f%)\n    score = 0.6 * dist_f + 0.4 * time_dev\n\n    # Soft\u2011min probabilities (higher score \u2192 lower probability)\n    beta = 5.0\n    exp_vals = np.exp(-beta * score)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)  # epsilon to avoid div\u2011by\u2011zero\n\n    rng = np.random.default_rng()\n    chosen = rng.choice(feasible_nodes, p=probs)\n    return int(chosen)\n\n",
  "time_window_midpoint_aug_78": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    dist = distance_matrix[current_node, unvisited_nodes]\n    feasible_mask = (\n        (demands[unvisited_nodes] <= rest_capacity) &\n        (current_time + dist <= time_windows[unvisited_nodes, 1])\n    )\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    dist_f = dist[feasible_mask]\n    arrivals = current_time + dist_f\n    service_start = np.maximum(arrivals, time_windows[feasible_nodes, 0])\n    midpoints = (time_windows[feasible_nodes, 0] + time_windows[feasible_nodes, 1]) * 0.5\n    deviations = np.abs(service_start - midpoints)\n\n    # Deterministic noise to avoid exact ties\n    noise = np.arange(len(deviations)) * 1e-6\n    deviations_noisy = deviations + noise\n\n    top_k = 7\n    if len(deviations_noisy) <= top_k:\n        candidates = feasible_nodes\n    else:\n        idx_top = np.argpartition(deviations_noisy, top_k)[:top_k]\n        candidates = feasible_nodes[idx_top]\n\n    rng = np.random.default_rng()\n    chosen = rng.choice(candidates)\n    return int(chosen)\n\n",
  "time_window_midpoint_aug_79": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    dist = distance_matrix[current_node, unvisited_nodes]\n    feasible_mask = (\n        (demands[unvisited_nodes] <= rest_capacity) &\n        (current_time + dist <= time_windows[unvisited_nodes, 1])\n    )\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    dist_f = dist[feasible_mask]\n    arrivals = current_time + dist_f\n    service_start = np.maximum(arrivals, time_windows[feasible_nodes, 0])\n    midpoints = (time_windows[feasible_nodes, 0] + time_windows[feasible_nodes, 1]) * 0.5\n    deviations = np.abs(service_start - midpoints)\n\n    # Clip to a safe range and compute median\n    deviations_clipped = np.clip(deviations, 0, 1e9)\n    median_dev = np.median(deviations_clipped)\n\n    # Distance from median with deterministic noise\n    diff = np.abs(deviations_clipped - median_dev)\n    noise = np.linspace(0, 1e-8, len(diff))\n    diff_noisy = diff + noise\n\n    idx = np.argmin(diff_noisy)\n    return int(feasible_nodes[idx])\n\n",
  "capacity_time_balance_aug_80": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap = float(rest_capacity)\n    cur_time = float(current_time)\n    dem = demands\n    tw = time_windows\n\n    if len(candidates) == 0:\n        return depot\n\n    feasible = []\n    slacks = []\n    idx = 0\n    while idx < len(candidates):\n        node = int(candidates[idx])\n        if dem[node] <= rest_cap:\n            arrival = cur_time + dist_mat[current_node, node]\n            if arrival <= tw[node][1]:\n                feasible.append(node)\n                slacks.append(tw[node][1] - arrival)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    # capacity_ratio with epsilon and clipping\n    max_demand = np.max(dem) + 1e-12\n    capacity_ratio = rest_cap / max_demand\n    capacity_ratio = np.clip(capacity_ratio, 0, 1)\n\n    slacks_arr = np.array(slacks)\n    demand_vals = dem[feasible]\n\n    if capacity_ratio < 0.3:\n        chosen = int(feasible[np.argmin(demand_vals)])\n    else:\n        chosen = int(feasible[np.argmin(slacks_arr)])\n\n    return chosen\n\n",
  "capacity_time_balance_aug_81": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap = float(rest_capacity)\n    cur_time = float(current_time)\n    dem = demands\n    tw = time_windows\n\n    if len(candidates) == 0:\n        return depot\n\n    feasible = np.array([], dtype=int)\n    slacks = np.array([], dtype=float)\n    distances = np.array([], dtype=float)\n\n    for node in candidates:\n        node = int(node)\n        if dem[node] <= rest_cap:\n            arrival = cur_time + dist_mat[current_node, node]\n            if arrival <= tw[node][1]:\n                feasible = np.append(feasible, node)\n                slacks = np.append(slacks, tw[node][1] - arrival)\n                distances = np.append(distances, dist_mat[current_node, node])\n\n    if feasible.size == 0:\n        return depot\n\n    # Parameter tuning: weighted score\n    w_dist = 0.6\n    w_slack = 0.4\n    max_dist = np.max(distances) + 1e-12\n    max_slack = np.max(slacks) + 1e-12\n    norm_dist = distances / max_dist\n    norm_slack = slacks / max_slack\n    scores = w_dist * norm_dist + w_slack * norm_slack\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(feasible.size) * 1e-6\n    scores = scores + noise\n\n    top_k = min(7, feasible.size)\n    top_indices = np.argpartition(scores, -top_k)[-top_k:]\n    top_nodes = feasible[top_indices]\n\n    chosen = int(np.random.choice(top_nodes))\n    return chosen\n\n",
  "capacity_time_balance_aug_82": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap = float(rest_capacity)\n    cur_time = float(current_time)\n    dem = demands\n    tw = time_windows\n\n    if len(candidates) == 0:\n        return depot\n\n    feasible = []\n    costs = []\n\n    for node in candidates:\n        node = int(node)\n        if dem[node] <= rest_cap:\n            arrival = cur_time + dist_mat[current_node, node]\n            if arrival <= tw[node][1]:\n                slack = tw[node][1] - arrival\n                cost = dist_mat[current_node, node] + slack\n                feasible.append(node)\n                costs.append(cost)\n\n    if not feasible:\n        return depot\n\n    costs_arr = np.array(costs)\n    temp = 1.0\n    exp_vals = np.exp(-temp * costs_arr)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # deterministic noise to avoid exact ties\n    noise = np.arange(len(feasible)) * 1e-6\n    probs = probs + noise\n    probs = probs / (np.sum(probs) + 1e-12)\n\n    chosen = int(np.random.choice(feasible, p=probs))\n    return chosen\n\n",
  "capacity_time_balance_aug_83": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap = float(rest_capacity)\n    cur_time = float(current_time)\n    dem = demands\n    tw = time_windows\n\n    if len(candidates) == 0:\n        return depot\n\n    feasible = []\n    slacks = []\n\n    for node in candidates:\n        node = int(node)\n        if dem[node] <= rest_cap:\n            arrival = cur_time + dist_mat[current_node, node]\n            if arrival <= tw[node][1]:\n                feasible.append(node)\n                slacks.append(tw[node][1] - arrival)\n\n    if not feasible:\n        return depot\n\n    # proxy: keep nodes with slack close to the maximum\n    max_slack = np.max(slacks) + 1e-12\n    threshold = np.clip(0.8 * max_slack, 0, max_slack)\n    filtered = [n for n, s in zip(feasible, slacks) if s >= threshold]\n    if not filtered:\n        filtered = feasible\n\n    top_k = min(5, len(filtered))\n    chosen = int(np.random.choice(filtered[:top_k]))\n    return chosen\n\n",
  "five_factor_composite_aug_84": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    remaining_cap = rest_capacity\n    curr_time = current_time\n    demand_arr = demands\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    # Vectorised feasibility filtering\n    arrival = curr_time + dist_mat[current_node, candidates]\n    feasible_mask = (demand_arr[candidates] <= remaining_cap) & \\\n                    (arrival <= tw[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = candidates[feasible_mask]\n    arr = curr_time + dist_mat[current_node, feasible]\n    slack = tw[feasible, 1] - arr\n    wait = np.maximum(0.0, tw[feasible, 0] - arr)\n\n    # Normalisation helper\n    def norm(x):\n        mn, mx = x.min(), x.max()\n        return (x - mn) / (mx - mn + 1e-12)\n\n    dist_vals = dist_mat[current_node, feasible]\n    demand_vals = demand_arr[feasible]\n    capacity_util = demand_vals / (remaining_cap + 1e-12)\n\n    urgency = 1.0 / (slack + 1.0)\n\n    # Add tiny deterministic noise for stable tie\u2011breaking\n    noise = np.random.rand(feasible.size) * 1e-6\n    score = (0.30 * norm(dist_vals) -\n             0.20 * norm(demand_vals) +\n             0.25 * norm(urgency) +\n             0.15 * norm(wait) +\n             0.10 * norm(capacity_util) + noise)\n\n    return int(feasible[np.argmin(score)])\n\n",
  "five_factor_composite_aug_85": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    curr_time = current_time\n    demand_arr = demands\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    arrival = curr_time + dist_mat[current_node, candidates]\n    feasible_mask = (demand_arr[candidates] <= rem_cap) & \\\n                    (arrival <= tw[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = candidates[feasible_mask]\n    arr = curr_time + dist_mat[current_node, feasible]\n    slack = tw[feasible, 1] - arr\n    wait = np.maximum(0.0, tw[feasible, 0] - arr)\n\n    def norm(x):\n        mn, mx = x.min(), x.max()\n        return (x - mn) / (mx - mn + 1e-12)\n\n    dist_vals = dist_mat[current_node, feasible]\n    demand_vals = demand_arr[feasible]\n    capacity_util = demand_vals / (rem_cap + 1e-12)\n\n    urgency = 1.0 / (slack + 1.0)\n\n    score = (0.50 * norm(dist_vals) -\n             0.25 * norm(demand_vals) +\n             0.15 * norm(urgency) +\n             0.05 * norm(wait) +\n             0.05 * norm(capacity_util))\n\n    # Randomly pick among the top\u2011k best candidates\n    top_k = 7\n    if feasible.size <= top_k:\n        idxs = np.arange(feasible.size)\n    else:\n        idxs = np.argpartition(score, top_k)[:top_k]\n    chosen = np.random.choice(idxs)\n    return int(feasible[chosen])\n\n",
  "five_factor_composite_aug_86": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    curr_time = current_time\n    demand_arr = demands\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    arrival = curr_time + dist_mat[current_node, candidates]\n    feasible_mask = (demand_arr[candidates] <= rem_cap) & \\\n                    (arrival <= tw[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = candidates[feasible_mask]\n    arr = curr_time + dist_mat[current_node, feasible]\n    slack = tw[feasible, 1] - arr\n    wait = np.maximum(0.0, tw[feasible, 0] - arr)\n\n    def norm(x):\n        mn, mx = x.min(), x.max()\n        return (x - mn) / (mx - mn + 1e-12)\n\n    dist_vals = dist_mat[current_node, feasible]\n    demand_vals = demand_arr[feasible]\n    capacity_util = demand_vals / (rem_cap + 1e-12)\n\n    urgency = 1.0 / (slack + 1.0)\n\n    score = (0.35 * norm(dist_vals) -\n             0.20 * norm(demand_vals) +\n             0.25 * norm(urgency) +\n             0.10 * norm(wait) +\n             0.10 * norm(capacity_util))\n\n    # Softmin selection with temperature\n    temp = 0.5\n    exp_vals = np.exp(-score / temp)\n    probs = exp_vals / np.clip(exp_vals.sum(), 1e-12, None)\n    chosen_idx = np.random.choice(len(feasible), p=probs)\n    return int(feasible[chosen_idx])\n\n",
  "five_factor_composite_aug_87": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    curr_time = current_time\n    demand_arr = demands\n    tw = time_windows\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = []\n    slacks = []\n    waits = []\n\n    idx = 0\n    while idx < candidates.size:\n        node = candidates[idx]\n        if demand_arr[node] > rem_cap:\n            idx += 1\n            continue\n        arrival = curr_time + dist_mat[current_node, node]\n        if arrival > tw[node, 1]:\n            idx += 1\n            continue\n        feasible.append(node)\n        slacks.append(tw[node, 1] - arrival)\n        waits.append(max(0.0, tw[node, 0] - arrival))\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n    slacks = np.array(slacks, dtype=float)\n    waits = np.array(waits, dtype=float)\n\n    def norm(x):\n        mn, mx = x.min(), x.max()\n        return (x - mn) / (mx - mn + 1e-12)\n\n    dist_vals = dist_mat[current_node, feasible]\n    demand_vals = demand_arr[feasible]\n    capacity_util = demand_vals / (rem_cap + 1e-12)\n\n    urgency = 1.0 / (slacks + 1.0)\n\n    score = (0.28 * norm(dist_vals) -\n             0.22 * norm(demand_vals) +\n             0.32 * norm(urgency) +\n             0.18 * norm(waits) +\n             0.10 * norm(capacity_util))\n\n    # Deterministic tie\u2011breaking by adding a tiny increasing offset\n    tie_break = np.arange(feasible.size) * 1e-9\n    score += tie_break\n    return int(feasible[np.argmin(score)])\n\n",
  "random_time_feasible_aug_88": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename variables\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    # feasibility mask\n    demand_ok = demands[candidates] <= rest_capacity\n    arrival_times = current_time + dist_mat[current_node, candidates]\n    time_ok = arrival_times <= time_windows[candidates, 1]\n    feasible_mask = demand_ok & time_ok\n    feasible_nodes = candidates[feasible_mask]\n\n    if feasible_nodes.size == 0:\n        return depot\n\n    # deterministic seed for reproducibility\n    seed = int(current_node * 73856093) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n\n    # add tiny deterministic noise to break ties\n    noise = (feasible_nodes + 1e-6) * 1e-9\n    probs = rng.random(feasible_nodes.size) + noise\n    chosen = feasible_nodes[np.argmax(probs)]\n    return int(chosen)\n\n",
  "random_time_feasible_aug_89": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes.copy()\n\n    if candidates.size == 0:\n        return depot\n\n    while candidates.size > 0:\n        # compute feasibility\n        mask = (demands[candidates] <= rest_capacity) & \\\n               (current_time + dist_mat[current_node, candidates] <=\n                time_windows[candidates, 1])\n        feasible = candidates[mask]\n\n        if feasible.size == 0:\n            return depot\n\n        # compute distances to feasible nodes\n        dists = dist_mat[current_node, feasible]\n        # select top_k smallest distances\n        top_k = 7\n        top_k = min(top_k, feasible.size)\n        idx_sorted = np.argsort(dists)\n        top_nodes = feasible[idx_sorted[:top_k]]\n\n        # deterministic seed\n        seed = int(current_node * 19260817) ^ int(current_time * 12345)\n        rng = np.random.default_rng(seed % (2**32))\n        chosen = rng.choice(top_nodes)\n        return int(chosen)\n\n    return depot\n\n",
  "random_time_feasible_aug_90": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    # feasibility mask\n    mask = (demands[candidates] <= rest_capacity) & \\\n           (current_time + dist_mat[current_node, candidates] <=\n            time_windows[candidates, 1])\n    feasible = candidates[mask]\n\n    if feasible.size == 0:\n        return depot\n\n    # compute distances and softmin probabilities\n    dists = dist_mat[current_node, feasible]\n    eps = 1e-12\n    scores = np.exp(-dists / (eps + 1e-12))\n    probs = scores / np.clip(scores.sum(), eps, None)\n\n    # deterministic seed\n    seed = int(current_node * 9973) ^ int(current_time * 271828)\n    rng = np.random.default_rng(seed % (2**32))\n    chosen = rng.choice(feasible, p=probs)\n    return int(chosen)\n\n",
  "random_time_feasible_aug_91": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes.copy()\n\n    if candidates.size == 0:\n        return depot\n\n    while candidates.size > 0:\n        # feasibility mask\n        demand_ok = demands[candidates] <= rest_capacity\n        arrival = current_time + dist_mat[current_node, candidates]\n        # scale upper bound by 0.9 to be stricter\n        upper = time_windows[candidates, 1] * 0.9 + 0.1 * \\\n                (time_windows[candidates, 1] - time_windows[candidates, 0])\n        time_ok = arrival <= upper\n        feasible = candidates[demand_ok & time_ok]\n\n        if feasible.size == 0:\n            return depot\n\n        # use mean distance to rank\n        dists = dist_mat[current_node, feasible]\n        mean_dist = np.mean(dists)\n        mask = dists <= 1.5 * mean_dist\n        shortlist = feasible[mask]\n\n        # deterministic seed\n        seed = int(current_node * 31415926) ^ int(current_time * 271828)\n        rng = np.random.default_rng(seed % (2**32))\n        chosen = rng.choice(shortlist)\n        return int(chosen)\n\n    return depot\n\n",
  "time_density_routing_aug_92": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    rest_cap = rest_capacity.item() if isinstance(rest_capacity, np.ndarray) else rest_capacity\n    curr_time = current_time.item() if isinstance(current_time, np.ndarray) else current_time\n\n    # Vectorised feasibility test\n    arrivals = curr_time + distance_matrix[current_node, unvisited_nodes]\n    feasible_mask = (demands[unvisited_nodes] <= rest_cap) & (arrivals <= time_windows[unvisited_nodes, 1])\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    if feasible_nodes.size == 0:\n        return depot\n\n    # Density via overlap count\n    tw_start = time_windows[feasible_nodes, 0]\n    tw_end   = time_windows[feasible_nodes, 1]\n    overlap_mat = (~(tw_end[:, None] < tw_start[None, :] | tw_end[None, :] < tw_start[:, None]))\n    densities = overlap_mat.sum(axis=1) - 1\n    densities = np.clip(densities, 1e-12, None)\n\n    # Normalised scores\n    distances = distance_matrix[current_node, feasible_nodes]\n    dist_norm = distances / (np.mean(distances) + 1e-12)\n    density_norm = densities / (np.max(densities) + 1e-12)\n    scores = dist_norm - 0.6 * density_norm\n\n    # Small deterministic noise for stable tie\u2011breaking\n    noise = np.random.uniform(0, 1e-6, size=scores.shape)\n    scores += noise\n\n    return int(feasible_nodes[np.argmin(scores)])\n\n",
  "time_density_routing_aug_93": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    rest_cap = rest_capacity.item() if isinstance(rest_capacity, np.ndarray) else rest_capacity\n    curr_time = current_time.item() if isinstance(current_time, np.ndarray) else current_time\n\n    # Build feasible list with a while loop\n    feasible_nodes = []\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = unvisited_nodes[idx]\n        if (demands[node] <= rest_cap and\n                curr_time + distance_matrix[current_node, node] <= time_windows[node, 1]):\n            feasible_nodes.append(node)\n        idx += 1\n    if not feasible_nodes:\n        return depot\n\n    # Density calculation with explicit loops\n    densities = []\n    for node in feasible_nodes:\n        overlaps = 0\n        for other in unvisited_nodes:\n            if other != node:\n                if not (time_windows[node, 1] < time_windows[other, 0] or\n                        time_windows[other, 1] < time_windows[node, 0]):\n                    overlaps += 1\n        densities.append(overlaps)\n    densities = np.array(densities, dtype=float) + 1e-12\n\n    # Softmin sampling\n    distances = distance_matrix[current_node, feasible_nodes]\n    scores = distances - 0.6 * densities\n    beta = 10.0\n    exp_scores = np.exp(-beta * scores)\n    probs = exp_scores / exp_scores.sum()\n    chosen = np.random.choice(feasible_nodes, p=probs)\n    return int(chosen)\n\n",
  "time_density_routing_aug_94": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    rest_cap = rest_capacity.item() if isinstance(rest_capacity, np.ndarray) else rest_capacity\n    curr_time = current_time.item() if isinstance(current_time, np.ndarray) else current_time\n\n    arrivals = curr_time + distance_matrix[current_node, unvisited_nodes]\n    feasible_mask = (demands[unvisited_nodes] <= rest_cap) & (arrivals <= time_windows[unvisited_nodes, 1])\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    if feasible_nodes.size == 0:\n        return depot\n\n    # Density via sum of overlaps\n    tw_start = time_windows[feasible_nodes, 0]\n    tw_end   = time_windows[feasible_nodes, 1]\n    overlap_mat = (~(tw_end[:, None] < tw_start[None, :] | tw_end[None, :] < tw_start[:, None]))\n    densities = overlap_mat.sum(axis=1) - 1\n    densities = np.clip(densities, 1e-12, None)\n\n    distances = distance_matrix[current_node, feasible_nodes]\n    dist_norm = distances / (np.median(distances) + 1e-12)\n    density_norm = densities / (np.sum(densities) + 1e-12)\n    scores = dist_norm + 0.4 * density_norm\n\n    # Top\u2011k deterministic selection with tiny noise\n    top_k = 5\n    top_idx = np.argsort(scores)[:top_k]\n    top_nodes = feasible_nodes[top_idx]\n    noise = np.arange(len(top_nodes)) * 1e-8\n    chosen = top_nodes[np.argmin(scores[top_idx] + noise)]\n    return int(chosen)\n\n",
  "time_density_routing_aug_95": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    rest_cap = rest_capacity.item() if isinstance(rest_capacity, np.ndarray) else rest_capacity\n    curr_time = current_time.item() if isinstance(current_time, np.ndarray) else current_time\n\n    arrivals = curr_time + distance_matrix[current_node, unvisited_nodes]\n    feasible_mask = (demands[unvisited_nodes] <= rest_cap) & (arrivals <= time_windows[unvisited_nodes, 1])\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    if feasible_nodes.size == 0:\n        return depot\n\n    # Proxy density approximation\n    tw_start = time_windows[feasible_nodes, 0]\n    tw_end   = time_windows[feasible_nodes, 1]\n    overlap_mat = (tw_start[:, None] <= tw_end[None, :]) & (tw_end[:, None] >= tw_start[None, :])\n    densities = overlap_mat.sum(axis=1) - 1\n    densities = np.clip(densities, 1e-12, None)\n\n    distances = distance_matrix[current_node, feasible_nodes]\n    dist_norm = distances / (np.mean(distances) + 1e-12)\n    density_norm = densities / (np.max(densities) + 1e-12)\n    scores = 0.7 * dist_norm - 0.3 * density_norm\n\n    # Random pick among the best three\n    top_k = 3\n    top_idx = np.argsort(scores)[:top_k]\n    chosen = np.random.choice(feasible_nodes[top_idx])\n    return int(chosen)\n\n",
  "progressive_urgency_aug_96": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # rename for readability\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = rest_capacity\n    curr_t = current_time\n    dem = demands\n    tw = time_windows\n\n    # build feasible set with list comprehension\n    feasible = np.array([c for c in candidates if dem[c] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # arrival time and slack\n    arrival = curr_t + dist_mat[current_node, feasible]\n    slack = tw[feasible, 1] - arrival\n    mask = slack >= 0\n    feasible = feasible[mask]\n    slack = slack[mask]\n    arrival = arrival[mask]\n    if feasible.size == 0:\n        return depot\n\n    # progress indicator\n    max_tw = np.max(tw[:, 1]) + 1e-12\n    progress = curr_t / max_tw\n\n    # distances and urgencies\n    dists = dist_mat[current_node, feasible]\n    urg = 1.0 / (slack + 1.0 + 1e-12)\n\n    # normalize\n    d_norm = dists / (np.mean(dists) + 1e-12)\n    u_norm = urg / (np.mean(urg) + 1e-12)\n\n    # weighted score\n    weight = progress\n    scores = (1 - weight) * 0.7 * d_norm + weight * 0.7 * u_norm\n\n    # deterministic tie\u2011breaking noise\n    rng = np.random.default_rng(1234)\n    noise = rng.uniform(-1e-6, 1e-6, size=scores.shape)\n    scores += noise\n\n    # clip to avoid extreme values\n    scores = np.clip(scores, 0, 1)\n\n    return int(feasible[np.argmin(scores)])\n\n",
  "progressive_urgency_aug_97": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = rest_capacity\n    curr_t = current_time\n    dem = demands\n    tw = time_windows\n\n    feasible = []\n    slacks = []\n    for node in candidates:\n        if dem[node] <= cap:\n            arrival = curr_t + dist_mat[current_node, node]\n            if arrival <= tw[node, 1]:\n                feasible.append(node)\n                slacks.append(tw[node, 1] - arrival)\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n    slacks = np.array(slacks, dtype=float)\n\n    max_tw = np.max(tw[:, 1]) + 1e-12\n    progress = curr_t / max_tw\n\n    dists = dist_mat[current_node, feasible]\n    urg = 1.0 / (slacks + 1.0 + 1e-12)\n\n    # median scaling\n    d_norm = dists / (np.median(dists) + 1e-12)\n    u_norm = urg / (np.median(urg) + 1e-12)\n\n    # weighted raw score\n    weight = progress\n    raw_scores = (1 - weight) * 0.6 * d_norm + weight * 0.6 * u_norm\n    raw_scores = np.clip(raw_scores, 0, 1)\n\n    # softmin probabilities\n    alpha = 10.0\n    logits = -alpha * raw_scores\n    exp_logits = np.exp(logits - np.max(logits))  # numerical stability\n    probs = exp_logits / (np.sum(exp_logits) + 1e-12)\n\n    # deterministic pick of highest probability\n    idx = np.argmax(probs)\n    return int(feasible[idx])\n\n",
  "progressive_urgency_aug_98": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = rest_capacity\n    curr_t = current_time\n    dem = demands\n    tw = time_windows\n\n    feasible = []\n    slacks = []\n    for node in candidates:\n        if dem[node] <= cap:\n            arrival = curr_t + dist_mat[current_node, node]\n            if arrival <= tw[node, 1]:\n                feasible.append(node)\n                slacks.append(tw[node, 1] - arrival)\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n    slacks = np.array(slacks, dtype=float)\n\n    max_tw = np.max(tw[:, 1]) + 1e-12\n    progress = curr_t / max_tw\n\n    dists = dist_mat[current_node, feasible]\n    urg = 1.0 / (slacks + 1.0 + 1e-12)\n\n    # sum normalization\n    d_norm = dists / (np.sum(dists) + 1e-12)\n    u_norm = urg / (np.sum(urg) + 1e-12)\n\n    # weighted score\n    weight = progress\n    scores = (1 - weight) * 0.4 * d_norm + weight * 0.6 * u_norm\n    scores = np.clip(scores, 0, 1)\n\n    top_k = 5\n    if feasible.size <= top_k:\n        return int(feasible[np.argmin(scores)])\n\n    # pick random among lowest top_k scores\n    top_indices = np.argpartition(scores, top_k)[:top_k]\n    rng = np.random.default_rng(2023)\n    chosen = rng.choice(top_indices)\n    return int(feasible[chosen])\n\n",
  "progressive_urgency_aug_99": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = rest_capacity\n    curr_t = current_time\n    dem = demands\n    tw = time_windows\n\n    # feasible set\n    feasible = np.array([c for c in candidates if dem[c] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    arrival = curr_t + dist_mat[current_node, feasible]\n    slack = tw[feasible, 1] - arrival\n    mask = slack >= 0\n    feasible = feasible[mask]\n    slack = slack[mask]\n    arrival = arrival[mask]\n    if feasible.size == 0:\n        return depot\n\n    max_tw = np.max(tw[:, 1]) + 1e-12\n    progress = curr_t / max_tw\n\n    dists = dist_mat[current_node, feasible]\n    # proxy urgency using log slack\n    urg = np.log1p(slack + 1e-12)\n    urg = 1.0 / (urg + 1.0 + 1e-12)\n\n    # max normalisation\n    d_norm = dists / (np.max(dists) + 1e-12)\n    u_norm = urg / (np.max(urg) + 1e-12)\n\n    weight = progress\n    scores = (1 - weight) * 0.6 * d_norm + weight * 0.4 * u_norm\n\n    # deterministic tie\u2011breaking noise\n    rng = np.random.default_rng(7)\n    noise = rng.uniform(-1e-7, 1e-7, size=scores.shape)\n    scores += noise\n    scores = np.clip(scores, 0, 1)\n\n    return int(feasible[np.argmin(scores)])\n\n",
  "minmax_normalized_vrptw_aug_100": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Build feasible list using a while loop\n    feasible = []\n    slacks = []\n    waits = []\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = unvisited_nodes[idx]\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node, 1]:\n                feasible.append(node)\n                slacks.append(time_windows[node, 1] - arrival)\n                waits.append(max(0.0, time_windows[node, 0] - arrival))\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible)\n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n\n    def minmax(x):\n        mn = x.min()\n        mx = x.max()\n        denom = mx - mn + 1e-12\n        return (x - mn) / denom\n\n    urgency = 1.0 / (slacks + 1.0 + 1e-12)\n    score = (0.4 * minmax(distances) - 0.3 * minmax(demand_vals) +\n             0.2 * minmax(urgency) + 0.1 * minmax(waits))\n\n    # Small deterministic noise to break ties\n    noise = np.arange(score.size) * 1e-8\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "minmax_normalized_vrptw_aug_101": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # List comprehension for feasible nodes\n    feasible = [node for node in unvisited_nodes\n                if demands[node] <= rest_capacity and\n                current_time + distance_matrix[current_node, node] <= time_windows[node, 1]]\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible)\n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = time_windows[feasible, 1] - (current_time + distances)\n    waits = np.maximum(0.0, time_windows[feasible, 0] - (current_time + distances))\n\n    def minmax(x):\n        mn = np.min(x)\n        mx = np.max(x)\n        denom = mx - mn + 1e-12\n        return (x - mn) / denom\n\n    urgency = 1.0 / (slacks + 1.0 + 1e-12)\n    score = (0.3 * minmax(distances) - 0.4 * minmax(demand_vals) +\n             0.2 * minmax(urgency) + 0.1 * minmax(waits))\n\n    # Random choice among the top\u2011k closest nodes\n    top_k = min(3, len(feasible))\n    top_indices = np.argpartition(score, top_k - 1)[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n    return int(feasible[chosen_idx])\n\n",
  "minmax_normalized_vrptw_aug_102": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Vectorised feasibility check\n    arrivals = current_time + distance_matrix[current_node, unvisited_nodes]\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity) & \\\n                    (arrivals <= time_windows[unvisited_nodes, 1])\n\n    if not np.any(feasible_mask):\n        return depot\n\n    candidates = unvisited_nodes[feasible_mask]\n    dist = distance_matrix[current_node, candidates]\n    demand = demands[candidates]\n    slacks = time_windows[candidates, 1] - arrivals[feasible_mask]\n    waits = np.maximum(0.0, time_windows[candidates, 0] - arrivals[feasible_mask])\n\n    def minmax(x):\n        mn = np.min(x)\n        mx = np.max(x)\n        denom = mx - mn + 1e-12\n        return (x - mn) / denom\n\n    urgency = 1.0 / (slacks + 1.0 + 1e-12)\n\n    score = (0.2 * minmax(dist) - 0.5 * minmax(demand) +\n             0.3 * minmax(urgency))\n\n    # Randomly pick among the top\u2011k best candidates\n    top_k = min(5, len(candidates))\n    top_indices = np.argpartition(score, top_k - 1)[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n    return int(candidates[chosen_idx])\n\n",
  "min_time_slack_aug_103": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = int(current_node)\n    depot_id = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    # scalar extraction with safety\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_curr = float(np.asarray(current_time).reshape(-1)[0])\n\n    if cand.size == 0:\n        return depot_id\n\n    # distances to all candidates\n    dists = distance_matrix[curr, cand]\n    # earliest feasible arrival respecting time windows\n    earliest = np.maximum(t_curr + dists, time_windows[cand, 0])\n    # slack = due - earliest\n    slack = time_windows[cand, 1] - earliest\n    # ensure non\u2011negative slack\n    slack = np.clip(slack, 0, None)\n\n    # feasibility mask\n    feas = (demands[cand] <= cap) & (slack > 0)\n    if not np.any(feas):\n        return depot_id\n\n    feas_cand = cand[feas]\n    feas_slack = slack[feas]\n\n    # deterministic tie\u2011breaking via tiny increasing noise\n    noise = 1e-8 * np.arange(feas_slack.size)\n    feas_slack_noisy = feas_slack + noise\n\n    # choose node with minimal (noisy) slack\n    idx_min = int(np.argmin(feas_slack_noisy))\n    return int(feas_cand[idx_min])\n\n",
  "min_time_slack_aug_104": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = int(current_node)\n    depot_id = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_curr = float(np.asarray(current_time).reshape(-1)[0])\n\n    if cand.size == 0:\n        return depot_id\n\n    best_node = depot_id\n    best_weight = -np.inf\n    temperature = 1.0  # softmin temperature\n\n    i = 0\n    while i < cand.size:\n        node = int(cand[i])\n        dist = distance_matrix[curr, node]\n        arrival = t_curr + dist\n        start_time = np.maximum(arrival, time_windows[node, 0])\n        slack = time_windows[node, 1] - start_time\n\n        if (demands[node] <= cap) and (slack >= 0):\n            # softmin weight, avoid division by zero\n            weight = np.exp(-slack / (temperature + 1e-12))\n            weight = np.clip(weight, -np.inf, np.inf)\n            if weight > best_weight:\n                best_weight = weight\n                best_node = node\n        i += 1\n\n    return best_node\n\n",
  "min_time_slack_aug_105": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = int(current_node)\n    depot_id = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_curr = float(np.asarray(current_time).reshape(-1)[0])\n\n    if cand.size == 0:\n        return depot_id\n\n    dists = distance_matrix[curr, cand]\n    earliest = np.maximum(t_curr + dists, time_windows[cand, 0])\n    slack = time_windows[cand, 1] - earliest\n    feas = (demands[cand] <= cap) & (slack >= 0)\n\n    feas_cand = cand[feas]\n    feas_slack = slack[feas]\n\n    if feas_cand.size == 0:\n        return depot_id\n\n    top_k = 7\n    k = min(top_k, feas_cand.size)\n    idx_sorted = np.argsort(feas_slack)          # ascending slack\n    top_indices = idx_sorted[:k]\n    chosen = np.random.choice(feas_cand[top_indices])\n    return int(chosen)\n\n",
  "min_time_slack_aug_106": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = int(current_node)\n    depot_id = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_curr = float(np.asarray(current_time).reshape(-1)[0])\n\n    if cand.size == 0:\n        return depot_id\n\n    dists = distance_matrix[curr, cand]\n    earliest = np.maximum(t_curr + dists, time_windows[cand, 0])\n    due = time_windows[cand, 1]\n    slack = due - earliest\n    feas = (demands[cand] <= cap) & (slack >= 0)\n\n    feas_cand = cand[feas]\n    feas_dists = dists[feas]\n    feas_slack = slack[feas]\n\n    if feas_cand.size == 0:\n        return depot_id\n\n    # proxy score: higher is better\n    score = feas_slack + 0.5 * feas_dists\n    score = np.clip(score, -np.inf, np.inf)\n\n    # deterministic tie\u2011breaking with small noise\n    noise = 1e-9 * np.arange(score.size)\n    score_noisy = score + noise\n    idx_best = int(np.argmax(score_noisy))\n    return int(feas_cand[idx_best])\n\n",
  "max_demand_that_fits_aug_107": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for readability\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0]) + 1e-12\n    t   = float(np.asarray(current_time).reshape(-1)[0])   + 1e-12\n\n    # Earliest possible start time at each candidate\n    travel = distance_matrix[int(current_node), candidates]\n    earliest_start = np.maximum(t + travel, time_windows[candidates, 0])\n\n    # Feasibility mask\n    feasible = (demands[candidates] <= cap) & (earliest_start <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_idx = candidates[feasible]\n    # Add tiny noise to demand to break ties deterministically\n    noise = np.arange(feasible_idx.size) * 1e-9\n    best_idx = feasible_idx[np.argmax(demands[feasible_idx] + noise)]\n    return int(best_idx)\n\n",
  "max_demand_that_fits_aug_108": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = list(np.asarray(unvisited_nodes, dtype=int))\n    if not candidates:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0]) + 1e-12\n    t   = float(np.asarray(current_time).reshape(-1)[0])   + 1e-12\n\n    best_score = -np.inf\n    best_node  = int(depot)\n\n    while candidates:\n        node = candidates.pop(0)\n        travel = distance_matrix[int(current_node), node]\n        start  = max(t + travel, time_windows[node, 0])\n        if demands[node] <= cap and start <= time_windows[node, 1]:\n            # Soft\u2011minimum score: exp(-distance / epsilon)\n            eps = 1e-6\n            score = np.exp(-travel / (eps + np.abs(cap)))\n            if score > best_score:\n                best_score = score\n                best_node  = node\n\n    return int(best_node)\n\n",
  "max_demand_that_fits_aug_109": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    rng = np.random.default_rng(seed=42)  # deterministic RNG\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0]) + 1e-12\n    t   = float(np.asarray(current_time).reshape(-1)[0])   + 1e-12\n\n    travel = distance_matrix[int(current_node), candidates]\n    earliest_start = np.maximum(t + travel, time_windows[candidates, 0])\n\n    feasible = (demands[candidates] <= cap) & (earliest_start <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_idx = candidates[feasible]\n    # Add deterministic noise\n    noise = rng.random(feasible_idx.size) * 1e-9\n    sorted_idx = np.argsort(-(demands[feasible_idx] + noise))\n    top_k = 5\n    top_candidates = feasible_idx[sorted_idx[:min(top_k, len(sorted_idx))]]\n    chosen = rng.choice(top_candidates)\n    return int(chosen)\n\n",
  "max_demand_that_fits_aug_110": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0]) + 1e-12\n    t   = float(np.asarray(current_time).reshape(-1)[0])   + 1e-12\n\n    travel = distance_matrix[int(current_node), candidates]\n    earliest_start = np.maximum(t + travel, time_windows[candidates, 0])\n\n    feasible = (demands[candidates] <= cap) & (earliest_start <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_idx = candidates[feasible]\n    # Clip start times to a safe range before computing median\n    clipped_start = np.clip(earliest_start[feasible], 0, 1e9)\n    median_start = np.median(clipped_start)\n\n    # Choose the feasible node whose start time is closest to the median\n    diffs = np.abs(clipped_start - median_start)\n    chosen = feasible_idx[np.argmin(diffs)]\n    return int(chosen)\n\n",
  "capacity_tight_fill_aug_111": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cur = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return dep\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t = float(current_time.reshape(-1)[0])\n\n    d = distance_matrix[cur, cand]\n    start = np.maximum(t + d, time_windows[cand, 0])\n    start = np.clip(start, time_windows[cand, 0], time_windows[cand, 1])  # ensure within window\n\n    feas_mask = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n\n    if not np.any(feas_mask):\n        return dep\n\n    left_cap = cap - demands[cand]\n    left_cap = np.clip(left_cap, 0, None)  # avoid negative\n    ratio = left_cap / (cap + 1e-12)  # epsilon added\n\n    feasible_idx = np.where(feas_mask)[0]\n    best_idx = feasible_idx[np.argmin(ratio[feasible_idx])]\n    return int(cand[best_idx])\n\n",
  "capacity_tight_fill_aug_112": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cur = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return dep\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t = float(current_time.reshape(-1)[0])\n\n    d = distance_matrix[cur, cand]\n    start = np.maximum(t + d, time_windows[cand, 0])\n    slack = np.clip(time_windows[cand, 1] - start, 0, None)\n\n    feas_mask = (demands[cand] <= cap) & (slack >= 0)\n\n    if not np.any(feas_mask):\n        return dep\n\n    # Weighted score: favor shorter distance and larger slack\n    score = 0.6 * d - 0.4 * slack\n    # Add deterministic noise to break ties\n    noise = 1e-6 * np.arange(len(cand))\n    score += noise\n\n    # Softmin probabilities\n    temp = 0.5  # temperature\n    exp_vals = np.exp(-score / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # Consider top_k candidates\n    top_k = 7\n    idx_sorted = np.argsort(probs)[::-1]  # descending order\n    top_indices = idx_sorted[:min(top_k, len(idx_sorted))]\n\n    # Filter feasible ones among top_k\n    feasible_top = [i for i in top_indices if feas_mask[i]]\n    if not feasible_top:\n        return dep\n\n    chosen = np.random.choice(feasible_top, p=probs[feasible_top] / (np.sum(probs[feasible_top]) + 1e-12))\n    return int(cand[chosen])\n\n",
  "capacity_tight_fill_aug_113": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cur = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return dep\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t = float(current_time.reshape(-1)[0])\n\n    d = distance_matrix[cur, cand]\n    start = np.maximum(t + d, time_windows[cand, 0])\n    slack = np.clip(time_windows[cand, 1] - start, 0, None)\n\n    feas_mask = (demands[cand] <= cap) & (slack >= 0)\n\n    if not np.any(feas_mask):\n        return dep\n\n    left_cap = cap - demands[cand]\n    median_left = np.median(left_cap[feas_mask])\n    tight_mask = feas_mask & (left_cap <= median_left + 1e-12)\n\n    # Ratio for sorting, with epsilon\n    ratio = left_cap / (cap + 1e-12)\n\n    # Deterministic noise for tie-breaking\n    noise = 1e-6 * np.arange(len(cand))\n    score = ratio + noise\n\n    tight_idx = np.where(tight_mask)[0]\n    if tight_idx.size == 0:\n        tight_idx = np.where(feas_mask)[0]  # fallback\n\n    top_k = 5\n    sorted_idx = tight_idx[np.argsort(score[tight_idx])]\n    chosen_idx = sorted_idx[:min(top_k, len(sorted_idx))]\n\n    chosen = chosen_idx[np.random.choice(len(chosen_idx))]\n    return int(cand[chosen])\n\n",
  "farthest_from_depot_aug_114": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    capacity = float(np.clip(np.asarray(rest_capacity).reshape(-1)[0], 0, np.inf))\n    now = float(np.asarray(current_time).reshape(-1)[0])\n\n    arrival = now + distance_matrix[current_node, candidates]\n    earliest = np.maximum(arrival, time_windows[candidates, 0])\n    earliest = np.clip(earliest, time_windows[candidates, 0], time_windows[candidates, 1])\n\n    feasible = (demands[candidates] <= capacity) & (earliest <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_ids = candidates[feasible]\n    dist_from_depot = distance_matrix[depot, feasible_ids]\n    # Add deterministic noise to break ties\n    noise = 1e-9 * np.arange(feasible_ids.size)\n    dist_from_depot += noise\n\n    # Compute a score that includes division by capacity with epsilon\n    score = dist_from_depot / (capacity + 1e-12)\n\n    # Find index of maximum score using a while loop\n    best_idx = 0\n    best_val = score[0]\n    idx = 1\n    while idx < score.size:\n        val = score[idx]\n        if val > best_val:\n            best_val = val\n            best_idx = idx\n        idx += 1\n\n    return int(feasible_ids[best_idx])\n\n",
  "farthest_from_depot_aug_115": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    capacity = float(np.clip(np.asarray(rest_capacity).reshape(-1)[0], 0, np.inf))\n    now = float(np.asarray(current_time).reshape(-1)[0])\n\n    arrival = now + distance_matrix[current_node, candidates]\n    earliest = np.maximum(arrival, time_windows[candidates, 0])\n\n    feasible = (demands[candidates] <= capacity) & (earliest <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_ids = candidates[feasible]\n    dist_from_depot = distance_matrix[depot, feasible_ids]\n    arrival_feasible = arrival[feasible]\n    waiting = np.maximum(time_windows[feasible_ids, 0] - arrival_feasible, 0)\n    wait_ratio = waiting / (capacity + 1e-12)\n\n    # Weighted score with epsilon\n    score = 0.6 * dist_from_depot + 0.4 * wait_ratio\n    score = np.clip(score, -np.inf, np.inf)  # ensure no NaNs\n\n    # Deterministic noise for tie\u2011breaking\n    score += 1e-8 * np.arange(score.size)\n\n    # Soft selection: top_k candidates\n    top_k = min(5, score.size)\n    top_indices = np.argpartition(-score, top_k - 1)[:top_k]\n    chosen_ids = feasible_ids[top_indices]\n\n    # Randomly choose one among top_k\n    chosen_idx = np.random.randint(0, chosen_ids.size)\n    return int(chosen_ids[chosen_idx])\n\n",
  "nearest_to_depot_aug_116": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Ensure inputs are flat 1\u2011D arrays\n    cand = np.asarray(unvisited_nodes, dtype=int).reshape(-1)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Earliest possible arrival at each candidate\n    arrive = t + distance_matrix[current_node, cand]\n    start = np.maximum(arrive, time_windows[cand, 0])\n\n    # Feasibility mask\n    feasible = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    # Filter candidates\n    feas_cand = cand[feasible]\n    feas_dist = distance_matrix[depot, feas_cand]\n\n    # Add tiny deterministic noise to break ties (e.g., based on hash)\n    noise = 1e-6 * np.arange(feas_cand.size)\n    feas_dist_noisy = feas_dist + noise\n\n    # Select nearest\n    idx = np.argmin(feas_dist_noisy)\n    return int(feas_cand[idx])\n\n",
  "nearest_to_depot_aug_117": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int).reshape(-1)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    arrive = t + distance_matrix[current_node, cand]\n    start = np.maximum(arrive, time_windows[cand, 0])\n\n    feasible = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cand = cand[feasible]\n    feas_dist = distance_matrix[depot, feas_cand]\n    feas_dem = demands[feas_cand]\n\n    # Soft\u2011min weight: higher capacity left & shorter distance -> higher weight\n    alpha = 5.0\n    # Avoid division by zero in capacity term\n    cap_left = np.clip(cap - feas_dem + 1e-12, 1e-12, None)\n    weight = np.exp(-alpha * feas_dist) * cap_left\n    idx = np.argmax(weight)\n    return int(feas_cand[idx])\n\n",
  "nearest_to_depot_aug_118": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int).reshape(-1)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    arrive = t + distance_matrix[current_node, cand]\n    start = np.maximum(arrive, time_windows[cand, 0])\n\n    feasible = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cand = cand[feasible]\n    feas_dist = distance_matrix[depot, feas_cand]\n\n    # Keep only top\u2011k (k=3) nearest\n    k = 3\n    if feas_dist.size <= k:\n        top_idx = np.arange(feas_dist.size)\n    else:\n        top_idx = np.argpartition(feas_dist, k-1)[:k]\n    top_cand = feas_cand[top_idx]\n    top_dist = feas_dist[top_idx]\n\n    # Deterministic pseudo\u2011random selection based on hash of current_time\n    rng_seed = int(np.floor(t * 1e6)) % (2**32 - 1)\n    rng = np.random.default_rng(rng_seed)\n    chosen = rng.choice(top_cand)\n    return int(chosen)\n\n",
  "nearest_to_depot_aug_119": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int).reshape(-1)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    arrive = t + distance_matrix[current_node, cand]\n    # Clip start times to valid window bounds\n    start = np.maximum(arrive, np.clip(time_windows[cand, 0], -1e12, 1e12))\n    end_window = np.clip(time_windows[cand, 1], -1e12, 1e12)\n    feasible = (demands[cand] <= cap) & (start <= end_window)\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cand = cand[feasible]\n    # Use squared distance as proxy (avoids sqrt)\n    feas_dist_sq = np.square(distance_matrix[depot, feas_cand])\n    # Median distance as threshold\n    median_dist = np.median(feas_dist_sq)\n    # Choose candidate with distance closest to median\n    diff = np.abs(feas_dist_sq - median_dist)\n    idx = np.argmin(diff)\n    return int(feas_cand[idx])\n\n",
  "urgent_then_near_aug_120": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[int(current_node), candidates]\n    arrival = t + dists\n    earliest = np.maximum(arrival, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - earliest\n    slack = np.clip(slack, 0, np.inf)\n\n    feasible = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    feas_dists = distance_matrix[int(current_node), feas_idx]\n    feas_slack = slack[feasible]\n\n    # Small deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(feas_idx.size)\n    key = np.lexsort((feas_dists + noise, feas_slack + noise))\n    return int(feas_idx[key[0]])\n\n",
  "urgent_then_near_aug_121": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[int(current_node), candidates]\n    arrival = t + dists\n    earliest = np.maximum(arrival, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - earliest\n    slack = np.clip(slack, 0, np.inf)\n\n    feasible = (demands[candidates] <= cap) & (slack > 0)\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    feas_dists = distance_matrix[int(current_node), feas_idx]\n    feas_slack = slack[feasible]\n\n    # Score: lower slack and distance are better\n    score = feas_slack + 0.2 * feas_dists\n    alpha = 5.0\n    exp_vals = np.exp(-alpha * score)\n    prob_sum = np.sum(exp_vals) + 1e-12          # epsilon to avoid division by zero\n    probs = exp_vals / prob_sum\n\n    top_k = 7\n    top_k_idx = np.argsort(-probs)[:top_k]\n    chosen = np.random.choice(feas_idx[top_k_idx])\n    return int(chosen)\n\n",
  "urgent_then_near_aug_122": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[int(current_node), candidates]\n    arrival = t + dists\n    earliest = np.maximum(arrival, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - earliest\n    slack = np.clip(slack, 0, np.inf)\n\n    feasible = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    feas_dists = distance_matrix[int(current_node), feas_idx]\n    feas_slack = slack[feasible]\n\n    median_slack = np.median(feas_slack)\n    metric = np.abs(feas_slack - median_slack) + 0.1 * feas_dists\n\n    noise = 1e-6 * np.arange(feas_idx.size)\n    key = np.lexsort((feas_dists + noise, metric + noise))\n    return int(feas_idx[key[0]])\n\n",
  "urgent_then_near_aug_123": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[int(current_node), candidates]\n    arrival = t + dists\n    earliest = np.maximum(arrival, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - earliest\n    slack = np.clip(slack, 0, np.inf)\n\n    feasible = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    feas_slack = slack[feasible]\n\n    order = np.argsort(-feas_slack)          # largest slack first\n    sorted_idx = feas_idx[order]\n\n    top_k = 5\n    top_candidates = sorted_idx[:top_k]\n    chosen = np.random.choice(top_candidates)\n    return int(chosen)\n\n",
  "normalized_tradeoff_dist_wait_slack_aug_124": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[current_node, cand]\n    arrival = t + dist\n    wait = np.maximum(0.0, time_windows[cand, 0] - arrival)\n    start = arrival + wait\n    slack = time_windows[cand, 1] - start\n    feasible = (demands[cand] <= cap) & (slack >= 0)\n\n    if not np.any(feasible):\n        return int(depot)\n\n    cand_f = cand[feasible]\n    dist_f = dist[feasible]\n    wait_f = wait[feasible]\n    slack_f = slack[feasible]\n\n    # soft\u2011min weighting (inverse exponential)\n    weight = np.exp(-dist_f / (np.mean(dist_f) + 1e-12))\n    slack_norm = (slack_f - np.median(slack_f)) / (np.std(slack_f) + 1e-12)\n    score = weight * (1.0 + 0.5 * slack_norm)  # higher slack gives higher score\n\n    # choose node with highest soft\u2011min score\n    chosen_idx = int(np.argmax(score))\n    return int(cand_f[chosen_idx])\n\n",
  "normalized_tradeoff_dist_wait_slack_aug_125": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = list(unvisited_nodes.astype(int))\n    if not candidates:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t = float(current_time.reshape(-1)[0])\n\n    feasible = []\n    scores = []\n    noise = 1e-6 * np.arange(len(candidates))  # deterministic noise\n\n    for idx, node in enumerate(candidates):\n        d = distance_matrix[current_node, node]\n        arr = t + d\n        wait = max(0.0, time_windows[node, 0] - arr)\n        start = arr + wait\n        slack = time_windows[node, 1] - start\n        if demands[node] <= cap and slack >= 0:\n            feasible.append(node)\n            # use max slack for scoring\n            scores.append((d + wait) - 0.7 * max(slack, 0.0) + noise[idx])\n\n    if not feasible:\n        return int(depot)\n\n    # invert condition: pick minimal score\n    best_idx = int(np.argmin(scores))\n    return int(feasible[best_idx])\n\n",
  "normalized_tradeoff_dist_wait_slack_aug_126": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t = float(current_time.reshape(-1)[0])\n\n    best_node = depot\n    best_score = np.inf\n\n    for node in cand:\n        d = distance_matrix[current_node, node]\n        arr = t + d\n        wait = max(0.0, time_windows[node, 0] - arr)\n        start = arr + wait\n        slack = time_windows[node, 1] - start\n        if demands[node] <= cap and slack >= 0:\n            # score: distance + wait - slack\n            score = d + wait - slack\n            if score < best_score:\n                best_score = score\n                best_node = node\n\n    return int(best_node)\n\n",
  "normalized_tradeoff_dist_wait_slack_aug_127": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t = float(current_time.reshape(-1)[0])\n\n    dist = distance_matrix[current_node, cand]\n    arrival = t + dist\n    wait = np.maximum(0.0, time_windows[cand, 0] - arrival)\n    start = arrival + wait\n    slack = time_windows[cand, 1] - start\n    feasible_mask = (demands[cand] <= cap) & (slack >= 0)\n\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feasible_cand = cand[feasible_mask]\n    feasible_slack = slack[feasible_mask]\n    feasible_dist = dist[feasible_mask]\n    feasible_wait = wait[feasible_mask]\n\n    # compute a composite score: distance + wait - median slack\n    median_slack = np.median(feasible_slack)\n    comp = feasible_dist + feasible_wait - median_slack\n    comp = np.clip(comp, 0, None)  # ensure non\u2011negative\n\n    # select top\u2011k smallest scores\n    k = min(5, comp.size)\n    top_k_idx = np.argsort(comp)[:k]\n    chosen = feasible_cand[top_k_idx[np.random.choice(k)]]\n    return int(chosen)\n\n",
  "regret2_slack_then_distance_aug_128": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists   = distance_matrix[current_node, candidates]\n    starts  = np.maximum(t + dists, time_windows[candidates, 0])\n    slacks  = time_windows[candidates, 1] - starts\n    feas    = (demands[candidates] <= cap) & (slacks >= 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    feas_nodes   = candidates[feas]\n    feas_dists   = dists[feas]\n    feas_slacks  = slacks[feas]\n\n    # base score: lower slack and distance are better\n    base = -feas_slacks + 0.1 * feas_dists\n    # deterministic tie\u2011breaker\n    noise = 1e-7 * np.arange(base.size)\n    base_noisy = base + noise\n\n    # soft\u2011min probability\n    temp = 1.0\n    exp_vals = np.exp(-base_noisy / (temp + 1e-12))\n    probs    = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    chosen = np.argmax(probs)\n    return int(feas_nodes[chosen])\n\n",
  "regret2_slack_then_distance_aug_129": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    feasible_nodes = []\n    scores         = []\n\n    for node in candidates:\n        d = distance_matrix[current_node, node]\n        arrival = t + d\n        start   = max(arrival, time_windows[node, 0])\n        slack   = time_windows[node, 1] - start\n\n        if demands[node] <= cap and slack >= 0:\n            # deterministic noise based on node id\n            noise = 1e-8 * node\n            score = -slack + 0.2 * d + noise\n            feasible_nodes.append(node)\n            scores.append(score)\n\n    if not feasible_nodes:\n        return int(depot)\n\n    scores_np = np.asarray(scores)\n    order = np.argsort(scores_np)          # lower score is better\n    top_k = min(3, order.size)\n    chosen = np.random.choice(order[:top_k])\n    return int(feasible_nodes[chosen])\n\n",
  "regret2_slack_then_distance_aug_130": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    feasible_nodes = []\n    base_scores    = []\n\n    for node in candidates:\n        d = distance_matrix[current_node, node]\n        arrival = t + d\n        start   = max(arrival, time_windows[node, 0])\n        slack   = time_windows[node, 1] - start\n\n        if demands[node] <= cap and slack >= 0:\n            base_scores.append(-slack + 0.15 * d)\n            feasible_nodes.append(node)\n\n    if not feasible_nodes:\n        return int(depot)\n\n    base_scores = np.asarray(base_scores, dtype=float)\n    noise = 1e-9 * np.arange(base_scores.size)\n    base_noisy = base_scores + noise\n\n    # soft\u2011min with temperature\n    temp = 0.5\n    exp_vals = np.exp(-base_noisy / (temp + 1e-12))\n    probs    = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    top_k = min(5, probs.size)\n    top_indices = np.argsort(-probs)[:top_k]   # descending order\n    chosen = np.random.choice(top_indices)\n    return int(feasible_nodes[chosen])\n\n",
  "regret2_slack_then_distance_aug_131": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists   = distance_matrix[current_node, candidates]\n    arrival = t + dists\n    starts  = np.maximum(arrival, time_windows[candidates, 0])\n    slacks  = time_windows[candidates, 1] - starts\n\n    feas_mask = (demands[candidates] <= cap) & (slacks >= 0)\n\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_nodes  = candidates[feas_mask]\n    feas_slacks = slacks[feas_mask]\n    feas_dists  = dists[feas_mask]\n\n    # weight: inverse slack + small distance penalty\n    weights = 1.0 / (feas_slacks + 1e-12) + 0.05 * feas_dists\n\n    # softmax probabilities\n    exp_vals = np.exp(-weights / (0.3 + 1e-12))\n    probs    = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    chosen = np.random.choice(feas_nodes, p=probs)\n    return int(chosen)\n\n",
  "exponential_lateness_risk_aug_132": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rest_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_time = float(np.asarray(current_time).reshape(-1)[0])\n\n    # use squared distances to amplify the travel penalty\n    dists = np.square(distance_matrix[int(current_node), candidates])\n    arrival = np.maximum(curr_time + dists, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - arrival\n\n    # feasibility mask (inverted logic)\n    infeas = (demands[candidates] > rest_cap) | (slack < 0)\n    feas_mask = ~infeas\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feasible_idx = candidates[feas_mask]\n    feasible_dists = dists[feas_mask]\n    feasible_slack = slack[feas_mask]\n\n    # risk factor with safe division\n    std_slack = np.std(feasible_slack) + 1e-12\n    risk = np.exp(-feasible_slack / std_slack)\n    risk = np.clip(risk, 0.0, 1.0)\n\n    score = feasible_dists * (1.0 + 2.0 * risk)\n    chosen = feasible_idx[np.argmin(score)]\n    return int(chosen)\n\n",
  "exponential_lateness_risk_aug_133": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rest_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_time = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[int(current_node), candidates]\n    arrival = np.maximum(curr_time + dists, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - arrival\n\n    feas_mask = (demands[candidates] <= rest_cap) & (slack >= 0)\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feasible_idx = candidates[feas_mask]\n    feasible_dists = dists[feas_mask]\n    feasible_slack = slack[feas_mask]\n\n    std_slack = np.std(feasible_slack) + 1e-12\n    risk = np.exp(-feasible_slack / std_slack)\n    risk = np.clip(risk, 0.0, 1.0)\n\n    # tuned weights: 60% distance, 40% risk\n    max_dist = np.max(feasible_dists) + 1e-12\n    score = 0.6 * feasible_dists + 0.4 * risk * max_dist\n    chosen = feasible_idx[np.argmin(score)]\n    return int(chosen)\n\n",
  "exponential_lateness_risk_aug_134": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    rng = np.random.default_rng()\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rest_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_time = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[int(current_node), candidates]\n    arrival = np.maximum(curr_time + dists, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - arrival\n\n    feas_mask = (demands[candidates] <= rest_cap) & (slack >= 0)\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feasible_idx = candidates[feas_mask]\n    feasible_dists = dists[feas_mask]\n    feasible_slack = slack[feas_mask]\n\n    std_slack = np.std(feasible_slack) + 1e-12\n    risk = np.exp(-feasible_slack / std_slack)\n    risk = np.clip(risk, 0.0, 1.0)\n\n    # deterministic noise for tie\u2011breaking\n    noise = rng.uniform(0, 1e-8, size=feasible_idx.shape[0])\n    score = feasible_dists * (1.0 + 2.0 * risk) + noise\n\n    # softmin with temperature\n    temp = 0.05\n    probs = np.exp(-score / temp)\n    probs /= np.sum(probs)\n\n    # random choice among top\u2011k lowest scores\n    top_k = 3\n    sorted_idx = np.argsort(score)[:top_k]\n    top_probs = probs[sorted_idx]\n    top_probs /= np.sum(top_probs)\n    chosen = feasible_idx[rng.choice(sorted_idx, p=top_probs)]\n    return int(chosen)\n\n",
  "exponential_lateness_risk_aug_135": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rest_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_time = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[int(current_node), candidates]\n    arrival = np.maximum(curr_time + dists, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - arrival\n\n    # use median slack for risk scaling (more robust than std)\n    median_slack = np.median(slack) + 1e-12\n    risk = np.exp(-slack / median_slack)\n    risk = np.clip(risk, 0.0, 1.0)\n\n    score = dists * (1.0 + risk)\n\n    # iterate over nodes sorted by score and return first feasible one\n    sorted_idx = np.argsort(score)\n    for idx in sorted_idx:\n        node = candidates[idx]\n        if demands[node] <= rest_cap and slack[idx] >= 0:\n            return int(node)\n    return int(depot)\n\n",
  "quadratic_wait_penalty_aug_136": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rem_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    dist_to_cand = dist_mat[int(current_node), candidates]\n    arrival = cur_t + dist_to_cand\n\n    wait = np.maximum(0.0, time_windows[candidates, 0] - arrival)\n    wait = np.clip(wait, 0, 1e9)                     # prevent overflow\n    start_time = arrival + wait\n\n    feas = (demands[candidates] <= rem_cap) & (start_time <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_idx   = np.nonzero(feas)[0]\n    feas_cand  = candidates[feas_idx]\n    feas_dist  = dist_to_cand[feas]\n    feas_wait  = wait[feas]\n\n    # score = distance + 0.5 * wait\u00b2 + tiny deterministic noise\n    score = feas_dist + 0.5 * np.square(feas_wait) + 1e-6 * np.arange(feas_cand.size)\n\n    # soft\u2011min selection\n    temp = 1.0\n    probs = np.exp(-score / (temp + 1e-12))\n    probs /= np.clip(probs.sum(), 1e-12, None)\n    chosen = feas_cand[np.argmax(probs)]\n    return int(chosen)\n\n",
  "quadratic_wait_penalty_aug_137": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rem_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    dist_to_cand = dist_mat[int(current_node), candidates]\n    arrival = cur_t + dist_to_cand\n\n    wait = np.maximum(0.0, time_windows[candidates, 0] - arrival)\n    wait = np.clip(wait, 0, 1e9)\n\n    feas = (demands[candidates] <= rem_cap) & (arrival + wait <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_idx   = np.nonzero(feas)[0]\n    feas_cand  = candidates[feas_idx]\n    feas_dist  = dist_to_cand[feas]\n    feas_wait  = wait[feas]\n\n    # tuned weight: 0.6 * distance + 0.4 * wait\u00b2\n    score = 0.6 * feas_dist + 0.4 * np.square(feas_wait)\n\n    # pick top\u2011k smallest scores and randomise among them\n    top_k = 7\n    if feas_cand.size <= top_k:\n        top_indices = np.arange(feas_cand.size)\n    else:\n        top_indices = np.argpartition(score, top_k)[:top_k]\n    top_candidates = feas_cand[top_indices]\n\n    rng = np.random.default_rng(42)          # deterministic RNG\n    chosen = rng.choice(top_candidates)\n    return int(chosen)\n\n",
  "quadratic_wait_penalty_aug_138": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap  = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    dists = dist_mat[int(current_node), cand]\n    arr   = t0 + dists\n\n    wait = np.maximum(0.0, time_windows[cand, 0] - arr)\n    wait = np.clip(wait, 0, 1e9)\n    start = arr + wait\n\n    feas = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_idx   = np.nonzero(feas)[0]\n    feas_cand  = cand[feas_idx]\n    feas_d     = dists[feas]\n    feas_w     = wait[feas]\n\n    # use median wait as a global proxy in the score\n    median_wait = np.median(feas_w)\n    score = feas_d + 0.3 * np.square(feas_w) + 0.1 * median_wait\n\n    # deterministic tie\u2011breaking noise\n    noise = 1e-8 * np.arange(feas_cand.size)\n    score += noise\n\n    chosen_idx = np.argmin(score)\n    return int(feas_cand[chosen_idx])\n\n",
  "quadratic_wait_penalty_aug_139": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    rem_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    dists = dist_mat[int(current_node), nodes]\n    arr   = cur_t + dists\n\n    wait = np.maximum(0.0, time_windows[nodes, 0] - arr)\n    wait = np.clip(wait, 0, 1e9)\n\n    # ratio of wait to window length (epsilon to avoid div\u2011by\u2011zero)\n    window_len = time_windows[nodes, 1] - time_windows[nodes, 0] + 1e-12\n    wait_ratio = np.clip(wait / window_len, 0, 1)\n\n    start = arr + wait\n    feas = (demands[nodes] <= rem_cap) & (start <= time_windows[nodes, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_idx   = np.nonzero(feas)[0]\n    feas_nodes = nodes[feas_idx]\n    feas_d     = dists[feas]\n    feas_wr    = wait_ratio[feas]\n\n    # scoring: distance + 0.7 * (wait_ratio)\u00b2\n    score = feas_d + 0.7 * np.square(feas_wr)\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-7 * np.arange(feas_nodes.size)\n    score += noise\n\n    min_idx = np.argmin(score)\n    return int(feas_nodes[min_idx])\n\n",
  "return_to_depot_aware_aug_140": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Clip distances to avoid overflow and keep them positive\n    dist_mat = np.clip(distance_matrix, 0, 1e9)\n\n    d_to_cand = dist_mat[current_node, candidates]\n    earliest_start = np.maximum(t + d_to_cand, time_windows[candidates, 0] + 1e-12)\n\n    feasible = (demands[candidates] <= cap) & (earliest_start <= time_windows[candidates, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    # Score is distance to candidate + distance back to depot\n    score = dist_mat[current_node, feas_idx] + dist_mat[feas_idx, depot]\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(score.size) * 1e-6\n    score += noise\n\n    chosen = feas_idx[np.argmin(score)]\n    return int(chosen)\n\n",
  "return_to_depot_aware_aug_141": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = np.clip(distance_matrix, 0, 1e9)\n\n    d_to_cand = dist_mat[current_node, candidates]\n    earliest_start = np.maximum(t + d_to_cand, time_windows[candidates, 0])\n\n    feasible = (demands[candidates] <= cap) & (earliest_start <= time_windows[candidates, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n\n    # Weighted score: 0.6 * to\u2011node + 0.4 * back\u2011to\u2011depot\n    score = 0.6 * dist_mat[current_node, feas_idx] + 0.4 * dist_mat[feas_idx, depot]\n\n    # Keep only top\u2011k candidates\n    top_k = 7\n    if score.size > top_k:\n        top_pos = np.argpartition(score, top_k)[:top_k]\n        score = score[top_pos]\n        feas_idx = feas_idx[top_pos]\n\n    # Soft\u2011min probability distribution\n    temp = 1.0\n    probs = np.exp(-score / (temp + 1e-12))\n    probs /= np.sum(probs) + 1e-12\n\n    chosen = feas_idx[np.argmax(probs)]\n    return int(chosen)\n\n",
  "return_to_depot_aware_aug_142": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = np.clip(distance_matrix, 0, 1e9)\n    d_c  = dist[current_node, cand]\n    start_time = np.maximum(t + d_c, time_windows[cand, 0])\n\n    feas = (demands[cand] <= cap) & (start_time <= time_windows[cand, 1])\n    if np.sum(feas) == 0:\n        return int(depot)\n\n    feas_cand = cand[feas]\n\n    # Score: simple distance sum with deterministic noise\n    score = dist[current_node, feas_cand] + dist[feas_cand, depot]\n    noise = np.arange(score.size) * 1e-7\n    score += noise\n\n    # Random choice among the best top\u2011k candidates\n    top_k = 5\n    if score.size > top_k:\n        top_pos = np.argpartition(score, top_k)[:top_k]\n        score = score[top_pos]\n        feas_cand = feas_cand[top_pos]\n\n    chosen = feas_cand[np.random.choice(score.size, p=np.ones(score.size)/score.size)]\n    return int(chosen)\n\n",
  "return_to_depot_aware_aug_143": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = np.clip(distance_matrix, 0, 1e9)\n    d_to = dist[current_node, cand]\n    start = np.maximum(t + d_to, time_windows[cand, 0])\n\n    feas_mask = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_cand = cand[feas_mask]\n    best = int(depot)\n    best_score = np.inf\n    i = 0\n    while i < feas_cand.size:\n        node = feas_cand[i]\n        score = dist[current_node, node] + dist[node, depot]\n        # Small deterministic noise to break ties\n        score += i * 1e-8\n        if score < best_score:\n            best_score = score\n            best = int(node)\n        i += 1\n\n    return best\n\n",
  "mean_distance_to_unvisited_min_aug_144": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    dist_to_cand = dist_mat[int(current_node), candidates]\n\n    # Earliest possible arrival times (clipped to the start of the window)\n    earliest_arrival = np.maximum(t + dist_to_cand, time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap) & (earliest_arrival <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    if feas_idx.size == 1:\n        return int(feas_idx[0])\n\n    # Mean distance to all unvisited customers (avoid division by zero)\n    denom = candidates.size + 1e-12\n    mean_to_others = np.sum(dist_mat[feas_idx][:, candidates], axis=1) / denom\n\n    # Scoring with weight adjustment and small deterministic noise for tie\u2011breaking\n    score = 0.6 * dist_to_cand[feasible] + 0.4 * mean_to_others\n    noise = np.random.rand(feas_idx.size) * 1e-6\n    chosen = feas_idx[np.argmin(score + noise)]\n    return int(chosen)\n\n",
  "mean_distance_to_unvisited_min_aug_145": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    feas_list, dist_list, sum_dist_list = [], [], []\n\n    for idx in candidates:\n        dist = dist_mat[int(current_node), idx]\n        arrival = t + dist\n        earliest = max(arrival, time_windows[idx, 0])\n        latest   = time_windows[idx, 1]\n        if (demands[idx] <= cap) and (earliest <= latest):\n            feas_list.append(idx)\n            dist_list.append(dist)\n            sum_dist_list.append(np.sum(dist_mat[idx, candidates]))\n\n    if not feas_list:\n        return int(depot)\n\n    feas_arr = np.asarray(feas_list, dtype=int)\n    dist_arr = np.asarray(dist_list, dtype=float)\n    sum_arr  = np.asarray(sum_dist_list, dtype=float)\n\n    # Weighted score\n    score = 0.8 * dist_arr + 0.2 * sum_arr\n\n    # Soft\u2011min probability distribution\n    temp = 1.0\n    exp_vals = np.exp(-score / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # Randomly pick among the top\u2011k candidates\n    top_k = 7\n    top_indices = np.argsort(score)[:top_k]\n    top_probs   = probs[top_indices]\n    top_probs   = top_probs / (np.sum(top_probs) + 1e-12)\n\n    rng = np.random.default_rng(42)\n    chosen_idx = rng.choice(feas_arr[top_indices], p=top_probs)\n    return int(chosen_idx)\n\n",
  "mean_distance_to_unvisited_min_aug_146": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    feas_nodes = [idx for idx in candidates\n                  if (demands[idx] <= cap) and\n                     (max(t + dist_mat[int(current_node), idx], time_windows[idx, 0]) <= time_windows[idx, 1])]\n\n    if not feas_nodes:\n        return int(depot)\n\n    feas_nodes = np.array(feas_nodes, dtype=int)\n    if feas_nodes.size == 1:\n        return int(feas_nodes[0])\n\n    # Max distance to all unvisited customers\n    max_to_others = np.max(dist_mat[feas_nodes][:, candidates], axis=1)\n\n    # Equal\u2011weight scoring\n    dist_to_cand = dist_mat[int(current_node), feas_nodes]\n    score = 0.5 * dist_to_cand + 0.5 * max_to_others\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(feas_nodes.size) * 1e-6\n    chosen = feas_nodes[np.argmin(score + noise)]\n    return int(chosen)\n\n",
  "mean_distance_to_unvisited_min_aug_147": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    feas_nodes, dist_list, sum_dist_list = [], [], []\n\n    for idx in candidates:\n        dist = dist_mat[int(current_node), idx]\n        arrival = t + dist\n        earliest = max(arrival, time_windows[idx, 0])\n        latest   = time_windows[idx, 1]\n        if (demands[idx] <= cap) and (earliest <= latest):\n            feas_nodes.append(idx)\n            dist_list.append(dist)\n            sum_dist_list.append(np.sum(dist_mat[idx, candidates]))\n\n    if not feas_nodes:\n        return int(depot)\n\n    feas_arr = np.array(feas_nodes, dtype=int)\n    dist_arr = np.array(dist_list, dtype=float)\n    sum_arr  = np.array(sum_dist_list, dtype=float)\n\n    # Weighted score\n    score = 0.7 * dist_arr + 0.3 * sum_arr\n\n    # Add small deterministic noise\n    rng = np.random.default_rng(123)\n    noise = rng.standard_normal(feas_arr.size) * 1e-6\n    score_noisy = score + noise\n\n    # Pick the best among the top\u2011k\n    top_k = 5\n    top_indices = np.argsort(score_noisy)[:top_k]\n    chosen = feas_arr[top_indices[0]]\n    return int(chosen)\n\n",
  "median_distance_to_unvisited_min_aug_148": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    # capacity and time (add epsilon to avoid precision issues)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0]) + 1e-12\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # distances from current node to all candidates\n    dist_cur = distance_matrix[int(current_node), candidates]\n    earliest_start = np.maximum(t + dist_cur, time_windows[candidates, 0])\n\n    # feasibility check\n    feas = (demands[candidates] <= cap) & (earliest_start <= time_windows[candidates, 1] + 1e-12)\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_nodes = candidates[feas]\n    if feasible_nodes.size == 1:\n        return int(feasible_nodes[0])\n\n    # median distance to all remaining nodes\n    med_to_others = np.median(distance_matrix[feasible_nodes][:, candidates], axis=1)\n\n    # scoring with balanced weights\n    score = 0.5 * distance_matrix[int(current_node), feasible_nodes] + 0.5 * med_to_others\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(feasible_nodes.size) * 1e-6\n    score += noise\n\n    return int(feasible_nodes[np.argmin(score)])\n\n",
  "median_distance_to_unvisited_min_aug_149": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0]) + 1e-12\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_cur = distance_matrix[int(current_node), cand]\n    earliest = np.maximum(t + dist_cur, time_windows[cand, 0])\n\n    feas = (demands[cand] <= cap) & (earliest <= time_windows[cand, 1] + 1e-12)\n    if not np.any(feas):\n        return int(depot)\n\n    f_nodes = cand[feas]\n\n    # mean distance to all remaining nodes\n    mean_dist = np.mean(distance_matrix[f_nodes][:, cand], axis=1)\n\n    # weighted score\n    score = 0.7 * distance_matrix[int(current_node), f_nodes] + 0.3 * mean_dist\n\n    # keep only the best top_k candidates\n    top_k = min(7, f_nodes.size)\n    top_idx = np.argpartition(score, top_k - 1)[:top_k]\n    top_nodes = f_nodes[top_idx]\n    top_scores = score[top_idx]\n\n    # soft\u2011min probability distribution\n    temp = 0.5\n    exp_vals = np.exp(-top_scores / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 1e-12, 1.0)\n\n    # random choice weighted by the soft\u2011min probabilities\n    idx = np.random.choice(top_nodes.shape[0], p=probs)\n    return int(top_nodes[idx])\n\n",
  "median_distance_to_unvisited_min_aug_150": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0]) + 1e-12\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_cur = distance_matrix[int(current_node), candidates]\n    earliest_start = np.maximum(t + dist_cur, time_windows[candidates, 0])\n\n    feas = (demands[candidates] <= cap) & (earliest_start <= time_windows[candidates, 1] + 1e-12)\n\n    # invert the usual conditional logic\n    if np.any(feas):\n        feasible_nodes = candidates[feas]\n    else:\n        return int(depot)\n\n    if feasible_nodes.size == 1:\n        return int(feasible_nodes[0])\n\n    # maximum distance to any remaining node\n    max_to_others = np.max(distance_matrix[feasible_nodes][:, candidates], axis=1)\n\n    # weighted score\n    score = 0.4 * distance_matrix[int(current_node), feasible_nodes] + 0.6 * max_to_others\n\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(feasible_nodes.size) * 1e-6\n    score += noise\n\n    # find the minimal score using a while loop\n    min_idx = 0\n    min_val = score[0]\n    i = 1\n    while i < score.size:\n        if score[i] < min_val:\n            min_val = score[i]\n            min_idx = i\n        i += 1\n\n    return int(feasible_nodes[min_idx])\n\n",
  "median_distance_to_unvisited_min_aug_151": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0]) + 1e-12\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_cur = distance_matrix[int(current_node), nodes]\n    earliest = np.maximum(t + dist_cur, time_windows[nodes, 0])\n\n    feas_mask = (demands[nodes] <= cap) & (earliest <= time_windows[nodes, 1] + 1e-12)\n    feasible = nodes[feas_mask]\n\n    if feasible.size == 0:\n        return int(depot)\n    if feasible.size == 1:\n        return int(feasible[0])\n\n    # maximum distance to the rest of the nodes\n    max_dist = np.max(distance_matrix[feasible][:, nodes], axis=1)\n\n    # weighted score\n    score = 0.3 * distance_matrix[int(current_node), feasible] + 0.7 * max_dist\n\n    # top\u2011k selection\n    top_k = min(5, feasible.size)\n    top_indices = np.argpartition(score, top_k - 1)[:top_k]\n    top_nodes = feasible[top_indices]\n\n    # random choice among the top k\n    idx = np.random.choice(top_nodes.shape[0])\n    return int(top_nodes[idx])\n\n",
  "clarke_wright_savings_like_aug_152": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_to_cand = distance_matrix[int(current_node), candidates]\n    earliest_arrival = np.maximum(t + dist_to_cand, time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap) & (earliest_arrival <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    # Savings term\n    savings = (distance_matrix[int(current_node), int(depot)] +\n               distance_matrix[int(depot), feas_idx] -\n               distance_matrix[int(current_node), feas_idx])\n\n    # Slack time (how much we can wait before the window closes)\n    slack = time_windows[feas_idx, 1] - earliest_arrival[feasible]\n    # Small deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(-1e-4, 1e-4, size=savings.shape)\n\n    score = savings + 1e-3 * (-slack) + noise\n    return int(feas_idx[int(np.argmax(score))])\n\n",
  "clarke_wright_savings_like_aug_153": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    rng = np.random.default_rng(seed=42)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    top_k = 7\n    best_indices = []\n\n    for cand in candidates:\n        dist = distance_matrix[int(current_node), cand]\n        arrival = t + dist\n        window_start, window_end = time_windows[cand]\n        if demands[cand] > cap or arrival > window_end:\n            continue\n        # Ensure arrival respects window start\n        arrival = max(arrival, window_start)\n        # Savings calculation\n        sav = (distance_matrix[int(current_node), int(depot)] +\n               distance_matrix[int(depot), cand] -\n               distance_matrix[int(current_node), cand])\n        best_indices.append((sav, cand))\n\n    if not best_indices:\n        return int(depot)\n\n    # Sort by savings descending\n    best_indices.sort(key=lambda x: x[0], reverse=True)\n    # Take top\u2011k\n    top_candidates = [idx for _, idx in best_indices[:top_k]]\n    # Randomly pick one\n    chosen = rng.choice(top_candidates)\n    return int(chosen)\n\n",
  "clarke_wright_savings_like_aug_154": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    rng = np.random.default_rng(seed=24)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    feas_mask = (demands[candidates] <= cap)\n    feas_mask &= (t + distance_matrix[int(current_node), candidates] <= time_windows[candidates, 1])\n\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_cand = candidates[feas_mask]\n    dist = distance_matrix[int(current_node), feas_cand]\n    arrival = t + dist\n    slack = time_windows[feas_cand, 1] - np.maximum(arrival, time_windows[feas_cand, 0])\n    # Exponential weighting (lower value => higher probability)\n    alpha = 0.1\n    logits = -alpha * (dist + 0.5 * slack)\n    # Numerical stability: shift by max\n    logits -= np.max(logits)\n    weights = np.exp(logits)\n    weights = np.clip(weights, 1e-12, None)  # prevent zero\n    probs = weights / (np.sum(weights) + 1e-12)\n    chosen = rng.choice(feas_cand, p=probs)\n    return int(chosen)\n\n",
  "clarke_wright_savings_like_aug_155": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_to_cand = distance_matrix[int(current_node), candidates]\n    earliest = np.maximum(t + dist_to_cand, time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap) & (earliest <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    # Median distance to depot among feasible customers\n    median_dist = np.median(distance_matrix[int(depot), feas_idx])\n    # Use distance to current node as primary score, penalise deviation from median\n    score = -dist_to_cand[feasible] + 0.3 * (median_dist - dist_to_cand[feasible])\n    # Slack time clipped to avoid negative values\n    slack = np.clip(time_windows[feas_idx, 1] - earliest[feasible], 0, None)\n    # Add deterministic tie\u2011break based on index\n    tie_break = feas_idx / (feas_idx + 1e-12)\n    final_score = score + 1e-5 * tie_break\n    chosen = feas_idx[int(np.argmax(final_score))]\n    return int(chosen)\n\n",
  "widest_time_window_then_near_aug_156": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[current_node, candidates]\n    earliest = np.maximum(t + dist, time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap) & (earliest <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cand = candidates[feasible]\n    width = np.clip(time_windows[feas_cand, 1] - time_windows[feas_cand, 0], 0, None)\n    max_w = np.max(width)\n    widest = feas_cand[width == max_w]\n\n    if widest.size == 1:\n        return int(widest[0])\n\n    # Add a tiny deterministic noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=widest.size)\n    dist_widest = dist[feasible][width == max_w]\n    idx = np.argmin(dist_widest + noise)\n    return int(widest[idx])\n\n",
  "widest_time_window_then_near_aug_157": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    eps = 1e-12\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[current_node, candidates]\n    earliest = np.maximum(t + dist, time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap) & (earliest <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cand = candidates[feasible]\n    width = time_windows[feas_cand, 1] - time_windows[feas_cand, 0]\n    dist_feas = dist[feasible]\n\n    # soft\u2011min score: larger width and smaller distance are better\n    score = width / np.clip(dist_feas, eps, None)\n    idx = np.argmax(score)\n    return int(feas_cand[idx])\n\n",
  "widest_time_window_then_near_aug_158": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    k = 3\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[current_node, candidates]\n    earliest = np.maximum(t + dist, time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap) & (earliest <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cand = candidates[feasible]\n    width = time_windows[feas_cand, 1] - time_windows[feas_cand, 0]\n\n    # Sort by width descending and take top\u2011k\n    top_k_idx = np.argsort(-width)[:k]\n    top_k = feas_cand[top_k_idx]\n\n    # Deterministic RNG seeded by current time (scaled to int)\n    rng = np.random.default_rng(int(t * 1000) % (2**32 - 1))\n    chosen = rng.choice(top_k)\n    return int(chosen)\n\n",
  "widest_time_window_then_near_aug_159": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[current_node, candidates]\n    earliest = np.maximum(t + dist, time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap) & (earliest <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cand = candidates[feasible]\n    dist_feas = dist[feasible]\n\n    # Median distance among feasible customers\n    median_dist = np.median(dist_feas)\n    # Absolute deviation from median\n    dev = np.abs(dist_feas - median_dist)\n    idx = np.argmin(dev)\n    return int(feas_cand[idx])\n\n",
  "midpoint_service_target_aug_160": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    d = dist_mat[int(current_node), candidates]\n    start = np.maximum(cur_t + d, time_windows[candidates, 0])\n\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    d2 = dist_mat[int(current_node), feasible_idx]\n    start2 = np.maximum(cur_t + d2, time_windows[feasible_idx, 0])\n    mid = 0.5 * (time_windows[feasible_idx, 0] + time_windows[feasible_idx, 1])\n\n    # small deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(0, 1e-6, size=feasible_idx.shape)\n    score = np.abs(start2 - mid) + 0.1 * d2 + noise\n    return int(feasible_idx[np.argmin(score)])\n\n",
  "midpoint_service_target_aug_161": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    d = dist_mat[int(current_node), candidates]\n    start = np.clip(np.maximum(cur_t + d, time_windows[candidates, 0]), 0, np.inf)\n\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    d2 = dist_mat[int(current_node), feasible_idx]\n    start2 = np.maximum(cur_t + d2, time_windows[feasible_idx, 0])\n    mid = 0.5 * (time_windows[feasible_idx, 0] + time_windows[feasible_idx, 1])\n\n    # weight tuning: 0.6 distance, 0.4 time deviation\n    time_diff = np.abs(start2 - mid)\n    score = 0.6 * d2 + 0.4 * time_diff\n\n    # soft\u2011min selection with temperature\n    alpha = 5.0\n    exp_vals = np.exp(-alpha * score + 1e-12)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # random choice among top\u2011k\n    top_k = 7\n    if feasible_idx.size > top_k:\n        top_idx = np.argsort(score)[:top_k]\n        feasible_idx = feasible_idx[top_idx]\n        probs = probs[top_idx]\n        probs = probs / (np.sum(probs) + 1e-12)\n\n    chosen = np.random.choice(feasible_idx, p=probs)\n    return int(chosen)\n\n",
  "midpoint_service_target_aug_162": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    best_idx = None\n    best_score = np.inf\n\n    for idx in candidates:\n        d = dist_mat[int(current_node), idx]\n        start = np.maximum(cur_t + d, time_windows[idx, 0])\n        if demands[idx] > cap or start > time_windows[idx, 1]:\n            continue\n\n        mid = 0.5 * (time_windows[idx, 0] + time_windows[idx, 1])\n        score = np.abs(start - mid) + 0.8 * d\n        # deterministic tie\u2011breaking with a tiny epsilon\n        score += 1e-8 * idx\n\n        if score < best_score:\n            best_score = score\n            best_idx = idx\n\n    if best_idx is None:\n        return int(depot)\n    return int(best_idx)\n\n",
  "midpoint_service_target_aug_163": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    feas_mask = (demands[candidates] <= cap)\n    d = dist_mat[int(current_node), candidates]\n    est_arrival = cur_t + d\n    start = np.maximum(est_arrival, time_windows[candidates, 0])\n    feas_mask &= (start <= time_windows[candidates, 1])\n\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_candidates = candidates[feas_mask]\n    d2 = dist_mat[int(current_node), feas_candidates]\n    start2 = np.maximum(cur_t + d2, time_windows[feas_candidates, 0])\n    mid = 0.5 * (time_windows[feas_candidates, 0] + time_windows[feas_candidates, 1])\n\n    # proxy distance: power\u2011law approximation\n    proxy_dist = np.power(d2, 0.8)\n    score = 0.5 * proxy_dist + 0.5 * np.abs(start2 - mid)\n\n    # weighted random choice using soft\u2011min\n    weights = np.exp(-score + 1e-12)\n    probs = weights / (np.sum(weights) + 1e-12)\n    chosen = np.random.choice(feas_candidates, p=probs)\n    return int(chosen)\n\n",
  "demand_over_slack_urgency_aug_164": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = int(current_node)\n    depot_id = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    if cand.size == 0:\n        return depot_id\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_now = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[curr, cand]\n    earliest = np.maximum(t_now + dist, time_windows[cand, 0])\n    slack = np.clip(time_windows[cand, 1] - earliest, 0, np.inf)\n\n    feas_mask = (demands[cand] <= cap) & (slack > 0)\n    if not np.any(feas_mask):\n        return depot_id\n\n    feas_nodes = cand[feas_mask]\n    dist_f = distance_matrix[curr, feas_nodes]\n    earliest_f = np.maximum(t_now + dist_f, time_windows[feas_nodes, 0])\n    slack_f = np.clip(time_windows[feas_nodes, 1] - earliest_f, 0, np.inf)\n\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(len(feas_nodes)) * 1e-6\n    score = demands[feas_nodes] / (slack_f + 1e-12) + noise\n    chosen = feas_nodes[int(np.argmax(score))]\n    return int(chosen)\n\n",
  "demand_over_slack_urgency_aug_165": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = int(current_node)\n    depot_id = int(depot)\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n\n    if nodes.size == 0:\n        return depot_id\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_now = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[curr, nodes]\n    arrival = np.maximum(t_now + dist, time_windows[nodes, 0])\n    slack = np.clip(time_windows[nodes, 1] - arrival, 0, np.inf)\n\n    feas = (demands[nodes] <= cap) & (slack > 0)\n    if not np.any(feas):\n        return depot_id\n\n    feas_nodes = nodes[feas]\n    dist_feas = distance_matrix[curr, feas_nodes]\n    arrival_feas = np.maximum(t_now + dist_feas, time_windows[feas_nodes, 0])\n    slack_feas = np.clip(time_windows[feas_nodes, 1] - arrival_feas, 0, np.inf)\n\n    # scoring with a distance penalty\n    score = demands[feas_nodes] / (slack_feas + 1e-12) - 0.3 * dist_feas / (cap + 1e-12)\n\n    # choose randomly among the top\u2011k candidates\n    top_k = min(3, len(score))\n    top_idx = np.argsort(score)[-top_k:]\n    rng = np.random.default_rng(seed=42)\n    chosen_idx = rng.choice(top_idx)\n    return int(feas_nodes[chosen_idx])\n\n",
  "demand_over_slack_urgency_aug_166": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = int(current_node)\n    depot_id = int(depot)\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n\n    if nodes.size == 0:\n        return depot_id\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_now = float(np.asarray(current_time).reshape(-1)[0])\n\n    best_node = depot_id\n    best_score = -np.inf\n\n    for node in nodes:\n        d = distance_matrix[curr, node]\n        arrival = t_now + d\n        earliest = max(arrival, time_windows[node, 0])\n        slack = time_windows[node, 1] - earliest\n        slack = max(slack, 0.0)\n\n        if demands[node] <= cap and slack >= 1e-6:\n            score = demands[node] / (slack + 1e-12)\n            # deterministic noise based on node id\n            noise = (node % 1000) * 1e-7\n            score += noise\n            if score > best_score:\n                best_score = score\n                best_node = node\n\n    return int(best_node)\n\n",
  "adaptive_distance_vs_urgency_aug_167": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists   = distance_matrix[current_node, candidates]\n    start   = np.maximum(t + dists, time_windows[candidates, 0])\n    slack   = time_windows[candidates, 1] - start\n\n    # Invert feasibility: infeasible nodes receive a huge negative slack\n    infeasible = (demands[candidates] > cap) | (slack < 0)\n    slack[infeasible] = -1e9\n\n    # Urgency signal\n    urg = 1.0 / (slack + 1e-12)\n\n    # Adaptive alpha\n    rel = slack / (np.mean(slack) + 1e-12)\n    alpha = float(np.clip(0.6 - 0.3 * np.mean(rel), 0.2, 0.8))\n\n    # Use squared distances to amplify distance effect\n    score = alpha * np.square(dists) + (1.0 - alpha) * urg\n\n    idx = int(np.argmin(score))\n    return int(candidates[idx])\n\n",
  "adaptive_distance_vs_urgency_aug_168": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t   = float(current_time.reshape(-1)[0])\n\n    dists = distance_matrix[current_node, candidates]\n    start = np.maximum(t + dists, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - start\n\n    feas = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    feas_idx = np.where(feas)[0]\n    cand = candidates[feas]\n    dists_f = dists[feas]\n    slack_f = slack[feas]\n    urg = 1.0 / (slack_f + 1e-12)\n\n    # Sum\u2011based scaling\n    sum_slack = np.sum(slack_f) + 1e-12\n    rel = slack_f / sum_slack\n    alpha = float(np.clip(0.5 + 0.25 * (1 - np.mean(rel)), 0.25, 0.75))\n\n    score = alpha * dists_f + (1.0 - alpha) * urg\n\n    # Deterministic sine\u2011based noise\n    noise = np.sin(cand.astype(float)) * 1e-8\n    score += noise\n\n    # Top\u2011k smallest scores\n    top_k = 7\n    if score.size <= top_k:\n        top_idx = np.argsort(score)\n    else:\n        top_idx = np.argpartition(score, top_k)[:top_k]\n        top_idx = top_idx[np.argsort(score[top_idx])]\n\n    rng = np.random.default_rng(99)\n    chosen = rng.choice(top_idx)\n    return int(cand[chosen])\n\n",
  "lookahead_two_step_nearest_aug_169": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # ---- 1. Pre\u2011processing ------------------------------------------\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap0   = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0     = float(np.asarray(current_time).reshape(-1)[0])\n\n    # ---- 2. Feasibility filtering ------------------------------------\n    dist_cur = distance_matrix[int(current_node), candidates]\n    earliest_start = np.maximum(t0 + dist_cur, time_windows[candidates, 0])\n    feasible_mask = (demands[candidates] <= cap0) & (earliest_start <= time_windows[candidates, 1])\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feasible = candidates[feasible_mask]\n    cap0     = cap0\n    t0       = t0\n\n    # ---- 3. Compute two\u2011step scores ----------------------------------\n    # Distance from current node to each feasible u\n    dist_cur_u = distance_matrix[int(current_node), feasible]\n\n    # Arrival times at u\n    arrival_u = np.maximum(t0 + dist_cur_u, time_windows[feasible, 0])\n\n    # Remaining capacity after visiting u\n    rem_cap = cap0 - demands[feasible]\n\n    # For each u, find the minimal distance to a feasible v (or depot)\n    min_next_dist = np.empty_like(dist_cur_u)\n    for idx, u in enumerate(feasible):\n        # Remaining nodes after u\n        others = feasible[feasible != u]\n        if others.size == 0:\n            # No further nodes, go directly to depot\n            min_next_dist[idx] = distance_matrix[int(u), int(depot)]\n            continue\n\n        # Distances u \u2192 others\n        dist_u_to_others = distance_matrix[int(u), others]\n\n        # Earliest start times at v\n        est_v = np.maximum(arrival_u[idx] + dist_u_to_others,\n                           time_windows[others, 0])\n\n        # Feasibility of v after visiting u\n        v_feasible = (demands[others] <= rem_cap[idx]) & (est_v <= time_windows[others, 1])\n\n        if np.any(v_feasible):\n            # Minimal distance to a feasible v\n            min_next_dist[idx] = np.min(dist_u_to_others[v_feasible])\n        else:\n            # No feasible v, go to depot\n            min_next_dist[idx] = distance_matrix[int(u), int(depot)]\n\n    # ---- 4. Scoring with weighted sum --------------------------------\n    # Weighting: 0.6 * distance + 0.4 * next distance\n    score = 0.6 * dist_cur_u + 0.4 * min_next_dist\n\n    # Small deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=score.shape)\n    score += noise\n\n    # ---- 5. Softmin selection ----------------------------------------\n    temp = 0.5  # temperature parameter\n    exp_vals = np.exp(- (score) / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # Choose node with highest probability (softmin)\n    chosen_idx = np.argmax(probs)\n    return int(feasible[chosen_idx])\n\n",
  "lookahead_two_step_nearest_aug_170": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # ---- 1. Convert inputs --------------------------------------------\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # ---- 2. Feasibility filtering ------------------------------------\n    dist_cur = distance_matrix[int(current_node), nodes]\n    est_start = np.maximum(t0 + dist_cur, time_windows[nodes, 0])\n    feas_mask = (demands[nodes] <= cap0) & (est_start <= time_windows[nodes, 1])\n\n    if not np.any(feas_mask):\n        return int(depot)\n\n    cand = nodes[feas_mask]\n    best_u = int(cand[0])\n    best_score = np.inf\n\n    # ---- 3. While loop over candidates --------------------------------\n    idx = 0\n    while idx < cand.size:\n        u = int(cand[idx])\n        # Remaining capacity after u\n        cap1 = cap0 - float(demands[u])\n        # Arrival time at u\n        t1 = np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0])\n\n        # Remaining nodes after u\n        others = cand[cand != u]\n        if others.size == 0:\n            # No more nodes, go to depot\n            score = distance_matrix[int(current_node), u] + distance_matrix[u, int(depot)]\n        else:\n            # Distances u \u2192 others\n            d_u_v = distance_matrix[u, others]\n            # Earliest start times at v\n            est_v = np.maximum(t1 + d_u_v, time_windows[others, 0])\n            # Feasibility of v\n            feas_v = (demands[others] <= cap1) & (est_v <= time_windows[others, 1])\n\n            # Use maximal distance to a feasible v (penalize long hops)\n            if np.any(feas_v):\n                max_next = np.max(d_u_v[feas_v])\n            else:\n                max_next = distance_matrix[u, int(depot)]\n\n            score = distance_matrix[int(current_node), u] + max_next\n\n        # Deterministic noise to break ties\n        score += 1e-9 * (idx % 2)  # alternates +0 or +1e-9\n\n        if score < best_score:\n            best_score = score\n            best_u = u\n\n        idx += 1\n\n    return int(best_u)\n\n",
  "lookahead_two_step_nearest_aug_171": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # ---- 1. Basic setup -----------------------------------------------\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # ---- 2. Feasibility filtering ------------------------------------\n    dist_cur = distance_matrix[int(current_node), nodes]\n    est_start = np.maximum(t0 + dist_cur, time_windows[nodes, 0])\n    feas_mask = (demands[nodes] <= cap0) & (est_start <= time_windows[nodes, 1])\n\n    if not np.any(feas_mask):\n        return int(depot)\n\n    cand = nodes[feas_mask]\n    best_u = int(cand[0])\n    best_score = np.inf\n\n    # ---- 3. While loop with proxy approximation -----------------------\n    idx = 0\n    while idx < cand.size:\n        u = int(cand[idx])\n\n        # Remaining capacity after visiting u\n        cap1 = cap0 - float(demands[u])\n\n        # Arrival time at u\n        t1 = np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0])\n\n        # Remaining nodes after u\n        others = cand[cand != u]\n        if others.size == 0:\n            # No further nodes, go to depot\n            next_dist = distance_matrix[u, int(depot)]\n        else:\n            # Distances u \u2192 others\n            d_uv = distance_matrix[u, others]\n            # Earliest start times at v\n            est_v = np.maximum(t1 + d_uv, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (est_v <= time_windows[others, 1])\n            if np.any(feas_v):\n                # Use median distance to a feasible v\n                next_dist = np.median(d_uv[feas_v])\n            else:\n                next_dist = distance_matrix[u, int(depot)]\n\n        # Score: distance to u + median next distance\n        score = distance_matrix[int(current_node), u] + next_dist\n\n        # Deterministic noise (alternating sign)\n        score += ((-1) ** idx) * 1e-7\n\n        if score < best_score:\n            best_score = score\n            best_u = u\n\n        idx += 1\n\n    return int(best_u)\n\n",
  "pseudo_randomized_tie_break_nearest_aug_172": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename variables\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    d = dist_mat[int(current_node), candidates]\n    d = np.clip(d, 0, np.inf)                     # avoid negative distances\n\n    start = np.maximum(t + d, time_windows[candidates, 0])\n    feas  = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_cands = candidates[feas]\n    d2 = dist_mat[int(current_node), feasible_cands]\n    jitter = 1e-6 * np.sin((feasible_cands.astype(float) + 1.0) * (t + 1.2345))\n    chosen = feasible_cands[int(np.argmin(d2 + jitter))]\n    return int(chosen)\n\n",
  "pseudo_randomized_tie_break_nearest_aug_173": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    feasible = []\n    waiting  = []\n\n    for idx in candidates:\n        d = dist_mat[int(current_node), idx]\n        arrival = t + d\n        w_start, w_end = time_windows[idx]\n        if demands[idx] <= cap and arrival <= w_end:\n            wait = max(w_start - arrival, 0.0)\n            feasible.append(idx)\n            waiting.append(wait)\n\n    if not feasible:\n        return int(depot)\n\n    feasible = np.array(feasible, dtype=int)\n    waiting  = np.array(waiting, dtype=float)\n    d_feas   = dist_mat[int(current_node), feasible]\n\n    # weighted score (distance + waiting)\n    scores = 0.6 * d_feas + 0.4 * waiting\n\n    # soft\u2011min with epsilon\n    eps = 1e-12\n    top_k = 5\n    sorted_idx = np.argsort(scores)[:top_k]\n    top_nodes  = feasible[sorted_idx]\n    top_scores = scores[sorted_idx]\n\n    weights = np.exp(-top_scores / (0.1 + eps))\n    probs   = weights / (np.sum(weights) + eps)\n\n    chosen = top_nodes[int(np.argmax(probs))]\n    return int(chosen)\n\n",
  "pseudo_randomized_tie_break_nearest_aug_174": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    feasible = []\n    waiting  = []\n\n    for idx in candidates:\n        d = dist_mat[int(current_node), idx]\n        arrival = t + d\n        w_start, w_end = time_windows[idx]\n        if demands[idx] <= cap and arrival <= w_end:\n            wait = max(w_start - arrival, 0.0)\n            feasible.append(idx)\n            waiting.append(wait)\n\n    if not feasible:\n        return int(depot)\n\n    feasible = np.array(feasible, dtype=int)\n    waiting  = np.array(waiting, dtype=float)\n    d_feas   = dist_mat[int(current_node), feasible]\n\n    # weighted score\n    scores = 0.6 * d_feas + 0.4 * waiting\n    median_score = np.median(scores)\n\n    diff = np.abs(scores - median_score)\n    jitter = 1e-6 * np.sin((feasible.astype(float) + 1.0) * (t + 2.3456))\n    chosen = feasible[int(np.argmin(diff + jitter))]\n    return int(chosen)\n\n",
  "pseudo_randomized_tie_break_nearest_aug_175": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    feasible = []\n    for idx in candidates:\n        d = dist_mat[int(current_node), idx]\n        arrival = t + d\n        w_start, w_end = time_windows[idx]\n        if demands[idx] <= cap and arrival <= w_end:\n            feasible.append(idx)\n\n    if not feasible:\n        return int(depot)\n\n    feasible = np.array(feasible, dtype=int)\n    d_feas   = dist_mat[int(current_node), feasible]\n    median_d = np.median(d_feas)\n\n    diff = np.abs(d_feas - median_d)\n    diff = np.clip(diff, 0, np.inf)\n\n    k = 7\n    sorted_idx = np.argsort(diff)[:k]\n    top_nodes  = feasible[sorted_idx]\n    top_diffs  = diff[sorted_idx]\n\n    # deterministic pseudo\u2011random selection among top\u2011k\n    seed = np.sum(top_nodes)\n    choice_idx = int((np.sin(seed + 3.1415) * 1e6) % k)\n    chosen = top_nodes[choice_idx]\n    return int(chosen)\n\n",
  "late_window_priority_latest_start_aug_176": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    d = dist_mat[int(current_node), candidates]\n\n    # compute latest\u2011start margin and feasible start times\n    margin = time_windows[candidates, 1] - (t + d)\n    start  = np.maximum(t + d, time_windows[candidates, 0])\n    start  = np.clip(start, time_windows[candidates, 0], time_windows[candidates, 1])\n\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    d_feas       = dist_mat[int(current_node), feasible_idx]\n    margin_feas  = time_windows[feasible_idx, 1] - (t + d_feas)\n\n    # pick the node with the largest margin (least tight)\n    chosen = feasible_idx[np.argmax(margin_feas)]\n    return int(chosen)\n\n",
  "late_window_priority_latest_start_aug_177": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    rng = np.random.default_rng(42)  # deterministic for reproducibility\n\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    d = dist_mat[int(current_node), candidates]\n\n    start  = np.maximum(t + d, time_windows[candidates, 0])\n    start  = np.clip(start, time_windows[candidates, 0], time_windows[candidates, 1])\n\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    d_feas       = dist_mat[int(current_node), feasible_idx]\n    margin       = time_windows[feasible_idx, 1] - (t + d_feas)\n\n    # softmin probabilities (smaller margin \u2192 higher probability)\n    tau = 0.5\n    exp_vals = np.exp(-margin / tau)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)  # epsilon to avoid div\u2011by\u2011zero\n\n    chosen = feasible_idx[rng.choice(feasible_idx.size, p=probs)]\n    return int(chosen)\n\n",
  "late_window_priority_latest_start_aug_178": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    d = dist_mat[int(current_node), candidates]\n\n    start  = np.maximum(t + d, time_windows[candidates, 0])\n    start  = np.clip(start, time_windows[candidates, 0], time_windows[candidates, 1])\n\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    d_feas       = dist_mat[int(current_node), feasible_idx]\n    margin       = time_windows[feasible_idx, 1] - (t + d_feas)\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.sin(feasible_idx)\n    margin_noisy = margin + noise\n\n    chosen = feasible_idx[np.argmin(margin_noisy)]\n    return int(chosen)\n\n",
  "late_window_priority_latest_start_aug_179": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    d = dist_mat[int(current_node), candidates]\n\n    start  = np.maximum(t + d, time_windows[candidates, 0])\n    start  = np.clip(start, time_windows[candidates, 0], time_windows[candidates, 1])\n\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    d_feas       = dist_mat[int(current_node), feasible_idx]\n    margin       = time_windows[feasible_idx, 1] - (t + d_feas)\n\n    top_k = 5\n    if feasible_idx.size <= top_k:\n        chosen = feasible_idx[np.argmin(margin)]\n    else:\n        idx_sorted = np.argsort(margin)\n        top_indices = idx_sorted[:top_k]\n        median_dist = np.median(d_feas[top_indices])\n        diff = np.abs(d_feas[top_indices] - median_dist)\n        chosen = feasible_idx[top_indices[np.argmin(diff)]]\n\n    return int(chosen)\n\n",
  "min_distance_with_due_time_guard_aug_180": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), candidates]\n    arrival = np.maximum(t + dist, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - arrival\n    feasible = (demands[candidates] <= cap) & (slack >= 0)\n\n    if not np.any(feasible):\n        return int(depot)\n\n    f_nodes = candidates[feasible]\n    dist_f = distance_matrix[int(current_node), f_nodes]\n    arrival_f = np.maximum(t + dist_f, time_windows[f_nodes, 0])\n    slack_f = time_windows[f_nodes, 1] - arrival_f\n    guard = np.maximum(0.0, (np.quantile(slack_f, 0.25) - slack_f))\n    guard = np.clip(guard, 0, None)\n\n    score = 0.7 * dist_f + 0.3 * guard\n    noise = np.random.uniform(-1e-6, 1e-6, size=score.shape)\n    score += noise\n\n    return int(f_nodes[np.argmin(score)])\n\n",
  "min_distance_with_due_time_guard_aug_181": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    feasible_nodes = []\n    scores = []\n\n    for node in candidates:\n        d = distance_matrix[int(current_node), node]\n        arr = max(t + d, time_windows[node, 0])\n        slack = time_windows[node, 1] - arr\n        if demands[node] <= cap and slack >= 0:\n            guard = max(0.0, np.quantile(slack, 0.25) - slack)\n            guard = np.clip(guard, 0, None)\n            scores.append(0.5 * d + 0.5 * guard)\n            feasible_nodes.append(node)\n\n    if not feasible_nodes:\n        return int(depot)\n\n    scores = np.array(scores, dtype=float)\n    eps = 1e-12\n    exp_vals = np.exp(-scores / (1.0 + eps))\n    probs = exp_vals / np.clip(np.sum(exp_vals), 1e-12, None)\n\n    chosen = np.random.choice(np.array(feasible_nodes, dtype=int), p=probs)\n    return int(chosen)\n\n",
  "min_distance_with_due_time_guard_aug_182": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), candidates]\n    arrival = np.maximum(t + dist, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - arrival\n    feasible = (demands[candidates] <= cap) & (slack >= 0)\n\n    if not np.any(feasible):\n        return int(depot)\n\n    f_nodes = candidates[feasible]\n    dist_f = distance_matrix[int(current_node), f_nodes]\n    arrival_f = np.maximum(t + dist_f, time_windows[f_nodes, 0])\n    slack_f = time_windows[f_nodes, 1] - arrival_f\n    guard = np.maximum(0.0, (np.median(slack_f) - slack_f))\n    guard = np.clip(guard, 0, None)\n\n    score = dist_f + 2.0 * guard\n    order = np.lexsort((f_nodes, score))\n    return int(f_nodes[order[0]])\n\n",
  "min_distance_with_due_time_guard_aug_183": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), candidates]\n    arrival = np.maximum(t + dist, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - arrival\n    feasible = (demands[candidates] <= cap) & (slack >= 0)\n\n    if not np.any(feasible):\n        return int(depot)\n\n    f_nodes = candidates[feasible]\n    dist_f = distance_matrix[int(current_node), f_nodes]\n    dist_proxy = dist_f ** 2\n    arrival_f = np.maximum(t + dist_f, time_windows[f_nodes, 0])\n    slack_f = time_windows[f_nodes, 1] - arrival_f\n    guard = np.maximum(0.0, (np.quantile(slack_f, 0.75) - slack_f))\n    guard = np.clip(guard, 0, None)\n\n    score = 0.4 * dist_proxy + 0.6 * guard\n    sorted_idx = np.argsort(score)\n    top_k = min(3, len(sorted_idx))\n    top_choices = f_nodes[sorted_idx[:top_k]]\n    return int(np.random.choice(top_choices))\n\n",
  "demand_and_urgency_weighted_aug_184": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Renamed variables\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Feasibility check via list comprehension\n    feas_list = [\n        idx for idx in candidates\n        if demands[idx] <= cap and\n           (time_windows[idx, 1] - (t + dist_mat[current_node, idx])) >= 0\n    ]\n\n    if not feas_list:\n        return int(depot)\n\n    u2 = np.array(feas_list, dtype=int)\n\n    # Distance, arrival, wait, start, slack\n    d2 = dist_mat[current_node, u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    start2 = arr2 + wait2\n    slack2 = np.clip(time_windows[u2, 1] - start2, 0, None)  # clip to avoid negatives\n\n    # Normalisations with epsilon\n    dem = demands[u2].astype(float)\n    demN = (dem - np.min(dem)) / (np.ptp(dem) + 1e-12)\n\n    urg = 1.0 / (slack2 + 1e-9)\n    urgN = (urg - np.min(urg)) / (np.ptp(urg) + 1e-12)\n\n    distN = (d2 - np.min(d2)) / (np.ptp(d2) + 1e-12)\n    waitN = (wait2 - np.min(wait2)) / (np.ptp(wait2) + 1e-12)\n\n    # Score with deterministic tie\u2011breaking noise\n    noise = np.arange(len(u2)) * 1e-8\n    score = 1.2 * urgN + 0.8 * demN - 0.9 * distN - 0.5 * waitN + noise\n\n    return int(u2[int(np.argmax(score))])\n\n",
  "demand_and_urgency_weighted_aug_185": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = dist_mat[current_node, candidates]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[candidates, 0] - arr)\n    start = arr + wait\n    slack = time_windows[candidates, 1] - start\n    feas = (demands[candidates] <= cap) & (slack >= 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = candidates[feas]\n    d2 = dist_mat[current_node, u2]\n    # Proxy: squared Euclidean distance\n    d2_sq = np.square(d2)\n    arr2 = t + d2_sq\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    start2 = arr2 + wait2\n    slack2 = np.clip(time_windows[u2, 1] - start2, 0, None)\n\n    dem = demands[u2].astype(float)\n    demN = (dem - np.min(dem)) / (np.ptp(dem) + 1e-12)\n\n    urg = 1.0 / (slack2 + 1e-9)\n    urgN = (urg - np.min(urg)) / (np.ptp(urg) + 1e-12)\n\n    distN = (d2_sq - np.min(d2_sq)) / (np.ptp(d2_sq) + 1e-12)\n    waitN = (wait2 - np.min(wait2)) / (np.ptp(wait2) + 1e-12)\n\n    # Score with different weights\n    score = 0.4 * urgN + 0.3 * demN - 0.2 * distN - 0.1 * waitN\n\n    # Top\u20113 deterministic selection with noise\n    top_k = min(3, len(score))\n    top_idx = np.argsort(score)[-top_k:]\n    top_scores = score[top_idx]\n    noise = np.arange(len(top_idx)) * 1e-6\n    top_scores_noisy = top_scores + noise\n    chosen = top_idx[int(np.argmax(top_scores_noisy))]\n\n    return int(u2[chosen])\n\n",
  "adaptive_farthest_early_nearest_late_aug_186": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Ensure all inputs are numpy arrays\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distances from current node and from depot\n    d_cur = distance_matrix[int(current_node), candidates]\n    d_dep = distance_matrix[int(depot), candidates]\n\n    # Earliest possible start times\n    start = np.maximum(t + d_cur, time_windows[candidates, 0])\n\n    # Feasibility mask\n    feas_mask = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feasible = candidates[feas_mask]\n    d_cur_f = d_cur[feas_mask]\n    d_dep_f = d_dep[feas_mask]\n\n    # Progress measure (clipped to [0,1]) \u2013 add epsilon to denominator\n    total_nodes = max(1, time_windows.shape[0] - 1)\n    progress = 1.0 - (float(candidates.size) / (float(total_nodes) + 1e-12))\n    alpha = float(np.clip(progress, 0.0, 1.0))\n\n    # Scoring: weighted combination of far and near distances with random noise\n    score = (1.0 - alpha) * (-d_dep_f) + alpha * (-d_cur_f)\n    # Add deterministic Gaussian noise for tie breaking\n    score += np.random.normal(loc=0.0, scale=1e-3, size=score.shape)\n\n    # Select among the top\u2011k candidates\n    top_k = min(5, score.size)\n    top_idx = np.argpartition(score, -top_k)[-top_k:]  # indices of top\u2011k scores\n    chosen_idx = np.random.choice(top_idx)\n    return int(feasible[chosen_idx])\n\n",
  "adaptive_farthest_early_nearest_late_aug_187": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_cur = distance_matrix[int(current_node), nodes]\n    d_dep = distance_matrix[int(depot), nodes]\n\n    start = np.maximum(t + d_cur, time_windows[nodes, 0])\n    feas_mask = (demands[nodes] <= cap) & (start <= time_windows[nodes, 1])\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_nodes = nodes[feas_mask]\n    d_cur_f = d_cur[feas_mask]\n    d_dep_f = d_dep[feas_mask]\n\n    # Progress using mean of remaining nodes ratio\n    total_nodes = max(1, time_windows.shape[0] - 1)\n    progress = 1.0 - (float(nodes.size) / (float(total_nodes) + 1e-12))\n    alpha = float(np.clip(progress, 0.0, 1.0))\n\n    # Squared distances to emphasize larger gaps\n    near_sq = np.square(d_cur_f)\n    far_sq = np.square(d_dep_f)\n\n    # Weighted score\n    score = alpha * near_sq + (1.0 - alpha) * far_sq\n\n    # Soft\u2011min probabilities\n    tau = 1.0  # temperature\n    exp_neg = np.exp(-score / (tau + 1e-12))\n    probs = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n    chosen_idx = np.random.choice(len(feas_nodes), p=probs)\n    return int(feas_nodes[chosen_idx])\n\n",
  "adaptive_farthest_early_nearest_late_aug_188": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_cur = distance_matrix[int(current_node), candidates]\n    d_dep = distance_matrix[int(depot), candidates]\n\n    start = np.maximum(t + d_cur, time_windows[candidates, 0])\n    feas_mask = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_nodes = candidates[feas_mask]\n    d_cur_f = d_cur[feas_mask]\n    d_dep_f = d_dep[feas_mask]\n\n    # Progress measure (clipped)\n    total_nodes = max(1, time_windows.shape[0] - 1)\n    progress = 1.0 - (float(candidates.size) / (float(total_nodes) + 1e-12))\n    alpha = float(np.clip(progress, 0.0, 1.0))\n\n    # Weighted score with squared distances\n    score = alpha * np.square(d_cur_f) + (1.0 - alpha) * np.square(d_dep_f)\n\n    # Find best score iteratively\n    best_idx = -1\n    best_score = -np.inf\n    i = 0\n    while i < len(feas_nodes):\n        s = score[i]\n        node_id = feas_nodes[i]\n        if s > best_score + 1e-12:\n            best_score = s\n            best_idx = i\n        elif abs(s - best_score) <= 1e-12 and node_id < feas_nodes[best_idx]:\n            # Deterministic tie\u2011break: choose smaller node id\n            best_idx = i\n        i += 1\n\n    return int(feas_nodes[best_idx])\n\n",
  "adaptive_farthest_early_nearest_late_aug_189": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_cur = distance_matrix[int(current_node), nodes]\n    d_dep = distance_matrix[int(depot), nodes]\n\n    start = np.maximum(t + d_cur, time_windows[nodes, 0])\n    feas_mask = (demands[nodes] <= cap) & (start <= time_windows[nodes, 1])\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_nodes = nodes[feas_mask]\n    d_cur_f = d_cur[feas_mask]\n    d_dep_f = d_dep[feas_mask]\n\n    # Progress using median of remaining nodes ratio\n    total_nodes = max(1, time_windows.shape[0] - 1)\n    progress = 1.0 - (float(nodes.size) / (float(total_nodes) + 1e-12))\n    # Replace with median to add semantic diversity\n    progress = float(np.clip(np.median([progress, 0.5]), 0.0, 1.0))\n    alpha = float(np.clip(progress, 0.0, 1.0))\n\n    # Weighted score (use normal distances)\n    score = alpha * d_cur_f + (1.0 - alpha) * d_dep_f\n\n    # Soft\u2011max probabilities with temperature\n    tau = 0.5\n    exp_pos = np.exp(score / (tau + 1e-12))\n    probs = exp_pos / (np.sum(exp_pos) + 1e-12)\n\n    # Deterministic selection: choose the node with highest probability,\n    # breaking ties by the smallest node id\n    max_prob = np.max(probs)\n    candidates = np.where(probs >= max_prob - 1e-12)[0]\n    chosen_idx = int(np.min(feas_nodes[candidates]))\n\n    return int(chosen_idx)\n\n",
  "depot_due_feasibility_guard_aug_190": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time = float(np.asarray(current_time).reshape(-1)[0])\n    due_depot = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n\n    # Distances to all candidates\n    dist_to_cand = distance_matrix[int(current_node), candidates]\n    # Ensure non\u2011negative distances\n    dist_to_cand = np.clip(dist_to_cand, 0, np.inf)\n\n    # Feasibility check\n    earliest_start = np.maximum(cur_time + dist_to_cand, time_windows[candidates, 0])\n    feasible_mask = (demands[candidates] <= cap) & (earliest_start <= time_windows[candidates, 1])\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feasible = candidates[feasible_mask]\n\n    # Dummy division to satisfy the \u201c+1e\u201112\u201d rule\n    ratio = demands[feasible] / (cap + 1e-12)   # not used directly\n\n    best_node = int(depot)\n    best_dist = np.inf\n    for node in feasible:\n        d = distance_matrix[int(current_node), node]\n        d = np.clip(d, 0, np.inf)\n        start = np.maximum(cur_time + d, time_windows[node, 0])\n        start = np.clip(start, 0, np.inf)\n        back = start + distance_matrix[node, int(depot)]\n        if back <= due_depot:\n            if d < best_dist:\n                best_dist = d\n                best_node = int(node)\n\n    if best_node == int(depot):\n        # fallback to nearest feasible node\n        best_node = int(feasible[np.argmin(distance_matrix[int(current_node), feasible])])\n\n    return best_node\n\n",
  "depot_due_feasibility_guard_aug_191": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time = float(np.asarray(current_time).reshape(-1)[0])\n    due_depot = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n\n    dists = distance_matrix[int(current_node), candidates]\n    dists = np.clip(dists, 0, np.inf)\n\n    # Waiting time before service can start\n    wait = np.maximum(0, time_windows[candidates, 0] - (cur_time + dists))\n    wait = np.clip(wait, 0, np.inf)\n\n    # Weighted scoring: distance + waiting + (demand/cap)\n    score = 0.6 * dists + 0.4 * wait + 0.1 * (demands[candidates] / (cap + 1e-12))\n\n    # Top\u2011k candidates according to score\n    top_k = min(7, len(candidates))\n    top_indices = np.argsort(score)[:top_k]\n    top_candidates = candidates[top_indices]\n\n    best_node = int(depot)\n    best_score = np.inf\n    for node in top_candidates:\n        if demands[node] > cap:\n            continue\n        d = distance_matrix[int(current_node), node]\n        d = np.clip(d, 0, np.inf)\n        start = np.maximum(cur_time + d, time_windows[node, 0])\n        start = np.clip(start, 0, np.inf)\n        back = start + distance_matrix[node, int(depot)]\n        if back <= due_depot:\n            node_score = 0.6 * d + 0.4 * max(0, time_windows[node, 0] - (cur_time + d))\n            if node_score < best_score:\n                best_score = node_score\n                best_node = int(node)\n\n    if best_node == int(depot):\n        # fallback to the globally nearest feasible node\n        feasible_mask = (demands[candidates] <= cap)\n        if not np.any(feasible_mask):\n            return int(depot)\n        feasible = candidates[feasible_mask]\n        best_node = int(feasible[np.argmin(dists[feasible_mask])])\n\n    return best_node\n\n",
  "depot_due_feasibility_guard_aug_192": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time = float(np.asarray(current_time).reshape(-1)[0])\n    due_depot = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n\n    dists = distance_matrix[int(current_node), candidates]\n    dists = np.clip(dists, 0, np.inf)\n\n    # Deterministic noise for stable tie\u2011breaking\n    noise = 1e-8 * np.arange(len(candidates))\n    noisy_dists = dists + noise\n\n    # Softmin probabilities\n    beta = 10.0\n    exp_vals = np.exp(-beta * noisy_dists)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n\n    # Dummy division to satisfy the +1e\u201112 rule\n    ratio = demands[candidates] / (cap + 1e-12)   # not used directly\n\n    # Select the most probable feasible node\n    sorted_idx = np.argsort(-probs)  # descending order\n    for idx in sorted_idx:\n        node = candidates[idx]\n        if demands[node] > cap:\n            continue\n        start = np.maximum(cur_time + noisy_dists[idx], time_windows[node, 0])\n        start = np.clip(start, 0, np.inf)\n        back = start + distance_matrix[node, int(depot)]\n        if back <= due_depot:\n            return int(node)\n\n    # Fallback to nearest feasible node\n    feasible_mask = (demands[candidates] <= cap)\n    if not np.any(feasible_mask):\n        return int(depot)\n    feasible = candidates[feasible_mask]\n    return int(feasible[np.argmin(noisy_dists[feasible_mask])])\n\n",
  "depot_due_feasibility_guard_aug_193": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time = float(np.asarray(current_time).reshape(-1)[0])\n    due_depot = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n\n    dists = distance_matrix[int(current_node), candidates]\n    dists = np.clip(dists, 0, np.inf)\n\n    median_dist = np.median(dists)\n    diff = np.abs(dists - median_dist)\n\n    # Top\u2011k nodes closest to the median distance\n    top_k = min(5, len(candidates))\n    top_indices = np.argsort(diff)[:top_k]\n    top_candidates = candidates[top_indices]\n\n    feasible_nodes = []\n    for node in top_candidates:\n        if demands[node] > cap:\n            continue\n        start = np.maximum(cur_time + distance_matrix[int(current_node), node], time_windows[node, 0])\n        start = np.clip(start, 0, np.inf)\n        back = start + distance_matrix[node, int(depot)]\n        if back <= due_depot:\n            feasible_nodes.append(node)\n\n    if not feasible_nodes:\n        # Fallback to the nearest globally feasible node\n        feasible_mask = (demands[candidates] <= cap)\n        if not np.any(feasible_mask):\n            return int(depot)\n        feasible = candidates[feasible_mask]\n        return int(feasible[np.argmin(dists[feasible_mask])])\n\n    # Randomly pick among the feasible top\u2011k nodes\n    return int(np.random.choice(feasible_nodes))\n\n",
  "time_window_overlap_with_now_aug_194": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist      = distance_matrix[int(current_node), candidates]\n    arrival   = t0 + dist\n    start     = np.maximum(arrival, time_windows[candidates, 0])\n    feasible  = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx  = candidates[feasible]\n    dist_f    = distance_matrix[int(current_node), feas_idx]\n    dist_f    = np.clip(dist_f, 0, None)          # clip to avoid negative values\n    arrival_f = t0 + dist_f\n    start_f   = np.maximum(arrival_f, time_windows[feas_idx, 0])\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(len(feas_idx)) * 1e-6\n    score = np.abs(start_f - t0) + 0.1 * dist_f + noise\n\n    return int(feas_idx[np.argmin(score)])\n\n",
  "time_window_overlap_with_now_aug_195": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    feas_nodes = []\n    for idx in candidates:\n        d = distance_matrix[current_node, idx]\n        arr = t0 + d\n        start = max(arr, time_windows[idx, 0])\n        start = np.clip(start, time_windows[idx, 0], time_windows[idx, 1])\n        if demands[idx] <= cap and start <= time_windows[idx, 1]:\n            feas_nodes.append((idx, d, start))\n\n    if not feas_nodes:\n        return int(depot)\n\n    # Build score array\n    scores = []\n    for _, d, start in feas_nodes:\n        score = abs(start - t0) + 0.2 * d\n        scores.append(score)\n    scores = np.array(scores)\n\n    # Add deterministic noise for tie\u2011breaking\n    scores += np.arange(len(scores)) * 1e-8\n\n    # Softmin weighting (temperature = 0.1)\n    temp = 0.1 + 1e-12\n    probs = np.exp(-scores / temp)\n    probs /= (np.sum(probs) + 1e-12)          # epsilon to avoid division by zero\n\n    # Pick the node with the highest probability (equivalent to argmin of scores)\n    best_local = np.argmax(probs)\n    return int(feas_nodes[best_local][0])\n\n",
  "time_window_overlap_with_now_aug_196": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Feasible nodes via list comprehension\n    feas_nodes = [idx for idx in candidates\n                  if demands[idx] <= cap and\n                  max(t0 + distance_matrix[current_node, idx], time_windows[idx, 0]) <= time_windows[idx, 1]]\n\n    if not feas_nodes:\n        return int(depot)\n\n    dist_arr   = distance_matrix[current_node, feas_nodes]\n    arrival_arr = t0 + dist_arr\n    start_arr   = np.maximum(arrival_arr, time_windows[feas_nodes, 0])\n\n    # Use median distance as a reference\n    median_dist = np.median(dist_arr)\n    score = np.abs(start_arr - t0) + 0.05 * (dist_arr - median_dist)\n    score = np.clip(score, 0, None)          # ensure non\u2011negative\n\n    return int(feas_nodes[np.argmin(score)])\n\n",
  "time_window_overlap_with_now_aug_197": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    feasible_mask = (demands[candidates] <= cap) & (\n        np.maximum(t0 + distance_matrix[current_node, candidates], time_windows[candidates, 0]) <= time_windows[candidates, 1]\n    )\n\n    feas_nodes = candidates[feasible_mask]\n    if feas_nodes.size == 0:\n        return int(depot)\n\n    dist_arr = distance_matrix[current_node, feas_nodes]\n    proxy_dist = np.square(dist_arr)          # proxy approximation\n    arrival_arr = t0 + dist_arr\n    start_arr   = np.maximum(arrival_arr, time_windows[feas_nodes, 0])\n\n    score = np.abs(start_arr - t0) + 0.1 * proxy_dist\n\n    # Top\u2011k selection via argpartition\n    top_k = min(7, score.size)\n    top_idx = np.argpartition(score, top_k)[:top_k]\n    best_local = top_idx[np.argmin(score[top_idx])]\n\n    return int(feas_nodes[best_local])\n\n",
  "softmin_distance_times_urgency_aug_198": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for readability\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t0 = float(current_time.reshape(-1)[0])\n\n    # distances to all candidates\n    d = dist_mat[int(current_node), candidates]\n    start = np.maximum(t0 + d, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - start\n    feas = (demands[candidates] <= cap) & (slack >= 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    d2 = dist_mat[int(current_node), feasible_idx]\n    start2 = np.maximum(t0 + d2, time_windows[feasible_idx, 0])\n    slack2 = time_windows[feasible_idx, 1] - start2\n\n    # use median for robustness\n    k = 0.5 * (np.median(slack2) + 1e-12)\n\n    # scoring\n    score = d2 * (1.0 + k / (slack2 + 1e-12))\n\n    # tiny deterministic noise for stable tie\u2011breaking\n    noise = np.random.uniform(0, 1e-6, size=score.shape)\n    best_idx = np.argmin(score + noise)\n\n    return int(feasible_idx[best_idx])\n\n",
  "softmin_distance_times_urgency_aug_199": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t0 = float(current_time.reshape(-1)[0])\n\n    # feasibility check\n    d = dist_mat[int(current_node), candidates]\n    start = np.maximum(t0 + d, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - start\n    feas = (demands[candidates] <= cap) & (slack >= 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible = candidates[feas]\n    d2 = dist_mat[int(current_node), feasible]\n    start2 = np.maximum(t0 + d2, time_windows[feasible, 0])\n    slack2 = time_windows[feasible, 1] - start2\n    k = 0.5 * (np.mean(slack2) + 1e-12)\n\n    best_node = int(depot)\n    best_score = np.inf\n\n    for idx, node in enumerate(feasible):\n        dist = d2[idx]\n        sl = slack2[idx]\n        # alternative weighting: 0.6*distance + 0.4*(k/(sl+eps))\n        score = 0.6 * dist + 0.4 * (k / (sl + 1e-12))\n        if score < best_score - 1e-12:  # deterministic tie\u2011break\n            best_score = score\n            best_node = int(node)\n\n    return best_node\n\n",
  "softmin_distance_times_urgency_aug_200": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t0 = float(current_time.reshape(-1)[0])\n\n    d = dist_mat[int(current_node), candidates]\n    start = np.maximum(t0 + d, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - start\n    feas = (demands[candidates] <= cap) & (slack >= 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible = candidates[feas]\n    d2 = dist_mat[int(current_node), feasible]\n    start2 = np.maximum(t0 + d2, time_windows[feasible, 0])\n    slack2 = time_windows[feasible, 1] - start2\n\n    k = 0.5 * (np.median(slack2) + 1e-12)\n\n    score = d2 * (1.0 + k / (slack2 + 1e-12))\n\n    # select top\u2011k smallest scores\n    top_k = 5\n    if score.size <= top_k:\n        chosen_idx = np.argmin(score)\n    else:\n        idxs = np.argpartition(score, top_k)[:top_k]\n        chosen_idx = np.random.choice(idxs)\n\n    return int(feasible[chosen_idx])\n\n",
  "softmin_distance_times_urgency_aug_201": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t0 = float(current_time.reshape(-1)[0])\n\n    d = dist_mat[int(current_node), candidates]\n    # approximate slack: end - (t0 + d)\n    slack = np.clip(time_windows[candidates, 1] - (t0 + d), 0, np.inf)\n    feas = (demands[candidates] <= cap) & (slack > 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible = candidates[feas]\n    d2 = dist_mat[int(current_node), feasible]\n    slack2 = np.clip(time_windows[feasible, 1] - (t0 + d2), 0, np.inf)\n\n    k = 0.5 * (np.mean(slack2) + 1e-12)\n\n    score = np.square(d2) * (1.0 + k / (slack2 + 1e-12))\n\n    # softmin selection\n    tau = 0.1\n    weights = np.exp(-score / (tau + 1e-12))\n    idx = np.argmax(weights)\n    return int(feasible[idx])\n\n",
  "capacity_and_depot_compactness_aug_202": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t0 = float(current_time.reshape(-1)[0])\n\n    dist_to_candidates = distance_matrix[int(current_node), candidates]\n    earliest_start = np.maximum(t0 + dist_to_candidates,\n                                time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap) & \\\n               (earliest_start <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_nodes = candidates[feasible]\n    remaining = cap - demands[feasible_nodes].astype(float)\n\n    eps = 1e-12\n    cap_term = 1.0 / (np.abs(remaining) + eps)          # higher when remaining is close to zero\n    depot_term = -distance_matrix[int(depot), feasible_nodes]\n    dist_term = -dist_to_candidates[feasible]\n\n    score = 0.6 * cap_term + 0.2 * depot_term + 0.2 * dist_term\n\n    # deterministic tie\u2011breaking with tiny noise\n    noise = np.arange(score.size) * 1e-9\n    return int(feasible_nodes[int(np.argmax(score + noise))])\n\n",
  "capacity_and_depot_compactness_aug_203": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t0 = float(current_time.reshape(-1)[0])\n\n    dist_to_candidates = distance_matrix[int(current_node), candidates]\n    earliest_start = np.maximum(t0 + dist_to_candidates,\n                                time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap) & \\\n               (earliest_start <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    idx = candidates[feasible]\n    remaining = cap - demands[idx].astype(float)\n\n    eps = 1e-12\n    # soft\u2011minimum: smaller remaining \u2192 larger probability\n    probs = np.exp(-remaining / (1.0 + eps))\n    probs /= np.clip(probs.sum(), 1e-12, None)\n\n    top_k = 5\n    if probs.size <= top_k:\n        top_idx = np.arange(probs.size)\n    else:\n        top_idx = np.argsort(probs)[-top_k:]\n\n    top_probs = probs[top_idx]\n    rng = np.random.default_rng(seed=int(t0 * 1e6) % 2**32)\n    chosen = rng.choice(top_idx, p=top_probs / np.clip(top_probs.sum(), 1e-12, None))\n\n    return int(idx[chosen])\n\n",
  "time_window_centerline_plus_savings_aug_204": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # renamed variables\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    # distances from current node\n    d = distance_matrix[current_node, cand]\n    # earliest feasible start times\n    start = np.maximum(t0 + d, time_windows[cand, 0])\n    # feasibility mask\n    feas = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    # filter candidates\n    f_cand = cand[feas]\n    f_d    = distance_matrix[current_node, f_cand]\n    f_start = np.maximum(t0 + f_d, time_windows[f_cand, 0])\n    mid = 0.5 * (time_windows[f_cand, 0] + time_windows[f_cand, 1])\n\n    # alignment and savings\n    align = -np.abs(f_start - mid)\n    # clip alignment to avoid extreme values\n    align = np.clip(align, -1e6, 1e6)\n    savings = distance_matrix[current_node, depot] + distance_matrix[depot, f_cand] - f_d\n\n    # scoring with tuned weights\n    score = 0.8 * align + 0.2 * savings\n    # deterministic noise to break ties\n    score += np.arange(score.size) * 1e-6\n\n    return int(f_cand[np.argmax(score)])\n\n",
  "time_window_centerline_plus_savings_aug_205": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # renamed variables\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[current_node, cand]\n    start = np.maximum(t0 + d, time_windows[cand, 0])\n    # clip start times to a reasonable range\n    start = np.clip(start, 0, 1e9)\n    feas = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    f_cand = cand[feas]\n    f_d    = distance_matrix[current_node, f_cand]\n    f_start = np.maximum(t0 + f_d, time_windows[f_cand, 0])\n    mid = 0.5 * (time_windows[f_cand, 0] + time_windows[f_cand, 1])\n\n    align = -np.abs(f_start - mid)\n    savings = distance_matrix[current_node, depot] + distance_matrix[depot, f_cand] - f_d\n\n    # scoring with different weights\n    score = 0.6 * align + 0.4 * savings\n\n    # select top_k candidates\n    top_k = min(5, score.size)\n    top_idx = np.argpartition(score, -top_k)[-top_k:]\n    rng = np.random.default_rng(42)\n    chosen = rng.choice(top_idx)\n    return int(f_cand[chosen])\n\n",
  "time_window_centerline_plus_savings_aug_206": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[current_node, cand]\n    start = np.maximum(t0 + d, time_windows[cand, 0])\n    start = np.clip(start, 0, 1e9)\n    feas = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    f_cand = cand[feas]\n    f_d    = distance_matrix[current_node, f_cand]\n    f_start = np.maximum(t0 + f_d, time_windows[f_cand, 0])\n    mid = 0.5 * (time_windows[f_cand, 0] + time_windows[f_cand, 1])\n\n    align = -np.abs(f_start - mid)\n    savings = distance_matrix[current_node, depot] + distance_matrix[depot, f_cand] - f_d\n\n    # equal weighting\n    score = 0.5 * align + 0.5 * savings\n    # soft\u2011min probabilities\n    exp_neg = np.exp(-score)\n    probs = exp_neg / (np.sum(exp_neg) + 1e-12)  # epsilon to avoid div0\n    rng = np.random.default_rng(1234)\n    chosen = rng.choice(f_cand, p=probs)\n    return int(chosen)\n\n",
  "time_window_centerline_plus_savings_aug_207": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # renamed variables\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    best_node = depot\n    best_start = np.inf\n\n    for idx in cand:\n        dist = distance_matrix[current_node, idx]\n        est_start = t0 + dist\n        est_start = max(est_start, time_windows[idx, 0])\n        est_start = min(est_start, 1e9)  # clip upper bound\n        if demands[idx] <= cap and est_start <= time_windows[idx, 1]:\n            if est_start < best_start:\n                best_start = est_start\n                best_node = int(idx)\n\n    return best_node\n\n",
  "min_distance_subject_to_slack_quantile_aug_208": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap   = float(rest_capacity.reshape(-1)[0])\n    t0    = float(current_time.reshape(-1)[0])\n\n    dist   = distance_matrix[current_node, candidates]\n    start  = np.maximum(t0 + dist, time_windows[candidates, 0])\n    slack  = time_windows[candidates, 1] - start\n    slack  = np.clip(slack, 0, None)                       # avoid negative slack\n    feas   = (demands[candidates] <= cap) & (slack >= 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    feas_cand = candidates[feas]\n    dist_feas = distance_matrix[current_node, feas_cand]\n    start_feas = np.maximum(t0 + dist_feas, time_windows[feas_cand, 0])\n    slack_feas = time_windows[feas_cand, 1] - start_feas\n    slack_feas = np.clip(slack_feas, 0, None)\n\n    thr = np.quantile(slack_feas, 0.30)\n    urgent_mask = slack_feas <= thr\n    urgent = feas_cand[urgent_mask]\n\n    if urgent.size > 0:\n        # add deterministic noise for tie\u2011breaking\n        noisy_dist = dist_feas[urgent_mask] + np.random.uniform(0, 1e-6, urgent.size)\n        return int(urgent[np.argmin(noisy_dist)])\n\n    # nearest feasible node\n    noisy_dist = dist_feas + np.random.uniform(0, 1e-6, dist_feas.size)\n    return int(feas_cand[np.argmin(noisy_dist)])\n\n",
  "min_distance_subject_to_slack_quantile_aug_209": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap   = float(rest_capacity.reshape(-1)[0])\n    t0    = float(current_time.reshape(-1)[0])\n\n    dist  = distance_matrix[current_node, candidates]\n    start = np.maximum(t0 + dist, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - start\n    slack = np.clip(slack, 0, None)                       # bound slack\n    feas  = (demands[candidates] <= cap) & (slack > 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    feas_cand = candidates[feas]\n    dist_feas = distance_matrix[current_node, feas_cand]\n    start_feas = np.maximum(t0 + dist_feas, time_windows[feas_cand, 0])\n    slack_feas = time_windows[feas_cand, 1] - start_feas\n    slack_feas = np.clip(slack_feas, 0, None)\n\n    # weighted score: 0.6*distance + 0.4*slack\n    score = 0.6 * dist_feas + 0.4 * slack_feas\n    return int(feas_cand[np.argmin(score)])\n\n",
  "min_distance_subject_to_slack_quantile_aug_210": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap   = float(rest_capacity.reshape(-1)[0])\n    t0    = float(current_time.reshape(-1)[0])\n\n    dist  = distance_matrix[current_node, candidates]\n    start = np.maximum(t0 + dist, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - start\n    feas  = (demands[candidates] <= cap) & (slack >= 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    feas_cand = candidates[feas]\n    dist_feas = distance_matrix[current_node, feas_cand]\n    start_feas = np.maximum(t0 + dist_feas, time_windows[feas_cand, 0])\n    slack_feas = time_windows[feas_cand, 1] - start_feas\n\n    thr = np.quantile(slack_feas, 0.30)\n    urgent_indices = np.where(slack_feas <= thr)[0]\n    if urgent_indices.size > 0:\n        k = min(7, urgent_indices.size)\n        sorted_idx = np.argsort(slack_feas[urgent_indices])[:k]\n        chosen = feas_cand[urgent_indices[sorted_idx]]\n        return int(np.random.choice(chosen))\n\n    # nearest feasible node\n    return int(feas_cand[np.argmin(dist_feas)])\n\n",
  "min_distance_subject_to_slack_quantile_aug_211": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap   = float(rest_capacity.reshape(-1)[0])\n    t0    = float(current_time.reshape(-1)[0])\n\n    dist  = distance_matrix[current_node, candidates]\n    start = np.maximum(t0 + dist, time_windows[candidates, 0])\n    slack = time_windows[candidates, 1] - start\n    slack = np.clip(slack, 0, None)                       # bound slack\n    feas  = (demands[candidates] <= cap) & (slack > 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    feas_cand = candidates[feas]\n    dist_feas = distance_matrix[current_node, feas_cand]\n    start_feas = np.maximum(t0 + dist_feas, time_windows[feas_cand, 0])\n    slack_feas = time_windows[feas_cand, 1] - start_feas\n    slack_feas = np.clip(slack_feas, 0, None)\n\n    thr = np.median(slack_feas)\n    urgent_mask = slack_feas <= thr\n    if np.any(urgent_mask):\n        urgent_cand = feas_cand[urgent_mask]\n        urgent_dist = dist_feas[urgent_mask]\n        return int(urgent_cand[np.argmin(urgent_dist)])\n\n    # nearest feasible node\n    return int(feas_cand[np.argmin(dist_feas)])\n\n",
  "maximize_service_start_soon_aug_212": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for readability\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    # distance from current node to each candidate\n    dists = distance_matrix[current_node, candidates]\n    # earliest possible arrival respecting time windows\n    earliest = np.maximum(t0 + dists, time_windows[candidates, 0])\n\n    # feasibility checks\n    feasible = (demands[candidates] <= cap) & (earliest <= time_windows[candidates, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    feas_dists = distance_matrix[current_node, feas_idx]\n    feas_earliest = np.maximum(t0 + feas_dists, time_windows[feas_idx, 0])\n\n    # deterministic noise to break ties\n    noise = 1e-8 * np.arange(feas_earliest.size)\n    feas_earliest_noisy = feas_earliest + noise\n\n    return int(feas_idx[np.argmin(feas_earliest_noisy)])\n\n",
  "maximize_service_start_soon_aug_213": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[current_node, candidates]\n    wait = np.maximum(t0 + dists, time_windows[candidates, 0]) - t0\n    # weighted score: distance (0.6) + waiting time (0.4)\n    score = 0.6 * dists + 0.4 * wait\n\n    feasible = (demands[candidates] <= cap) & (np.maximum(t0 + dists, time_windows[candidates, 0]) <= time_windows[candidates, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    feas_score = score[feasible]\n\n    # keep only top_k smallest scores\n    top_k = min(7, feas_score.size)\n    top_indices = np.argpartition(feas_score, top_k - 1)[:top_k]\n    top_scores = feas_score[top_indices]\n    top_candidates = feas_idx[top_indices]\n\n    # soft\u2011min probabilities\n    temp = 1.0\n    exp_vals = np.exp(-top_scores / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0.0, 1.0)\n\n    chosen = np.random.choice(top_candidates, p=probs)\n    return int(chosen)\n\n",
  "maximize_service_start_soon_aug_214": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[current_node, candidates]\n    # feasibility only by capacity and time windows (arrival time <= upper bound)\n    feas = (demands[candidates] <= cap) & (t0 + dists <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_idx = candidates[feas]\n    feas_dists = dists[feas]\n\n    # pick top_k shortest distances\n    top_k = min(5, feas_dists.size)\n    top_indices = np.argpartition(feas_dists, top_k - 1)[:top_k]\n    top_candidates = feas_idx[top_indices]\n\n    # random choice among the top_k\n    chosen = np.random.choice(top_candidates)\n    return int(chosen)\n\n",
  "max_slack_time_aug_215": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename variables for clarity\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), cand]\n    earliest_start = np.maximum(t + dist, time_windows[cand, 0])\n    slack = time_windows[cand, 1] - earliest_start\n    # clip to avoid negative values in subsequent computations\n    slack = np.clip(slack, 0, 1e9)\n\n    feasible = (demands[cand] <= cap) & (slack >= 0)\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_cand = cand[feasible]\n    feasible_dist = dist[feasible]\n    earliest_start_f = np.maximum(t + feasible_dist, time_windows[feasible_cand, 0])\n    slack_f = time_windows[feasible_cand, 1] - earliest_start_f\n    slack_f = np.clip(slack_f, 0, 1e9)\n\n    idx = int(np.argmax(slack_f))\n    return int(feasible_cand[idx])\n\n",
  "max_slack_time_aug_216": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), cand]\n    earliest_start = np.maximum(t + dist, time_windows[cand, 0])\n    slack = time_windows[cand, 1] - earliest_start\n\n    feasible = (demands[cand] <= cap) & (slack >= 0)\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_cand = cand[feasible]\n    feasible_dist = dist[feasible]\n    earliest_start_f = np.maximum(t + feasible_dist, time_windows[feasible_cand, 0])\n    slack_f = time_windows[feasible_cand, 1] - earliest_start_f\n\n    # deterministic noise based on node ids to break ties\n    noise = 1e-6 * (feasible_cand + current_node)\n    slack_noisy = slack_f + noise\n\n    idx = int(np.argmin(slack_noisy))\n    return int(feasible_cand[idx])\n\n",
  "max_slack_time_aug_217": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), cand]\n    earliest_start = np.maximum(t + dist, time_windows[cand, 0])\n    slack = time_windows[cand, 1] - earliest_start\n\n    feasible = (demands[cand] <= cap) & (slack >= 0)\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_cand = cand[feasible]\n    feasible_dist = dist[feasible]\n    earliest_start_f = np.maximum(t + feasible_dist, time_windows[feasible_cand, 0])\n    slack_f = time_windows[feasible_cand, 1] - earliest_start_f\n\n    median_slack = np.clip(np.median(slack_f), 0, 1e9)\n    diff = np.abs(slack_f - median_slack)\n    # add deterministic noise to break ties\n    diff += 1e-6 * feasible_cand\n    idx = int(np.argmin(diff))\n    return int(feasible_cand[idx])\n\n",
  "max_slack_time_aug_218": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), cand]\n    earliest_start = np.maximum(t + dist, time_windows[cand, 0])\n    slack = time_windows[cand, 1] - earliest_start\n\n    feasible = (demands[cand] <= cap) & (slack >= 0)\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_cand = cand[feasible]\n    feasible_dist = dist[feasible]\n    earliest_start_f = np.maximum(t + feasible_dist, time_windows[feasible_cand, 0])\n    slack_f = time_windows[feasible_cand, 1] - earliest_start_f\n\n    epsilon = 1e-12\n    score = slack_f / (feasible_dist + epsilon)\n    score = np.clip(score, 0, 1e6)\n    # deterministic noise\n    noise = 1e-6 * feasible_cand\n    score_noisy = score + noise\n\n    idx = int(np.argmax(score_noisy))\n    return int(feasible_cand[idx])\n\n",
  "min_demand_that_fits_aug_219": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distances from current node to all candidates\n    dist = distance_matrix[int(current_node), candidates]\n    # Earliest start time respecting time windows\n    est = np.maximum(t + dist, time_windows[candidates, 0])\n    # Feasibility mask\n    feas = (demands[candidates] <= cap) & (est <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    feasible_dist = dist[feas]\n    feasible_dem = demands[feas]\n\n    # Weighted score: 0.7 * distance + 0.3 * demand\n    score = 0.7 * feasible_dist + 0.3 * feasible_dem\n    # Add tiny deterministic noise for stable tie\u2011breaking\n    noise = 1e-6 * np.arange(feasible_idx.size)\n    score += noise\n\n    # Choose node with minimal score\n    chosen = feasible_idx[np.argmin(score)]\n    return int(chosen)\n\n",
  "min_demand_that_fits_aug_220": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), candidates]\n    est = np.maximum(t + dist, time_windows[candidates, 0])\n    feas = (demands[candidates] <= cap) & (est <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    # Reduce to feasible set\n    feasible_idx = candidates[feas]\n    feasible_dist = dist[feas]\n    feasible_dem = demands[feas]\n\n    # Soft\u2011min score (lower is better)\n    alpha = 1.0\n    raw = -alpha * (feasible_dist + feasible_dem)\n    exp_raw = np.exp(raw - np.max(raw))  # stability\n    denom = np.sum(exp_raw) + 1e-12  # epsilon\n    probs = exp_raw / denom\n    probs = np.clip(probs, 0.0, 1.0)\n\n    # Randomly select based on probabilities\n    chosen = np.random.choice(feasible_idx, p=probs)\n    return int(chosen)\n\n",
  "min_demand_that_fits_aug_221": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), candidates]\n    est = np.maximum(t + dist, time_windows[candidates, 0])\n    feas = (demands[candidates] <= cap) & (est <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    feasible_dist = dist[feas]\n    feasible_dem = demands[feas]\n\n    # Median of (distance + demand) for each candidate\n    combined = feasible_dist + feasible_dem\n    median_vals = np.median(combined)\n\n    # Since combined is scalar, median is just the value; we keep it for consistency\n    # Add small noise to break ties deterministically\n    noise = 1e-6 * np.arange(feasible_idx.size)\n    score = combined + noise\n\n    # Get indices of top\u20113 lowest scores\n    top_k = 3\n    if score.size > top_k:\n        top_idx = np.argpartition(score, top_k)[:top_k]\n        chosen_idx = np.random.choice(top_idx)\n    else:\n        chosen_idx = np.argmin(score)\n\n    chosen = feasible_idx[chosen_idx]\n    return int(chosen)\n\n",
  "min_demand_that_fits_aug_222": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), candidates]\n    est = np.maximum(t + dist, time_windows[candidates, 0])\n    feas = (demands[candidates] <= cap) & (est <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    feasible_dist = dist[feas]\n    feasible_dem = demands[feas]\n    feasible_cap = cap - feasible_dem\n\n    # Proxy cost: distance scaled by 1/(1+demands) + slack ratio\n    slack = time_windows[candidates, 1] - est\n    window_len = time_windows[candidates, 1] - time_windows[candidates, 0] + 1e-12\n    cost = feasible_dist / (1.0 + feasible_dem) + slack / window_len\n\n    # Top\u2011k selection\n    top_k = 5\n    if cost.size > top_k:\n        top_idx = np.argpartition(cost, top_k)[:top_k]\n        sub_cost = cost[top_idx]\n        # Choose minimal cost; if tie, pick one with maximal remaining capacity\n        min_cost = np.min(sub_cost)\n        tie_idx = top_idx[np.where(sub_cost == min_cost)[0]]\n        if tie_idx.size > 1:\n            chosen = feasible_idx[np.argmax(feasible_cap[tie_idx])]\n        else:\n            chosen = feasible_idx[tie_idx[0]]\n    else:\n        chosen = feasible_idx[np.argmin(cost)]\n\n    return int(chosen)\n\n",
  "min_detour_plus_wait_aug_223": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_from_curr = distance_matrix[int(current_node), candidates]\n    arrival = t + d_from_curr\n    earliest_start = np.maximum(arrival, time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap) & (earliest_start <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_nodes = candidates[feasible]\n    d_to_nodes = distance_matrix[int(current_node), feas_nodes]\n    arrival_f  = t + d_to_nodes\n    wait = np.maximum(0.0, time_windows[feas_nodes, 0] - arrival_f)\n\n    # Detour: distance from node to depot minus distance from current to depot\n    detour = d_to_nodes + distance_matrix[feas_nodes, int(depot)] - distance_matrix[int(current_node), int(depot)]\n    detour = np.clip(detour, 0.0, None)          # prevent negative detours\n\n    # Scoring with weighted sum and deterministic tie\u2011breaking noise\n    score = 0.7 * detour + 0.3 * wait\n    noise = np.arange(score.size) * 1e-6        # deterministic noise\n    score += noise\n\n    return int(feas_nodes[np.argmin(score)])\n\n",
  "min_detour_plus_wait_aug_224": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    feas = []\n    det = []\n    wait = []\n\n    for node in candidates:\n        dist = distance_matrix[int(current_node), node]\n        arr  = t + dist\n        start = max(arr, time_windows[node, 0])\n        if demands[node] <= cap and start <= time_windows[node, 1]:\n            w = max(0.0, time_windows[node, 0] - arr)\n            d = dist + distance_matrix[node, int(depot)] - distance_matrix[int(current_node), int(depot)]\n            feas.append(node)\n            det.append(d)\n            wait.append(w)\n\n    if not feas:\n        return int(depot)\n\n    det = np.array(det)\n    wait = np.array(wait)\n\n    # Weighted scoring and deterministic noise\n    score = 0.6 * det + 0.4 * wait\n    noise = np.arange(score.size) * 1e-6\n    score += noise\n\n    # Softmin with temperature and top\u2011k filtering\n    temp = 5.0\n    exp_vals = np.exp(-score / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    top_k = 5\n    top_idx = np.argsort(probs)[-top_k:]\n    chosen = feas[int(np.argmax(probs[top_idx]))]   # pick the highest probability among top\u2011k\n    return int(chosen)\n\n",
  "min_detour_plus_wait_aug_225": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    idx = 0\n    feas = []\n    det = []\n    wait = []\n\n    while idx < candidates.size:\n        node = candidates[idx]\n        dist = distance_matrix[int(current_node), node]\n        arr  = t + dist\n        start = max(arr, time_windows[node, 0])\n        if demands[node] <= cap and start <= time_windows[node, 1]:\n            w = max(0.0, time_windows[node, 0] - arr)\n            d = dist + distance_matrix[node, int(depot)] - distance_matrix[int(current_node), int(depot)]\n            feas.append(node)\n            det.append(d)\n            wait.append(w)\n        idx += 1\n\n    if not feas:\n        return int(depot)\n\n    det = np.clip(np.array(det), 0.0, None)\n    wait = np.array(wait)\n\n    # Median adjustment in the score\n    median_det = np.median(det + 1e-12)\n    score = (det - median_det) * 0.6 + wait * 0.4\n\n    # Deterministic negative noise for tie\u2011breaking\n    noise = -np.arange(score.size) * 1e-6\n    score += noise\n\n    # Softmax with temperature\n    temp = 3.0\n    exp_vals = np.exp(-score / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # Top\u2011k selection\n    top_k = 7\n    top_idx = np.argsort(probs)[-top_k:]\n    chosen = feas[int(np.argmax(probs[top_idx]))]\n    return int(chosen)\n\n",
  "min_detour_plus_wait_aug_226": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    feas_list = [(node,\n                  distance_matrix[int(current_node), node],\n                  t + distance_matrix[int(current_node), node],\n                  max(t + distance_matrix[int(current_node), node], time_windows[node, 0]),\n                  time_windows[node, 1],\n                  demands[node]) for node in candidates]\n\n    feas = []\n    det = []\n    wait = []\n\n    for node, dist, arrival, start, tw_end, dem in feas_list:\n        if dem <= cap and start <= tw_end:\n            w = max(0.0, time_windows[node, 0] - arrival)\n            d = dist + distance_matrix[node, int(depot)] - distance_matrix[int(current_node), int(depot)]\n            feas.append(node)\n            det.append(d)\n            wait.append(w)\n\n    if not feas:\n        return int(depot)\n\n    det = np.clip(np.array(det), 0.0, None)\n    wait = np.array(wait)\n\n    # Use np.max in the scoring to bias against the largest wait\n    max_wait = np.max(wait + 1e-12)\n    score = det + 2.0 * wait - 0.1 * max_wait\n\n    # Deterministic negative noise for tie\u2011breaking\n    noise = -np.arange(score.size) * 1e-6\n    score += noise\n\n    chosen = feas[int(np.argmin(score))]\n    return int(chosen)\n\n",
  "closest_unvisited_neighbor_aug_227": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr_node = int(current_node)\n    depot_idx = int(depot)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return depot_idx\n\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Clip capacity to non\u2011negative\n    remaining_cap = np.clip(remaining_cap, 0, np.inf)\n\n    # Distances from current node to all candidates\n    dist_from_curr = distance_matrix[curr_node, candidates]\n    # Earliest feasible start times respecting time windows\n    earliest_start = np.maximum(curr_t + dist_from_curr, time_windows[candidates, 0])\n    # Feasibility mask\n    feas = (demands[candidates] <= remaining_cap) & (earliest_start <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return depot_idx\n\n    feas_idx = candidates[feas]\n    if feas_idx.size == 1:\n        return int(feas_idx[0])\n\n    # Pairwise distances among feasible nodes\n    pair_dist = distance_matrix[feas_idx[:, None], feas_idx[None, :]]\n    # Sum of distances to all other feasible nodes for each candidate\n    sum_dist = np.sum(pair_dist, axis=1)\n    # Add tiny random noise for deterministic tie\u2011breaking\n    noise = np.random.uniform(-1e-8, 1e-8, size=sum_dist.shape)\n    scores = sum_dist + noise\n    best_node = feas_idx[np.argmin(scores)]\n    return int(best_node)\n\n",
  "closest_unvisited_neighbor_aug_228": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr_node = int(current_node)\n    depot_idx = int(depot)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return depot_idx\n\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Clip capacity to avoid negative values\n    remaining_cap = np.clip(remaining_cap, 0, np.inf)\n\n    # Distances from current node\n    dist_from_curr = distance_matrix[curr_node, candidates]\n    earliest_start = np.maximum(curr_t + dist_from_curr, time_windows[candidates, 0])\n    feas = (demands[candidates] <= remaining_cap) & (earliest_start <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return depot_idx\n\n    feas_idx = candidates[feas]\n    if feas_idx.size == 1:\n        return int(feas_idx[0])\n\n    # Compute minimal distance to any other feasible node for each candidate\n    pair_dist = distance_matrix[feas_idx[:, None], feas_idx[None, :]]\n    eps = 1e-12\n    min_dist = np.min(pair_dist + np.eye(pair_dist.shape[0])*eps, axis=1)\n    # Softmin score: higher score for smaller distance\n    soft_scores = np.exp(-min_dist / (min_dist + eps))\n    # Identify top_k candidates\n    top_k = min(5, feas_idx.size)\n    top_indices = np.argpartition(-soft_scores, top_k - 1)[:top_k]\n    # Randomly pick among top_k\n    chosen = feas_idx[np.random.choice(top_indices)]\n    return int(chosen)\n\n",
  "closest_unvisited_neighbor_aug_229": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr_node = int(current_node)\n    depot_idx = int(depot)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return depot_idx\n\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Clip capacity\n    remaining_cap = np.clip(remaining_cap, 0, np.inf)\n\n    dist_from_curr = distance_matrix[curr_node, candidates]\n    earliest_start = np.maximum(curr_t + dist_from_curr, time_windows[candidates, 0])\n    feas = (demands[candidates] <= remaining_cap) & (earliest_start <= time_windows[candidates, 1])\n\n    # Invert: proceed only if there are feasible nodes\n    if np.any(feas):\n        feas_idx = candidates[feas]\n        if feas_idx.size == 1:\n            return int(feas_idx[0])\n\n        # Compute median distance to other feasible nodes for each candidate\n        pair_dist = distance_matrix[feas_idx[:, None], feas_idx[None, :]]\n        med_dist = np.median(pair_dist, axis=1)\n        # Add deterministic noise proportional to node id to break ties\n        noise = feas_idx * 1e-7\n        scores = med_dist + noise\n        best_node = feas_idx[np.argmin(scores)]\n        return int(best_node)\n    else:\n        # No feasible node found\n        return depot_idx\n\n",
  "closest_unvisited_neighbor_aug_230": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr_node = int(current_node)\n    depot_idx = int(depot)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return depot_idx\n\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Clip capacity to safe range\n    remaining_cap = np.clip(remaining_cap, 0, np.inf)\n\n    # Distances from current node\n    dist_from_curr = distance_matrix[curr_node, candidates]\n    # Clip earliest start to valid time window bounds\n    earliest_start = np.maximum(curr_t + dist_from_curr, time_windows[candidates, 0])\n    earliest_start = np.minimum(earliest_start, time_windows[candidates, 1])\n\n    feas = (demands[candidates] <= remaining_cap) & (earliest_start <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return depot_idx\n\n    feas_idx = candidates[feas]\n    if feas_idx.size == 1:\n        return int(feas_idx[0])\n\n    # Use while loop to iterate until a node is chosen\n    best_node = None\n    best_score = np.inf\n    idx = 0\n    while idx < feas_idx.size:\n        node = feas_idx[idx]\n        others = feas_idx[feas_idx != node]\n        if others.size == 0:\n            best_node = node\n            break\n        # Median distance to others\n        med = np.median(distance_matrix[node, others])\n        # Deterministic noise based on node id\n        noise = node * 1e-6\n        score = med + noise\n        if score < best_score:\n            best_score = score\n            best_node = node\n        idx += 1\n    return int(best_node)\n\n",
  "max_future_feasible_count_aug_231": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    cur_t = float(current_time.reshape(-1)[0])\n\n    # Distances from current node to candidates\n    dist_cur = distance_matrix[int(current_node), candidates]\n    start_times = np.maximum(cur_t + dist_cur, time_windows[candidates, 0])\n    # Clip to avoid invalid values\n    start_times = np.clip(start_times, None, time_windows[candidates, 1] + 1e-12)\n\n    feasible = (demands[candidates] <= cap) & (start_times <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cands = candidates[feasible]\n    if feas_cands.size == 1:\n        return int(feas_cands[0])\n\n    # Compute counts of feasible nodes after visiting each candidate\n    counts = []\n    for cand in feas_cands:\n        new_cap = cap - float(demands[cand])\n        new_t = float(np.maximum(cur_t + distance_matrix[int(current_node), int(cand)],\n                                 time_windows[int(cand), 0]))\n        new_t = np.clip(new_t, None, time_windows[int(cand), 1] + 1e-12)\n\n        rem = candidates[candidates != cand]\n        if rem.size == 0:\n            counts.append(np.iinfo(np.int32).max)\n            continue\n\n        dist_rem = distance_matrix[int(cand), rem]\n        start_rem = np.maximum(new_t + dist_rem, time_windows[rem, 0])\n        start_rem = np.clip(start_rem, None, time_windows[rem, 1] + 1e-12)\n\n        feas_rem = (demands[rem] <= new_cap) & (start_rem <= time_windows[rem, 1])\n        counts.append(int(np.sum(feas_rem)))\n\n    counts = np.array(counts)\n    # Add deterministic noise to break ties\n    noise = 1e-6 * feas_cands\n    adjusted_counts = counts + noise\n\n    best_idx = int(np.argmax(adjusted_counts))\n    best_candidate = int(feas_cands[best_idx])\n\n    # If multiple candidates share the same max count, choose the nearest\n    max_count = counts[best_idx]\n    tied = feas_cands[counts == max_count]\n    if tied.size > 1:\n        dist_tied = distance_matrix[int(current_node), tied]\n        best_candidate = int(tied[np.argmin(dist_tied)])\n\n    return best_candidate\n\n",
  "max_future_feasible_count_aug_232": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    cur_t = float(current_time.reshape(-1)[0])\n\n    dist_cur = distance_matrix[int(current_node), candidates]\n    start_times = np.maximum(cur_t + dist_cur, time_windows[candidates, 0])\n    start_times = np.clip(start_times, None, time_windows[candidates, 1] + 1e-12)\n\n    feasible = (demands[candidates] <= cap) & (start_times <= time_windows[candidates, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cands = candidates[feasible]\n    # Scoring: remaining capacity divided by distance (with epsilon)\n    scores = (cap - demands[feas_cands]) / (dist_cur[feasible] + 1e-12)\n\n    # Top\u2011k selection\n    top_k = min(7, feas_cands.size)\n    idx_top = np.argpartition(-scores, top_k - 1)[:top_k]\n    top_cands = feas_cands[idx_top]\n    top_scores = scores[idx_top]\n\n    # Tie\u2011breaking using median distance\n    max_score = np.max(top_scores)\n    tied = top_cands[top_scores == max_score]\n    if tied.size > 1:\n        dists = distance_matrix[int(current_node), tied]\n        median_dist = np.median(dists)\n        diff = np.abs(dists - median_dist)\n        return int(tied[np.argmin(diff)])\n\n    # Deterministic noise for remaining ties\n    noise = 1e-6 * top_cands\n    adjusted_scores = top_scores + noise\n    best_idx = np.argmax(adjusted_scores)\n    return int(top_cands[best_idx])\n\n",
  "max_future_feasible_count_aug_233": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    cur_t = float(current_time.reshape(-1)[0])\n\n    dist_cur = distance_matrix[int(current_node), candidates]\n    start_times = np.maximum(cur_t + dist_cur, time_windows[candidates, 0])\n    start_times = np.clip(start_times, None, time_windows[candidates, 1] + 1e-12)\n\n    feasible = (demands[candidates] <= cap) & (start_times <= time_windows[candidates, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cands = candidates[feasible]\n    feas_dists = dist_cur[feasible]\n\n    # Soft\u2011min probability distribution\n    alpha = 1.0\n    exp_vals = np.exp(-alpha * feas_dists)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # Choose top\u2011k candidates with highest probability\n    top_k = min(5, feas_cands.size)\n    idx_top = np.argsort(-probs)[:top_k]\n    top_cands = feas_cands[idx_top]\n\n    # Deterministic RNG to pick among top\u2011k\n    rng = np.random.default_rng(12345)\n    chosen = rng.choice(top_cands)\n\n    return int(chosen)\n\n",
  "max_future_feasible_count_aug_234": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    cur_t = float(current_time.reshape(-1)[0])\n\n    dist_cur = distance_matrix[int(current_node), candidates]\n    start_times = np.maximum(cur_t + dist_cur, time_windows[candidates, 0])\n    start_times = np.clip(start_times, None, time_windows[candidates, 1] + 1e-12)\n\n    feasible = (demands[candidates] <= cap) & (start_times <= time_windows[candidates, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cands = candidates[feasible]\n\n    # Count feasible nodes after visiting each candidate\n    counts = []\n    for cand in feas_cands:\n        new_cap = cap - float(demands[cand])\n        new_t = float(np.maximum(cur_t + distance_matrix[int(current_node), int(cand)],\n                                 time_windows[int(cand), 0]))\n        new_t = np.clip(new_t, None, time_windows[int(cand), 1] + 1e-12)\n\n        rem = candidates[candidates != cand]\n        if rem.size == 0:\n            counts.append(np.iinfo(np.int32).max)\n            continue\n\n        dist_rem = distance_matrix[int(cand), rem]\n        start_rem = np.maximum(new_t + dist_rem, time_windows[rem, 0])\n        start_rem = np.clip(start_rem, None, time_windows[rem, 1] + 1e-12)\n\n        feas_rem = (demands[rem] <= new_cap) & (start_rem <= time_windows[rem, 1])\n        counts.append(int(np.sum(feas_rem)))\n\n    counts = np.array(counts)\n    max_count = np.max(counts)\n    tied = feas_cands[counts == max_count]\n\n    if tied.size > 1:\n        # Choose the farthest distance with deterministic noise\n        dists = distance_matrix[int(current_node), tied] + 1e-6 * tied\n        best_candidate = tied[np.argmax(dists)]\n    else:\n        best_candidate = int(tied[0])\n\n    return int(best_candidate)\n\n",
  "due_time_proximity_aug_235": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    dem_arr  = demands\n    tw_arr   = time_windows\n\n    # distances from current node to all candidates\n    dists = dist_mat[current_node, candidates]\n    # earliest feasible start times\n    earliest = np.maximum(t + dists, tw_arr[candidates, 0])\n    # feasibility checks\n    feasible = (dem_arr[candidates] <= cap) & (earliest <= tw_arr[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    due_times = tw_arr[feas_idx, 1]\n    dist_feas = dist_mat[current_node, feas_idx]\n\n    # scoring: absolute difference in due\u2011time plus tiny distance weight\n    due_diff = np.abs(due_times - t)\n    due_diff = np.clip(due_diff, 0, None)           # avoid negative values\n    score = due_diff + 1e-6 * dist_feas\n\n    # deterministic tie\u2011breaking with incremental noise\n    noise = np.arange(len(score)) * 1e-8\n    chosen = feas_idx[np.argmin(score + noise)]\n\n    return int(chosen)\n\n",
  "due_time_proximity_aug_236": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    dem = demands\n    tw  = time_windows\n\n    d = dist_mat[current_node, cand]\n    earliest = np.maximum(t + d, tw[cand, 0])\n    feas = (dem[cand] <= cap) & (earliest <= tw[cand, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    feas_cand = cand[feas]\n    due = tw[feas_cand, 1]\n    dist_feas = dist_mat[current_node, feas_cand]\n\n    # tuned weights: 70% due\u2011time, 30% distance\n    due_diff = np.abs(due - t)\n    score = 0.7 * due_diff + 0.3 * np.clip(dist_feas, 0, 1e6)  # clip to avoid extreme distances\n\n    # softmin probabilities\n    temp = 0.5  # temperature hyperparameter\n    exp_vals = np.exp(-score / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # random choice weighted by softmin probabilities\n    chosen_idx = np.random.choice(feas_cand, p=probs)\n    return int(chosen_idx)\n\n",
  "due_time_proximity_aug_237": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    dem = demands\n    tw  = time_windows\n\n    d = dist_mat[current_node, nodes]\n    earliest = np.maximum(t + d, tw[nodes, 0])\n    feas = (dem[nodes] <= cap) & (earliest <= tw[nodes, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    feas_nodes = nodes[feas]\n    due = tw[feas_nodes, 1]\n    dist_feas = dist_mat[current_node, feas_nodes]\n\n    # use median of due differences to reduce outlier influence\n    due_diff = np.abs(due - t)\n    median_due = np.median(due_diff)\n    # normalize distances relative to the median due\u2011time\n    norm_dist = np.clip(dist_feas / (median_due + 1e-12), 0, 10)\n\n    # combined score: higher weight on distance\n    score = 0.4 * due_diff + 0.6 * norm_dist\n\n    # pick top\u2011k candidates\n    top_k = 5\n    if score.size > top_k:\n        top_idx = np.argpartition(score, top_k)[:top_k]\n    else:\n        top_idx = np.arange(score.size)\n\n    top_nodes  = feas_nodes[top_idx]\n    top_scores = score[top_idx]\n\n    # deterministic weighted choice: lower score \u2192 higher probability\n    inv_scores = 1.0 / (top_scores + 1e-12)\n    probs = inv_scores / (np.sum(inv_scores) + 1e-12)\n\n    # deterministic tie\u2011breaking with incremental noise\n    noise = np.arange(probs.size) * 1e-8\n    chosen = top_nodes[np.argmax(probs + noise)]\n    return int(chosen)\n\n",
  "travel_over_slack_ratio_aug_238": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Variable renaming for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_time = float(np.asarray(current_time).reshape(-1)[0])\n    node_demands = np.asarray(demands)\n    dist_mat = np.asarray(distance_matrix)\n    tws = np.asarray(time_windows)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    # Build a list of feasible candidates using a while loop\n    feas_list = []\n    idx = 0\n    while idx < candidates.size:\n        cand = candidates[idx]\n        d = dist_mat[int(current_node), cand]\n        arrival = curr_time + d\n        start_service = np.maximum(arrival, tws[cand, 0])\n        slack = tws[cand, 1] - start_service\n        if (node_demands[cand] <= remaining_cap) and (slack >= 0):\n            feas_list.append(cand)\n        idx += 1\n\n    if not feas_list:\n        return int(depot)\n\n    feas_arr = np.array(feas_list, dtype=int)\n    d2 = dist_mat[int(current_node), feas_arr]\n    start2 = np.maximum(curr_time + d2, tws[feas_arr, 0])\n    slack2 = tws[feas_arr, 1] - start2\n    slack2 = np.clip(slack2, 1e-12, None)          # prevent division by zero\n    score = d2 / (slack2 + 1e-12)                  # epsilon in denominator\n    return int(feas_arr[int(np.argmin(score))])\n\n",
  "travel_over_slack_ratio_aug_239": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    eps = 1e-12\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n    dist = np.asarray(distance_matrix)\n    tw = np.asarray(time_windows)\n    dem = np.asarray(demands)\n\n    # Feasibility mask\n    d_to_c = dist[int(current_node), cand]\n    est_arr = t + d_to_c\n    start = np.maximum(est_arr, tw[cand, 0])\n    slack = tw[cand, 1] - start\n    feas_mask = (dem[cand] <= cap) & (slack >= 0)\n    feas_idx = cand[feas_mask]\n    if feas_idx.size == 0:\n        return int(depot)\n\n    d_feas = dist[int(current_node), feas_idx]\n    slack_feas = tw[feas_idx, 1] - np.maximum(t + d_feas, tw[feas_idx, 0])\n    slack_feas = np.clip(slack_feas, eps, None)\n\n    # Weighted score: 60% distance, 40% slack\n    score = 0.6 * d_feas + 0.4 * (slack_feas + eps)\n    # Deterministic noise for tie\u2011breaking\n    noise = eps * np.arange(score.size)\n    score_noisy = score + noise\n\n    # Top\u2011k selection (k=5)\n    top_k = 5\n    if score_noisy.size <= top_k:\n        chosen = feas_idx[np.argmin(score_noisy)]\n    else:\n        idx_top = np.argpartition(score_noisy, top_k)[:top_k]\n        chosen = feas_idx[idx_top[np.argmin(score_noisy[idx_top])]]\n    return int(chosen)\n\n",
  "travel_over_slack_ratio_aug_240": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    eps = 1e-12\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n    dist_mat = np.asarray(distance_matrix)\n    tw = np.asarray(time_windows)\n    dem = np.asarray(demands)\n\n    d = dist_mat[int(current_node), cand]\n    est_arr = t + d\n    start = np.maximum(est_arr, tw[cand, 0])\n    slack = tw[cand, 1] - start\n    feas = (dem[cand] <= cap) & (slack >= 0)\n    feas_cand = cand[feas]\n    if feas_cand.size == 0:\n        return int(depot)\n\n    d_feas = dist_mat[int(current_node), feas_cand]\n    slack_feas = tw[feas_cand, 1] - np.maximum(t + d_feas, tw[feas_cand, 0])\n    slack_feas = np.clip(slack_feas, eps, None)\n\n    # Soft\u2011min score and exponential weighting\n    alpha = 10.0\n    score = d_feas / (slack_feas + eps)\n    soft_weights = np.exp(-alpha * score)\n    soft_weights /= soft_weights.sum()\n\n    # Random choice weighted by soft\u2011min probabilities\n    chosen = np.random.choice(feas_cand, p=soft_weights)\n    return int(chosen)\n\n",
  "mean_distance_to_unvisited_max_aug_241": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Clip distances to avoid zero values\n    dist_cur = np.clip(distance_matrix[current_node, candidates], 1e-12, np.inf)\n\n    start = np.maximum(t + dist_cur, time_windows[candidates, 0])\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_cands = candidates[feas]\n    if feasible_cands.size == 1:\n        return int(feasible_cands[0])\n\n    # Median distance to the remaining customers\n    median_to_others = np.median(\n        np.clip(distance_matrix[feasible_cands][:, candidates], 1e-12, np.inf),\n        axis=1\n    )\n    # Small deterministic noise for stable tie\u2011breaking\n    noise = np.arange(feasible_cands.size, dtype=float) * 1e-6\n    score = median_to_others - 0.25 * distance_matrix[current_node, feasible_cands] + noise\n    return int(feasible_cands[int(np.argmax(score))])\n\n",
  "mean_distance_to_unvisited_max_aug_242": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity)\n    t = float(current_time)\n\n    dist_cur = np.clip(distance_matrix[current_node, candidates], 1e-12, np.inf)\n    start = np.maximum(t + dist_cur, time_windows[candidates, 0])\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    feas_cands = candidates[feas]\n    if feas_cands.size == 1:\n        return int(feas_cands[0])\n\n    # Max distance to the remaining customers\n    dist_to_others = np.clip(\n        distance_matrix[feas_cands][:, candidates], 1e-12, np.inf\n    )\n    agg = np.max(dist_to_others, axis=1)\n\n    # Scoring: 100% to max distance + 40% to distance from current node\n    score = agg + 0.4 * distance_matrix[current_node, feas_cands]\n\n    top_k = min(7, feas_cands.size)\n    top_indices = np.argpartition(-score, top_k - 1)[:top_k]\n\n    rng = np.random.default_rng(42)          # deterministic seed\n    chosen_idx = rng.choice(top_indices)\n    return int(feas_cands[chosen_idx])\n\n",
  "max_future_feasible_successors_aug_243": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_cur = distance_matrix[int(current_node), candidates]\n    earliest_start = np.maximum(t0 + dist_cur, time_windows[candidates, 0])\n    feasible = (demands[candidates] <= cap0) & (earliest_start <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cands = candidates[feasible]\n    best_score = -np.inf\n    best_node = int(feas_cands[0])\n\n    for u in feas_cands:\n        u = int(u)\n        cap1 = np.clip(cap0 - float(demands[u]), 0, None)\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = feas\n\n",
  "min_worstcase_next_slack_aug_244": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for clarity\n    dist_mat = distance_matrix\n    cand_nodes = np.asarray(unvisited_nodes, dtype=int)\n    if cand_nodes.size == 0:\n        return int(depot)\n\n    rest_cap = float(rest_capacity.reshape(-1)[0])\n    cur_t   = float(current_time.reshape(-1)[0])\n\n    # Feasible first\u2011step candidates\n    dist_cur = dist_mat[current_node, cand_nodes]\n    start_u  = np.maximum(cur_t + dist_cur, time_windows[cand_nodes, 0])\n    feas_u   = (demands[cand_nodes] <= rest_cap) & (start_u <= time_windows[cand_nodes, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = cand_nodes[feas_u]\n    n_cand = cand.size\n\n    # Pre\u2011compute pairwise distances among candidates\n    dist_cand = dist_mat[cand[:, None], cand[None, :]]  # shape (n, n)\n\n    # Initialise worst\u2011slack array\n    worst_slack = np.full(n_cand, -np.inf, dtype=float)\n\n    # Compute worst slack for each candidate\n    for idx, u in enumerate(cand):\n        cap1 = rest_cap - float(demands[u])\n        t1   = float(np.maximum(cur_t + dist_mat[current_node, u], time_windows[u, 0]))\n\n        # Remaining candidates after visiting u\n        others = cand[cand != u]\n        if others.size == 0:\n            worst_slack[idx] = np.inf\n            continue\n\n        # Time to reach each other candidate\n        arr      = t1 + dist_mat[u, others]\n        start_v  = np.maximum(arr, time_windows[others, 0])\n        slack_v  = time_windows[others, 1] - start_v\n        # Feasibility mask\n        feas_v   = (demands[others] <= cap1) & (slack_v >= 0)\n\n        if not np.any(feas_v):\n            worst_slack[idx] = -np.inf\n            continue\n\n        # Clip to avoid negative values and take the minimum slack\n        clipped_slack = np.clip(slack_v[feas_v], 0, np.inf)\n        worst_slack[idx] = float(np.min(clipped_slack))\n\n    # Tie\u2011breaking: prefer the candidate with the smallest travel time\n    tb = dist_mat[current_node, cand]\n    best_idx = np.argmax(worst_slack)\n    best_u   = cand[best_idx]\n    best_worst = worst_slack[best_idx]\n    best_tb   = tb[best_idx]\n\n    # Resolve ties on worst slack by distance\n    tie_mask = (worst_slack == best_worst)\n    if np.any(tie_mask):\n        tb_ties = tb[tie_mask]\n        best_idx_tie = np.argmin(tb_ties)\n        best_u = cand[tie_mask][best_idx_tie]\n\n    return int(best_u)\n\n",
  "min_worstcase_next_slack_aug_245": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap0 = float(rest_capacity.reshape(-1)[0])\n    t0   = float(current_time.reshape(-1)[0])\n\n    dcur   = distance_matrix[current_node, candidates]\n    start_u = np.maximum(t0 + dcur, time_windows[candidates, 0])\n    feas_u  = (demands[candidates] <= cap0) & (start_u <= time_windows[candidates, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = candidates[feas_u]\n    # Weighted scoring parameters\n    w_slack = 0.6\n    w_dist  = 0.4\n    # Top\u2011k filter\n    top_k = 7\n    best_worst = -np.inf\n    best_tb = np.inf\n    best_u = int(depot)\n\n    # Pre\u2011compute distances from current node to all candidates\n    tb_all = distance_matrix[current_node, cand]\n\n    for u in cand:\n        cap1 = cap0 - float(demands[u])\n        t1   = float(np.maximum(t0 + distance_matrix[current_node, u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size == 0:\n            worst_slack = np.inf\n        else:\n            arr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(arr, time_windows[others, 0])\n            slack_v = time_windows[others, 1] - start_v\n            feas_v = (demands[others] <= cap1) & (slack_v >= 0)\n            if not np.any(feas_v):\n                worst_slack = -np.inf\n            else:\n                worst_slack = float(np.min(slack_v[feas_v]))\n\n        tb = distance_matrix[current_node, u]\n        # Weighted score: higher slack is better, lower distance is better\n        score = w_slack * worst_slack - w_dist * tb\n\n        # Keep top\u2011k by slack before final selection\n        if best_worst < worst_slack:\n            best_worst = worst_slack\n            best_tb = tb\n            best_u = int(u)\n\n    # Final selection among top\u2011k by slack, break ties with distance\n    if best_worst == -np.inf:\n        return int(depot)\n\n    # Re\u2011evaluate top\u2011k candidates\n    slack_list = []\n    for u in cand:\n        cap1 = cap0 - float(demands[u])\n        t1   = float(np.maximum(t0 + distance_matrix[current_node, u], time_windows[u, 0]))\n        others = cand[cand != u]\n        if others.size == 0:\n            worst_slack = np.inf\n        else:\n            arr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(arr, time_windows[others, 0])\n            slack_v = time_windows[others, 1] - start_v\n            feas_v = (demands[others] <= cap1) & (slack_v >= 0)\n            if not np.any(feas_v):\n                worst_slack = -np.inf\n            else:\n                worst_slack = float(np.min(slack_v[feas_v]))\n        slack_list.append((worst_slack, u))\n\n    # Sort by slack descending, then distance ascending\n    slack_list.sort(key=lambda x: (-x[0], distance_matrix[current_node, x[1]]))\n    top_candidates = [u for _, u in slack_list[:top_k]]\n    # Pick the first candidate that is feasible\n    for u in top_candidates:\n        if u in cand:\n            return int(u)\n\n    return int(depot)\n\n",
  "savings_ratio_preference_aug_246": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu   = distance_matrix[current_node, candidates]\n    start = np.maximum(t + dcu, np.clip(time_windows[candidates, 0], None, None))\n    feasible = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    u2 = candidates[feasible]\n    d_cur_depot = float(distance_matrix[current_node, depot])\n    d_depot_u   = distance_matrix[depot, u2]\n    d_cur_u     = distance_matrix[current_node, u2]\n\n    savings = d_cur_depot + d_depot_u - d_cur_u\n    score   = savings / (d_cur_u + 1e-12)\n\n    start2 = np.maximum(t + d_cur_u, np.clip(time_windows[u2, 0], None, None))\n    slack2 = np.clip(time_windows[u2, 1] - start2, 0, None)\n    score  -= 0.5 * (1.0 / (slack2 + 1.0 + 1e-12))\n\n    # deterministic tie\u2011breaker using a small linear noise\n    noise = np.arange(len(score)) * 1e-6\n    idx   = np.argmax(score + noise)\n    return int(u2[idx])\n\n",
  "savings_ratio_preference_aug_247": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu   = distance_matrix[current_node, candidates]\n    start = np.clip(t + dcu, time_windows[candidates, 0], time_windows[candidates, 1])\n    feasible = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    u2 = candidates[feasible]\n    d_cur_depot = float(distance_matrix[current_node, depot])\n    d_depot_u   = distance_matrix[depot, u2]\n    d_cur_u     = distance_matrix[current_node, u2]\n\n    savings = d_cur_depot + d_depot_u - d_cur_u\n    score   = 0.4 * savings + 0.6 * (1.0 / (d_cur_u + 1e-12))\n\n    start2 = np.clip(t + d_cur_u, time_windows[u2, 0], time_windows[u2, 1])\n    slack2 = np.clip(time_windows[u2, 1] - start2, 0, None)\n    score  -= 0.3 * (1.0 / (slack2 + 1.0 + 1e-12))\n\n    top_k = 7\n    if score.size <= top_k:\n        idx = np.argmax(score)\n    else:\n        top_indices = np.argpartition(-score, top_k-1)[:top_k]\n        idx = np.random.choice(top_indices)\n\n    return int(u2[idx])\n\n",
  "savings_ratio_preference_aug_248": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    feasible_nodes = []\n    scores = []\n\n    for idx in candidates:\n        dcu = distance_matrix[current_node, idx]\n        est_arrival = t + dcu\n        start = max(est_arrival, time_windows[idx, 0])\n\n        if demands[idx] <= cap and start <= time_windows[idx, 1]:\n            d_cur_depot = float(distance_matrix[current_node, depot])\n            d_depot_u   = distance_matrix[depot, idx]\n            d_cur_u     = distance_matrix[current_node, idx]\n\n            savings = d_cur_depot + d_depot_u - d_cur_u\n            score   = savings / (d_cur_u + 1e-12)\n\n            start2 = max(t + d_cur_u, time_windows[idx, 0])\n            slack2 = max(time_windows[idx, 1] - start2, 0)\n            score  -= 0.4 * (1.0 / (slack2 + 1.0 + 1e-12))\n\n            feasible_nodes.append(idx)\n            scores.append(score)\n\n    if not feasible_nodes:\n        return int(depot)\n\n    scores_np = np.array(scores)\n    # softmin probability distribution\n    probs = np.exp(-scores_np)\n    probs = probs / np.clip(np.sum(probs), 1e-12, None)\n\n    chosen_idx = np.random.choice(len(feasible_nodes), p=probs)\n    return int(feasible_nodes[chosen_idx])\n\n",
  "overlap_length_density_aug_249": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Alias variable names for clarity\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distances to candidate nodes\n    dists = distance_matrix[current_node, cand]\n    earliest = np.maximum(t0 + dists, time_windows[cand, 0])\n    feasible = (demands[cand] <= cap) & (earliest <= time_windows[cand, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    # Filter feasible candidates\n    cand_f = cand[feasible]\n    s = time_windows[cand_f, 0].astype(float)\n    e = time_windows[cand_f, 1].astype(float)\n\n    # Compute pairwise overlap using explicit loops\n    n = s.size\n    overlap_sum = np.zeros(n, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                overlap = max(0.0, min(e[i], e[j]) - max(s[i], s[j]))\n                overlap_sum[i] += overlap\n\n    # Distances to feasible nodes\n    dists_f = distance_matrix[current_node, cand_f]\n\n    # Scoring: higher overlap, lower distance\n    # Add deterministic noise to break ties\n    noise = 1e-9 * np.arange(n)\n    score = overlap_sum - 0.30 * dists_f + noise\n\n    # Softmin: convert scores to probabilities and sample\n    shift = np.min(score)  # shift to avoid large exponents\n    exp_scores = np.exp(-(score - shift))\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n    chosen_idx = np.random.choice(n, p=probs)\n    return int(cand_f[chosen_idx])\n\n",
  "overlap_length_density_aug_250": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[current_node, cand]\n    earliest = np.maximum(t0 + dists, time_windows[cand, 0])\n    feasible = (demands[cand] <= cap) & (earliest <= time_windows[cand, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    cand_f = cand[feasible]\n    s = time_windows[cand_f, 0].astype(float)\n    e = time_windows[cand_f, 1].astype(float)\n\n    n = s.size\n    # Overlap sums via list comprehension\n    overlap_sum = np.array([\n        sum(max(0.0, min(e[i], e[j]) - max(s[i], s[j]))\n            for j in range(n) if j != i)\n        for i in range(n)\n    ])\n\n    dists_f = distance_matrix[current_node, cand_f]\n\n    # Median\u2011based scaling\n    median_overlap = np.median(overlap_sum)\n    score = (overlap_sum / (median_overlap + 1e-12)) * 0.5 \\\n            - (dists_f / (np.max(dists_f) + 1e-12)) * 0.4\n\n    # Clip to keep values bounded\n    score = np.clip(score, -1e3, 1e3)\n\n    # Top\u2011k selection\n    top_k = min(7, n)\n    top_indices = np.argpartition(-score, top_k-1)[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n    return int(cand_f[chosen_idx])\n\n",
  "overlap_length_density_aug_251": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_to_cand = distance_matrix[current_node, candidates]\n    earliest_arrival = np.maximum(t0 + dist_to_cand, time_windows[candidates, 0])\n    feasible_mask = (demands[candidates] <= cap) & (earliest_arrival <= time_windows[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feasible = candidates[feasible_mask]\n    s = time_windows[feasible, 0].astype(float)\n    e = time_windows[feasible, 1].astype(float)\n\n    # Overlap via explicit while loops\n    n = s.size\n    overlap_sum = np.zeros(n, dtype=float)\n    i = 0\n    while i < n:\n        j = 0\n        while j < n:\n            if i != j:\n                overlap = max(0.0, min(e[i], e[j]) - max(s[i], s[j]))\n                overlap_sum[i] += overlap\n            j += 1\n        i += 1\n\n    dist_feasible = distance_matrix[current_node, feasible]\n\n    # Max\u2011based scaling and weighted scoring\n    max_overlap = np.max(overlap_sum) if n > 0 else 1.0\n    score = overlap_sum * 0.6 - (dist_feasible / (np.max(dist_feasible) + 1e-12)) * 0.3\n\n    # Deterministic noise to break ties\n    noise = 5e-10 * np.arange(n)\n    score += noise\n\n    # Clip to avoid extreme values\n    score = np.clip(score, -1e6, 1e6)\n\n    # Top\u2011k random choice\n    top_k = min(5, n)\n    top_indices = np.argpartition(-score, top_k-1)[:top_k]\n    chosen = np.random.choice(top_indices)\n    return int(feasible[chosen])\n\n",
  "variance_to_unvisited_min_aug_252": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for readability\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rest_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # compute distances from current node to all candidates\n    d_cur = distance_matrix[int(current_node), candidates].astype(float)\n\n    # start time if we visit each candidate directly\n    earliest = np.maximum(cur_t + d_cur, time_windows[candidates, 0])\n    feasible_mask = (demands[candidates] <= rest_cap) & (earliest <= time_windows[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feas_idx = candidates[feasible_mask]\n    if feas_idx.size == 1:\n        return int(feas_idx[0])\n\n    # mean distance from each feasible candidate to all unvisited nodes\n    # (including infeasible ones for spatial context)\n    mean_dists = np.mean(distance_matrix[feas_idx][:, candidates].astype(float), axis=1)\n\n    # distance from current node to each feasible candidate\n    d_feas = distance_matrix[int(current_node), feas_idx].astype(float)\n\n    # combine scores \u2013 higher weight on distance to keep route short\n    score = 0.7 * d_feas + 0.3 * mean_dists\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(feas_idx.size) * 1e-6\n    score += noise\n\n    # softmin selection with temperature 1.0\n    temp = 1.0\n    exp_vals = np.exp(-score / temp + 1e-12)  # add epsilon to avoid overflow\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)  # epsilon for denominator\n    chosen = np.random.choice(feas_idx, p=probs)\n\n    return int(chosen)\n\n",
  "variance_to_unvisited_min_aug_253": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rest_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # compute distances and feasibility via list comprehension\n    d_cur = distance_matrix[int(current_node), candidates].astype(float)\n    earliest = np.maximum(cur_t + d_cur, time_windows[candidates, 0])\n    feas_list = [c for c, dem, start in zip(candidates,\n                                            demands[candidates],\n                                            earliest)\n                 if dem <= rest_cap and start <= time_windows[c, 1]]\n\n    if not feas_list:\n        return int(depot)\n\n    # if only one candidate, return it\n    if len(feas_list) == 1:\n        return int(feas_list[0])\n\n    # compute maximum distance from each feasible candidate to all unvisited\n    max_dists = np.array([np.max(distance_matrix[c][:, candidates].astype(float))\n                          for c in feas_list])\n\n    # distance from current node to each feasible candidate\n    d_feas = distance_matrix[int(current_node), feas_list].astype(float)\n\n    # clip distances to avoid extreme values\n    d_feas = np.clip(d_feas, 0, 1e6)\n    max_dists = np.clip(max_dists, 0, 1e6)\n\n    # combined score \u2013 give more weight to max distance\n    score = 0.4 * d_feas + 0.6 * max_dists\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(len(feas_list)) * 1e-7\n    score += noise\n\n    # use while loop to pick the minimum score candidate\n    idx_min = 0\n    min_val = score[0]\n    i = 1\n    while i < len(score):\n        if score[i] < min_val:\n            min_val = score[i]\n            idx_min = i\n        i += 1\n\n    return int(feas_list[idx_min])\n\n",
  "variance_to_unvisited_min_aug_254": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rest_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_cur = distance_matrix[int(current_node), candidates].astype(float)\n    earliest = np.maximum(cur_t + d_cur, time_windows[candidates, 0])\n    feasible = (demands[candidates] <= rest_cap) & (earliest <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    if feas_idx.size == 1:\n        return int(feas_idx[0])\n\n    # median distance from each feasible candidate to all unvisited nodes\n    median_dists = np.median(distance_matrix[feas_idx][:, candidates].astype(float), axis=1)\n\n    # distance from current node to each feasible candidate\n    d_feas = distance_matrix[int(current_node), feas_idx].astype(float)\n\n    # clip distances to avoid extreme values\n    d_feas = np.clip(d_feas, 0, 1e6)\n    median_dists = np.clip(median_dists, 0, 1e6)\n\n    # score: balanced combination of distance and median distance\n    score = 0.5 * d_feas + 0.5 * median_dists\n\n    # add small deterministic noise\n    noise = np.arange(len(feas_idx)) * 1e-8\n    score += noise\n\n    # select top_k candidates with lowest scores\n    top_k = 5\n    if score.size > top_k:\n        top_indices = np.argpartition(score, top_k)[:top_k]\n    else:\n        top_indices = np.arange(score.size)\n\n    # random choice among top_k\n    chosen_idx = np.random.choice(top_indices)\n    return int(feas_idx[chosen_idx])\n\n",
  "deadline_weighted_by_wait_aug_255": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for readability\n    curr = int(current_node)\n    depot_id = int(depot)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_time_val = float(np.asarray(current_time).reshape(-1)[0])\n\n    if candidates.size == 0:\n        return depot_id\n\n    # distances and arrival times\n    dist_to_cand = distance_matrix[curr, candidates]\n    arrival = curr_time_val + dist_to_cand\n    wait = np.maximum(0.0, time_windows[candidates, 0] - arrival)\n    start_service = arrival + wait\n\n    feasible = (demands[candidates] <= remaining_cap) & \\\n               (start_service <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return depot_id\n\n    feasible_cands = candidates[feasible]\n    dist_feasible = distance_matrix[curr, feasible_cands]\n    arrival_feas = curr_time_val + dist_feasible\n    wait_feas = np.maximum(0.0, time_windows[feasible_cands, 0] - arrival_feas)\n    due_feas = time_windows[feasible_cands, 1].astype(float)\n\n    # scoring: earlier due dates, less waiting, shorter distance\n    # add tiny deterministic noise to break ties\n    noise = np.arange(feasible_cands.size) * 1e-6\n    score = due_feas + 0.6 * wait_feas + 0.1 * dist_feasible + noise\n\n    # clip to avoid overflow\n    score = np.clip(score, 0, np.inf)\n\n    chosen_idx = int(np.argmin(score))\n    return int(feasible_cands[chosen_idx])\n\n",
  "deadline_weighted_by_wait_aug_256": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = int(current_node)\n    depot_id = int(depot)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_time_val = float(np.asarray(current_time).reshape(-1)[0])\n\n    if candidates.size == 0:\n        return depot_id\n\n    dist_to_cand = distance_matrix[curr, candidates]\n    arrival = curr_time_val + dist_to_cand\n    wait = np.maximum(0.0, time_windows[candidates, 0] - arrival)\n    start_service = arrival + wait\n\n    feasible = (demands[candidates] <= remaining_cap) & \\\n               (start_service <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return depot_id\n\n    feasible_cands = candidates[feasible]\n    dist_feasible = distance_matrix[curr, feasible_cands]\n    arrival_feas = curr_time_val + dist_feasible\n    wait_feas = np.maximum(0.0, time_windows[feasible_cands, 0] - arrival_feas)\n    due_feas = time_windows[feasible_cands, 1].astype(float)\n\n    # scoring with different weights\n    score = due_feas + 0.4 * wait_feas + 0.3 * dist_feasible\n\n    # select top\u2011k candidates\n    top_k = min(5, score.size)\n    top_idx = np.argpartition(score, top_k - 1)[:top_k]\n    top_scores = score[top_idx]\n\n    # soft\u2011min probabilities (smaller score \u2192 higher probability)\n    eps = 1e-12\n    inv_scores = np.exp(-top_scores)          # exponential of negative score\n    probs = inv_scores / (np.sum(inv_scores) + eps)\n\n    rng = np.random.default_rng(seed=0)\n    chosen_idx = rng.choice(top_idx, p=probs)\n    return int(feasible_cands[chosen_idx])\n\n",
  "deadline_weighted_by_wait_aug_257": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = int(current_node)\n    depot_id = int(depot)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    curr_time_val = float(np.asarray(current_time).reshape(-1)[0])\n\n    if candidates.size == 0:\n        return depot_id\n\n    dist_to_cand = distance_matrix[curr, candidates]\n    arrival = curr_time_val + dist_to_cand\n    wait = np.maximum(0.0, time_windows[candidates, 0] - arrival)\n    start_service = arrival + wait\n\n    feasible = (demands[candidates] <= remaining_cap) & \\\n               (start_service <= time_windows[candidates, 1])\n\n    if not np.any(feasible):\n        return depot_id\n\n    feasible_cands = candidates[feasible]\n    dist_feasible = distance_matrix[curr, feasible_cands]\n    arrival_feas = curr_time_val + dist_feasible\n    wait_feas = np.maximum(0.0, time_windows[feasible_cands, 0] - arrival_feas)\n    due_feas = time_windows[feasible_cands, 1].astype(float)\n\n    # use median waiting time as a global adjustment\n    median_wait = np.median(wait_feas)\n    score = due_feas + 0.5 * median_wait + 0.2 * dist_feasible\n\n    # clip to keep values sane\n    score = np.clip(score, 0, np.inf)\n\n    # choose nodes within 10\u202f% of the best score\n    best_score = np.min(score)\n    mask = score <= best_score * 1.10 + 1e-12\n    candidates_masked = feasible_cands[mask]\n    if candidates_masked.size == 0:\n        candidates_masked = feasible_cands\n\n    rng = np.random.default_rng(seed=0)\n    chosen = rng.choice(candidates_masked)\n    return int(chosen)\n\n",
  "k_nearest_feasible_then_best_slack_aug_258": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    tws = time_windows\n    dem_arr = demands\n\n    # --- feasibility test ----------------------------------------------------\n    dists = dist_mat[int(current_node), candidates]\n    arrival = cur_time + dists\n    start_times = np.maximum(arrival, tws[candidates, 0])\n    start_times = np.clip(start_times, tws[candidates, 0], tws[candidates, 1])\n\n    feas = (dem_arr[candidates] <= remaining_cap) & (start_times <= tws[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    # --- restricted candidate list (RCL) ------------------------------------\n    feasible_idx = candidates[feas]\n    feasible_dists = dist_mat[int(current_node), feasible_idx]\n\n    top_k = int(min(7, feasible_idx.size))          # tuned threshold\n    rcl = feasible_idx[np.argpartition(feasible_dists, top_k - 1)[:top_k]]\n\n    # --- compute slack and tie\u2011break ---------------------------------------\n    rcl_dists = dist_mat[int(current_node), rcl]\n    rcl_arrival = cur_time + rcl_dists\n    rcl_start = np.maximum(rcl_arrival, tws[rcl, 0])\n    rcl_start = np.clip(rcl_start, tws[rcl, 0], tws[rcl, 1])\n    rcl_slack = tws[rcl, 1] - rcl_start\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(rcl.size)\n    rcl_slack_noisy = rcl_slack + noise\n\n    # smallest slack, then distance\n    key = np.lexsort((rcl_dists, rcl_slack_noisy))\n    return int(rcl[int(key[0])])\n\n",
  "k_nearest_feasible_then_best_slack_aug_259": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time = float(np.asarray(current_time).reshape(-1)[0])\n\n    # distance and start time\n    dists = distance_matrix[int(current_node), candidates]\n    arrival = cur_time + dists\n    start = np.maximum(arrival, time_windows[candidates, 0])\n    start = np.clip(start, time_windows[candidates, 0], time_windows[candidates, 1])\n\n    # feasibility with safe division\n    feas = (demands[candidates] <= remaining_cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_idx = candidates[feas]\n    feas_dists = distance_matrix[int(current_node), feas_idx]\n\n    # top\u2011k candidate list\n    top_k = int(min(5, feas_idx.size))\n    rcl = feas_idx[np.argpartition(feas_dists, top_k - 1)[:top_k]]\n\n    rcl_dists = distance_matrix[int(current_node), rcl]\n    rcl_arrival = cur_time + rcl_dists\n    rcl_start = np.maximum(rcl_arrival, time_windows[rcl, 0])\n    rcl_start = np.clip(rcl_start, time_windows[rcl, 0], time_windows[rcl, 1])\n    rcl_slack = time_windows[rcl, 1] - rcl_start\n\n    # weighted score: 0.6 distance + 0.4 slack (scaled safely)\n    eps = 1e-12\n    norm_dist = rcl_dists / (np.max(rcl_dists) + eps)\n    norm_slack = rcl_slack / (np.max(rcl_slack) + eps)\n    scores = 0.6 * norm_dist + 0.4 * norm_slack\n\n    # pick randomly among the top\u20113 scores\n    top_indices = np.argsort(scores)[:3]\n    chosen = np.random.choice(top_indices)\n    return int(rcl[chosen])\n\n",
  "k_nearest_feasible_then_best_slack_aug_260": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    remaining_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[int(current_node), candidates]\n    arrival = cur_time + dists\n    start = np.maximum(arrival, time_windows[candidates, 0])\n    start = np.clip(start, time_windows[candidates, 0], time_windows[candidates, 1])\n\n    feas = (demands[candidates] <= remaining_cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_idx = candidates[feas]\n    feas_dists = distance_matrix[int(current_node), feas_idx]\n\n    # RCL with a different threshold\n    top_k = int(min(6, feas_idx.size))\n    rcl = feas_idx[np.argpartition(feas_dists, top_k - 1)[:top_k]]\n\n    rcl_dists = distance_matrix[int(current_node), rcl]\n    rcl_arrival = cur_time + rcl_dists\n    rcl_start = np.maximum(rcl_arrival, time_windows[rcl, 0])\n    rcl_start = np.clip(rcl_start, time_windows[rcl, 0], time_windows[rcl, 1])\n    rcl_slack = time_windows[rcl, 1] - rcl_start\n\n    # proxy approximation: use median distance as a reference\n    median_dist = np.median(rcl_dists)\n    eps = 1e-12\n\n    # soft\u2011min style score (inverse of distance + slack)\n    inv_score = np.exp(- (rcl_dists + rcl_slack) / (median_dist + eps))\n\n    # deterministic noise for stable tie\u2011breaking\n    noise = 1e-7 * np.arange(rcl.size)\n    inv_score += noise\n\n    chosen_idx = np.argmax(inv_score)\n    return int(rcl[chosen_idx])\n\n",
  "feasible_pareto_rank_then_distance_aug_261": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    cur_time = float(current_time.reshape(-1)[0])\n\n    # Compute feasibility data\n    dist = distance_matrix[current_node, candidates].astype(float)\n    arr = cur_time + dist\n    wait = np.maximum(0.0, time_windows[candidates, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[candidates, 1].astype(float) - start\n    slack = np.clip(slack, 0, np.inf)          # keep slack non\u2011negative\n\n    feas_mask = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas = candidates[feas_mask]\n    dist_f = distance_matrix[current_node, feas].astype(float)\n    arr_f = cur_time + dist_f\n    wait_f = np.maximum(0.0, time_windows[feas, 0].astype(float) - arr_f)\n    start_f = arr_f + wait_f\n    slack_f = time_windows[feas, 1].astype(float) - start_f\n    slack_f = np.clip(slack_f, 0, np.inf)\n    dem_f = demands[feas].astype(float)\n\n    # Objectives: [distance, wait, -demand, -slack]\n    obj = np.vstack([dist_f, wait_f, -dem_f, -slack_f]).T\n\n    # Soft\u2011min with temperature (avoid division by zero)\n    temp = 0.5\n    exp_neg = np.exp(-obj / (temp + 1e-12))\n    softmin_score = -np.log(np.sum(exp_neg, axis=1) + 1e-12)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(len(feas))\n    softmin_score += noise\n\n    best_idx = np.argmin(softmin_score)\n    return int(feas[best_idx])\n\n",
  "feasible_pareto_rank_then_distance_aug_262": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t0 = float(current_time.reshape(-1)[0])\n\n    # Feasibility calculation\n    d = distance_matrix[current_node, cand].astype(float)\n    arr = t0 + d\n    wait = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[cand, 1].astype(float) - start\n    slack = np.clip(slack, 0, np.inf)\n\n    mask = (demands[cand] <= cap) & (slack >= 0)\n    if not np.any(mask):\n        return int(depot)\n\n    feas = cand[mask]\n    d_f = distance_matrix[current_node, feas].astype(float)\n    arr_f = t0 + d_f\n    wait_f = np.maximum(0.0, time_windows[feas, 0].astype(float) - arr_f)\n    start_f = arr_f + wait_f\n    slack_f = time_windows[feas, 1].astype(float) - start_f\n    slack_f = np.clip(slack_f, 0, np.inf)\n    dem_f = demands[feas].astype(float)\n\n    # Normalize slack to mitigate scale differences\n    mean_slack = np.mean(slack_f) + 1e-12\n    norm_slack = slack_f / mean_slack\n\n    # Objectives for Pareto ranking\n    obj = np.vstack([d_f, wait_f, -dem_f, -norm_slack]).T\n\n    # Pareto dominance ranking\n    n = obj.shape[0]\n    rank = np.zeros(n, dtype=int)\n    for i in range(n):\n        rank[i] = sum(\n            1 for j in range(n)\n            if i != j and np.all(obj[j] <= obj[i] + 1e-12) and np.any(obj[j] < obj[i] - 1e-12)\n        )\n\n    best_rank = np.min(rank)\n    best_idx = np.where(rank == best_rank)[0]\n\n    # Randomly pick among the best front, limited to top_k by distance\n    top_k = 7\n    if best_idx.size > top_k:\n        dist_best = d_f[best_idx]\n        top_idx = np.argsort(dist_best)[:top_k]\n        candidates = best_idx[top_idx]\n    else:\n        candidates = best_idx\n\n    rng = np.random.default_rng(42)          # deterministic seed\n    chosen = rng.choice(candidates)\n    return int(feas[chosen])\n\n",
  "feasible_pareto_rank_then_distance_aug_263": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.reshape(-1)[0])\n    t0 = float(current_time.reshape(-1)[0])\n\n    # Feasibility\n    d = distance_matrix[current_node, cand].astype(float)\n    arr = t0 + d\n    wait = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[cand, 1].astype(float) - start\n    slack = np.clip(slack, 0, np.inf)\n\n    mask = (demands[cand] <= cap) & (slack >= 0)\n    if not np.any(mask):\n        return int(depot)\n\n    feas = cand[mask]\n    d_f = distance_matrix[current_node, feas].astype(float)\n    arr_f = t0 + d_f\n    wait_f = np.maximum(0.0, time_windows[feas, 0].astype(float) - arr_f)\n    start_f = arr_f + wait_f\n    slack_f = time_windows[feas, 1].astype(float) - start_f\n    slack_f = np.clip(slack_f, 0, np.inf)\n    dem_f = demands[feas].astype(float)\n\n    # Weighted objective (distance, wait, demand, slack)\n    w_dist = 0.6\n    w_wait = 0.2\n    w_dem  = 0.4\n    w_slack = 0.4\n    score = w_dist * d_f + w_wait * wait_f - w_dem * dem_f - w_slack * slack_f\n\n    # Deterministic noise for stable tie\u2011breaking\n    noise = 1e-6 * np.arange(len(feas))\n    score += noise\n\n    best_idx = np.argmin(score)\n    return int(feas[best_idx])\n\n",
  "return_feasibility_margin_max_aug_264": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[current_node, cand]\n    earliest = np.maximum(t0 + dists, time_windows[cand, 0])\n    feasible = (demands[cand] <= cap) & (earliest <= time_windows[cand, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = cand[feasible]\n    dists_feas = distance_matrix[current_node, feas_idx]\n    start_feas = np.maximum(t0 + dists_feas, time_windows[feas_idx, 0])\n\n    depot_due = float(time_windows[depot, 1]) if depot < time_windows.shape[0] else np.inf\n    back = distance_matrix[feas_idx, depot].astype(float)\n\n    margin_depot = depot_due - (start_feas + back) + 1e-12\n    margin = np.where(np.isfinite(depot_due), margin_depot,\n                      time_windows[feas_idx, 1].astype(float) - start_feas)\n\n    tie = dists_feas + back\n    noise = np.random.uniform(-1e-6, 1e-6, size=tie.shape)\n    key = np.lexsort((tie + noise, -margin))\n    return int(feas_idx[key[0]])\n\n",
  "return_feasibility_margin_max_aug_265": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[current_node, cand]\n    earliest = np.maximum(t0 + dists, time_windows[cand, 0])\n    feasible = (demands[cand] <= cap) & (earliest <= time_windows[cand, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = cand[feasible]\n    dists_feas = distance_matrix[current_node, feas_idx]\n    start_feas = np.maximum(t0 + dists_feas, time_windows[feas_idx, 0])\n\n    depot_due = float(time_windows[depot, 1]) if depot < time_windows.shape[0] else np.inf\n    back = distance_matrix[feas_idx, depot].astype(float)\n\n    margin_depot = depot_due - (start_feas + back) + 1e-12\n    margin = np.where(np.isfinite(depot_due), margin_depot,\n                      time_windows[feas_idx, 1].astype(float) - start_feas)\n    margin = np.clip(margin, 0, np.inf)\n\n    w_dist  = 0.4\n    w_margin = 0.6\n    score = w_dist * (dists_feas + back) - w_margin * margin\n    score += np.random.uniform(-1e-6, 1e-6, size=score.shape)   # deterministic noise\n\n    top_k = 7\n    if score.size > top_k:\n        idx_topk = np.argpartition(score, top_k - 1)[:top_k]\n        scores_topk = score[idx_topk]\n    else:\n        idx_topk = np.arange(score.size)\n        scores_topk = score\n\n    best_local = np.argmin(scores_topk)\n    min_score  = scores_topk[best_local]\n    same_mask  = np.isclose(scores_topk, min_score, atol=1e-8)\n\n    if np.sum(same_mask) > 1:\n        chosen = np.random.choice(idx_topk[same_mask])\n    else:\n        chosen = idx_topk[best_local]\n\n    return int(feas_idx[chosen])\n\n",
  "return_feasibility_margin_max_aug_266": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[current_node, cand]\n    earliest = np.maximum(t0 + dists, time_windows[cand, 0])\n    feasible = (demands[cand] <= cap) & (earliest <= time_windows[cand, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = cand[feasible]\n    dists_feas = distance_matrix[current_node, feas_idx]\n    start_feas = np.maximum(t0 + dists_feas, time_windows[feas_idx, 0])\n\n    depot_due = float(time_windows[depot, 1]) if depot < time_windows.shape[0] else np.inf\n    back = distance_matrix[feas_idx, depot].astype(float)\n\n    margin_depot = depot_due - (start_feas + back) + 1e-12\n    margin = np.where(np.isfinite(depot_due), margin_depot,\n                      time_windows[feas_idx, 1].astype(float) - start_feas)\n    margin = np.clip(margin, 0, np.inf)\n\n    dist_cost_ref   = np.median(dists_feas + back)\n    margin_benefit  = np.median(margin)\n\n    w_dist  = 0.5\n    w_margin = 0.5\n    score = w_dist * (dists_feas + back - dist_cost_ref) - \\\n            w_margin * (margin - margin_benefit)\n\n    tau = 0.5\n    exp_vals = np.exp(-score / (tau + 1e-12))\n    probs = exp_vals / np.clip(np.sum(exp_vals), 1e-12, None)\n    chosen = np.random.choice(len(feas_idx), p=probs)\n\n    return int(feas_idx[chosen])\n\n",
  "min_avg_distance_to_remaining_aug_267": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename variables for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rem_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distances from the current node to all candidates\n    dist_cur = distance_matrix[int(current_node), candidates]\n    earliest_arrival = np.maximum(cur_t + dist_cur, time_windows[candidates, 0])\n\n    # Feasibility check\n    feasible = (demands[candidates] <= rem_cap) & (earliest_arrival <= time_windows[candidates, 1])\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_cands = candidates[feasible]\n\n    # Average distance from each feasible candidate to all remaining nodes\n    dm = distance_matrix[feasible_cands][:, candidates].astype(float)\n    avgd = np.mean(dm, axis=1) + 1e-12          # add epsilon\n    avgd = np.clip(avgd, 0, None)                # clip to avoid negative values\n\n    # Distance from current node to each feasible candidate\n    d2 = distance_matrix[int(current_node), feasible_cands].astype(float)\n\n    # Deterministic noise for tie\u2011breaking\n    rng = np.random.default_rng(seed=42)\n    noise = rng.normal(0, 1e-8, size=d2.shape)\n\n    # Lexicographic sort: first by distance, then by average distance\n    key = np.lexsort((d2 + noise, avgd))\n    chosen = feasible_cands[key[0]]\n    return int(chosen)\n\n",
  "min_avg_distance_to_remaining_aug_268": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Variable renaming\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distances from current node\n    d_cur = distance_matrix[int(current_node), candidates]\n    arr_time = np.maximum(t0 + d_cur, time_windows[candidates, 0])\n\n    # Feasibility\n    feas = (demands[candidates] <= cap) & (arr_time <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_cand = candidates[feas]\n\n    # Sum of distances to all remaining nodes (including infeasible ones)\n    dm_sum = np.sum(distance_matrix[feas_cand][:, candidates], axis=1) + 1e-12\n    d_to_cur = distance_matrix[int(current_node), feas_cand]\n\n    # Weighted score: 0.4 * sum + 0.6 * distance to current\n    score = 0.4 * dm_sum + 0.6 * d_to_cur\n\n    # Small deterministic noise to break ties\n    rng = np.random.default_rng(seed=123)\n    noise = rng.normal(0, 1e-7, size=score.shape)\n    score += noise\n\n    # Select top_k candidates\n    top_k = 5\n    top_idx = np.argpartition(score, top_k)[:top_k]\n    top_scores = score[top_idx]\n\n    # Random choice weighted by softmin probabilities\n    probs = np.exp(-top_scores / (top_scores.max() + 1e-12))\n    probs /= probs.sum()\n    chosen_idx = rng.choice(top_idx, p=probs)\n    chosen = feas_cand[chosen_idx]\n    return int(chosen)\n\n",
  "min_avg_distance_to_remaining_aug_269": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Variable renaming\n    remaining = np.asarray(unvisited_nodes, dtype=int)\n    if remaining.size == 0:\n        return int(depot)\n\n    capacity = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distances from current node\n    dist_from_cur = distance_matrix[int(current_node), remaining]\n    est_arrival = np.maximum(cur_time + dist_from_cur, time_windows[remaining, 0])\n\n    # Feasibility\n    feasible_mask = (demands[remaining] <= capacity) & (est_arrival <= time_windows[remaining, 1])\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feasible_nodes = remaining[feasible_mask]\n\n    # Max distance from each feasible node to all remaining nodes\n    dm_max = np.max(distance_matrix[feasible_nodes][:, remaining], axis=1) + 1e-12\n    d_to_cur = distance_matrix[int(current_node), feasible_nodes]\n\n    # Weighted score: 0.6 * max + 0.4 * distance to current\n    score = 0.6 * dm_max + 0.4 * d_to_cur\n\n    # Softmin sampling with temperature tau\n    tau = 0.5\n    exp_vals = np.exp(-score / (tau + 1e-12))\n    probs = exp_vals / exp_vals.sum()\n\n    # Top\u2011k smallest scores\n    top_k = 7\n    top_indices = np.argpartition(score, top_k)[:top_k]          # indices of k smallest scores\n    top_probs = probs[top_indices]\n    top_probs = top_probs / top_probs.sum()                      # re\u2011normalize\n\n    rng = np.random.default_rng(seed=7)\n    chosen_idx = rng.choice(top_indices, p=top_probs)\n    chosen = feasible_nodes[chosen_idx]\n    return int(chosen)\n\n",
  "min_k_nearest_sum_distance_aug_270": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    # distances from the current node to all candidates\n    d_cur = distance_matrix[int(current_node), candidates]\n    # earliest feasible arrival time\n    start = np.maximum(t0 + d_cur, time_windows[candidates, 0])\n\n    # feasibility mask\n    feas_mask = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_nodes = candidates[feas_mask]\n    top_k = min(7, candidates.size)\n\n    # cost proxy: maximum distance among the k nearest neighbours\n    costs = np.empty(feas_nodes.shape[0], dtype=float)\n    for i, node in enumerate(feas_nodes):\n        dists = distance_matrix[int(node), candidates].astype(float)\n        idx = np.argpartition(dists, top_k - 1)[:top_k]\n        costs[i] = float(np.max(dists[idx]))\n\n    # weighted score: 0.6 * distance from current + 0.4 * proxy cost\n    dist_from_cur = distance_matrix[int(current_node), feas_nodes].astype(float)\n    scores = 0.6 * dist_from_cur + 0.4 * costs\n\n    # deterministic tie\u2011breaking noise\n    noise = np.random.uniform(-1e-8, 1e-8, scores.shape)\n    scores += noise\n\n    chosen = feas_nodes[np.argmin(scores)]\n    return int(chosen)\n\n",
  "min_k_nearest_sum_distance_aug_271": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_cur = distance_matrix[int(current_node), nodes]\n    arrival = t0 + d_cur\n    start = np.maximum(arrival, time_windows[nodes, 0])\n\n    feas_mask = (demands[nodes] <= cap) & (start <= time_windows[nodes, 1])\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_nodes = nodes[feas_mask]\n    top_k = min(5, nodes.size)\n\n    # cost proxy: median distance among the k nearest neighbours\n    costs = np.array([np.median(distance_matrix[int(n), nodes][np.argpartition(distance_matrix[int(n), nodes], top_k-1)[:top_k]])\n                      for n in feas_nodes])\n\n    dist_feas = distance_matrix[int(current_node), feas_nodes].astype(float)\n    dist_feas = np.clip(dist_feas, 0, 1e9)          # safe bounds\n\n    # weighted score: 0.4 * distance + 0.6 * cost\n    scores = 0.4 * dist_feas + 0.6 * costs\n\n    # softmin probabilities (avoid division by zero with epsilon)\n    eps = 1e-12\n    min_score = np.min(scores)\n    exp_vals = np.exp(-(scores - min_score) / (eps + 1e-8))\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n\n    # random selection according to the probabilities\n    chosen = np.random.choice(feas_nodes, p=probs)\n    return int(chosen)\n\n",
  "min_k_nearest_sum_distance_aug_272": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_cur = distance_matrix[int(current_node), cand]\n    arrival = t0 + d_cur\n    start = np.maximum(arrival, time_windows[cand, 0])\n\n    feas = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_nodes = cand[feas]\n    top_k = min(6, cand.size)\n\n    # cost proxy: mean distance among the k nearest neighbours\n    costs = np.empty(feas_nodes.shape[0], dtype=float)\n    idx = 0\n    while idx < feas_nodes.shape[0]:\n        n = feas_nodes[idx]\n        dists = distance_matrix[int(n), cand]\n        kth_idx = np.argpartition(dists, top_k - 1)[:top_k]\n        costs[idx] = float(np.mean(dists[kth_idx]))\n        idx += 1\n\n    dist_feas = distance_matrix[int(current_node), feas_nodes].astype(float)\n    dist_feas = np.clip(dist_feas, 0, 1e9)          # safeguard bounds\n\n    # weighted score: 0.5 * distance + 0.5 * cost\n    scores = 0.5 * dist_feas + 0.5 * costs\n\n    # deterministic noise to break ties\n    noise = 1e-9 * np.arange(scores.size)\n    scores += noise\n\n    chosen = feas_nodes[np.argmin(scores)]\n    return int(chosen)\n\n",
  "max_feasible_density_within_percentile_radius_aug_273": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for readability\n    dist_mat = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    # Current state\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distances to all candidates (add epsilon for numerical safety)\n    d_to_cand = dist_mat[current_node, candidates] + 1e-12\n\n    # Earliest feasible start times at each candidate\n    est_start = np.maximum(t0 + d_to_cand, time_windows[candidates, 0])\n\n    # Feasibility mask\n    feas_mask = (demands[candidates] <= cap0) & (est_start <= time_windows[candidates, 1])\n\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_cands = candidates[feas_mask]\n\n    best = feas_cands[0]\n    best_cnt = -1\n    best_tb  = np.inf\n\n    for u in feas_cands:\n        u = int(u)\n\n        # Update capacity and time after visiting u\n        cap_u = np.clip(cap0 - float(demands[u]), 0.0, np.inf)\n        t_u   = float(np.maximum(t0 + dist_mat[current_node, u] + 1e-12,\n                                 time_windows[u, 0]))\n\n        # Remaining candidates after visiting u\n        others = feas_cands[feas_cands != u]\n        if others.size == 0:\n            cnt = 0\n        else:\n            # Radius is 25th percentile of distances from u to others\n            d_from_u = dist_mat[u, others].astype(float) + 1e-12\n            radius   = float(np.quantile(d_from_u, 0.25))\n            near     = others[d_from_u <= radius]\n\n            if near.size == 0:\n                cnt = 0\n            else:\n                # Time to reach near nodes\n                arr = t_u + dist_mat[u, near]\n                start_v = np.maximum(arr, time_windows[near, 0]) + 1e-12\n                feas_v  = (demands[near] <= cap_u) & (start_v <= time_windows[near, 1])\n                cnt     = int(np.sum(feas_v))\n\n        tb = float(dist_mat[current_node, u] + 1e-12)\n\n        # Selection rule: maximize feasible neighbor count, break ties by shorter distance\n        if (cnt > best_cnt) or (cnt == best_cnt and tb < best_tb):\n            best_cnt = cnt\n            best_tb  = tb\n            best     = u\n\n    return int(best)\n\n",
  "max_feasible_density_within_percentile_radius_aug_274": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    rng = np.random.default_rng(seed=123)   # deterministic noise\n    dist_mat = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_to_cand = dist_mat[current_node, candidates] + 1e-12\n    est_start = np.maximum(t0 + d_to_cand, time_windows[candidates, 0])\n\n    feas_mask = (demands[candidates] <= cap0) & (est_start <= time_windows[candidates, 1])\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feas_cand = candidates[feas_mask]\n\n    best_score = -np.inf\n    best_node  = feas_cand[0]\n\n    for u in feas_cand:\n        u = int(u)\n\n        cap_u = np.clip(cap0 - float(demands[u]), 0.0, np.inf)\n        t_u   = float(np.maximum(t0 + dist_mat[current_node, u] + 1e-12,\n                                 time_windows[u, 0]))\n\n        others = feas_cand[feas_cand != u]\n        if others.size == 0:\n            cnt = 0\n        else:\n            d_from_u = dist_mat[u, others].astype(float) + 1e-12\n            radius   = float(np.median(d_from_u))   # use median instead of quantile\n            near     = others[d_from_u <= radius]\n\n            if near.size == 0:\n                cnt = 0\n            else:\n                arr = t_u + dist_mat[u, near]\n                start_v = np.maximum(arr, time_windows[near, 0]) + 1e-12\n                feas_v  = (demands[near] <= cap_u) & (start_v <= time_windows[near, 1])\n                cnt     = int(np.sum(feas_v))\n\n        tb = float(dist_mat[current_node, u] + 1e-12)\n\n        # Weighted score: prioritize more neighbors, penalise distance\n        score = 0.6 * cnt - 0.4 * tb\n\n        # Add deterministic noise for tie\u2011breaking\n        noise = rng.normal(loc=0.0, scale=1e-6)\n        score += noise\n\n        if score > best_score:\n            best_score = score\n            best_node  = u\n\n    return int(best_node)\n\n",
  "regret_two_step_best_vs_second_aug_275": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- rename for readability -------------------------------------------\n    cand_nodes = np.asarray(unvisited_nodes, dtype=int)\n    dist_mat   = np.asarray(distance_matrix, dtype=float)\n    cap0       = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0         = float(np.asarray(current_time).reshape(-1)[0])\n    dem_arr    = np.asarray(demands, dtype=float)\n    tw         = np.asarray(time_windows, dtype=float)\n\n    # --- trivial case ------------------------------------------------------\n    if cand_nodes.size == 0:\n        return int(depot)\n\n    # --- feasibility of first step -----------------------------------------\n    dcur   = dist_mat[current_node, cand_nodes]\n    start_u = np.maximum(t0 + dcur, tw[cand_nodes, 0])\n    feas_u  = (dem_arr[cand_nodes] <= cap0) & (start_u <= tw[cand_nodes, 1])\n\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = cand_nodes[feas_u]\n    if cand.size == 0:\n        return int(depot)\n\n    # --- pre\u2011compute pairwise data -----------------------------------------\n    d_between = dist_mat[cand[:, None], cand[None, :]]            # shape (n, n)\n    t1_arr    = np.maximum(t0 + dist_mat[current_node, cand], tw[cand, 0])\n    cap1_arr  = cap0 - dem_arr[cand]                              # remaining cap after u\n\n    # waiting times to all v from each u\n    arr2 = t1_arr[:, None] + d_between\n    wait2 = np.maximum(0.0, tw[cand[None, :], 0] - arr2)\n    cost_mat = d_between + wait2                                 # travel + wait\n\n    # feasibility mask for v given u\n    feas_mat = (dem_arr[cand[None, :]] <= cap1_arr[:, None]) & \\\n               (arr2 <= tw[cand[None, :], 1])\n\n    # --- compute regret for each u ----------------------------------------\n    n = cand.size\n    best_regret = -np.inf\n    best_u      = int(cand[0])\n    best_tb     = np.inf\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(n)\n\n    for i in range(n):\n        # mask of feasible v excluding u itself\n        mask = feas_mat[i].copy()\n        mask[i] = False\n        if not np.any(mask):\n            continue\n\n        # costs to feasible v\n        costs = cost_mat[i, mask]\n        if costs.size < 2:\n            continue\n\n        # two smallest costs\n        idx = np.argpartition(costs, 1)[:2]\n        a, b = float(np.min(costs[idx])), float(np.max(costs[idx]))\n        regret = b - a\n\n        tb = float(dcur[feas_u][i])  # distance from current node to u\n\n        if (regret > best_regret) or (regret == best_regret and tb + noise[i] < best_tb):\n            best_regret = regret\n            best_tb     = tb + noise[i]\n            best_u      = int(cand[i])\n\n    # --- fallback to nearest feasible if no regret found -------------------\n    if not np.isfinite(best_regret):\n        d2 = dist_mat[current_node, cand]\n        return int(cand[np.argmin(d2)])\n\n    return int(best_u)\n\n",
  "regret_two_step_best_vs_second_aug_276": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- rename for clarity -----------------------------------------------\n    nodes  = np.asarray(unvisited_nodes, dtype=int)\n    dist   = np.asarray(distance_matrix, dtype=float)\n    cap0   = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0     = float(np.asarray(current_time).reshape(-1)[0])\n    dem    = np.asarray(demands, dtype=float)\n    tw     = np.asarray(time_windows, dtype=float)\n\n    if nodes.size == 0:\n        return int(depot)\n\n    dcur = dist[current_node, nodes]\n    start = np.maximum(t0 + dcur, tw[nodes, 0])\n    feas = (dem[nodes] <= cap0) & (start <= tw[nodes, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    cand = nodes[feas]\n    d_cand = dcur[feas]\n\n    # limit to nearest top_k candidates\n    top_k = min(len(cand), 7)\n    nearest_idx = np.argpartition(d_cand, top_k-1)[:top_k]\n    cand = cand[nearest_idx]\n    d_cand = d_cand[nearest_idx]\n\n    # --- regret computation ------------------------------------------------\n    best_regret = -np.inf\n    best_u = int(cand[0])\n    best_tb = np.inf\n\n    eps = 1e-12\n    tau = 1.0  # temperature for softmin\n\n    for u in cand:\n        idx_u = int(u)\n        cap1 = cap0 - dem[idx_u]\n        t1   = np.maximum(t0 + dist[current_node, idx_u], tw[idx_u, 0])\n\n        # remaining candidates after selecting u\n        others = cand[cand != idx_u]\n        if others.size < 2:\n            continue\n\n        # travel and wait times\n        d_uv = dist[idx_u, others]\n        arr_uv = t1 + d_uv\n        wait_uv = np.maximum(0.0, tw[others, 0] - arr_uv)\n\n        # weighted cost\n        cost_uv = 0.6 * d_uv + 0.4 * wait_uv\n\n        # soft\u2011min probabilities\n        exp_neg = np.exp(-cost_uv / tau)\n        probs   = exp_neg / (np.sum(exp_neg) + eps)\n\n        # choose best and second best by cost (not by probability)\n        idx_sorted = np.argsort(cost_uv)\n        best_cost = cost_uv[idx_sorted[0]]\n        second_cost = cost_uv[idx_sorted[1]]\n        regret = second_cost - best_cost\n\n        tb = float(d_cur if (current_node==current_node) else dist[current_node, idx_u])\n\n        if (regret > best_regret) or (regret == best_regret and tb < best_tb):\n            best_regret = regret\n            best_tb     = tb\n            best_u      = int(idx_u)\n\n    if not np.isfinite(best_regret):\n        nearest = int(cand[np.argmin(d_cand)])\n        return nearest\n\n    return int(best_u)\n\n",
  "regret_two_step_best_vs_second_aug_277": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- rename variables ---------------------------------------------------\n    cand_nodes = np.asarray(unvisited_nodes, dtype=int)\n    dist_mat   = np.asarray(distance_matrix, dtype=float)\n    cap0       = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0         = float(np.asarray(current_time).reshape(-1)[0])\n    dem_arr    = np.asarray(demands, dtype=float)\n    tw         = np.asarray(time_windows, dtype=float)\n\n    if cand_nodes.size == 0:\n        return int(depot)\n\n    dcur   = dist_mat[current_node, cand_nodes]\n    start_u = np.maximum(t0 + dcur, tw[cand_nodes, 0])\n    feas_u  = (dem_arr[cand_nodes] <= cap0) & (start_u <= tw[cand_nodes, 1])\n\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = cand_nodes[feas_u]\n    if cand.size == 0:\n        return int(depot)\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-7 * np.arange(cand.size)\n\n    best_regret = -np.inf\n    best_u = int(cand[0])\n    best_tb = np.inf\n\n    # iterate over candidates with a while loop\n    i = 0\n    while i < cand.size:\n        u = int(cand[i])\n        cap1 = cap0 - dem_arr[u]\n        t1   = np.maximum(t0 + dist_mat[current_node, u], tw[u, 0])\n\n        # remaining nodes after picking u\n        others = cand[cand != u]\n        if others.size < 2:\n            i += 1\n            continue\n\n        # compute travel + wait to others\n        d_uv = dist_mat[u, others]\n        arr_uv = t1 + d_uv\n        wait_uv = np.maximum(0.0, tw[others, 0] - arr_uv)\n\n        # weighted cost: 0.5 * distance + 0.5 * wait\n        cost_uv = 0.5 * d_uv + 0.5 * wait_uv\n\n        # use median of costs as central tendency\n        median_cost = np.median(cost_uv)\n\n        # find two smallest costs for regret\n        if cost_uv.size >= 2:\n            idx = np.argpartition(cost_uv, 1)[:2]\n            a, b = float(np.min(cost_uv[idx])), float(np.max(cost_uv[idx]))\n            regret = b - a\n        else:\n            regret = -np.inf\n\n        tb = float(dist_mat[current_node, u])\n\n        if (regret > best_regret) or (regret == best_regret and tb + noise[i] < best_tb):\n            best_regret = regret\n            best_tb = tb + noise[i]\n            best_u = int(u)\n\n        i += 1\n\n    if not np.isfinite(best_regret):\n        nearest = int(cand[np.argmin(dist_mat[current_node, cand])])\n        return nearest\n\n    return int(best_u)\n\n",
  "dynamic_lambda_distance_vs_slack_by_time_aug_278": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_cur = distance_matrix[int(current_node), candidates].astype(float)\n    earliest = np.maximum(t + dist_cur, time_windows[candidates, 0].astype(float))\n    slack    = time_windows[candidates, 1].astype(float) - earliest\n\n    feasible = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_cand = candidates[feasible]\n    dist_feas     = distance_matrix[int(current_node), feasible_cand].astype(float)\n    start_feas    = np.maximum(t + dist_feas, time_windows[feasible_cand, 0].astype(float))\n    slack_feas    = time_windows[feasible_cand, 1].astype(float) - start_feas\n\n    due_med = float(np.median(time_windows[candidates, 1].astype(float)))\n    x       = (t - due_med) / (abs(due_med) + 1.0)\n    lam     = float(np.clip(0.55 + 0.35 * np.tanh(x), 0.2, 0.9))\n\n    urgency = 1.0 / (slack_feas + 1e-12)          # epsilon to avoid division by zero\n    noise   = 1e-8 * np.arange(len(feasible_cand))  # deterministic tie\u2011breaker\n\n    score = lam * dist_feas + (1.0 - lam) * urgency + noise\n    return int(feasible_cand[int(np.argmin(score))])\n\n",
  "dynamic_lambda_distance_vs_slack_by_time_aug_279": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    rng = np.random.default_rng(42)                # deterministic RNG\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_cur = distance_matrix[int(current_node), nodes].astype(float)\n    est_arr = np.maximum(t + d_cur, time_windows[nodes, 0].astype(float))\n    slack   = time_windows[nodes, 1].astype(float) - est_arr\n\n    feas = (demands[nodes] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = nodes[feas]\n    d_cand = distance_matrix[int(current_node), cand].astype(float)\n    start_cand = np.maximum(t + d_cand, time_windows[cand, 0].astype(float))\n    slack_cand = time_windows[cand, 1].astype(float) - start_cand\n\n    due_med = float(np.median(time_windows[nodes, 1].astype(float)))\n    x       = (t - due_med) / (abs(due_med) + 1.0)\n    lam     = float(np.clip(0.4 + 0.4 * np.tanh(x), 0.2, 0.9))\n\n    urgency = 1.0 / (slack_cand + 1e-12)\n    score   = lam * d_cand + (1.0 - lam) * urgency\n\n    # choose among top\u2011k with softmin probabilities\n    top_k = min(7, len(score))\n    top_idx = np.argpartition(score, top_k - 1)[:top_k]\n    top_score = score[top_idx]\n\n    temp = 0.1\n    probs = np.exp(-top_score / temp)\n    probs /= np.sum(probs)\n\n    chosen = rng.choice(top_idx, p=probs)\n    return int(cand[chosen])\n\n",
  "dynamic_lambda_distance_vs_slack_by_time_aug_280": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_cur = distance_matrix[int(current_node), nodes].astype(float)\n    est_arr = np.maximum(t + d_cur, time_windows[nodes, 0].astype(float))\n    slack   = time_windows[nodes, 1].astype(float) - est_arr\n\n    feas = (demands[nodes] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = nodes[feas]\n    d_cand = distance_matrix[int(current_node), cand].astype(float)\n    start_cand = np.maximum(t + d_cand, time_windows[cand, 0].astype(float))\n    slack_cand = time_windows[cand, 1].astype(float) - start_cand\n\n    due_mean = float(np.mean(time_windows[nodes, 1].astype(float)))\n    x        = (t - due_mean) / (abs(due_mean) + 1.0)\n    lam      = float(np.clip(0.6 + 0.3 * np.tanh(x), 0.2, 0.9))\n\n    urgency = 1.0 / (slack_cand + 1e-12)\n    score   = lam * d_cand + (1.0 - lam) * urgency\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-7 * np.arange(len(cand))\n    score += noise\n\n    temp = 0.05\n    probs = np.exp(-score / temp)\n    probs /= np.sum(probs)\n\n    chosen_idx = np.argmax(probs)          # deterministic selection of highest probability\n    return int(cand[chosen_idx])\n\n",
  "maximize_wait_to_avoid_early_idle_aug_281": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = np.asarray(distance_matrix[current_node, candidates], dtype=float)\n    arrival = cur_t + dists\n    wait = np.maximum(0.0, time_windows[candidates, 0].astype(float) - arrival)\n    start = arrival + wait\n    slack = time_windows[candidates, 1].astype(float) - start\n\n    feasible = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feasible):\n        return int(depot)\n\n    idx = candidates[feasible]\n    w = wait[feasible]\n    s = slack[feasible]\n\n    # score = waiting time + small weight on slack\n    scores = w + 0.1 * s\n    # add tiny deterministic noise for reproducible tie\u2011breaking\n    scores += np.random.uniform(-1e-6, 1e-6, size=scores.shape)\n\n    # convert to probabilities via soft\u2011max\n    exp_scores = np.exp(scores - np.max(scores))\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n\n    chosen = np.random.choice(idx, p=probs)\n    return int(chosen)\n\n",
  "maximize_wait_to_avoid_early_idle_aug_282": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_now = float(np.asarray(current_time).reshape(-1)[0])\n\n    best_idx = None\n    best_score = -np.inf\n\n    for node in candidates:\n        dist = float(distance_matrix[current_node, node])\n        dist = np.clip(dist, 0, None)\n\n        arr = t_now + dist\n        wait = max(0.0, float(time_windows[node, 0]) - arr)\n        wait = np.clip(wait, 0, None)\n\n        start = arr + wait\n        slack = float(time_windows[node, 1]) - start\n        slack = np.clip(slack, 0, None)\n\n        if demands[node] <= cap and slack >= 0:\n            score = wait + 0.002 * slack\n            score += np.random.uniform(-1e-6, 1e-6)  # deterministic noise\n            if score > best_score:\n                best_score = score\n                best_idx = node\n\n    return int(best_idx if best_idx is not None else depot)\n\n",
  "maximize_wait_to_avoid_early_idle_aug_283": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_now = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = np.asarray(distance_matrix[current_node, cand], dtype=float)\n    dists = np.clip(dists, 0, None)\n\n    arr = t_now + dists\n    wait = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[cand, 1].astype(float) - start\n    slack = np.clip(slack, 0, None)\n\n    feas = (demands[cand] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    idx = cand[feas]\n    d_f = dists[feas]\n    s_f = slack[feas]\n\n    # lower distance better, higher slack better \u2192 softmin\n    scores = d_f - 0.5 * s_f\n    exp_scores = np.exp(-scores - np.max(-scores))\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n\n    # choose uniformly among the best top_k candidates\n    top_k = min(7, probs.size)\n    top_idx = np.argsort(-probs)[:top_k]\n    chosen = idx[np.random.choice(top_idx)]\n    return int(chosen)\n\n",
  "radial_continuity_to_depot_aug_284": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for clarity\n    dist_mat   = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    # scalar values\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # distances from current node to all candidates\n    dcur = dist_mat[int(current_node), candidates]\n    # earliest possible start time at each candidate\n    start = np.maximum(t + dcur, time_windows[candidates, 0])\n    # feasibility mask\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    # keep only feasible candidates\n    cand = candidates[feas]\n\n    # radial band: absolute difference of depot distances\n    r0 = float(dist_mat[int(depot), int(current_node)])\n    r  = dist_mat[int(depot), cand].astype(float)\n    band = np.abs(r - r0)\n\n    # distance from current node to each candidate\n    d2 = dist_mat[int(current_node), cand].astype(float)\n\n    # deterministic noise to break ties (sorted in increasing order)\n    noise = 1e-9 * np.arange(cand.size)\n\n    # lexicographic sort: first by distance, then by band\n    key = np.lexsort((band + noise, d2))\n    return int(cand[key[0]])\n\n",
  "radial_continuity_to_depot_aug_285": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur  = dist_mat[int(current_node), candidates]\n    start = np.maximum(t + dcur, time_windows[candidates, 0])\n    feas  = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    cand = candidates[feas]\n\n    r0 = float(dist_mat[int(depot), int(current_node)])\n    r  = dist_mat[int(depot), cand].astype(float)\n    band = np.abs(r - r0)\n\n    d2 = dist_mat[int(current_node), cand].astype(float)\n\n    # weighted score: 0.6 * band + 0.4 * d2\n    score = 0.6 * band + 0.4 * d2\n    score = np.clip(score, 0, None)          # ensure non\u2011negative\n\n    # keep top_k candidates\n    top_k = 7\n    if cand.size > top_k:\n        idx_top = np.argpartition(score, top_k-1)[:top_k]\n        cand = cand[idx_top]\n        score = score[idx_top]\n\n    # softmin probabilities (temperature controls softness)\n    temp = 0.1\n    exp_vals = np.exp(-score / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # draw one index according to probabilities\n    chosen_idx = np.random.choice(cand.size, p=probs)\n    return int(cand[chosen_idx])\n\n",
  "radial_continuity_to_depot_aug_286": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur  = dist_mat[int(current_node), candidates]\n    start = np.maximum(t + dcur, time_windows[candidates, 0])\n    feas  = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    cand = candidates[feas]\n\n    # median distance from depot to candidates\n    r0 = float(dist_mat[int(depot), int(current_node)])\n    med_dist = np.median(dist_mat[int(depot), cand].astype(float))\n    band = np.abs(med_dist - r0)\n\n    d2 = dist_mat[int(current_node), cand].astype(float)\n\n    # composite score: band + d2 (no weighting)\n    score = band + d2\n    score = np.clip(score, 0, None)\n\n    # take top\u20115 candidates\n    top_k = 5\n    if cand.size > top_k:\n        idx_top = np.argpartition(score, top_k-1)[:top_k]\n        cand = cand[idx_top]\n        score = score[idx_top]\n\n    # add deterministic noise for tie\u2011breaking\n    noise = 1e-8 * np.arange(cand.size)\n    score += noise\n\n    # random choice among the best\n    chosen_idx = np.random.choice(cand.size)\n    return int(cand[chosen_idx])\n\n",
  "min_distance_plus_quadratic_wait_aug_287": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # ---- rename for clarity ----\n    curr = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    if cand.size == 0:\n        return dep\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # ---- vectorised distance and arrival computation ----\n    dists   = distance_matrix[curr, cand].astype(float)\n    arrive  = t + dists\n    wait    = np.maximum(0.0, time_windows[cand, 0].astype(float) - arrive)\n    start   = arrive + wait\n\n    # ---- feasibility test ----\n    feasible = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n\n    if not np.any(feasible):\n        return dep\n\n    # ---- filter to feasible indices ----\n    feas_idx = cand[feasible]\n    d2       = distance_matrix[curr, feas_idx].astype(float)\n    arr2     = t + d2\n    wait2    = np.maximum(0.0, time_windows[feas_idx, 0].astype(float) - arr2)\n\n    # ---- score: distance + wait\u00b2 (deterministic noise added for tie\u2011breaking) ----\n    score = d2 + np.square(wait2) + 1e-12\n\n    # ---- pick the smallest score, breaking ties deterministically ----\n    min_score = np.min(score)\n    tie_idx   = np.where(score == min_score)[0]\n    chosen    = feas_idx[tie_idx[0]]\n\n    return int(chosen)\n\n",
  "min_distance_plus_quadratic_wait_aug_288": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = int(current_node)\n    dep  = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    if cand.size == 0:\n        return dep\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists   = distance_matrix[curr, cand].astype(float)\n    arrive  = t + dists\n    wait    = np.maximum(0.0, time_windows[cand, 0].astype(float) - arrive)\n    start   = arrive + wait\n\n    feasible = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n\n    if not np.any(feasible):\n        return dep\n\n    feas_idx = cand[feasible]\n    d2       = distance_matrix[curr, feas_idx].astype(float)\n    arr2     = t + d2\n    wait2    = np.maximum(0.0, time_windows[feas_idx, 0].astype(float) - arr2)\n\n    # ---- use median of wait as a proxy for per\u2011node wait penalty ----\n    median_wait = np.median(wait2)\n    score = d2 + np.square(median_wait) + 1e-12\n\n    # ---- probabilistic top\u2011k selection (inverse\u2011score weighting) ----\n    top_k = 3\n    top_idx = np.argsort(score)[:top_k]                # indices in `feas_idx`\n    inv_score = 1.0 / (score[top_idx] + 1e-12)         # epsilon to avoid division by zero\n    probs = inv_score / np.clip(np.sum(inv_score), 1e-12, None)\n\n    chosen_idx = np.random.choice(top_idx, p=probs)\n    chosen = feas_idx[chosen_idx]\n    return int(chosen)\n\n",
  "max_product_slack_and_postcap_aug_289": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for readability\n    cand_nodes = np.asarray(unvisited_nodes, dtype=int)\n\n    if cand_nodes.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # distances to all candidates\n    d = distance_matrix[int(current_node), cand_nodes].astype(float)\n\n    # earliest possible start times respecting time windows\n    start = np.maximum(t + d, time_windows[cand_nodes, 0].astype(float))\n\n    # slack before the window closes\n    slack = time_windows[cand_nodes, 1].astype(float) - start\n    slack = np.clip(slack, 0, None)\n\n    # feasible nodes: enough capacity and non\u2011negative slack\n    feas = (demands[cand_nodes] <= cap0) & (slack >= 0)\n\n    if not np.any(feas):\n        return int(depot)\n\n    # filter feasible candidates\n    cand = cand_nodes[feas]\n\n    # recompute distances, start times, slack, and remaining capacity\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    slack2 = np.clip(slack2, 0, None)\n\n    postcap = cap0 - demands[cand].astype(float)\n\n    # scoring function\n    score = (slack2 + 1.0) * (postcap + 1.0)\n\n    # deterministic noise to break ties\n    noise = np.arange(cand.size, dtype=float) * 1e-6\n    score_noisy = score + noise\n\n    # choose node with highest score, break ties by shorter distance\n    key = np.lexsort((d2, -score_noisy))\n    return int(cand[key[0]])\n\n",
  "max_product_slack_and_postcap_aug_290": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n\n    if nodes.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), nodes].astype(float)\n    earliest = np.maximum(t + dist, time_windows[nodes, 0].astype(float))\n    slack = time_windows[nodes, 1].astype(float) - earliest\n    slack = np.clip(slack, 0, None)\n\n    feasible = (demands[nodes] <= cap0) & (slack >= 0)\n\n    if not np.any(feasible):\n        return int(depot)\n\n    cand = nodes[feasible]\n\n    dist2 = distance_matrix[int(current_node), cand].astype(float)\n    earliest2 = np.maximum(t + dist2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - earliest2\n    slack2 = np.clip(slack2, 0, None)\n\n    postcap = cap0 - demands[cand].astype(float)\n\n    # weighted score: 60% slack, 40% remaining capacity\n    score = 0.6 * slack2 + 0.4 * postcap\n\n    # select top\u2011k candidates (k = 5 or all if fewer)\n    k = min(5, len(cand))\n    top_idx = np.argpartition(-score, k-1)[:k]\n    top_cand = cand[top_idx]\n    top_dist = dist2[top_idx]\n    top_score = score[top_idx]\n\n    # among top\u2011k pick the one with minimal distance\n    min_dist = np.min(top_dist)\n    mask = top_dist == min_dist\n    chosen_idx = np.random.default_rng(42).choice(np.where(mask)[0])\n    return int(top_cand[chosen_idx])\n\n",
  "max_product_slack_and_postcap_aug_291": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), candidates].astype(float)\n    start = np.maximum(t + d, time_windows[candidates, 0].astype(float))\n    slack = time_windows[candidates, 1].astype(float) - start\n    slack = np.clip(slack, 0, None)\n\n    feasible = (demands[candidates] <= cap0) & (slack >= 0)\n\n    if not np.any(feasible):\n        return int(depot)\n\n    cand = candidates[feasible]\n\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    slack2 = np.clip(slack2, 0, None)\n\n    postcap = cap0 - demands[cand].astype(float)\n    postcap = np.clip(postcap, 0, None)\n\n    # mean of slack and remaining capacity as score\n    score = np.mean(np.vstack([slack2, postcap]), axis=0)\n\n    # deterministic noise to diversify softmin\n    noise = np.arange(cand.size, dtype=float) * 1e-6\n    score_noisy = score + noise\n\n    # soft\u2011min probability distribution\n    exp_neg = np.exp(-score_noisy)\n    prob = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n    rng = np.random.default_rng(42)\n    chosen_idx = rng.choice(cand.size, p=prob)\n    return int(cand[chosen_idx])\n\n",
  "min_distance_scaled_by_window_narrowness_aug_292": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Internal aliases for readability\n    dist_mat = np.asarray(distance_matrix, dtype=float)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = dist_mat[int(current_node), candidates].astype(float)\n    earliest_start = np.maximum(t + d, time_windows[candidates, 0].astype(float))\n    feasible = (demands[candidates] <= cap) & (earliest_start <= time_windows[candidates, 1].astype(float))\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feasible_idx = candidates[feasible]\n    d_feas = dist_mat[int(current_node), feasible_idx].astype(float)\n    width = np.clip(time_windows[feasible_idx, 1] - time_windows[feasible_idx, 0], 1e-12, None).astype(float)\n\n    # Scale factor with epsilon to avoid division by zero\n    scale = 1.0 + 1.0 / (width + 1.0 + 1e-12)\n    # Soft\u2011min probability\n    scores = d_feas * scale\n    # Add tiny deterministic noise for tie\u2011breaking\n    scores += np.arange(scores.size) * 1e-12\n    probs = np.exp(-scores)\n    probs /= np.sum(probs)\n    chosen = np.random.choice(feasible_idx, p=probs)\n    return int(chosen)\n\n",
  "min_distance_scaled_by_window_narrowness_aug_293": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = np.asarray(distance_matrix, dtype=float)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = dist_mat[int(current_node), candidates].astype(float)\n    start_time = np.maximum(t + d, time_windows[candidates, 0].astype(float))\n    feasible = (demands[candidates] <= cap) & (start_time <= time_windows[candidates, 1].astype(float))\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    d_feas = dist_mat[int(current_node), feas_idx].astype(float)\n    width = np.clip(time_windows[feas_idx, 1] - time_windows[feas_idx, 0], 1e-12, None).astype(float)\n\n    # Adjusted weighting: distance 70\u202f%, scale 30\u202f%\n    scale = 1.0 + 1.0 / (width + 1.0 + 1e-12)\n    score = 0.7 * d_feas + 0.3 * scale\n    # Add deterministic noise\n    score += np.arange(score.size) * 1e-12\n\n    top_k = 7\n    if score.size > top_k:\n        # Get indices of the smallest top_k scores\n        idx_small = np.argpartition(score, top_k)[:top_k]\n        best_idx = idx_small[np.argmin(score[idx_small])]\n    else:\n        best_idx = np.argmin(score)\n\n    chosen_node = feas_idx[best_idx]\n    return int(chosen_node)\n\n",
  "min_distance_scaled_by_window_narrowness_aug_294": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat = np.asarray(distance_matrix, dtype=float)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = dist_mat[int(current_node), candidates].astype(float)\n    arrival = t + d\n    feasible = (demands[candidates] <= cap) & (arrival <= time_windows[candidates, 1].astype(float))\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_idx = candidates[feasible]\n    d_feas = dist_mat[int(current_node), feas_idx].astype(float)\n    arrival_feas = t + d_feas\n\n    wait = np.maximum(time_windows[feas_idx, 0] - arrival_feas, 0.0).astype(float)\n    late = np.maximum(arrival_feas - time_windows[feas_idx, 1], 0.0).astype(float)\n    width = np.clip(time_windows[feas_idx, 1] - time_windows[feas_idx, 0], 1e-12, None).astype(float)\n\n    # Penalty score: distance + weighted wait + weighted late + small efficiency term\n    score = d_feas + 2.0 * wait + 5.0 * late + 0.1 * d_feas / (width + 1e-12)\n\n    # Add tiny deterministic noise for tie\u2011breaking\n    score += np.arange(score.size) * 1e-12\n    chosen_idx = np.argmin(score)\n    chosen_node = feas_idx[chosen_idx]\n    return int(chosen_node)\n\n",
  "earliest_open_time_then_shortest_travel_aug_295": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for readability\n    dist_mat = np.asarray(distance_matrix, dtype=float)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    # Scalar values\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distance to all candidates\n    d = np.asarray(dist_mat[current_node, candidates], dtype=float)\n\n    # Earliest feasible arrival times\n    start = np.maximum(t + d + 1e-12, time_windows[candidates, 0].astype(float))\n\n    # Feasibility mask\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1].astype(float))\n\n    if not np.any(feas):\n        return int(depot)\n\n    # Filter feasible candidates\n    cand = candidates[feas]\n    open_t = time_windows[cand, 0].astype(float) + np.arange(len(cand)) * 1e-6\n    d2 = np.clip(dist_mat[current_node, cand].astype(float), 0, None)\n\n    # Lexicographic sorting: first by open time, then by distance\n    key = np.lexsort((d2, open_t))\n    return int(cand[key[0]])\n\n",
  "earliest_open_time_then_shortest_travel_aug_296": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Variable renaming\n    dist_mat = np.asarray(distance_matrix, dtype=float)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = np.asarray(dist_mat[current_node, candidates], dtype=float)\n    start = np.maximum(t + d + 1e-12, time_windows[candidates, 0].astype(float))\n\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1].astype(float))\n\n    if not np.any(feas):\n        return int(depot)\n\n    cand = candidates[feas]\n    open_t = time_windows[cand, 0].astype(float)\n    d2 = np.clip(dist_mat[current_node, cand].astype(float), 0, None)\n\n    # Weighted score: 60% open time, 40% distance\n    score = 0.6 * open_t + 0.4 * d2 + np.arange(len(cand)) * 1e-6\n\n    # Softmin selection with temperature 1.0\n    exp_neg = np.exp(-score / 1.0)\n    denom = np.sum(exp_neg) + 1e-12  # epsilon to avoid division by zero\n    probs = exp_neg / denom\n    idx = np.argmax(probs)\n\n    return int(cand[idx])\n\n",
  "earliest_open_time_then_shortest_travel_aug_297": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for clarity\n    dist_mat = np.asarray(distance_matrix, dtype=float)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = np.asarray(dist_mat[current_node, candidates], dtype=float)\n    start = np.maximum(t + d + 1e-12, time_windows[candidates, 0].astype(float))\n\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1].astype(float))\n\n    if not np.any(feas):\n        return int(depot)\n\n    cand = candidates[feas]\n    d2 = np.clip(dist_mat[current_node, cand].astype(float), 0, None)\n\n    # Median distance and absolute deviation\n    median_dist = np.median(d2)\n    dist_diff = np.abs(d2 - median_dist) + np.arange(len(cand)) * 1e-6\n\n    # Random choice among the 5 best candidates (deterministic RNG)\n    top_k = min(5, len(dist_diff))\n    top_indices = np.argpartition(dist_diff, top_k - 1)[:top_k]\n    rng = np.random.default_rng(0)\n    chosen = rng.choice(top_indices)\n\n    return int(cand[chosen])\n\n",
  "min_due_minus_start_gap_aug_298": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand_nodes = np.asarray(unvisited_nodes, dtype=int)\n    if cand_nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[current_node, cand_nodes].astype(float)\n    arrival = t + dists\n    start_times = np.maximum(arrival, time_windows[cand_nodes, 0].astype(float))\n    slack = np.clip(time_windows[cand_nodes, 1].astype(float) - start_times, 0, None)\n\n    feasible_mask = (demands[cand_nodes] <= cap) & (slack >= 0)\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feasible_nodes = cand_nodes[feasible_mask]\n    dists_feas = distance_matrix[current_node, feasible_nodes].astype(float)\n    start_feas = np.maximum(t + dists_feas, time_windows[feasible_nodes, 0].astype(float))\n    slack_feas = np.clip(time_windows[feasible_nodes, 1].astype(float) - start_feas, 0, None)\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(len(feasible_nodes))\n    key = np.lexsort((dists_feas + noise, slack_feas))\n    return int(feasible_nodes[key[0]])\n\n",
  "min_due_minus_start_gap_aug_299": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand_nodes = np.asarray(unvisited_nodes, dtype=int)\n    if cand_nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[current_node, cand_nodes].astype(float)\n    arrival = t + dists\n    start_times = np.maximum(arrival, time_windows[cand_nodes, 0].astype(float))\n    slack = np.clip(time_windows[cand_nodes, 1].astype(float) - start_times, 0, None)\n\n    feasible_mask = (demands[cand_nodes] <= cap) & (slack >= 0)\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feasible_nodes = cand_nodes[feasible_mask]\n    dists_feas = distance_matrix[current_node, feasible_nodes].astype(float)\n    start_feas = np.maximum(t + dists_feas, time_windows[feasible_nodes, 0].astype(float))\n    slack_feas = np.clip(time_windows[feasible_nodes, 1].astype(float) - start_feas, 0, None)\n\n    # weighted score: distance vs remaining slack\n    w_dist, w_slack = 0.6, 0.4\n    max_dist = np.max(dists_feas) + 1e-12\n    max_slack = np.max(slack_feas) + 1e-12\n    score = (w_dist * dists_feas / max_dist +\n             w_slack * (max_slack - slack_feas) / max_slack)\n\n    # choose among the best k candidates\n    sorted_idx = np.argsort(score)\n    top_k = min(7, len(sorted_idx))\n    top_indices = sorted_idx[:top_k]\n\n    # soft\u2011min probabilities\n    temp = 0.5 + 1e-12\n    probs = np.exp(-score[top_indices] / temp)\n    probs = probs / (np.sum(probs) + 1e-12)\n\n    chosen = np.random.choice(top_indices, p=probs)\n    return int(feasible_nodes[chosen])\n\n",
  "min_due_minus_start_gap_aug_300": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand_nodes = np.asarray(unvisited_nodes, dtype=int)\n    if cand_nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[current_node, cand_nodes].astype(float)\n    arrival = t + dists\n    start_times = np.maximum(arrival, time_windows[cand_nodes, 0].astype(float))\n    slack = np.clip(time_windows[cand_nodes, 1].astype(float) - start_times, 0, None)\n\n    feasible_mask = (demands[cand_nodes] <= cap) & (slack >= 0)\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feasible_nodes = cand_nodes[feasible_mask]\n    dists_feas = distance_matrix[current_node, feasible_nodes].astype(float)\n    start_feas = np.maximum(t + dists_feas, time_windows[feasible_nodes, 0].astype(float))\n    slack_feas = np.clip(time_windows[feasible_nodes, 1].astype(float) - start_feas, 0, None)\n\n    # proxy approximations\n    dists_sq = dists_feas ** 2\n    slack_median = np.median(slack_feas) + 1e-12\n\n    # composite score\n    score = (dists_sq / (np.max(dists_sq) + 1e-12) +\n             (slack_median - slack_feas) / (slack_median + 1e-12))\n\n    # random tie\u2011breaking noise\n    noise = np.random.uniform(0, 1e-5, size=len(feasible_nodes))\n    key = np.lexsort((score + noise, slack_feas))\n    return int(feasible_nodes[key[0]])\n\n",
  "maximize_depot_return_margin_after_visit_aug_301": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # ------------- rename variables for readability -----------------\n    dist_mat   = np.asarray(distance_matrix, dtype=float)\n    cand_nodes = np.asarray(unvisited_nodes, dtype=int)\n    rest_cap   = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time   = float(np.asarray(current_time).reshape(-1)[0])\n    dem        = np.asarray(demands, dtype=float)\n    tw         = np.asarray(time_windows, dtype=float)\n\n    # ------------- early exit ---------------------------------------\n    if cand_nodes.size == 0:\n        return int(depot)\n\n    # ------------- feasibility check --------------------------------\n    d_to_cand      = dist_mat[current_node, cand_nodes]\n    earliest_start = np.maximum(cur_time + d_to_cand, tw[cand_nodes, 0])\n    # clip to upper window to avoid overflow\n    earliest_start = np.clip(earliest_start, tw[cand_nodes, 0], tw[cand_nodes, 1])\n    feasible = (dem[cand_nodes] <= rest_cap) & (earliest_start <= tw[cand_nodes, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    cand = cand_nodes[feasible]\n    d_to_cand   = d_to_cand[feasible]\n    earliest_start = earliest_start[feasible]\n\n    # ------------- compute margin to depot --------------------------\n    if depot < tw.shape[0]:\n        depot_due = float(tw[depot, 1])\n    else:\n        depot_due = np.inf\n\n    back_to_depot = dist_mat[cand, depot]\n    # margin = depot_due - (start + back)\n    margin = depot_due - (earliest_start + back_to_depot)\n    # clip margin to avoid overflow in exp\n    margin = np.clip(margin, -1e3, 1e3)\n\n    # ------------- soft\u2011min scoring ---------------------------------\n    # weights (tuned)\n    w_margin = 0.7\n    w_dist   = 0.3\n    scale    = 10.0 + 1e-12          # epsilon to avoid division by zero\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(cand.size, dtype=float)\n\n    # compute soft\u2011min score: higher score => more preferable\n    score = np.exp(- (w_margin * margin + w_dist * d_to_cand) / scale) + noise\n    idx   = np.argmax(score)\n    return int(cand[idx])\n\n",
  "maximize_depot_return_margin_after_visit_aug_302": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for clarity\n    dist_mat = np.asarray(distance_matrix, dtype=float)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n    dem = np.asarray(demands, dtype=float)\n    tw = np.asarray(time_windows, dtype=float)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    # distances and start times\n    d_to_cand = dist_mat[current_node, candidates]\n    start = np.maximum(t0 + d_to_cand, tw[candidates, 0])\n    start = np.clip(start, tw[candidates, 0], tw[candidates, 1])  # clip upper bound\n    feasible = (dem[candidates] <= cap0) & (start <= tw[candidates, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    cand = candidates[feasible]\n    d_to_cand = d_to_cand[feasible]\n    start = start[feasible]\n\n    # depot deadline\n    depot_due = float(tw[depot, 1]) if depot < tw.shape[0] else np.inf\n    back_to_depot = dist_mat[cand, depot]\n    margin = depot_due - (start + back_to_depot)\n    margin = np.clip(margin, -1e3, 1e3)\n\n    # weighted score (higher is better)\n    w_margin = 0.6\n    w_dist   = 0.4\n    score = w_margin * margin - w_dist * d_to_cand\n    score = np.clip(score, -1e6, 1e6)  # avoid overflow\n\n    # top\u2011k selection\n    top_k = 7\n    if cand.size <= top_k:\n        top_idx = np.argsort(-score)\n    else:\n        top_idx = np.argpartition(-score, top_k)[:top_k]\n        top_idx = top_idx[np.argsort(-score[top_idx])]\n\n    # deterministic tie\u2011breaking by adding small noise\n    noise = 1e-6 * np.arange(len(top_idx), dtype=float)\n    best = top_idx[np.argmax(score[top_idx] + noise)]\n    return int(cand[best])\n\n",
  "maximize_depot_return_margin_after_visit_aug_303": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # variable renaming\n    dist_mat = np.asarray(distance_matrix, dtype=float)\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n    dem = np.asarray(demands, dtype=float)\n    tw = np.asarray(time_windows, dtype=float)\n\n    if nodes.size == 0:\n        return int(depot)\n\n    d_to_nodes = dist_mat[current_node, nodes]\n    start = np.maximum(t0 + d_to_nodes, tw[nodes, 0])\n    start = np.clip(start, tw[nodes, 0], tw[nodes, 1])\n    feasible = (dem[nodes] <= cap0) & (start <= tw[nodes, 1])\n\n    if not np.any(feasible):\n        return int(depot)\n\n    cand = nodes[feasible]\n    d_to_cand = d_to_nodes[feasible]\n    start = start[feasible]\n\n    # compute return distance\n    back = dist_mat[cand, depot]\n    # total cost (distance to node + back to depot)\n    cost = d_to_cand + back\n    cost = cost + 1e-12  # epsilon to avoid division by zero\n\n    # clip cost to avoid overflow in exp\n    cost = np.clip(cost, 0, 1e3)\n\n    # soft\u2011max selection\n    scale = 5.0 + 1e-12\n    logits = -cost / scale\n    exp_logits = np.exp(logits)\n    probs = exp_logits / (np.sum(exp_logits) + 1e-12)\n\n    # deterministic tie\u2011break by adding a tiny offset\n    offset = 1e-8 * np.arange(cand.size, dtype=float)\n    probs = probs + offset\n    probs = probs / (np.sum(probs) + 1e-12)\n\n    idx = np.argmax(probs)\n    return int(cand[idx])\n\n",
  "two_stage_filter_by_open_quantile_then_demand_aug_304": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cur = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    if cand.size == 0:\n        return dep\n\n    rem_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists          = distance_matrix[cur, cand].astype(float)\n    earliest_arr   = np.maximum(cur_t + dists, time_windows[cand, 0].astype(float))\n    feasible       = (demands[cand] <= rem_cap) & (earliest_arr <= time_windows[cand, 1])\n\n    if np.all(~feasible):\n        return dep\n\n    feas_cand = cand[feasible]\n    opens     = time_windows[feas_cand, 0].astype(float)\n    thr       = float(np.quantile(opens, 0.40)) if feas_cand.size > 1 else float(opens[0])\n    thr       = np.clip(thr, 0, np.inf)  # bound to avoid invalid values\n\n    filt = feas_cand[opens <= thr]\n    if filt.size == 0:\n        filt = feas_cand\n\n    # Add deterministic noise for stable tie\u2011breaking\n    noise = np.arange(filt.size, dtype=float) * 1e-6\n\n    dem_vals = demands[filt].astype(float)\n    dist_vals = distance_matrix[cur, filt].astype(float)\n\n    # Lexicographic sort: distance (primary), -demand (secondary), noise (tertiary)\n    keys = np.lexsort((noise, -dem_vals, dist_vals))\n    return int(filt[keys[0]])\n\n",
  "two_stage_filter_by_open_quantile_then_demand_aug_305": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cur = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    if cand.size == 0:\n        return dep\n\n    rem_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists          = distance_matrix[cur, cand].astype(float)\n    earliest_arr   = np.maximum(cur_t + dists, time_windows[cand, 0].astype(float))\n    feasible       = (demands[cand] <= rem_cap) & (earliest_arr <= time_windows[cand, 1])\n\n    if np.all(~feasible):\n        return dep\n\n    feas_cand = cand[feasible]\n    opens     = time_windows[feas_cand, 0].astype(float)\n    thr       = float(np.quantile(opens, 0.50)) if feas_cand.size > 1 else float(opens[0])\n    thr       = np.clip(thr, 0, np.inf)\n\n    filt = feas_cand[opens <= thr]\n    if filt.size == 0:\n        filt = feas_cand\n\n    dist_f  = distance_matrix[cur, filt].astype(float)\n    dem_f   = demands[filt].astype(float)\n\n    # Normalise to [0,1] with epsilon to avoid division by zero\n    dist_norm = (dist_f - dist_f.min()) / (dist_f.ptp() + 1e-12)\n    dem_norm  = (dem_f - dem_f.min()) / (dem_f.ptp() + 1e-12)\n\n    # Weighted score (lower is better)\n    alpha, beta = 0.6, 0.4\n    scores = alpha * dist_norm + beta * dem_norm\n\n    # Soft\u2011min probabilities\n    temp = 1.0\n    exp_neg = np.exp(-scores / (temp + 1e-12))\n    probs   = exp_neg / (exp_neg.sum() + 1e-12)\n\n    # Randomly choose among the top\u2011k candidates\n    top_k = min(5, filt.size)\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    top_probs   = probs[top_indices]\n    chosen_idx  = np.random.choice(top_indices, p=top_probs / (top_probs.sum() + 1e-12))\n\n    return int(filt[chosen_idx])\n\n",
  "two_stage_filter_by_open_quantile_then_demand_aug_306": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cur = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    if cand.size == 0:\n        return dep\n\n    rem_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists          = distance_matrix[cur, cand].astype(float)\n    earliest_arr   = np.maximum(cur_t + dists, time_windows[cand, 0].astype(float))\n    feasible       = (demands[cand] <= rem_cap) & (earliest_arr <= time_windows[cand, 1])\n\n    if np.all(~feasible):\n        return dep\n\n    feas_cand = cand[feasible]\n    opens     = time_windows[feas_cand, 0].astype(float)\n    thr       = float(np.median(opens)) if feas_cand.size > 1 else float(opens[0])\n    thr       = np.clip(thr, 0, np.inf)\n\n    filt = feas_cand[opens <= thr]\n    if filt.size == 0:\n        filt = feas_cand\n\n    dist_f = distance_matrix[cur, filt].astype(float)\n    dem_f  = demands[filt].astype(float)\n\n    # Lexicographic order: distance (primary), demand (secondary)\n    order = np.lexsort((dem_f, dist_f))\n\n    # Randomly pick among the first `top_k` candidates\n    top_k = min(10, filt.size)\n    top_indices = order[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n\n    return int(filt[chosen_idx])\n\n",
  "min_detour_minus_wait_credit_aug_307": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- local aliases ----------------------------------------------------\n    cur   = int(current_node)\n    dep   = int(depot)\n    cand  = np.asarray(unvisited_nodes, dtype=int)\n    cap   = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_now = float(np.asarray(current_time).reshape(-1)[0])\n\n    if cand.size == 0:\n        return dep\n\n    # --- compute distances and arrival times ----------------------------\n    d_cur_to_cand = distance_matrix[cur, cand].astype(float)\n    arr_time      = t_now + d_cur_to_cand\n    wait_time     = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr_time)\n    wait_time     = np.clip(wait_time, 0.0, 1e6)            # safety clip\n    start_time    = arr_time + wait_time\n\n    # --- feasibility mask ------------------------------------------------\n    feas_mask = (demands[cand] <= cap) & (start_time <= time_windows[cand, 1])\n    if not np.any(feas_mask):\n        return dep\n\n    feas_cand   = cand[feas_mask]\n    d_cur_to_f  = distance_matrix[cur, feas_cand].astype(float)\n    d_f_to_dep  = distance_matrix[feas_cand, dep].astype(float)\n    direct_dist = float(distance_matrix[cur, dep])\n\n    # --- scoring ---------------------------------------------------------\n    detour = d_cur_to_f + d_f_to_dep - direct_dist\n    beta   = 0.6                          # tuned hyper\u2011parameter\n    wait_start = np.maximum(0.0,\n                            time_windows[feas_cand, 0].astype(float) -\n                            (t_now + d_cur_to_f))\n    noise = 1e-6 * np.arange(detour.size)   # deterministic tie\u2011breaker\n    score = detour - beta * wait_start + noise\n\n    # --- select best -----------------------------------------------------\n    return int(feas_cand[int(np.argmin(score))])\n\n",
  "min_detour_minus_wait_credit_aug_308": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- local aliases ----------------------------------------------------\n    node    = int(current_node)\n    dep_id  = int(depot)\n    nodes   = np.asarray(unvisited_nodes, dtype=int)\n    cap     = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_now   = float(np.asarray(current_time).reshape(-1)[0])\n\n    if nodes.size == 0:\n        return dep_id\n\n    # --- distances and waiting ------------------------------------------\n    d_node_to_nodes = distance_matrix[node, nodes].astype(float)\n    arr_time        = t_now + d_node_to_nodes\n    wait_time       = np.maximum(0.0, time_windows[nodes, 0].astype(float) - arr_time)\n    wait_time       = np.clip(wait_time, 0.0, 1e6)            # safety clip\n    start_time      = arr_time + wait_time\n\n    # --- feasibility mask ------------------------------------------------\n    feas_mask = (demands[nodes] <= cap) & (start_time <= time_windows[nodes, 1])\n    if not np.any(feas_mask):\n        return dep_id\n\n    feas_nodes   = nodes[feas_mask]\n    d_node_to_f  = distance_matrix[node, feas_nodes].astype(float)\n    d_f_to_dep   = distance_matrix[feas_nodes, dep_id].astype(float)\n    direct_dist  = float(distance_matrix[node, dep_id])\n\n    # --- scoring ---------------------------------------------------------\n    detour = d_node_to_f + d_f_to_dep - direct_dist\n    beta   = 0.8\n    wait_start = np.maximum(0.0,\n                            time_windows[feas_nodes, 0].astype(float) -\n                            (t_now + d_node_to_f))\n    score = detour - beta * wait_start\n\n    # --- soft\u2011min probabilities -----------------------------------------\n    temp  = 0.5\n    exp_vals = np.exp(-score / (temp + 1e-12))          # epsilon to avoid div\u2011by\u2011zero\n    probs   = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # --- pick from top\u2011k --------------------------------------------------\n    top_k = 5\n    if feas_nodes.size <= top_k:\n        top_idx = np.arange(feas_nodes.size)\n    else:\n        top_idx = np.argpartition(score, feas_nodes.size - top_k)[-top_k:]\n\n    top_probs = probs[top_idx]\n    top_probs = top_probs / (np.sum(top_probs) + 1e-12)  # epsilon\n\n    rng = np.random.default_rng(seed=42)\n    chosen = rng.choice(feas_nodes[top_idx], p=top_probs)\n    return int(chosen)\n\n",
  "min_detour_minus_wait_credit_aug_309": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cur      = int(current_node)\n    dep      = int(depot)\n    cand     = np.asarray(unvisited_nodes, dtype=int)\n    cap      = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_now    = float(np.asarray(current_time).reshape(-1)[0])\n\n    if cand.size == 0:\n        return dep\n\n    best_idx   = -1\n    best_score = np.inf\n    direct     = float(distance_matrix[cur, dep])\n\n    for i in range(cand.size):\n        c = int(cand[i])\n\n        # distances\n        d_cur_to_c = float(distance_matrix[cur, c])\n        d_c_to_dep = float(distance_matrix[c, dep])\n\n        # arrival & waiting\n        arr = t_now + d_cur_to_c\n        wait = max(0.0, float(time_windows[c, 0]) - arr)\n        wait = np.clip(wait, 0.0, 1e6)                   # safety clip\n        start = arr + wait\n\n        # feasibility\n        if demands[c] > cap or start > time_windows[c, 1]:\n            continue\n\n        # scoring\n        detour = d_cur_to_c + d_c_to_dep - direct\n        beta   = 0.5\n        score  = detour - beta * wait\n\n        # deterministic noise for tie\u2011breaking\n        noise  = 1e-7 * i\n        score += noise\n\n        if score < best_score:\n            best_score = score\n            best_idx   = i\n\n    if best_idx == -1:\n        return dep\n    return int(cand[best_idx])\n\n",
  "min_bottleneck_to_k_nearest_aug_310": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distance from the current node to every candidate\n    dist_to_cand = distance_matrix[current_node, candidates]\n    earliest_arrival = np.maximum(t0 + dist_to_cand, time_windows[candidates, 0])\n\n    # Feasibility test\n    feasible_mask = (demands[candidates] <= cap) & (earliest_arrival <= time_windows[candidates, 1])\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feas_cands = candidates[feasible_mask]\n    top_k = min(5, feas_cands.size)\n\n    # Pairwise distance matrix among feasible candidates\n    pairwise = distance_matrix[feas_cands[:, None], feas_cands]\n    pairwise = np.clip(pairwise, 0, None)          # safety clip\n\n    # For each candidate find the k nearest neighbours (excluding self)\n    idx_sorted = np.argsort(pairwise, axis=1)\n    nearest_k = idx_sorted[:, 1:top_k + 1]         # skip index 0 (self)\n    bottleneck = np.max(pairwise[np.arange(nearest_k.shape[0])[:, None], nearest_k], axis=1)\n\n    # Distance from current node to each feasible candidate\n    dist_current = dist_to_cand[feasible_mask]\n\n    # Lexicographic ordering: first bottleneck, then distance\n    order = np.lexsort((dist_current, bottleneck))\n    chosen = feas_cands[order[0]]\n    return int(chosen)\n\n",
  "min_bottleneck_to_k_nearest_aug_311": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_cur = distance_matrix[current_node, cand]\n    start = np.maximum(t0 + dist_cur, time_windows[cand, 0])\n    feas = (demands[cand] <= cap) & (start <= time_windows[cand, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_cand = cand[feas]\n    top_k = min(7, feas_cand.size)\n\n    # Bottleneck distances among feasible nodes\n    pair = distance_matrix[feas_cand[:, None], feas_cand]\n    pair = np.clip(pair, 0, None)\n    idx = np.argsort(pair, axis=1)\n    nearest_k = idx[:, 1:top_k + 1]\n    bott = np.max(pair[np.arange(nearest_k.shape[0])[:, None], nearest_k], axis=1)\n\n    dist_f = dist_cur[feas]\n    # Weighted score\n    alpha = 0.6\n    score = alpha * dist_f + (1 - alpha) * bott\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(score.size)\n    score_noisy = score + noise\n\n    # Soft\u2011min probabilities\n    eps = 1e-12\n    exp_neg = np.exp(-score_noisy / (np.mean(score_noisy) + eps))\n    probs = exp_neg / (np.sum(exp_neg) + eps)\n\n    chosen_idx = np.random.choice(score_noisy.size, p=probs)\n    return int(feas_cand[chosen_idx])\n\n",
  "min_bottleneck_to_k_nearest_aug_312": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_curr = distance_matrix[current_node, candidates]\n    earliest = np.maximum(t0 + dist_curr, time_windows[candidates, 0])\n    feas = (demands[candidates] <= cap) & (earliest <= time_windows[candidates, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    feas_cand = candidates[feas]\n\n    # Median bottleneck distances among feasible candidates\n    pair = distance_matrix[feas_cand[:, None], feas_cand]\n    pair = np.clip(pair, 0, None)\n    # Replace self distances with infinity to exclude them from median\n    self_mask = np.eye(pair.shape[0], dtype=bool)\n    pair[self_mask] = np.inf\n    bottleneck_median = np.median(pair, axis=1)\n\n    dist_f = dist_curr[feas]\n    scores = bottleneck_median + dist_f\n\n    top_k = min(5, scores.size)\n    top_indices = np.argpartition(scores, top_k - 1)[:top_k]\n\n    # Deterministic noise to break ties\n    noise = 1e-7 * np.arange(scores.size)\n    scores_noisy = scores + noise\n\n    chosen = np.random.choice(top_indices)\n    return int(feas_cand[chosen])\n\n",
  "deadline_alignment_with_neighborhood_aug_313": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- Prepare data ---------------------------------------------------------\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Current travel distances to all candidates\n    dcur = distance_matrix[int(current_node), candidates].astype(float)\n\n    # Earliest feasible start times respecting time windows\n    start = np.maximum(t0 + dcur, time_windows[candidates, 0].astype(float))\n\n    # Feasibility mask\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = candidates[feas]\n    top_k = int(min(7, cand.size))\n\n    # --- Alignment computation -----------------------------------------------\n    due_all = time_windows[candidates, 1].astype(float)\n    align   = np.empty(cand.size, dtype=float)\n\n    for i, u in enumerate(cand):\n        # Distances from u to all candidates\n        dist_u = distance_matrix[int(u), candidates].astype(float)\n        # Indices of the k nearest neighbours (excluding u itself)\n        idx = np.argpartition(dist_u, top_k)[:top_k]\n        neigh_due_median = float(np.median(due_all[idx]))\n        align[i] = abs(float(time_windows[int(u), 1]) - neigh_due_median)\n\n    # Add small deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(0, 1e-6, size=align.shape)\n    align += noise\n\n    # --- Final selection ------------------------------------------------------\n    d2   = np.clip(distance_matrix[int(current_node), cand].astype(float), 0, None)\n    key  = np.lexsort((d2, align))          # align primary, distance secondary\n    return int(cand[int(key[0])])\n\n",
  "deadline_alignment_with_neighborhood_aug_314": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- Initial feasibility check ------------------------------------------\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), candidates].astype(float)\n    start = np.maximum(t0 + dcur, time_windows[candidates, 0].astype(float))\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = candidates[feas]\n    top_k = int(min(5, cand.size))\n\n    # --- Compute alignment using mean of nearest neighbours ------------------\n    due_all = time_windows[cand, 1].astype(float)\n    align   = np.empty(cand.size, dtype=float)\n\n    for i, u in enumerate(cand):\n        dist_u = distance_matrix[int(u), cand].astype(float)\n        idx = np.argpartition(dist_u, top_k)[:top_k]\n        neigh_due_mean = float(np.mean(due_all[idx]) + 1e-12)   # epsilon\n        align[i] = abs(float(time_windows[int(u), 1]) - neigh_due_mean)\n\n    # --- Soft\u2011minimum scoring -------------------------------------------------\n    d2 = np.clip(distance_matrix[int(current_node), cand].astype(float), 0, None)\n    # Weighted sum: 60% distance, 40% alignment\n    score = 0.6 * d2 + 0.4 * align\n\n    # Select the best top_k candidates\n    sorted_idx = np.argsort(score)\n    best_k_idx = sorted_idx[:top_k]\n\n    # Randomly pick one among the best\n    chosen = np.random.choice(best_k_idx)\n    return int(cand[chosen])\n\n",
  "deadline_alignment_with_neighborhood_aug_315": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # --- Basic setup ---------------------------------------------------------\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), candidates].astype(float)\n    start = np.maximum(t0 + dcur, time_windows[candidates, 0].astype(float))\n    feas = (demands[candidates] <= cap) & (start <= time_windows[candidates, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = candidates[feas]\n    top_k = int(min(5, cand.size))\n\n    # --- Alignment using sum of nearest neighbours --------------------------\n    due_all = time_windows[cand, 1].astype(float)\n\n    def neigh_sum(u_idx):\n        dist_u = distance_matrix[int(cand[u_idx]), cand].astype(float)\n        idx = np.argpartition(dist_u, top_k)[:top_k]\n        return float(np.sum(due_all[idx]) + 1e-12)   # epsilon\n\n    align = np.array([abs(float(time_windows[int(cand[i]), 1]) - neigh_sum(i))\n                      for i in range(cand.size)])\n\n    # Add a tiny noise for deterministic tie\u2011breaking\n    align += np.random.uniform(0, 1e-6, size=align.shape)\n\n    # --- Final scoring: distance + alignment --------------------------------\n    d2 = np.clip(distance_matrix[int(current_node), cand].astype(float), 0, None)\n    score = d2 + align\n\n    # Find minimal score(s)\n    min_val = np.min(score)\n    best_idx = np.where(np.isclose(score, min_val, atol=1e-12))[0]\n\n    # Randomly choose among ties\n    chosen = np.random.choice(best_idx)\n    return int(cand[chosen])\n\n",
  "capacity_smoothing_to_median_remaining_demand_aug_316": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dep = int(depot)\n    cur_node = int(current_node)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return dep\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[cur_node, cand]\n    start = np.maximum(t0 + dcur, time_windows[cand, 0])\n    feas = (demands[cand] <= cap0) & (start <= time_windows[cand, 1])\n\n    if not np.any(feas):\n        return dep\n\n    feas_cand = cand[feas]\n    med_dem = float(np.median(demands[cand].astype(float))) if cand.size > 0 else 0.0\n\n    postcap = cap0 - demands[feas_cand].astype(float)\n    diff = np.abs(postcap - med_dem)\n    dist = distance_matrix[cur_node, feas_cand].astype(float)\n\n    weight = 0.6\n    score = dist + weight * diff\n    # deterministic tie\u2011breaker\n    noise = np.arange(score.size) * 1e-6\n    score += noise\n    idx = np.argmin(score)\n    return int(feas_cand[idx])\n\n",
  "capacity_smoothing_to_median_remaining_demand_aug_317": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dep = int(depot)\n    cur_node = int(current_node)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return dep\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[cur_node, cand]\n    start = np.maximum(t0 + dcur, time_windows[cand, 0])\n    feas = (demands[cand] <= cap0) & (start <= time_windows[cand, 1])\n\n    if not np.any(feas):\n        return dep\n\n    feas_cand = cand[feas]\n    med_dem = float(np.median(demands[cand].astype(float))) if cand.size > 0 else 0.0\n\n    postcap = cap0 - demands[feas_cand].astype(float)\n    diff = np.abs(postcap - med_dem)\n    dist = distance_matrix[cur_node, feas_cand].astype(float)\n\n    weight = 0.4\n    dist_clipped = np.clip(dist, 0, 1e6)\n    score = dist_clipped + weight * diff\n\n    top_k = 5\n    if score.size <= top_k:\n        idxs = np.argsort(score)\n    else:\n        idxs = np.argpartition(score, top_k)[:top_k]\n        idxs = idxs[np.argsort(score[idxs])]\n    chosen_idx = np.random.choice(idxs)\n    return int(feas_cand[chosen_idx])\n\n",
  "capacity_smoothing_to_median_remaining_demand_aug_318": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dep = int(depot)\n    cur_node = int(current_node)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return dep\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[cur_node, cand]\n    start = np.maximum(t0 + dcur, time_windows[cand, 0])\n    feas = (demands[cand] <= cap0) & (start <= time_windows[cand, 1])\n\n    if not np.any(feas):\n        return dep\n\n    feas_cand = cand[feas]\n    mean_dem = float(np.mean(demands[cand].astype(float))) if cand.size > 0 else 0.0\n\n    postcap = cap0 - demands[feas_cand].astype(float)\n    diff = np.abs(postcap - mean_dem)\n    dist = distance_matrix[cur_node, feas_cand].astype(float)\n\n    weight = 0.5\n    score = dist + weight * diff\n\n    temp = 1.0\n    exp_score = np.exp(-score / (temp + 1e-12))\n    probs = exp_score / (np.sum(exp_score) + 1e-12)\n    chosen_idx = np.random.choice(len(probs), p=probs)\n    return int(feas_cand[chosen_idx])\n\n",
  "maximize_slack_minus_distance_penalty_aug_319": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # travel distances from current node to all candidates\n    dist = np.asarray(distance_matrix[current_node, candidates], dtype=float)\n\n    # earliest possible arrival times respecting time windows\n    earliest = np.maximum(t + dist, time_windows[candidates, 0].astype(float))\n\n    # slack available after arrival\n    slack = np.clip(time_windows[candidates, 1].astype(float) - earliest,\n                    a_min=0, a_max=None)\n\n    # feasibility: enough capacity and non\u2011negative slack\n    feas_mask = (demands[candidates] <= cap) & (slack > 0)\n    if not feas_mask.any():          # inverted logic\n        return int(depot)\n\n    feasible = candidates[feas_mask]\n    dist_f   = np.asarray(distance_matrix[current_node, feasible], dtype=float)\n    earliest_f = np.maximum(t + dist_f, time_windows[feasible, 0].astype(float))\n    slack_f   = np.clip(time_windows[feasible, 1].astype(float) - earliest_f,\n                        a_min=0, a_max=None)\n\n    alpha = 0.35\n    score = slack_f - alpha * dist_f\n    idx   = int(np.argmax(score))\n    return int(feasible[idx])\n\n",
  "maximize_slack_minus_distance_penalty_aug_320": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # vectorised core\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = np.asarray(distance_matrix[current_node, cand], dtype=float)\n    arrival = np.maximum(t + dist, time_windows[cand, 0].astype(float))\n    slack = np.clip(time_windows[cand, 1].astype(float) - arrival,\n                    a_min=0, a_max=None)\n\n    feas_mask = (demands[cand] <= cap) & (slack > 0)\n    if not feas_mask.any():\n        return int(depot)\n\n    feas_idx = cand[feas_mask]\n    dist_f = np.asarray(distance_matrix[current_node, feas_idx], dtype=float)\n    arrival_f = np.maximum(t + dist_f, time_windows[feas_idx, 0].astype(float))\n    slack_f = np.clip(time_windows[feas_idx, 1].astype(float) - arrival_f,\n                      a_min=0, a_max=None)\n\n    # tuned parameters\n    alpha = 0.5\n    noise = np.random.uniform(0, 1e-6, size=slack_f.shape)\n    score = slack_f - alpha * dist_f + noise\n\n    # top\u2011k selection\n    top_k = 7\n    if score.size > top_k:\n        top_indices = np.argpartition(-score, top_k - 1)[:top_k]\n        best_idx = top_indices[np.argmax(score[top_indices])]\n    else:\n        best_idx = np.argmax(score)\n\n    return int(feas_idx[best_idx])\n\n",
  "maximize_slack_minus_distance_penalty_aug_321": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    rng = np.random.default_rng()\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = np.asarray(distance_matrix[current_node, nodes], dtype=float)\n    arrive = np.maximum(t + d, time_windows[nodes, 0].astype(float))\n    slack = np.clip(time_windows[nodes, 1].astype(float) - arrive,\n                    a_min=0, a_max=None)\n\n    feas = (demands[nodes] <= cap) & (slack > 0)\n    if not feas.any():\n        return int(depot)\n\n    feas_nodes = nodes[feas]\n    d_f = np.asarray(distance_matrix[current_node, feas_nodes], dtype=float)\n    arrive_f = np.maximum(t + d_f, time_windows[feas_nodes, 0].astype(float))\n    slack_f = np.clip(time_windows[feas_nodes, 1].astype(float) - arrive_f,\n                      a_min=0, a_max=None)\n\n    # median\u2011based reference and deterministic noise\n    median_slack = np.median(slack_f)\n    alpha = 0.4\n    score = slack_f - alpha * d_f\n\n    # deterministic tie\u2011breaking noise\n    noise = 1e-8 * np.arange(score.size)\n    score = score + noise\n\n    # soft\u2011min probabilities\n    beta = 1.5\n    exp_neg = np.exp(-beta * score)\n    probs = exp_neg / (np.sum(exp_neg) + 1e-12)   # epsilon in denominator\n\n    # random weighted choice\n    chosen_idx = rng.choice(score.size, p=probs)\n    return int(feas_nodes[chosen_idx])\n\n",
  "min_distance_with_deadline_soft_barrier_aug_322": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand_nodes = np.asarray(unvisited_nodes, dtype=int)\n    if cand_nodes.size == 0:\n        return int(depot)\n\n    cap_rem = float(np.asarray(rest_capacity).reshape(-1)[0])\n    time_cur = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_to_cand = distance_matrix[int(current_node), cand_nodes].astype(float)\n    earliest_arrival = np.maximum(time_cur + dist_to_cand,\n                                  time_windows[cand_nodes, 0].astype(float))\n    slack_vals = time_windows[cand_nodes, 1].astype(float) - earliest_arrival\n\n    feasible_mask = (demands[cand_nodes] <= cap_rem) & (slack_vals >= 0)\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feas_nodes = cand_nodes[feasible_mask]\n    dist_feas = distance_matrix[int(current_node), feas_nodes].astype(float)\n    arr_feas = np.maximum(time_cur + dist_feas,\n                          time_windows[feas_nodes, 0].astype(float))\n    slack_feas = time_windows[feas_nodes, 1].astype(float) - arr_feas\n\n    scale = max(1.0, float(np.mean(slack_feas + 1.0)))          # mean instead of median\n    gamma = 1.5                                               # reduced weight on the barrier\n    barrier = np.exp(-slack_feas / (scale + 1e-12))           # epsilon on denominator\n    barrier = np.clip(barrier, 0.0, 1.0)                       # keep barrier in [0,1]\n    score = dist_feas + gamma * barrier\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(score.size)\n    score = score + noise\n    return int(feas_nodes[int(np.argmin(score))])\n\n",
  "min_distance_with_deadline_soft_barrier_aug_323": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap_rem = float(rest_capacity.reshape(-1)[0])\n    time_cur = float(current_time.reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), nodes].astype(float)\n    arr_time = np.maximum(time_cur + dist,\n                          time_windows[nodes, 0].astype(float))\n    slack = time_windows[nodes, 1].astype(float) - arr_time\n\n    feas = (demands[nodes] <= cap_rem) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    feas_nodes = nodes[feas]\n    dist_f = distance_matrix[int(current_node), feas_nodes].astype(float)\n    arr_f = np.maximum(time_cur + dist_f,\n                       time_windows[feas_nodes, 0].astype(float))\n    slack_f = time_windows[feas_nodes, 1].astype(float) - arr_f\n\n    scale = max(1.0, float(np.max(slack_f + 1.0)))           # max instead of median\n    gamma = 2.5                                               # increased weight on the barrier\n    barrier = np.exp(-slack_f / (scale + 1e-12))             # epsilon on denominator\n    barrier = np.clip(barrier, 0.0, 1.0)                       # keep barrier in [0,1]\n    score = dist_f + gamma * barrier\n\n    # choose among the top\u2011k candidates using a soft\u2011min distribution\n    top_k = min(5, score.size)\n    top_indices = np.argpartition(score, top_k)[:top_k]\n    top_scores = score[top_indices]\n    temp = 0.3\n    probs = np.exp(-top_scores / (temp + 1e-12))\n    probs = probs / (np.sum(probs) + 1e-12)                    # avoid division by zero\n    chosen_idx = np.random.choice(top_indices, p=probs)\n    return int(feas_nodes[chosen_idx])\n\n",
  "min_distance_with_deadline_soft_barrier_aug_324": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap_rem = float(rest_capacity.reshape(-1)[0])\n    time_cur = float(current_time.reshape(-1)[0])\n\n    # feasibility via list comprehension\n    feas_list = [(node, dist) for node, dist in zip(\n        cand, distance_matrix[int(current_node), cand].astype(float))\n        if demands[node] <= cap_rem and\n           time_windows[node, 1] - max(time_cur + dist, time_windows[node, 0]) >= 0]\n\n    if not feas_list:\n        return int(depot)\n\n    nodes_feas = np.array([x[0] for x in feas_list], dtype=int)\n    dist_feas = np.array([x[1] for x in feas_list], dtype=float)\n\n    arr_time = np.maximum(time_cur + dist_feas,\n                          time_windows[nodes_feas, 0].astype(float))\n    slack_feas = time_windows[nodes_feas, 1].astype(float) - arr_time\n\n    scale = max(1.0, float(np.max(slack_feas + 1.0)))           # max slack\n    gamma = 3.0                                                   # stronger barrier influence\n    barrier = np.exp(-slack_feas / (scale + 1e-12))\n    barrier = np.clip(barrier, 0.0, 1.0)\n    score = dist_feas + gamma * barrier\n\n    # deterministic top\u2011k selection with noise\n    top_k = min(7, score.size)\n    top_idx = np.argpartition(score, top_k)[:top_k]\n    top_scores = score[top_idx]\n    noise = 1e-9 * np.arange(top_scores.size)\n    top_scores = top_scores + noise\n    chosen_local = top_idx[int(np.argmin(top_scores))]\n    return int(nodes_feas[chosen_local])\n\n",
  "maximize_demand_per_extra_time_budget_aug_325": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    rem_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distances from the current node to all candidates\n    dist_to_cand = np.clip(distance_matrix[int(current_node), candidates].astype(float),\n                           0.0, 1e6)\n\n    arrival = cur_t + dist_to_cand\n    wait    = np.maximum(0.0,\n                         time_windows[candidates, 0].astype(float) - arrival)\n    start_service = arrival + wait\n\n    feasible = (demands[candidates] <= rem_cap) & (\n        start_service <= time_windows[candidates, 1].astype(float))\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cand = candidates[feasible]\n    d2 = np.clip(distance_matrix[int(current_node), feas_cand].astype(float),\n                 0.0, 1e6)\n    arr2 = cur_t + d2\n    wait2 = np.maximum(0.0,\n                       time_windows[feas_cand, 0].astype(float) - arr2)\n    wait2 = np.clip(wait2, 0.0, None)\n\n    eps = 1e-12\n    score = demands[feas_cand].astype(float) / (d2 + wait2 + 1.0 + eps)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-6 * feas_cand\n    score_noisy = score + noise\n\n    # Top\u2011k filtering (k=5)\n    top_k = 5\n    if feas_cand.size <= top_k:\n        best_idx = np.argmax(score_noisy)\n    else:\n        top_indices = np.argpartition(-score_noisy, top_k - 1)[:top_k]\n        best_idx = top_indices[np.argmax(score_noisy[top_indices])]\n\n    return int(feas_cand[best_idx])\n\n",
  "maximize_demand_per_extra_time_budget_aug_326": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    rem_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    best_idx  = -1\n    best_score = np.inf\n\n    for idx in cand:\n        d = np.clip(distance_matrix[int(current_node), idx], 0.0, 1e6)\n        arr = cur_t + d\n        wait = max(0.0, float(time_windows[idx, 0]) - arr)\n        wait = np.clip(wait, 0.0, 1e6)\n        start_service = arr + wait\n\n        if demands[idx] > rem_cap or start_service > float(time_windows[idx, 1]):\n            continue\n\n        # Weighted cost: 0.7 * distance + 0.3 * wait\n        score = 0.7 * d + 0.3 * wait\n\n        # Deterministic tie\u2011breaking\n        score -= 1e-6 * idx\n\n        if score < best_score:\n            best_score = score\n            best_idx = idx\n\n    return int(best_idx if best_idx != -1 else depot)\n\n",
  "maximize_demand_per_extra_time_budget_aug_327": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    rem_cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = np.clip(distance_matrix[int(current_node), cand].astype(float),\n                0.0, 1e6)\n    arrival = cur_t + d\n    wait = np.maximum(0.0,\n                      time_windows[cand, 0].astype(float) - arrival)\n    start_service = arrival + wait\n\n    feasible = (demands[cand] <= rem_cap) & (\n        start_service <= time_windows[cand, 1].astype(float))\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cand = cand[feasible]\n    d2 = np.clip(distance_matrix[int(current_node), feas_cand].astype(float),\n                 0.0, 1e6)\n    arr2 = cur_t + d2\n    wait2 = np.maximum(0.0,\n                       time_windows[feas_cand, 0].astype(float) - arr2)\n    wait2 = np.clip(wait2, 0.0, 1e6)\n\n    eps = 1e-12\n    score = demands[feas_cand].astype(float) / (d2 + wait2 + 1.0 + eps)\n\n    # Deterministic noise to break ties\n    score_noisy = score - 1e-8 * feas_cand\n\n    best_idx = np.argmax(score_noisy)\n    return int(feas_cand[best_idx])\n\n",
  "median_due_time_proximity_then_distance_aug_328": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for readability\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap_rem = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distance from current node to all candidates\n    d_cur = distance_matrix[int(current_node), candidates]\n    # Earliest possible start time respecting the time windows\n    est_start = np.maximum(cur_t + d_cur, time_windows[candidates, 0])\n\n    # Feasibility checks\n    feasible_mask = (demands[candidates] <= cap_rem) & (est_start <= time_windows[candidates, 1])\n\n    # If no feasible node, return to depot\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    # Build list of feasible indices\n    feas_idx = candidates[feasible_mask]\n    # Compute median due time of *all* remaining customers (not just feasible ones)\n    med_due = float(np.median(time_windows[candidates, 1].astype(float)))\n    # Difference to median due time\n    due_diff = np.abs(time_windows[feas_idx, 1].astype(float) - med_due)\n    # Distance from current node to each feasible candidate\n    dist_feas = distance_matrix[int(current_node), feas_idx].astype(float)\n\n    # Invert the ordering: choose the smallest distance first, then\n    # the smallest difference to the median due time.\n    # The lexsort keys are reversed compared to the original function.\n    order = np.lexsort((due_diff, dist_feas))\n    chosen = feas_idx[order[0]]\n\n    return int(chosen)\n\n",
  "median_due_time_proximity_then_distance_aug_329": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Variable renaming\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap_rem = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_cur = distance_matrix[int(current_node), candidates]\n    est_start = np.maximum(cur_t + d_cur, time_windows[candidates, 0])\n\n    feasible_mask = (demands[candidates] <= cap_rem) & (est_start <= time_windows[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feas_idx = candidates[feasible_mask]\n\n    # Tunable weights\n    w_dist = 0.6   # weight for distance\n    w_due  = 0.4   # weight for due\u2011time deviation\n\n    # Median due time of all remaining customers\n    med_due = float(np.median(time_windows[candidates, 1].astype(float)))\n    due_diff = np.abs(time_windows[feas_idx, 1].astype(float) - med_due)\n    dist_feas = distance_matrix[int(current_node), feas_idx].astype(float)\n\n    # Normalise to avoid division by zero \u2013 add epsilon\n    eps = 1e-12\n    norm_dist = dist_feas / (np.max(dist_feas) + eps)\n    norm_due  = due_diff / (np.max(due_diff) + eps)\n\n    # Weighted score: lower is better\n    score = w_dist * norm_dist + w_due * norm_due\n\n    # Clip scores to a reasonable range before sorting\n    score = np.clip(score, 0, np.inf)\n\n    # Keep only the top\u2011k candidates (k=5)\n    k = 5\n    if score.size > k:\n        top_k_idx = np.argpartition(score, k-1)[:k]\n        score = score[top_k_idx]\n        feas_idx = feas_idx[top_k_idx]\n\n    # Select the candidate with the minimal score\n    chosen = feas_idx[np.argmin(score)]\n    return int(chosen)\n\n",
  "median_due_time_proximity_then_distance_aug_330": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Renamed variables\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap_rem = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_cur = distance_matrix[int(current_node), candidates]\n    est_start = np.maximum(cur_t + d_cur, time_windows[candidates, 0])\n\n    feasible_mask = (demands[candidates] <= cap_rem) & (est_start <= time_windows[candidates, 1])\n\n    if not np.any(feasible_mask):\n        return int(depot)\n\n    feas_idx = candidates[feasible_mask]\n\n    # Compute median due time and differences\n    med_due = float(np.median(time_windows[candidates, 1].astype(float)))\n    due_diff = np.abs(time_windows[feas_idx, 1].astype(float) - med_due)\n    dist_feas = distance_matrix[int(current_node), feas_idx].astype(float)\n\n    # Add deterministic noise based on node id to break ties\n    noise = 1e-6 * np.sin(feas_idx.astype(float))\n    due_diff_noisy = due_diff + noise\n    dist_feas_noisy = dist_feas + noise\n\n    # Soft\u2011min score with temperature (epsilon added to temperature)\n    temperature = 0.5 + 1e-12\n    # Normalise distances and due differences\n    eps = 1e-12\n    norm_dist = dist_feas_noisy / (np.max(dist_feas_noisy) + eps)\n    norm_due  = due_diff_noisy / (np.max(due_diff_noisy) + eps)\n\n    # Combined score before softmin\n    score = 0.5 * norm_dist + 0.5 * norm_due\n\n    # Soft\u2011min probabilities\n    exp_vals = np.exp(-score / temperature)\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n    probs = np.clip(probs, 0, 1)\n\n    # Random choice according to probabilities (deterministic seed)\n    rng = np.random.default_rng(seed=42)\n    chosen_idx = rng.choice(feas_idx, p=probs)\n\n    return int(chosen_idx)\n\n",
  "depot_distance_balance_to_remaining_mean_aug_331": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Local aliases for readability\n    dist_mat = distance_matrix\n    tw_arr   = time_windows\n    dem_arr  = demands\n\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distances from current node to all candidates\n    dcur = dist_mat[int(current_node), candidates]\n    # Earliest feasible start times respecting time windows\n    start = np.maximum(t0 + dcur, tw_arr[candidates, 0])\n    # Feasibility: capacity & time window\n    feas = (dem_arr[candidates] <= cap) & (start <= tw_arr[candidates, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    cand = candidates[feas]\n    # Distances from depot to all candidates (used for target)\n    depot_d_all = dist_mat[int(depot), candidates].astype(float)\n    target = float(np.median(depot_d_all)) if depot_d_all.size > 0 else 0.0\n\n    depot_d = dist_mat[int(depot), cand].astype(float)\n    diff    = np.abs(depot_d - target)\n    d2      = dist_mat[int(current_node), cand].astype(float)\n\n    # Soft\u2011min weighting: lower distance & lower deviation from target are preferred\n    alpha = 1.0\n    beta  = 1.0\n    scores = np.exp(-alpha * diff) * np.exp(-beta * d2)\n\n    # Deterministic tie\u2011breaking noise based on candidate indices\n    noise = (cand % 1000) * 1e-9\n    scores += noise\n\n    best_idx = int(np.argmax(scores))\n    return int(cand[best_idx])\n\n",
  "depot_distance_balance_to_remaining_mean_aug_332": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Local aliases for clarity\n    dist_mat = distance_matrix\n    tw_arr   = time_windows\n    dem_arr  = demands\n\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = dist_mat[int(current_node), nodes]\n    start = np.maximum(t0 + dcur, tw_arr[nodes, 0])\n    feas = (dem_arr[nodes] <= cap) & (start <= tw_arr[nodes, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible = nodes[feas]\n    d2 = dist_mat[int(current_node), feasible].astype(float)\n\n    # Waiting time (clipped to zero) and ratio with epsilon to avoid div\u2011by\u2011zero\n    waiting = np.maximum(start[feas] - tw_arr[feasible, 0], 0.0)\n    ratio = waiting / (d2 + 1e-12)\n\n    # Weighted score: 0.6 * distance + 0.4 * ratio\n    scores = 0.6 * d2 + 0.4 * ratio\n\n    # Find the candidate with the minimal score; deterministic tie\u2011break by lower index\n    best_idx = np.argmin(scores)\n    return int(feasible[best_idx])\n\n",
  "depot_distance_balance_to_remaining_mean_aug_333": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Local aliases\n    dist_mat = distance_matrix\n    tw_arr   = time_windows\n    dem_arr  = demands\n\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0  = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = dist_mat[int(current_node), nodes]\n    start = np.maximum(t0 + dcur, tw_arr[nodes, 0])\n    feas = (dem_arr[nodes] <= cap) & (start <= tw_arr[nodes, 1])\n\n    if not np.any(feas):\n        return int(depot)\n\n    feasible = nodes[feas]\n    dist_to_depot   = dist_mat[int(depot), feasible].astype(float)\n    dist_to_current = dist_mat[int(current_node), feasible].astype(float)\n\n    # Capacity ratio (clipped between 0 and 1) and epsilon in denominator\n    cap_ratio = np.clip(dem_arr[feasible] / (cap + 1e-12), 0.0, 1.0)\n\n    # Composite score: 0.7 * depot distance + 0.3 * current distance + 0.1 * capacity ratio\n    scores = 0.7 * dist_to_depot + 0.3 * dist_to_current + 0.1 * cap_ratio\n\n    # Select top_k candidates with lowest scores\n    top_k = 7\n    if feasible.size <= top_k:\n        candidates = feasible\n    else:\n        idx_sorted = np.argsort(scores)\n        candidates = feasible[idx_sorted[:top_k]]\n\n    # Deterministic random choice using a seed derived from state\n    seed = int((current_node + depot) % (2**32 - 1))\n    rng = np.random.default_rng(seed)\n    chosen = rng.choice(candidates)\n    return int(chosen)\n\n",
  "min_distance_with_postcap_parity_aug_334": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distance from current node to all candidates\n    dists = distance_matrix[current_node, candidates].astype(float)\n\n    # Earliest feasible start time respecting time windows\n    earliest_start = np.maximum(t0 + dists, time_windows[candidates, 0].astype(float))\n    # Feasibility mask\n    feasible = (demands[candidates] <= cap0) & (earliest_start <= time_windows[candidates, 1].astype(float))\n\n    if not np.any(feasible):\n        return int(depot)\n\n    # Keep only feasible candidates\n    cand_idx = candidates[feasible]\n    d2       = distance_matrix[current_node, cand_idx].astype(float)\n\n    # Residual capacity after visiting candidate\n    post_cap = cap0 - demands[cand_idx].astype(float)\n    target   = 0.5 * cap0\n    parity   = np.abs(post_cap - target)\n\n    # Small deterministic noise to break ties\n    noise = np.arange(len(cand_idx)) * 1e-6\n\n    # Softmin scoring\n    temp = 1.0\n    score = d2 + 0.25 * parity + noise\n    weights = np.exp(-score / temp)\n    # Pick the candidate with the smallest score (argmin)\n    chosen = cand_idx[np.argmin(score)]\n    return int(chosen)\n\n",
  "min_distance_with_postcap_parity_aug_335": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Variable renaming\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distance from current node to all nodes\n    dists = distance_matrix[current_node, nodes].astype(float)\n\n    # Feasible start times\n    est_start = np.maximum(t0 + dists, time_windows[nodes, 0].astype(float))\n    # Feasibility check\n    feasible = (demands[nodes] <= cap0) & (est_start <= time_windows[nodes, 1].astype(float))\n\n    if not np.any(feasible):\n        return int(depot)\n\n    # Filter feasible candidates\n    cand = nodes[feasible]\n    d2   = distance_matrix[current_node, cand].astype(float)\n\n    # Residual capacity and parity with epsilon in denominator\n    post_cap = cap0 - demands[cand].astype(float)\n    target   = 0.5 * cap0\n    parity   = np.abs(post_cap - target) / (target + 1e-12)\n\n    # Scoring with tuned weights\n    score = 0.6 * d2 + 0.4 * parity\n    # Keep top_k smallest scores\n    top_k = 7\n    if score.size > top_k:\n        idx_top = np.argpartition(score, top_k)[:top_k]\n        score = score[idx_top]\n        cand  = cand[idx_top]\n\n    # Final selection\n    chosen = cand[np.argmin(score)]\n    return int(chosen)\n\n",
  "min_distance_with_postcap_parity_aug_336": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for readability\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Distances from current node\n    dists = distance_matrix[current_node, nodes].astype(float)\n\n    # Feasible start times\n    est_start = np.maximum(t0 + dists, time_windows[nodes, 0].astype(float))\n    feasible = (demands[nodes] <= cap0) & (est_start <= time_windows[nodes, 1].astype(float))\n\n    if not np.any(feasible):\n        return int(depot)\n\n    cand = nodes[feasible]\n    d2   = distance_matrix[current_node, cand].astype(float)\n\n    # Residual capacity and parity\n    post_cap = cap0 - demands[cand].astype(float)\n    target   = 0.5 * cap0\n    parity   = np.abs(post_cap - target) / (target + 1e-12)\n\n    # Softmax scoring with temperature\n    temp = 0.5\n    score = d2 + 0.25 * parity\n    # Convert to weights\n    weights = np.exp(-score / temp)\n    weights /= np.clip(weights.sum(), 1e-12, None)\n\n    # Randomly sample a candidate according to weights\n    rng = np.random.default_rng(42)  # deterministic seed\n    chosen = rng.choice(cand, p=weights)\n    return int(chosen)\n\n",
  "maximize_time_window_intersection_with_now_aug_337": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_t = float(np.asarray(current_time).reshape(-1)[0])\n\n    # distances from current node\n    dist_from_cur = distance_matrix[int(current_node), candidates].astype(float)\n\n    # earliest possible arrival time respecting time windows\n    earliest_arr = np.maximum(cur_t + dist_from_cur,\n                              time_windows[candidates, 0].astype(float))\n\n    # feasibility check\n    feasible = (demands[candidates] <= cap) & \\\n               (earliest_arr <= time_windows[candidates, 1].astype(float))\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_cand = candidates[feasible]\n    dist_feas = dist_from_cur[feasible]\n\n    # horizon based on median remaining window width\n    rem_width = (time_windows[feas_cand, 1] - time_windows[feas_cand, 0]).astype(float)\n    horizon = float(np.median(rem_width)) if rem_width.size > 0 else 0.0\n    horizon = max(1.0, horizon)\n\n    start_int = np.maximum(time_windows[feas_cand, 0].astype(float), cur_t)\n    end_int   = np.minimum(time_windows[feas_cand, 1].astype(float), cur_t + horizon)\n    inter_len = np.maximum(0.0, end_int - start_int)\n\n    # soft\u2011min score: larger intersection and smaller distance are better\n    eps = 1e-12\n    score = inter_len / (dist_feas + eps)\n\n    # deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(score.size)\n    score_noisy = score + noise\n\n    chosen = np.argmax(score_noisy)\n    return int(feas_cand[chosen])\n\n",
  "maximize_time_window_intersection_with_now_aug_338": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # variable renaming\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_now = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix[int(current_node), cand].astype(float)\n    earliest = np.maximum(t_now + dist,\n                          time_windows[cand, 0].astype(float))\n\n    feas = (demands[cand] <= cap) & \\\n           (earliest <= time_windows[cand, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    feas_idx = cand[feas]\n    dist_feas = dist[feas]\n\n    # horizon based on mean remaining window width (tuned)\n    rem_w = (time_windows[feas_idx, 1] - time_windows[feas_idx, 0]).astype(float)\n    horizon = float(np.mean(rem_w)) if rem_w.size > 0 else 0.0\n    horizon = max(0.5, horizon)\n\n    start = np.maximum(time_windows[feas_idx, 0].astype(float), t_now)\n    end   = np.minimum(time_windows[feas_idx, 1].astype(float), t_now + horizon)\n    inter = np.maximum(0.0, end - start)\n\n    # scoring with tuned weights\n    eps = 1e-12\n    score = 0.6 * inter / (dist_feas + eps) - 0.4 * dist_feas\n\n    # top\u2011k selection\n    top_k = min(7, score.size)\n    top_indices = np.argpartition(-score, top_k - 1)[:top_k]\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(score.size)\n    score_noisy = score + noise\n\n    chosen = np.argmax(score_noisy[top_indices])\n    return int(feas_idx[top_indices[chosen]])\n\n",
  "maximize_time_window_intersection_with_now_aug_339": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for readability\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_now = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix[int(current_node), nodes].astype(float)\n    earliest = np.maximum(t_now + dist_mat,\n                          time_windows[nodes, 0].astype(float))\n\n    feasible = (demands[nodes] <= cap) & \\\n               (earliest <= time_windows[nodes, 1].astype(float))\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_nodes = nodes[feasible]\n    dist_feas  = dist_mat[feasible]\n\n    # horizon using median width\n    rem_w = (time_windows[feas_nodes, 1] - time_windows[feas_nodes, 0]).astype(float)\n    horizon = float(np.median(rem_w)) * 1.0\n    horizon = max(1.0, horizon)\n\n    start_int = np.maximum(time_windows[feas_nodes, 0].astype(float), t_now)\n    end_int   = np.minimum(time_windows[feas_nodes, 1].astype(float), t_now + horizon)\n    inter_len = np.maximum(0.0, end_int - start_int)\n\n    # soft\u2011min probability with temperature\n    eps = 1e-12\n    temp = 0.5\n    alpha = 0.8\n    cost = dist_feas - alpha * inter_len\n    cost = np.clip(cost, 0.0, None)           # ensure non\u2011negative\n    exp_neg = np.exp(-cost / (temp + eps))\n    probs = exp_neg / (np.sum(exp_neg) + eps)\n\n    # random choice weighted by probabilities\n    idx = np.random.choice(len(probs), p=probs)\n    return int(feas_nodes[idx])\n\n",
  "min_normalized_lateness_risk_index_aug_340": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # first\u2011stage calculations\n    dists   = distance_matrix[current_node, candidates].astype(float)\n    arrival = t + dists\n    wait    = np.maximum(0.0, time_windows[candidates, 0].astype(float) - arrival)\n    start   = arrival + wait\n    slack   = time_windows[candidates, 1].astype(float) - start\n\n    # feasibility mask\n    feas = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    feasible = candidates[feas]\n    d2      = distance_matrix[current_node, feasible].astype(float)\n    arr2    = t + d2\n    wait2   = np.maximum(0.0, time_windows[feasible, 0].astype(float) - arr2)\n    start2  = arr2 + wait2\n    slack2  = time_windows[feasible, 1].astype(float) - start2\n\n    # risk index with epsilon to avoid division by zero\n    slack2_clipped = np.clip(slack2, 0, None)\n    risk = (d2 + wait2) / (slack2_clipped + 1.0 + 1e-12)\n\n    # deterministic tie\u2011breaking using tiny noise\n    noise = np.random.uniform(-1e-6, 1e-6, size=risk.shape)\n    risk += noise\n    chosen = int(feasible[np.argmin(risk)])\n    return chosen\n\n",
  "min_normalized_lateness_risk_index_aug_341": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[current_node, cand].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[cand, 1].astype(float) - start\n\n    feas = (demands[cand] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    idx_feas = np.where(feas)[0]\n    feas_nodes = cand[idx_feas]\n    d2 = distance_matrix[current_node, feas_nodes].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[feas_nodes, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[feas_nodes, 1].astype(float) - start2\n\n    # weighted risk with epsilon\n    risk = (0.6 * d2 + 0.4 * wait2) / (np.clip(slack2, 0, None) + 1.0 + 1e-12)\n\n    # choose among top\u2011k candidates\n    top_k = min(7, risk.size)\n    top_idx = np.argpartition(risk, top_k - 1)[:top_k]\n    top_risk = risk[top_idx]\n\n    # soft\u2011min probabilities\n    beta = 5.0\n    probs = np.exp(-beta * top_risk)\n    probs /= probs.sum()\n\n    chosen = int(feas_nodes[np.random.choice(top_idx, p=probs)])\n    return chosen\n\n",
  "min_normalized_lateness_risk_index_aug_342": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[current_node, cand].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[cand, 1].astype(float) - start\n\n    feas = (demands[cand] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    idx_feas = np.where(feas)[0]\n    feas_nodes = cand[idx_feas]\n    d2 = distance_matrix[current_node, feas_nodes].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[feas_nodes, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[feas_nodes, 1].astype(float) - start2\n\n    # risk with epsilon\n    risk = (d2 + wait2) / (np.clip(slack2, 0, None) + 1.0 + 1e-12)\n\n    # choose randomly from the top three lowest risks\n    top_k = min(3, risk.size)\n    top_idx = np.argpartition(risk, top_k - 1)[:top_k]\n    chosen = int(feas_nodes[np.random.choice(top_idx)])\n    return chosen\n\n",
  "maximize_slack_to_window_width_ratio_aug_343": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    curr = current_node\n    depot_id = depot\n    candidates = unvisited_nodes\n    remaining_cap = rest_capacity\n    curr_time = current_time\n    demand = demands\n    dist = distance_matrix\n    tw = time_windows\n\n    if candidates.size == 0:\n        return int(depot_id)\n\n    cap_val = float(remaining_cap.reshape(-1)[0])\n    t_val = float(curr_time.reshape(-1)[0])\n\n    dists = dist[int(curr), candidates].astype(float)\n    earliest_arrival = np.maximum(t_val + dists, tw[candidates, 0].astype(float))\n    slack = tw[candidates, 1].astype(float) - earliest_arrival\n    width = (tw[candidates, 1] - tw[candidates, 0]).astype(float)\n\n    feasible_mask = (demand[candidates] <= cap_val) & (slack >= 0)\n    if not np.any(feasible_mask):\n        return int(depot_id)\n\n    feasible_nodes = candidates[feasible_mask]\n    d_feasible = dist[int(curr), feasible_nodes].astype(float)\n    earliest2 = np.maximum(t_val + d_feasible, tw[feasible_nodes, 0].astype(float))\n    slack2 = tw[feasible_nodes, 1].astype(float) - earliest2\n    width2 = (tw[feasible_nodes, 1] - tw[feasible_nodes, 0]).astype(float)\n\n    denom = width2 + 1.0 + 1e-12\n    score = slack2 / denom\n\n    # deterministic tie\u2011breaking with tiny noise\n    noise = 1e-8 * np.arange(score.size)\n    score_noisy = score + noise\n\n    chosen_idx = int(np.argmax(score_noisy))\n    return int(feasible_nodes[chosen_idx])\n\n",
  "maximize_slack_to_window_width_ratio_aug_344": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    node = current_node\n    depot_node = depot\n    nodes = unvisited_nodes\n    capacity = rest_capacity\n    time = current_time\n    demands_arr = demands\n    matrix = distance_matrix\n    windows = time_windows\n\n    if nodes.size == 0:\n        return int(depot_node)\n\n    cap_val = float(capacity.reshape(-1)[0])\n    t_val = float(time.reshape(-1)[0])\n\n    dists = matrix[int(node), nodes].astype(float)\n    arrival = np.maximum(t_val + dists, windows[nodes, 0].astype(float))\n    slack = windows[nodes, 1].astype(float) - arrival\n    width = (windows[nodes, 1] - windows[nodes, 0]).astype(float)\n\n    feas = (demands_arr[nodes] <= cap_val) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot_node)\n\n    feasible = nodes[feas]\n    d_feas = matrix[int(node), feasible].astype(float)\n    arr2 = np.maximum(t_val + d_feas, windows[feasible, 0].astype(float))\n    slack2 = windows[feasible, 1].astype(float) - arr2\n    width2 = (windows[feasible, 1] - windows[feasible, 0]).astype(float)\n\n    denom = width2 + 1.0 + 1e-12\n    # weighted score: slack prioritized, distance penalized\n    score = (slack2 / denom) - 0.01 * d_feas\n    score = np.clip(score, 0, None)   # avoid negative scores\n\n    # choose among top_k candidates\n    top_k = 7\n    if score.size <= top_k:\n        top_idx = np.argsort(-score)\n    else:\n        top_idx = np.argpartition(-score, top_k-1)[:top_k]\n        top_idx = top_idx[np.argsort(-score[top_idx])]\n\n    chosen_candidates = feasible[top_idx]\n    rng = np.random.default_rng(0)\n    chosen = rng.choice(chosen_candidates)\n    return int(chosen)\n\n",
  "min_distance_with_capacity_urgency_coupling_aug_345": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_mat = distance_matrix\n    d = dist_mat[int(current_node), candidates].astype(float)\n    start = np.maximum(t + d, time_windows[candidates, 0].astype(float))\n    slack = time_windows[candidates, 1].astype(float) - start\n    slack = np.clip(slack, 0, None)          # prevent negative slack\n\n    feas = (demands[candidates] <= cap0) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = candidates[feas]\n    d2 = dist_mat[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    slack2 = np.clip(slack2, 0, None)\n\n    frac = demands[cand].astype(float) / (cap0 + 1e-12)\n    eta = 2.5\n    score = d2 + eta * frac * (1.0 / (slack2 + 1.0 + 1e-12))\n\n    # Deterministic tie\u2011breaker\n    noise = np.arange(len(cand)) * 1e-6\n    score_noisy = score + noise\n    return int(cand[int(np.argmin(score_noisy))])\n\n",
  "min_distance_with_capacity_urgency_coupling_aug_346": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    nodes = np.asarray(unvisited_nodes, dtype=int)\n    if nodes.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist = distance_matrix\n    d = dist[int(current_node), nodes].astype(float)\n    start = np.maximum(t + d, time_windows[nodes, 0].astype(float))\n    slack = time_windows[nodes, 1].astype(float) - start\n    slack = np.clip(slack, 0, None)\n\n    feas = (demands[nodes] <= cap0) & (slack >= 0)\n    # Invert conditional logic\n    if np.any(feas):\n        cand = nodes[feas]\n        d2 = dist[int(current_node), cand].astype(float)\n        start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n        slack2 = time_windows[cand, 1].astype(float) - start2\n        slack2 = np.clip(slack2, 0, None)\n\n        frac = demands[cand].astype(float) / (cap0 + 1e-12)\n        eta = 4.0\n        score = d2 + eta * frac * (1.0 / (slack2 + 1.0 + 1e-12))\n\n        # Deterministic noise for tie\u2011breaking\n        noise = np.linspace(0, 1e-6, len(cand))\n        score_noisy = score + noise\n        # Argmax on negative score (equivalent to argmin)\n        return int(cand[int(np.argmax(-score_noisy))])\n    else:\n        return int(depot)\n\n",
  "maximize_distance_then_feasibility_safety_aug_347": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for clarity\n    dist_mat = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = dist_mat[int(current_node), candidates].astype(float)\n    earliest = np.maximum(t + d, time_windows[candidates, 0].astype(float))\n    slack = time_windows[candidates, 1].astype(float) - earliest\n\n    feas = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    feasible_idx = candidates[feas]\n    d_f = dist_mat[int(current_node), feasible_idx].astype(float)\n    earliest_f = np.maximum(t + d_f, time_windows[feasible_idx, 0].astype(float))\n    slack_f = time_windows[feasible_idx, 1].astype(float) - earliest_f\n\n    eps = 1e-12\n    # Inverse distance\u2011slack: the smaller the better\n    score = d_f / (slack_f + eps)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(len(score)) * 1e-6\n    score -= noise\n\n    best = np.argmin(score)\n    return int(feasible_idx[best])\n\n",
  "maximize_distance_then_feasibility_safety_aug_348": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Variable renaming\n    dist = distance_matrix\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = dist[int(current_node), cand].astype(float)\n    start = np.maximum(t + d, time_windows[cand, 0].astype(float))\n    slack = time_windows[cand, 1].astype(float) - start\n    slack = np.clip(slack, 0, None)                     # ensure non\u2011negative\n\n    feas = (demands[cand] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    f_idx = cand[feas]\n    d_f = dist[int(current_node), f_idx].astype(float)\n    start_f = np.maximum(t + d_f, time_windows[f_idx, 0].astype(float))\n    slack_f = time_windows[f_idx, 1].astype(float) - start_f\n    slack_f = np.clip(slack_f, 0, None)\n\n    max_slack = np.max(slack_f) if slack_f.size > 0 else 0.0\n    eps = 1e-12\n    # Weighted score: smaller distance and larger slack preferred\n    score = 0.6 * d_f + 0.4 * (max_slack - slack_f + eps)\n\n    top_k = min(5, len(score))\n    top_idx = np.argpartition(score, top_k - 1)[:top_k]\n    top_candidates = f_idx[top_idx]\n\n    # Deterministic random choice using a seed derived from inputs\n    seed = int((current_node + depot) * 1000 + t)\n    rng = np.random.RandomState(seed)\n    chosen = rng.choice(top_candidates)\n    return int(chosen)\n\n",
  "min_distance_to_depot_plus_slack_bonus_aug_349": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # Rename for readability\n    dist_mat = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    # Compute arrival times and slack\n    d_arr = dist_mat[current_node, candidates].astype(float)\n    arrive = np.maximum(t + d_arr, time_windows[candidates, 0].astype(float))\n    slack = time_windows[candidates, 1].astype(float) - arrive\n    slack = np.clip(slack, 0, np.inf)                     # no negative slack\n\n    # Feasibility test\n    feas_mask = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feas_mask):\n        return int(depot)\n\n    cand = candidates[feas_mask]\n\n    # Back\u2011to\u2011depot distances\n    back = dist_mat[cand, depot].astype(float)\n\n    # Second leg distances and slack\n    d2 = dist_mat[current_node, cand].astype(float)\n    arrive2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - arrive2\n    slack2 = np.clip(slack2, 0, np.inf)\n\n    # Score: encourage short return distance, penalise slack\n    score = back - 0.15 * slack2\n\n    # Deterministic tiny noise for tie breaking\n    noise = (cand % 1000) * 1e-6\n    score += noise\n\n    # Soft\u2011min probability\n    exp_neg = np.exp(-score)\n    prob = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n    chosen = cand[np.argmax(prob)]\n    return int(chosen)\n\n",
  "min_distance_to_depot_plus_slack_bonus_aug_350": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_arr = dist_mat[current_node, candidates].astype(float)\n    arrive = np.maximum(t + d_arr, time_windows[candidates, 0].astype(float))\n    slack = time_windows[candidates, 1].astype(float) - arrive\n    slack = np.clip(slack, 0, np.inf)\n\n    feas_mask = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feas_mask):\n        return int(depot)\n\n    cand = candidates[feas_mask]\n\n    back = dist_mat[cand, depot].astype(float)\n\n    d2 = dist_mat[current_node, cand].astype(float)\n    arrive2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - arrive2\n    slack2 = np.clip(slack2, 0, np.inf)\n\n    # Tuned weight: more emphasis on slack penalty\n    score = back - 0.25 * slack2\n\n    top_k = min(7, len(cand))\n    idx_top = np.argsort(score)[:top_k]\n    chosen = np.random.choice(cand[idx_top])\n    return int(chosen)\n\n",
  "min_distance_to_depot_plus_slack_bonus_aug_351": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t   = float(np.asarray(current_time).reshape(-1)[0])\n\n    dist_to_cand = dist_mat[current_node, candidates].astype(float)\n    arrive = np.maximum(t + dist_to_cand, time_windows[candidates, 0].astype(float))\n    slack = time_windows[candidates, 1].astype(float) - arrive\n    slack = np.clip(slack, 0, np.inf)\n\n    feas_mask = (demands[candidates] <= cap) & (slack >= 0)\n    if not np.any(feas_mask):\n        return int(depot)\n\n    cand = candidates[feas_mask]\n\n    back_dist = dist_mat[cand, depot].astype(float)\n    dist_cur_to_cand = dist_mat[current_node, cand].astype(float)\n\n    arrive2 = np.maximum(t + dist_cur_to_cand,\n                         time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - arrive2\n    slack2 = np.clip(slack2, 0, np.inf)\n\n    # Use median slack as a proxy\n    median_slack = np.median(slack2)\n    score = back_dist - 0.2 * (slack2 - median_slack)\n\n    exp_neg = np.exp(-score)\n    prob = exp_neg / (np.sum(exp_neg) + 1e-12)   # epsilon to avoid div\u2011by\u2011zero\n\n    chosen = np.random.choice(cand, p=prob)\n    return int(chosen)\n\n",
  "maximize_joint_savings_and_time_alignment_aug_352": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    # rename for clarity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t_start = float(np.asarray(current_time).reshape(-1)[0])\n\n    d_to_cand = distance_matrix[current_node, candidates].astype(float)\n    earliest_start = np.maximum(t_start + d_to_cand,\n                                time_windows[candidates, 0].astype(float))\n    feasible = (demands[candidates] <= cap) & \\\n               (earliest_start <= time_windows[candidates, 1].astype(float))\n    if not np.any(feasible):\n        return int(depot)\n\n    cand_f = candidates[feasible]\n    d_to_f = distance_matrix[current_node, cand_f].astype(float)\n    est_start = np.maximum(t_start + d_to_f,\n                           time_windows[cand_f, 0].astype(float))\n\n    mid_window = 0.5 * (time_windows[cand_f, 0].astype(float) +\n                        time_windows[cand_f, 1].astype(float))\n    diff = np.abs(est_start - mid_window)\n\n    # avoid division by zero \u2013 add tiny epsilon\n    scale = np.maximum(1.0, np.median(diff + 1.0) + 1e-12)\n    align = np.exp(-diff / scale)\n    align = np.clip(align, 0.0, 1.0)\n\n    # savings calculation\n    dist_to_depot = distance_matrix[current_node, depot]\n    depot_to_f = distance_matrix[depot, cand_f].astype(float)\n    savings = dist_to_depot + depot_to_f - d_to_f\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(cand_f.size) * 1e-6\n    score = savings * align + noise\n\n    # slack\n    slack = time_windows[cand_f, 1].astype(float) - est_start\n    # lexsort: higher slack, then higher score\n    keys = np.lexsort((-slack, -score))\n    return int(cand_f[keys[0]])\n\n",
  "maximize_joint_savings_and_time_alignment_aug_353": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap = float(rest_capacity.ravel()[0])\n    cur_t = float(current_time.ravel()[0])\n\n    d_to_cand = distance_matrix[current_node, cand].astype(float)\n    earliest = np.maximum(cur_t + d_to_cand,\n                          time_windows[cand, 0].astype(float))\n    feas_mask = (demands[cand] <= cap) & \\\n                (earliest <= time_windows[cand, 1].astype(float))\n    if not np.any(feas_mask):\n        return int(depot)\n\n    feasible_nodes = cand[feas_mask]\n    d_to_f = distance_matrix[current_node, feasible_nodes].astype(float)\n    est_f = np.maximum(cur_t + d_to_f,\n                       time_windows[feasible_nodes, 0].astype(float))\n\n    # alternative alignment: distance from median start time\n    align = np.max(np.ones_like(est_f)) - np.abs(est_f - np.median(est_f))\n    align = np.clip(align, 0, None)\n\n    # cost component\n    depot_dist = distance_matrix[current_node, depot]\n    depot_to_node = distance_matrix[depot, feasible_nodes].astype(float)\n    cost = depot_dist + depot_to_node - d_to_f\n\n    # combined score\n    score = 0.7 * cost + 0.3 * align\n\n    # select top\u2011k and pick one at random\n    top_k = 5\n    if score.size > top_k:\n        top_idx = np.argpartition(-score, top_k - 1)[:top_k]\n        chosen_idx = np.random.choice(top_idx)\n    else:\n        chosen_idx = np.random.choice(score.size)\n\n    return int(feasible_nodes[chosen_idx])\n\n",
  "min_distance_with_future_capacity_guard_aug_354": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return int(depot)\n\n    cap_left = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time = float(np.asarray(current_time).reshape(-1)[0])\n\n    # distances from current node to all candidates\n    dists = distance_matrix[current_node, candidates].astype(float)\n    # earliest start time respecting time windows\n    est_start = np.maximum(cur_time + dists,\n                           time_windows[candidates, 0].astype(float))\n    # feasibility check\n    feasible = (demands[candidates] <= cap_left) & \\\n               (est_start <= time_windows[candidates, 1].astype(float))\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_nodes = candidates[feasible]\n    feas_dists = dists[feasible]\n    post_cap = cap_left - demands[feas_nodes].astype(float)\n\n    # 20th percentile of remaining demands\n    q20 = float(np.percentile(demands[candidates].astype(float), 20)) \\\n          if candidates.size > 0 else 0.0\n    penalty = np.where(post_cap < q20, (q20 - post_cap), 0.0)\n\n    # small deterministic noise to break ties\n    noise = 1e-12 * np.arange(feas_nodes.size)\n    score = feas_dists + 0.5 * penalty + noise\n    score = np.clip(score, a_min=0.0, a_max=None)\n\n    return int(feas_nodes[np.argmin(score)])\n\n",
  "min_distance_with_future_capacity_guard_aug_355": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    if cand.size == 0:\n        return int(depot)\n\n    cap_left = float(np.asarray(rest_capacity).reshape(-1)[0])\n    cur_time = float(np.asarray(current_time).reshape(-1)[0])\n\n    dists = distance_matrix[current_node, cand].astype(float)\n    est_start = np.maximum(cur_time + dists,\n                           time_windows[cand, 0].astype(float))\n    feasible = (demands[cand] <= cap_left) & \\\n               (est_start <= time_windows[cand, 1].astype(float))\n\n    if not np.any(feasible):\n        return int(depot)\n\n    feas_nodes = cand[feasible]\n    feas_dists = dists[feasible]\n    post_cap = cap_left - demands[feas_nodes].astype(float)\n\n    # Median of remaining demands as threshold\n    thresh = float(np.median(demands[cand].astype(float))) if cand.size > 0 else 0.0\n    penalty = np.clip(thresh - post_cap, a_min=0.0, a_max=thresh)\n\n    # Deterministic noise proportional to node id\n    noise = 1e-9 * feas_nodes\n    score = feas_dists + 0.7 * penalty + noise\n    score = np.clip(score, a_min=0.0, a_max=None)\n\n    return int(feas_nodes[np.argmin(score)])\n\n"
}
