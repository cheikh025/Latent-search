{
  "nearest_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Nearest neighbor considering time window and capacity constraints.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    return int(feasible[np.argmin(distances)])\n",
  "earliest_deadline_first": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with earliest deadline (time window end).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    deadlines = time_windows[feasible, 1]\n    return int(feasible[np.argmin(deadlines)])\n",
  "minimum_slack_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with minimum slack time (deadline - arrival).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                slacks.append(slack)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(slacks)])\n",
  "earliest_start_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with earliest time window start.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    start_times = time_windows[feasible, 0]\n    return int(feasible[np.argmin(start_times)])\n",
  "minimize_wait_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize wait time before service can begin.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    wait_times = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                wait = max(0, time_windows[node][0] - arrival)\n                wait_times.append(wait)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(wait_times)])\n",
  "time_distance_weighted": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Weighted: 50% distance + 50% time urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    slacks = np.array(slacks)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    slack_norm = slacks / (np.mean(slacks) + 1e-9)\n    \n    scores = 0.5 * dist_norm + 0.5 * (1.0 / (slack_norm + 1e-9))\n    return int(feasible[np.argmin(scores)])\n",
  "savings_with_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Clarke-Wright savings adapted for time windows.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    return int(feasible[np.argmax(savings)])\n",
  "urgency_capacity_balance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Balance time urgency and capacity utilization.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    \n    demand_norm = demand_vals / (np.mean(demand_vals) + 1e-9)\n    urgency = 1.0 / (slacks + 1e-9)\n    urgency_norm = urgency / (np.mean(urgency) + 1e-9)\n    \n    scores = 0.6 * urgency_norm - 0.4 * demand_norm\n    return int(feasible[np.argmax(scores)])\n",
  "time_window_width": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer nodes with narrower time windows (more constrained).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    widths = time_windows[feasible, 1] - time_windows[feasible, 0]\n    return int(feasible[np.argmin(widths)])\n",
  "latest_acceptable_arrival": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node where we can arrive latest without violating constraints.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    latest_arrivals = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                latest_arrivals.append(time_windows[node][1])\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmax(latest_arrivals)])\n",
  "minimal_detour_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize time detour from direct return to depot.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    direct_time = distance_matrix[current_node, depot]\n    detour_times = (distance_matrix[current_node, feasible] + \n                    distance_matrix[feasible, depot] - direct_time)\n    \n    return int(feasible[np.argmin(detour_times)])\n",
  "demand_to_distance_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize demand per unit distance, considering time feasibility.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible] + 1e-9\n    demand_vals = demands[feasible]\n    ratios = demand_vals / distances\n    \n    return int(feasible[np.argmax(ratios)])\n",
  "composite_time_dist_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Composite: 40% urgency + 30% distance + 30% demand.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = 0.4 * norm(urgency) + 0.3 * norm(distances) - 0.3 * norm(demand_vals)\n    \n    return int(feasible[np.argmin(score)])\n",
  "adaptive_time_pressure": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Adapt strategy based on how tight time windows are becoming.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    slacks = np.array(slacks)\n    avg_slack = np.mean(slacks)\n    \n    distances = distance_matrix[current_node, feasible]\n    \n    # Tight time windows: prioritize urgency; Loose: prioritize distance\n    if avg_slack < 5.0:\n        urgency = 1.0 / (slacks + 1e-9)\n        return int(feasible[np.argmax(urgency)])\n    else:\n        return int(feasible[np.argmin(distances)])\n",
  "regret_time_based": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with highest time-based regret.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    if len(feasible) == 1:\n        return int(feasible[0])\n    \n    slacks = np.array(slacks)\n    sorted_idx = np.argsort(slacks)\n    \n    if len(sorted_idx) > 1:\n        regret = slacks[sorted_idx[1]] - slacks[sorted_idx[0]]\n        return int(feasible[sorted_idx[0]])  # Most urgent\n    \n    return int(feasible[sorted_idx[0]])\n",
  "insertion_cost_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize insertion cost considering travel time.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    time_to_depot = distance_matrix[current_node, depot]\n    time_via_node = (distance_matrix[current_node, feasible] + \n                     distance_matrix[feasible, depot])\n    \n    insertion_costs = time_via_node - time_to_depot\n    return int(feasible[np.argmin(insertion_costs)])\n",
  "time_proximity_cluster": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Cluster nodes by time window similarity.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    # Prefer nodes with time windows close to current time\n    tw_starts = time_windows[feasible, 0]\n    time_proximity = np.abs(tw_starts - current_time)\n    \n    distances = distance_matrix[current_node, feasible]\n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    time_norm = time_proximity / (np.mean(time_proximity) + 1e-9)\n    \n    scores = 0.6 * dist_norm + 0.4 * time_norm\n    return int(feasible[np.argmin(scores)])\n",
  "wait_vs_travel_trade_off": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Balance wait time vs travel time.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    wait_times = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                wait_times.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    travel_times = distance_matrix[current_node, feasible]\n    wait_times = np.array(wait_times)\n    \n    total_times = travel_times + wait_times\n    return int(feasible[np.argmin(total_times)])\n",
  "deadline_proximity_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Ratio of slack time to travel time.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    ratios = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            travel = distance_matrix[current_node, node]\n            arrival = current_time + travel\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                ratio = slack / (travel + 1e-9)\n                ratios.append(ratio)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(ratios)])  # Prefer low slack-to-travel ratio\n",
  "stochastic_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Probabilistic selection based on urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    urgencies = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                urgencies.append(1.0 / (slack + 1.0))\n    \n    if not feasible:\n        return depot\n    \n    urgencies = np.array(urgencies)\n    probs = urgencies / np.sum(urgencies)\n    \n    seed = int(current_node * 2654435761) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "time_window_midpoint": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer arriving close to time window midpoint.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    deviations = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                midpoint = (time_windows[node][0] + time_windows[node][1]) / 2.0\n                service_start = max(arrival, time_windows[node][0])\n                deviations.append(abs(service_start - midpoint))\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(deviations)])\n",
  "capacity_time_balance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Balance capacity utilization with time urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    capacity_ratio = rest_capacity / (np.max(demands) + 1e-9)\n    slacks = np.array(slacks)\n    demand_vals = demands[feasible]\n    \n    # Low capacity: prefer small demand; High urgency: prefer urgent\n    if capacity_ratio < 0.3:\n        return int(feasible[np.argmin(demand_vals)])\n    else:\n        return int(feasible[np.argmin(slacks)])\n",
  "five_factor_composite": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Composite: distance + demand + urgency + wait + capacity.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    waits = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n                waits.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n    capacity_util = demand_vals / (rest_capacity + 1e-9)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = (0.25 * norm(distances) - \n             0.20 * norm(demand_vals) + \n             0.30 * norm(urgency) + \n             0.15 * norm(waits) + \n             0.10 * norm(capacity_util))\n    \n    return int(feasible[np.argmin(score)])\n",
  "random_time_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Random selection among time-feasible nodes.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    seed = int(current_node * 73856093) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible))\n",
  "hybrid_savings_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Hybrid: 50% savings + 50% urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    urgencies = 1.0 / (np.array(slacks) + 1.0)\n    \n    savings_norm = savings / (np.mean(np.abs(savings)) + 1e-9)\n    urgency_norm = urgencies / (np.mean(urgencies) + 1e-9)\n    \n    scores = 0.5 * savings_norm + 0.5 * urgency_norm\n    return int(feasible[np.argmax(scores)])\n",
  "time_density_routing": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Route through time-dense regions (many nodes with similar time windows).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    # Count how many other nodes have similar time windows\n    densities = []\n    for node in feasible:\n        tw_start = time_windows[node, 0]\n        tw_end = time_windows[node, 1]\n        # Count nodes with overlapping windows\n        overlaps = 0\n        for other in unvisited_nodes:\n            if other != node:\n                other_start = time_windows[other, 0]\n                other_end = time_windows[other, 1]\n                if not (tw_end < other_start or other_end < tw_start):\n                    overlaps += 1\n        densities.append(overlaps)\n    \n    distances = distance_matrix[current_node, feasible]\n    densities = np.array(densities)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    density_norm = densities / (np.max(densities) + 1e-9)\n    \n    scores = dist_norm - 0.6 * density_norm\n    return int(feasible[np.argmin(scores)])\n",
  "progressive_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Increase urgency weight as time progresses.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    # Progress indicator\n    max_time = np.max(time_windows[:, 1])\n    progress = current_time / (max_time + 1e-9)\n    \n    distances = distance_matrix[current_node, feasible]\n    urgencies = 1.0 / (np.array(slacks) + 1.0)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    urgency_norm = urgencies / (np.mean(urgencies) + 1e-9)\n    \n    # Early: 70% distance, 30% urgency; Late: 30% distance, 70% urgency\n    weight = progress\n    scores = (1 - weight) * 0.7 * dist_norm + weight * 0.7 * urgency_norm\n    \n    return int(feasible[np.argmin(scores)])\n",
  "minmax_normalized_vrptw": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Min-max normalize all VRPTW factors equally.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    waits = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n                waits.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n    \n    def minmax(x):\n        mn, mx = x.min(), x.max()\n        if mx - mn < 1e-9:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = (minmax(distances) - minmax(demand_vals) + \n             minmax(urgency) + minmax(waits))\n    \n    return int(feasible[np.argmin(score)])\n",
  "min_time_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Choose feasible customer with minimal time slack (due - service_start).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    due = time_windows[unv, 1]\n    slack = due - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    slack2 = time_windows[u2, 1] - np.maximum(t + distance_matrix[int(current_node), u2], time_windows[u2, 0])\n    return int(u2[int(np.argmin(slack2))])\n",
  "max_demand_that_fits": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible customer with largest demand (aggressive capacity utilization).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmax(demands[u2]))])\n",
  "capacity_tight_fill": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer feasible customer that leaves the smallest remaining vehicle capacity.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    left_cap = cap - demands[u2]\n    return int(u2[int(np.argmin(left_cap))])\n",
  "farthest_from_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Choose feasible customer farthest from depot (often used as a construction ordering rule).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmax(distance_matrix[int(depot), u2]))])\n",
  "nearest_to_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Choose feasible customer nearest to depot (keeps routes compact early).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmin(distance_matrix[int(depot), u2]))])\n",
  "urgent_then_near": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Lexicographic: smallest slack first; tie-break by shortest travel distance.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    slack2 = time_windows[u2, 1] - np.maximum(t + d2, time_windows[u2, 0])\n    key = np.lexsort((d2, slack2))\n    return int(u2[int(key[0])])\n",
  "normalized_tradeoff_dist_wait_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Z-score composite: (distance + wait) vs urgency (slack). Lower is better.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1] - start2\n\n    x = d2 + wait2\n    zx = (x - np.mean(x)) / (np.std(x) + 1e-12)\n    zs = (slack2 - np.mean(slack2)) / (np.std(slack2) + 1e-12)\n    score = zx - 0.8 * (-zs)  # penalize larger (less-urgent) slack\n    return int(u2[int(np.argmin(score))])\n",
  "regret2_slack_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Regret-2: prioritize node whose best vs second-best slack score differs most (avoid future loss).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    base = -slack2 + 0.05 * d2\n    order = np.argsort(base)\n    best = base[order[0]]\n    second = base[order[1]] if order.size > 1 else best\n    regret = second - best\n    # choose the node corresponding to best (lowest base) but if regret is large, lock it in\n    return int(u2[int(order[0])]) if regret >= 0 else int(u2[int(order[0])])\n",
  "exponential_lateness_risk": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize travel while exponentially penalizing low slack (risk-aware urgency).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    risk = np.exp(-slack2 / (np.std(slack2) + 1e-9))\n    score = d2 * (1.0 + 2.0 * risk)\n    return int(u2[int(np.argmin(score))])\n",
  "quadratic_wait_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize distance + (wait^2) to strongly avoid long waits.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    score = d2 + (wait2 ** 2)\n    return int(u2[int(np.argmin(score))])\n",
  "return_to_depot_aware": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Choose node minimizing (to-node + node-to-depot) while respecting its time window.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    score = distance_matrix[int(current_node), u2] + distance_matrix[u2, int(depot)]\n    return int(u2[int(np.argmin(score))])\n",
  "mean_distance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer a feasible node that is centrally located w.r.t. remaining customers (cluster-friendly).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    mean_to_others = np.mean(distance_matrix[u2][:, unv], axis=1)\n    score = 0.7 * distance_matrix[int(current_node), u2] + 0.3 * mean_to_others\n    return int(u2[int(np.argmin(score))])\n",
  "median_distance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Like clustering, but uses median distance to remaining nodes for robustness.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    med_to_others = np.median(distance_matrix[u2][:, unv], axis=1)\n    score = 0.6 * distance_matrix[int(current_node), u2] + 0.4 * med_to_others\n    return int(u2[int(np.argmin(score))])\n",
  "clarke_wright_savings_like": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize a Clarke-Wright-style savings term while staying feasible.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcu, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    savings = distance_matrix[int(current_node), int(depot)] + distance_matrix[int(depot), u2] - distance_matrix[int(current_node), u2]\n    # prefer higher savings, slight urgency tie-break\n    slack = time_windows[u2, 1] - np.maximum(t + distance_matrix[int(current_node), u2], time_windows[u2, 0])\n    score = savings + 1e-3 * (-slack)\n    return int(u2[int(np.argmax(score))])\n",
  "widest_time_window_then_near": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible customer with widest window; tie-break by nearest (diversity vs narrow-first).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    width = time_windows[u2, 1] - time_windows[u2, 0]\n    best_width = np.max(width)\n    cand = u2[width == best_width]\n    if cand.size == 1:\n        return int(cand[0])\n    return int(cand[int(np.argmin(distance_matrix[int(current_node), cand]))])\n",
  "midpoint_service_target": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Target starting service near the midpoint of the customer's window (stability heuristic).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    mid = 0.5 * (time_windows[u2, 0] + time_windows[u2, 1])\n    score = np.abs(start2 - mid) + 0.1 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "demand_over_slack_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize demand / (slack+eps) among feasible nodes (serve big + urgent first).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = demands[u2] / (slack2 + 1e-9)\n    return int(u2[int(np.argmax(score))])\n",
  "adaptive_distance_vs_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Adaptive blend: early in route favor distance; as slack tightens, favor urgency.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    # urgency signal: lower slack => higher urgency\n    urg = 1.0 / (slack2 + 1e-9)\n    # adaptive alpha based on how tight things are (relative slack)\n    rel = slack2 / (np.mean(slack2) + 1e-9)\n    alpha = float(np.clip(0.7 - 0.4 * np.mean(rel), 0.2, 0.8))\n    score = alpha * d2 + (1.0 - alpha) * (1.0 / (urg + 1e-9))\n    return int(u2[int(np.argmin(score))])\n",
  "lookahead_two_step_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Two-step lookahead: pick u minimizing d(cur,u) + min_v d(u,v) over feasible v after u.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n    best_u = int(cand[0])\n    best_score = np.inf\n\n    for u in cand:\n        cap1 = cap0 - float(demands[int(u)])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), int(u)], time_windows[int(u), 0]))\n        others = cand[cand != u]\n        if others.size == 0:\n            score = distance_matrix[int(current_node), int(u)]\n        else:\n            darr = t1 + distance_matrix[int(u), others]\n            start_v = np.maximum(darr, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (start_v <= time_windows[others, 1])\n            nxt = np.min(distance_matrix[int(u), others[feas_v]]) if np.any(feas_v) else distance_matrix[int(u), int(depot)]\n            score = distance_matrix[int(current_node), int(u)] + nxt\n        if score < best_score:\n            best_score = score\n            best_u = int(u)\n\n    return int(best_u)\n",
  "pseudo_randomized_tie_break_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Nearest-feasible with deterministic jitter (diversifies without true RNG).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    jitter = 1e-6 * np.sin((u2.astype(float) + 1.0) * (t + 1.2345))\n    return int(u2[int(np.argmin(d2 + jitter))])\n",
  "late_window_priority_latest_start": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible node with smallest latest-start margin: due - travel (latest-start-like).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    latest_start_margin = time_windows[unv, 1] - (t + d)\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    margin2 = time_windows[u2, 1] - (t + d2)\n    return int(u2[int(np.argmin(margin2))])\n",
  "min_distance_with_due_time_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Nearest feasible, but heavily penalize arriving close to due time (guard band).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    guard = np.maximum(0.0, (np.quantile(slack2, 0.25) - slack2))\n    score = d2 + 5.0 * guard\n    return int(u2[int(np.argmin(score))])\n",
  "demand_and_urgency_weighted": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Weighted score: -distance - wait + (demand bonus) + (urgency bonus).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1] - start2\n\n    dem = demands[u2].astype(float)\n    demN = (dem - np.min(dem)) / (np.ptp(dem) + 1e-12)\n    urg = 1.0 / (slack2 + 1e-9)\n    urgN = (urg - np.min(urg)) / (np.ptp(urg) + 1e-12)\n    distN = (d2 - np.min(d2)) / (np.ptp(d2) + 1e-12)\n    waitN = (wait2 - np.min(wait2)) / (np.ptp(wait2) + 1e-12)\n\n    score = 1.2 * urgN + 0.8 * demN - 0.9 * distN - 0.5 * waitN\n    return int(u2[int(np.argmax(score))])\n",
  "adaptive_farthest_early_nearest_late": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Early: go far from depot; late: tighten route with nearest-feasible (smooth blend).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    n_total = int(max(1, time_windows.shape[0] - 1))\n    progress = 1.0 - (float(unv.size) / float(n_total))\n    alpha = float(np.clip(progress, 0.0, 1.0))\n\n    near = distance_matrix[int(current_node), u2]\n    far = distance_matrix[int(depot), u2]\n    score = (1.0 - alpha) * (-far) + alpha * (-near)\n    return int(u2[int(np.argmax(score))])\n",
  "depot_due_feasibility_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Feasible node that also keeps return-to-depot within depot due time (if provided).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n    depot_due = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    back_time = start2 + distance_matrix[u2, int(depot)]\n    feas2 = back_time <= depot_due\n    if np.any(feas2):\n        u3 = u2[feas2]\n        return int(u3[int(np.argmin(distance_matrix[int(current_node), u3]))])\n    return int(u2[int(np.argmin(distance_matrix[int(current_node), u2]))])\n",
  "time_window_overlap_with_now": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer customers whose window overlaps 'now' soon (min abs(start - now)).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t0 + d\n    start = np.maximum(arr, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t0 + d2\n    start2 = np.maximum(arr2, time_windows[u2, 0])\n    score = np.abs(start2 - t0) + 0.05 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "softmin_distance_times_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize distance * (1 + k/ (slack+eps)) among feasible (multiplicative urgency).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    k = 0.5 * (np.mean(slack2) + 1e-9)\n    score = d2 * (1.0 + (k / (slack2 + 1e-9)))\n    return int(u2[int(np.argmin(score))])\n",
  "capacity_and_depot_compactness": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer: (tight capacity usage) + (compact wrt depot) while feasible in time windows.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    left_cap = cap - demands[u2].astype(float)\n    cap_term = -np.abs(left_cap)  # closer to 0 is better\n    depot_term = -distance_matrix[int(depot), u2]\n    dist_term = -distance_matrix[int(current_node), u2]\n    score = 0.6 * cap_term + 0.25 * depot_term + 0.15 * dist_term\n    return int(u2[int(np.argmax(score))])\n",
  "time_window_centerline_plus_savings": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Blend window-midpoint alignment with a savings-like term.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    mid = 0.5 * (time_windows[u2, 0] + time_windows[u2, 1])\n    align = -np.abs(start2 - mid)\n    savings = distance_matrix[int(current_node), int(depot)] + distance_matrix[int(depot), u2] - d2\n    score = 0.7 * align + 0.3 * savings\n    return int(u2[int(np.argmax(score))])\n",
  "min_distance_subject_to_slack_quantile": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Filter to most-urgent (lowest 30% slack), then take nearest feasible; fallback nearest feasible.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    thr = np.quantile(slack2, 0.30)\n    urgent = u2[slack2 <= thr]\n    if urgent.size > 0:\n        return int(urgent[int(np.argmin(distance_matrix[int(current_node), urgent]))])\n    return int(u2[int(np.argmin(d2))])\n",
  "maximize_service_start_soon": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible customer with smallest service start time (get moving on service quickly).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    return int(u2[int(np.argmin(start2))])\n",
  "max_slack_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select feasible node with maximum time slack (due - service_start).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    return int(u2[int(np.argmax(slack2))])\n",
  "min_demand_that_fits": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible node with smallest demand (save capacity).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    return int(u2[int(np.argmin(demands[u2]))])\n",
  "min_detour_plus_wait": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize detour to depot plus waiting time.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    start = np.maximum(arr, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    detour = d2 + distance_matrix[u2, int(depot)] - distance_matrix[int(current_node), int(depot)]\n    score = detour + wait2\n    return int(u2[int(np.argmin(score))])\n",
  "closest_unvisited_neighbor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer feasible node closest to another unvisited node (cluster-forming).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    best = int(u2[0])\n    best_dist = np.inf\n    for node in u2:\n        others = unv[unv != node]\n        if others.size == 0:\n            return int(node)\n        dmin = float(np.min(distance_matrix[int(node), others]))\n        if dmin < best_dist:\n            best_dist = dmin\n            best = int(node)\n    return int(best)\n",
  "max_future_feasible_count": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Lookahead: choose node that leaves the most feasible options next.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    best = int(u2[0])\n    best_count = -1\n    best_dist = np.inf\n    for node in u2:\n        cap2 = cap - float(demands[int(node)])\n        t2 = float(np.maximum(t + distance_matrix[int(current_node), int(node)], time_windows[int(node), 0]))\n        others = unv[unv != node]\n        if others.size == 0:\n            return int(node)\n        d2 = distance_matrix[int(node), others]\n        start2 = np.maximum(t2 + d2, time_windows[others, 0])\n        feas2 = (demands[others] <= cap2) & (start2 <= time_windows[others, 1])\n        count = int(np.sum(feas2))\n        dist_now = float(distance_matrix[int(current_node), int(node)])\n        if (count > best_count) or (count == best_count and dist_now < best_dist):\n            best_count = count\n            best_dist = dist_now\n            best = int(node)\n    return int(best)\n",
  "due_time_proximity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible node with due time closest to the current time.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    due = time_windows[u2, 1]\n    dist = distance_matrix[int(current_node), u2]\n    score = np.abs(due - t) + 1e-6 * dist\n    return int(u2[int(np.argmin(score))])\n",
  "travel_over_slack_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize travel/slack ratio (short travel with comfortable slack).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = d2 / (slack2 + 1e-9)\n    return int(u2[int(np.argmin(score))])\n",
  "mean_distance_to_unvisited_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer a feasible node far from remaining customers (diversify route).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    mean_to_others = np.mean(distance_matrix[u2][:, unv], axis=1)\n    score = mean_to_others - 0.15 * distance_matrix[int(current_node), u2]\n    return int(u2[int(np.argmax(score))])\n"
}
