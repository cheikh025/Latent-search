{
  "nearest_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Nearest neighbor considering time window and capacity constraints.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    return int(feasible[np.argmin(distances)])\n",
  "earliest_deadline_first": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with earliest deadline (time window end).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    deadlines = time_windows[feasible, 1]\n    return int(feasible[np.argmin(deadlines)])\n",
  "minimum_slack_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with minimum slack time (deadline - arrival).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                slacks.append(slack)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(slacks)])\n",
  "earliest_start_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with earliest time window start.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    start_times = time_windows[feasible, 0]\n    return int(feasible[np.argmin(start_times)])\n",
  "minimize_wait_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize wait time before service can begin.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    wait_times = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                wait = max(0, time_windows[node][0] - arrival)\n                wait_times.append(wait)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(wait_times)])\n",
  "time_distance_weighted": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Weighted: 50% distance + 50% time urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    slacks = np.array(slacks)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    slack_norm = slacks / (np.mean(slacks) + 1e-9)\n    \n    scores = 0.5 * dist_norm + 0.5 * (1.0 / (slack_norm + 1e-9))\n    return int(feasible[np.argmin(scores)])\n",
  "savings_with_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Clarke-Wright savings adapted for time windows.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    return int(feasible[np.argmax(savings)])\n",
  "urgency_capacity_balance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Balance time urgency and capacity utilization.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    \n    demand_norm = demand_vals / (np.mean(demand_vals) + 1e-9)\n    urgency = 1.0 / (slacks + 1e-9)\n    urgency_norm = urgency / (np.mean(urgency) + 1e-9)\n    \n    scores = 0.6 * urgency_norm - 0.4 * demand_norm\n    return int(feasible[np.argmax(scores)])\n",
  "time_window_width": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer nodes with narrower time windows (more constrained).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    widths = time_windows[feasible, 1] - time_windows[feasible, 0]\n    return int(feasible[np.argmin(widths)])\n",
  "latest_acceptable_arrival": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node where we can arrive latest without violating constraints.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    latest_arrivals = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                latest_arrivals.append(time_windows[node][1])\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmax(latest_arrivals)])\n",
  "minimal_detour_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize time detour from direct return to depot.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    direct_time = distance_matrix[current_node, depot]\n    detour_times = (distance_matrix[current_node, feasible] + \n                    distance_matrix[feasible, depot] - direct_time)\n    \n    return int(feasible[np.argmin(detour_times)])\n",
  "demand_to_distance_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize demand per unit distance, considering time feasibility.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible] + 1e-9\n    demand_vals = demands[feasible]\n    ratios = demand_vals / distances\n    \n    return int(feasible[np.argmax(ratios)])\n",
  "composite_time_dist_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Composite: 40% urgency + 30% distance + 30% demand.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = 0.4 * norm(urgency) + 0.3 * norm(distances) - 0.3 * norm(demand_vals)\n    \n    return int(feasible[np.argmin(score)])\n",
  "adaptive_time_pressure": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Adapt strategy based on how tight time windows are becoming.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    slacks = np.array(slacks)\n    avg_slack = np.mean(slacks)\n    \n    distances = distance_matrix[current_node, feasible]\n    \n    # Tight time windows: prioritize urgency; Loose: prioritize distance\n    if avg_slack < 5.0:\n        urgency = 1.0 / (slacks + 1e-9)\n        return int(feasible[np.argmax(urgency)])\n    else:\n        return int(feasible[np.argmin(distances)])\n",
  "regret_time_based": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with highest time-based regret.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    if len(feasible) == 1:\n        return int(feasible[0])\n    \n    slacks = np.array(slacks)\n    sorted_idx = np.argsort(slacks)\n    \n    if len(sorted_idx) > 1:\n        regret = slacks[sorted_idx[1]] - slacks[sorted_idx[0]]\n        return int(feasible[sorted_idx[0]])  # Most urgent\n    \n    return int(feasible[sorted_idx[0]])\n",
  "insertion_cost_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize insertion cost considering travel time.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    time_to_depot = distance_matrix[current_node, depot]\n    time_via_node = (distance_matrix[current_node, feasible] + \n                     distance_matrix[feasible, depot])\n    \n    insertion_costs = time_via_node - time_to_depot\n    return int(feasible[np.argmin(insertion_costs)])\n",
  "time_proximity_cluster": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Cluster nodes by time window similarity.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    # Prefer nodes with time windows close to current time\n    tw_starts = time_windows[feasible, 0]\n    time_proximity = np.abs(tw_starts - current_time)\n    \n    distances = distance_matrix[current_node, feasible]\n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    time_norm = time_proximity / (np.mean(time_proximity) + 1e-9)\n    \n    scores = 0.6 * dist_norm + 0.4 * time_norm\n    return int(feasible[np.argmin(scores)])\n",
  "wait_vs_travel_trade_off": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Balance wait time vs travel time.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    wait_times = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                wait_times.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    travel_times = distance_matrix[current_node, feasible]\n    wait_times = np.array(wait_times)\n    \n    total_times = travel_times + wait_times\n    return int(feasible[np.argmin(total_times)])\n",
  "deadline_proximity_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Ratio of slack time to travel time.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    ratios = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            travel = distance_matrix[current_node, node]\n            arrival = current_time + travel\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                ratio = slack / (travel + 1e-9)\n                ratios.append(ratio)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(ratios)])  # Prefer low slack-to-travel ratio\n",
  "stochastic_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Probabilistic selection based on urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    urgencies = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                urgencies.append(1.0 / (slack + 1.0))\n    \n    if not feasible:\n        return depot\n    \n    urgencies = np.array(urgencies)\n    probs = urgencies / np.sum(urgencies)\n    \n    seed = int(current_node * 2654435761) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "time_window_midpoint": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer arriving close to time window midpoint.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    deviations = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                midpoint = (time_windows[node][0] + time_windows[node][1]) / 2.0\n                service_start = max(arrival, time_windows[node][0])\n                deviations.append(abs(service_start - midpoint))\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(deviations)])\n",
  "capacity_time_balance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Balance capacity utilization with time urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    capacity_ratio = rest_capacity / (np.max(demands) + 1e-9)\n    slacks = np.array(slacks)\n    demand_vals = demands[feasible]\n    \n    # Low capacity: prefer small demand; High urgency: prefer urgent\n    if capacity_ratio < 0.3:\n        return int(feasible[np.argmin(demand_vals)])\n    else:\n        return int(feasible[np.argmin(slacks)])\n",
  "five_factor_composite": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Composite: distance + demand + urgency + wait + capacity.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    waits = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n                waits.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n    capacity_util = demand_vals / (rest_capacity + 1e-9)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = (0.25 * norm(distances) - \n             0.20 * norm(demand_vals) + \n             0.30 * norm(urgency) + \n             0.15 * norm(waits) + \n             0.10 * norm(capacity_util))\n    \n    return int(feasible[np.argmin(score)])\n",
  "random_time_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Random selection among time-feasible nodes.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    seed = int(current_node * 73856093) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible))\n",
  "hybrid_savings_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Hybrid: 50% savings + 50% urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    urgencies = 1.0 / (np.array(slacks) + 1.0)\n    \n    savings_norm = savings / (np.mean(np.abs(savings)) + 1e-9)\n    urgency_norm = urgencies / (np.mean(urgencies) + 1e-9)\n    \n    scores = 0.5 * savings_norm + 0.5 * urgency_norm\n    return int(feasible[np.argmax(scores)])\n",
  "time_density_routing": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Route through time-dense regions (many nodes with similar time windows).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    # Count how many other nodes have similar time windows\n    densities = []\n    for node in feasible:\n        tw_start = time_windows[node, 0]\n        tw_end = time_windows[node, 1]\n        # Count nodes with overlapping windows\n        overlaps = 0\n        for other in unvisited_nodes:\n            if other != node:\n                other_start = time_windows[other, 0]\n                other_end = time_windows[other, 1]\n                if not (tw_end < other_start or other_end < tw_start):\n                    overlaps += 1\n        densities.append(overlaps)\n    \n    distances = distance_matrix[current_node, feasible]\n    densities = np.array(densities)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    density_norm = densities / (np.max(densities) + 1e-9)\n    \n    scores = dist_norm - 0.6 * density_norm\n    return int(feasible[np.argmin(scores)])\n",
  "progressive_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Increase urgency weight as time progresses.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    # Progress indicator\n    max_time = np.max(time_windows[:, 1])\n    progress = current_time / (max_time + 1e-9)\n    \n    distances = distance_matrix[current_node, feasible]\n    urgencies = 1.0 / (np.array(slacks) + 1.0)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    urgency_norm = urgencies / (np.mean(urgencies) + 1e-9)\n    \n    # Early: 70% distance, 30% urgency; Late: 30% distance, 70% urgency\n    weight = progress\n    scores = (1 - weight) * 0.7 * dist_norm + weight * 0.7 * urgency_norm\n    \n    return int(feasible[np.argmin(scores)])\n",
  "minmax_normalized_vrptw": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Min-max normalize all VRPTW factors equally.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    waits = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n                waits.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n    \n    def minmax(x):\n        mn, mx = x.min(), x.max()\n        if mx - mn < 1e-9:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = (minmax(distances) - minmax(demand_vals) + \n             minmax(urgency) + minmax(waits))\n    \n    return int(feasible[np.argmin(score)])\n",
  "min_time_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Choose feasible customer with minimal time slack (due - service_start).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    due = time_windows[unv, 1]\n    slack = due - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    slack2 = time_windows[u2, 1] - np.maximum(t + distance_matrix[int(current_node), u2], time_windows[u2, 0])\n    return int(u2[int(np.argmin(slack2))])\n",
  "max_demand_that_fits": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible customer with largest demand (aggressive capacity utilization).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmax(demands[u2]))])\n",
  "capacity_tight_fill": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer feasible customer that leaves the smallest remaining vehicle capacity.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    left_cap = cap - demands[u2]\n    return int(u2[int(np.argmin(left_cap))])\n",
  "farthest_from_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Choose feasible customer farthest from depot (often used as a construction ordering rule).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmax(distance_matrix[int(depot), u2]))])\n",
  "nearest_to_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Choose feasible customer nearest to depot (keeps routes compact early).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmin(distance_matrix[int(depot), u2]))])\n",
  "urgent_then_near": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Lexicographic: smallest slack first; tie-break by shortest travel distance.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    slack2 = time_windows[u2, 1] - np.maximum(t + d2, time_windows[u2, 0])\n    key = np.lexsort((d2, slack2))\n    return int(u2[int(key[0])])\n",
  "normalized_tradeoff_dist_wait_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Z-score composite: (distance + wait) vs urgency (slack). Lower is better.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1] - start2\n\n    x = d2 + wait2\n    zx = (x - np.mean(x)) / (np.std(x) + 1e-12)\n    zs = (slack2 - np.mean(slack2)) / (np.std(slack2) + 1e-12)\n    score = zx - 0.8 * (-zs)  # penalize larger (less-urgent) slack\n    return int(u2[int(np.argmin(score))])\n",
  "regret2_slack_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Regret-2: prioritize node whose best vs second-best slack score differs most (avoid future loss).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    base = -slack2 + 0.05 * d2\n    order = np.argsort(base)\n    best = base[order[0]]\n    second = base[order[1]] if order.size > 1 else best\n    regret = second - best\n    # choose the node corresponding to best (lowest base) but if regret is large, lock it in\n    return int(u2[int(order[0])]) if regret >= 0 else int(u2[int(order[0])])\n",
  "exponential_lateness_risk": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize travel while exponentially penalizing low slack (risk-aware urgency).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    risk = np.exp(-slack2 / (np.std(slack2) + 1e-9))\n    score = d2 * (1.0 + 2.0 * risk)\n    return int(u2[int(np.argmin(score))])\n",
  "quadratic_wait_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize distance + (wait^2) to strongly avoid long waits.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    score = d2 + (wait2 ** 2)\n    return int(u2[int(np.argmin(score))])\n",
  "return_to_depot_aware": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Choose node minimizing (to-node + node-to-depot) while respecting its time window.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    score = distance_matrix[int(current_node), u2] + distance_matrix[u2, int(depot)]\n    return int(u2[int(np.argmin(score))])\n",
  "mean_distance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer a feasible node that is centrally located w.r.t. remaining customers (cluster-friendly).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    mean_to_others = np.mean(distance_matrix[u2][:, unv], axis=1)\n    score = 0.7 * distance_matrix[int(current_node), u2] + 0.3 * mean_to_others\n    return int(u2[int(np.argmin(score))])\n",
  "median_distance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Like clustering, but uses median distance to remaining nodes for robustness.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    med_to_others = np.median(distance_matrix[u2][:, unv], axis=1)\n    score = 0.6 * distance_matrix[int(current_node), u2] + 0.4 * med_to_others\n    return int(u2[int(np.argmin(score))])\n",
  "clarke_wright_savings_like": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize a Clarke-Wright-style savings term while staying feasible.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcu, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    savings = distance_matrix[int(current_node), int(depot)] + distance_matrix[int(depot), u2] - distance_matrix[int(current_node), u2]\n    # prefer higher savings, slight urgency tie-break\n    slack = time_windows[u2, 1] - np.maximum(t + distance_matrix[int(current_node), u2], time_windows[u2, 0])\n    score = savings + 1e-3 * (-slack)\n    return int(u2[int(np.argmax(score))])\n",
  "widest_time_window_then_near": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible customer with widest window; tie-break by nearest (diversity vs narrow-first).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    width = time_windows[u2, 1] - time_windows[u2, 0]\n    best_width = np.max(width)\n    cand = u2[width == best_width]\n    if cand.size == 1:\n        return int(cand[0])\n    return int(cand[int(np.argmin(distance_matrix[int(current_node), cand]))])\n",
  "midpoint_service_target": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Target starting service near the midpoint of the customer's window (stability heuristic).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    mid = 0.5 * (time_windows[u2, 0] + time_windows[u2, 1])\n    score = np.abs(start2 - mid) + 0.1 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "demand_over_slack_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize demand / (slack+eps) among feasible nodes (serve big + urgent first).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = demands[u2] / (slack2 + 1e-9)\n    return int(u2[int(np.argmax(score))])\n",
  "adaptive_distance_vs_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Adaptive blend: early in route favor distance; as slack tightens, favor urgency.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    # urgency signal: lower slack => higher urgency\n    urg = 1.0 / (slack2 + 1e-9)\n    # adaptive alpha based on how tight things are (relative slack)\n    rel = slack2 / (np.mean(slack2) + 1e-9)\n    alpha = float(np.clip(0.7 - 0.4 * np.mean(rel), 0.2, 0.8))\n    score = alpha * d2 + (1.0 - alpha) * (1.0 / (urg + 1e-9))\n    return int(u2[int(np.argmin(score))])\n",
  "lookahead_two_step_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Two-step lookahead: pick u minimizing d(cur,u) + min_v d(u,v) over feasible v after u.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n    best_u = int(cand[0])\n    best_score = np.inf\n\n    for u in cand:\n        cap1 = cap0 - float(demands[int(u)])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), int(u)], time_windows[int(u), 0]))\n        others = cand[cand != u]\n        if others.size == 0:\n            score = distance_matrix[int(current_node), int(u)]\n        else:\n            darr = t1 + distance_matrix[int(u), others]\n            start_v = np.maximum(darr, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (start_v <= time_windows[others, 1])\n            nxt = np.min(distance_matrix[int(u), others[feas_v]]) if np.any(feas_v) else distance_matrix[int(u), int(depot)]\n            score = distance_matrix[int(current_node), int(u)] + nxt\n        if score < best_score:\n            best_score = score\n            best_u = int(u)\n\n    return int(best_u)\n",
  "pseudo_randomized_tie_break_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Nearest-feasible with deterministic jitter (diversifies without true RNG).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    jitter = 1e-6 * np.sin((u2.astype(float) + 1.0) * (t + 1.2345))\n    return int(u2[int(np.argmin(d2 + jitter))])\n",
  "late_window_priority_latest_start": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible node with smallest latest-start margin: due - travel (latest-start-like).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    latest_start_margin = time_windows[unv, 1] - (t + d)\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    margin2 = time_windows[u2, 1] - (t + d2)\n    return int(u2[int(np.argmin(margin2))])\n",
  "min_distance_with_due_time_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Nearest feasible, but heavily penalize arriving close to due time (guard band).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    guard = np.maximum(0.0, (np.quantile(slack2, 0.25) - slack2))\n    score = d2 + 5.0 * guard\n    return int(u2[int(np.argmin(score))])\n",
  "demand_and_urgency_weighted": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Weighted score: -distance - wait + (demand bonus) + (urgency bonus).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1] - start2\n\n    dem = demands[u2].astype(float)\n    demN = (dem - np.min(dem)) / (np.ptp(dem) + 1e-12)\n    urg = 1.0 / (slack2 + 1e-9)\n    urgN = (urg - np.min(urg)) / (np.ptp(urg) + 1e-12)\n    distN = (d2 - np.min(d2)) / (np.ptp(d2) + 1e-12)\n    waitN = (wait2 - np.min(wait2)) / (np.ptp(wait2) + 1e-12)\n\n    score = 1.2 * urgN + 0.8 * demN - 0.9 * distN - 0.5 * waitN\n    return int(u2[int(np.argmax(score))])\n",
  "adaptive_farthest_early_nearest_late": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Early: go far from depot; late: tighten route with nearest-feasible (smooth blend).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    n_total = int(max(1, time_windows.shape[0] - 1))\n    progress = 1.0 - (float(unv.size) / float(n_total))\n    alpha = float(np.clip(progress, 0.0, 1.0))\n\n    near = distance_matrix[int(current_node), u2]\n    far = distance_matrix[int(depot), u2]\n    score = (1.0 - alpha) * (-far) + alpha * (-near)\n    return int(u2[int(np.argmax(score))])\n",
  "depot_due_feasibility_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Feasible node that also keeps return-to-depot within depot due time (if provided).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n    depot_due = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    back_time = start2 + distance_matrix[u2, int(depot)]\n    feas2 = back_time <= depot_due\n    if np.any(feas2):\n        u3 = u2[feas2]\n        return int(u3[int(np.argmin(distance_matrix[int(current_node), u3]))])\n    return int(u2[int(np.argmin(distance_matrix[int(current_node), u2]))])\n",
  "time_window_overlap_with_now": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer customers whose window overlaps 'now' soon (min abs(start - now)).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t0 + d\n    start = np.maximum(arr, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t0 + d2\n    start2 = np.maximum(arr2, time_windows[u2, 0])\n    score = np.abs(start2 - t0) + 0.05 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "softmin_distance_times_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize distance * (1 + k/ (slack+eps)) among feasible (multiplicative urgency).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    k = 0.5 * (np.mean(slack2) + 1e-9)\n    score = d2 * (1.0 + (k / (slack2 + 1e-9)))\n    return int(u2[int(np.argmin(score))])\n",
  "capacity_and_depot_compactness": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer: (tight capacity usage) + (compact wrt depot) while feasible in time windows.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    left_cap = cap - demands[u2].astype(float)\n    cap_term = -np.abs(left_cap)  # closer to 0 is better\n    depot_term = -distance_matrix[int(depot), u2]\n    dist_term = -distance_matrix[int(current_node), u2]\n    score = 0.6 * cap_term + 0.25 * depot_term + 0.15 * dist_term\n    return int(u2[int(np.argmax(score))])\n",
  "time_window_centerline_plus_savings": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Blend window-midpoint alignment with a savings-like term.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    mid = 0.5 * (time_windows[u2, 0] + time_windows[u2, 1])\n    align = -np.abs(start2 - mid)\n    savings = distance_matrix[int(current_node), int(depot)] + distance_matrix[int(depot), u2] - d2\n    score = 0.7 * align + 0.3 * savings\n    return int(u2[int(np.argmax(score))])\n",
  "min_distance_subject_to_slack_quantile": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Filter to most-urgent (lowest 30% slack), then take nearest feasible; fallback nearest feasible.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    thr = np.quantile(slack2, 0.30)\n    urgent = u2[slack2 <= thr]\n    if urgent.size > 0:\n        return int(urgent[int(np.argmin(distance_matrix[int(current_node), urgent]))])\n    return int(u2[int(np.argmin(d2))])\n",
  "maximize_service_start_soon": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible customer with smallest service start time (get moving on service quickly).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    return int(u2[int(np.argmin(start2))])\n",
  "max_slack_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select feasible node with maximum time slack (due - service_start).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    return int(u2[int(np.argmax(slack2))])\n",
  "min_demand_that_fits": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible node with smallest demand (save capacity).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    return int(u2[int(np.argmin(demands[u2]))])\n",
  "min_detour_plus_wait": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize detour to depot plus waiting time.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    start = np.maximum(arr, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    detour = d2 + distance_matrix[u2, int(depot)] - distance_matrix[int(current_node), int(depot)]\n    score = detour + wait2\n    return int(u2[int(np.argmin(score))])\n",
  "closest_unvisited_neighbor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer feasible node closest to another unvisited node (cluster-forming).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    best = int(u2[0])\n    best_dist = np.inf\n    for node in u2:\n        others = unv[unv != node]\n        if others.size == 0:\n            return int(node)\n        dmin = float(np.min(distance_matrix[int(node), others]))\n        if dmin < best_dist:\n            best_dist = dmin\n            best = int(node)\n    return int(best)\n",
  "max_future_feasible_count": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Lookahead: choose node that leaves the most feasible options next.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    best = int(u2[0])\n    best_count = -1\n    best_dist = np.inf\n    for node in u2:\n        cap2 = cap - float(demands[int(node)])\n        t2 = float(np.maximum(t + distance_matrix[int(current_node), int(node)], time_windows[int(node), 0]))\n        others = unv[unv != node]\n        if others.size == 0:\n            return int(node)\n        d2 = distance_matrix[int(node), others]\n        start2 = np.maximum(t2 + d2, time_windows[others, 0])\n        feas2 = (demands[others] <= cap2) & (start2 <= time_windows[others, 1])\n        count = int(np.sum(feas2))\n        dist_now = float(distance_matrix[int(current_node), int(node)])\n        if (count > best_count) or (count == best_count and dist_now < best_dist):\n            best_count = count\n            best_dist = dist_now\n            best = int(node)\n    return int(best)\n",
  "due_time_proximity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible node with due time closest to the current time.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    due = time_windows[u2, 1]\n    dist = distance_matrix[int(current_node), u2]\n    score = np.abs(due - t) + 1e-6 * dist\n    return int(u2[int(np.argmin(score))])\n",
  "travel_over_slack_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize travel/slack ratio (short travel with comfortable slack).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = d2 / (slack2 + 1e-9)\n    return int(u2[int(np.argmin(score))])\n",
  "mean_distance_to_unvisited_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer a feasible node far from remaining customers (diversify route).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    mean_to_others = np.mean(distance_matrix[u2][:, unv], axis=1)\n    score = mean_to_others - 0.15 * distance_matrix[int(current_node), u2]\n    return int(u2[int(np.argmax(score))])\n",
  "max_future_feasible_successors": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Lookahead-by-count: pick the next node that maximizes the number of feasible successors after visiting it.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n    best_u = int(cand[0])\n    best_cnt = -1\n    best_tiebreak = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size == 0:\n            cnt = 0\n        else:\n            darr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(darr, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (start_v <= time_windows[others, 1])\n            cnt = int(np.sum(feas_v))\n\n        # tie-break: smaller immediate travel\n        tb = float(distance_matrix[int(current_node), u])\n        if (cnt > best_cnt) or (cnt == best_cnt and tb < best_tiebreak):\n            best_cnt = cnt\n            best_tiebreak = tb\n            best_u = u\n\n    return int(best_u)\n",
  "min_worstcase_next_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Robust lookahead: choose u that maximizes the *minimum* slack among feasible successors after serving u.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n\n    best_u = int(cand[0])\n    best_worst = -np.inf\n    best_tb = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size == 0:\n            worst_slack = np.inf\n        else:\n            arr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(arr, time_windows[others, 0])\n            slack_v = time_windows[others, 1] - start_v\n            feas_v = (demands[others] <= cap1) & (slack_v >= 0)\n            if not np.any(feas_v):\n                worst_slack = -np.inf\n            else:\n                worst_slack = float(np.min(slack_v[feas_v]))\n\n        tb = float(distance_matrix[int(current_node), u])\n        if (worst_slack > best_worst) or (worst_slack == best_worst and tb < best_tb):\n            best_worst = worst_slack\n            best_tb = tb\n            best_u = u\n\n    return int(best_u)\n",
  "savings_ratio_preference": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize (Clarke-Wright-like savings) per unit travel from current (ratio form), among feasible nodes.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcu, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d_cur_depot = float(distance_matrix[int(current_node), int(depot)])\n    d_depot_u = distance_matrix[int(depot), u2]\n    d_cur_u = distance_matrix[int(current_node), u2]\n\n    savings = d_cur_depot + d_depot_u - d_cur_u\n    score = savings / (d_cur_u + 1e-9)\n\n    # mild penalty for tiny slack to avoid brittle picks\n    start2 = np.maximum(t + d_cur_u, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = score - 1e-3 * (1.0 / (slack2 + 1.0))\n\n    return int(u2[int(np.argmax(score))])\n",
  "overlap_length_density": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Time-window overlap *length* density: favor nodes whose window overlaps others the most (sum of overlap lengths).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    s = time_windows[u2, 0].astype(float)\n    e = time_windows[u2, 1].astype(float)\n\n    # overlap length matrix (vectorized): sum_j max(0, min(e_i,e_j) - max(s_i,s_j))\n    min_end = np.minimum(e[:, None], e[None, :])\n    max_start = np.maximum(s[:, None], s[None, :])\n    overlap = np.maximum(0.0, min_end - max_start)\n    overlap_sum = np.sum(overlap, axis=1) - np.diag(overlap)  # exclude self\n\n    dist = distance_matrix[int(current_node), u2]\n    # prefer high overlap, tie-break by shorter distance\n    score = overlap_sum - 0.25 * dist\n    return int(u2[int(np.argmax(score))])\n",
  "capacity_quantile_switch_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Demand-quantile switching: if remaining capacity is scarce vs remaining demands, pick smallest-demand feasible; else pick largest-demand feasible.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    dem = demands[u2].astype(float)\n\n    # scarcity proxy: where does cap sit in the demand distribution of remaining customers?\n    all_dem = demands[unv].astype(float)\n    q80 = float(np.quantile(all_dem, 0.80)) if all_dem.size > 0 else 0.0\n\n    # if cap is below a high-demand quantile, conserve capacity; otherwise, fill aggressively\n    if cap <= q80:\n        # conserve: smallest demand, tie-break by travel\n        dm = dem\n        d2 = distance_matrix[int(current_node), u2]\n        key = np.lexsort((d2, dm))\n        return int(u2[int(key[0])])\n    else:\n        # fill: largest demand, tie-break by travel\n        dm = -dem\n        d2 = distance_matrix[int(current_node), u2]\n        key = np.lexsort((d2, dm))\n        return int(u2[int(key[0])])\n",
  "variance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Structure-seeking: choose a feasible node whose distances to remaining customers have minimal variance (stays in a coherent region).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    # variance of distances from candidate to all unvisited (including infeasible ones as spatial context)\n    dist_mat = distance_matrix[u2][:, unv].astype(float)\n    var = np.var(dist_mat, axis=1)\n\n    # tie-break: shorter from current\n    d2 = distance_matrix[int(current_node), u2].astype(float)\n    score = var + 1e-3 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "deadline_weighted_by_wait": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prioritize early deadlines, but discount urgency if it would induce large waiting (serve \"ready\" urgent nodes first).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n\n    due = time_windows[u2, 1].astype(float)\n\n    # smaller due is better, but large wait reduces priority\n    score = due + 0.8 * wait2 + 0.05 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "k_nearest_feasible_then_best_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Restricted candidate list (RCL): take k nearest feasible nodes, then pick the one with smallest slack inside the RCL.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n\n    k = int(min(5, u2.size))\n    rcl = u2[np.argpartition(d2, k - 1)[:k]]\n\n    d3 = distance_matrix[int(current_node), rcl]\n    start3 = np.maximum(t0 + d3, time_windows[rcl, 0])\n    slack3 = time_windows[rcl, 1] - start3\n\n    # smallest slack in RCL; tie-break by distance\n    key = np.lexsort((d3, slack3))\n    return int(rcl[int(key[0])])\n",
  "feasible_pareto_rank_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Non-dominated sorting on (distance, wait, -demand, slack) then pick best rank; tie-break by distance.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n\n    d2 = distance_matrix[int(current_node), u2].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1].astype(float) - start2\n    dem2 = demands[u2].astype(float)\n\n    # Objectives to minimize: [distance, wait, -demand, -slack] (i.e., prefer big demand and big slack)\n    obj = np.vstack([d2, wait2, -dem2, -slack2]).T\n\n    n = obj.shape[0]\n    rank = np.zeros(n, dtype=int)\n    for i in range(n):\n        dominated_by = 0\n        for j in range(n):\n            if i == j:\n                continue\n            # j dominates i if <= in all and < in at least one\n            le_all = np.all(obj[j] <= obj[i] + 1e-12)\n            lt_any = np.any(obj[j] < obj[i] - 1e-12)\n            if le_all and lt_any:\n                dominated_by += 1\n        rank[i] = dominated_by\n\n    best_rank = np.min(rank)\n    idx = np.where(rank == best_rank)[0]\n    if idx.size == 1:\n        return int(u2[int(idx[0])])\n\n    # tie-break within best front by smallest distance\n    pick = idx[int(np.argmin(d2[idx]))]\n    return int(u2[int(pick)])\n",
  "return_feasibility_margin_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick the feasible node that maximizes margin for returning to depot by depot's due time (if any); else fallback to best margin to its own due.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n\n    # depot due might be finite (some instances encode it); if not, treat as infinity\n    depot_due = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n    back = distance_matrix[u2, int(depot)].astype(float)\n\n    # margin after serving u (ignores service times): depot_due - (service_start_u + travel_back)\n    margin_depot = depot_due - (start2 + back)\n\n    # if depot_due is inf, margin_depot is inf; then use own-due margin instead\n    if not np.isfinite(depot_due):\n        margin = time_windows[u2, 1].astype(float) - start2\n    else:\n        margin = margin_depot\n\n    # maximize margin; tie-break by shorter (to u + u to depot)\n    tie = (d2 + back)\n    key = np.lexsort((tie, -margin))\n    return int(u2[int(key[0])])\n",
  "min_avg_distance_to_remaining": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Centrality rule: pick feasible node with minimum average distance to remaining unvisited (stay near the 'center' of remaining demand).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    # average distance from candidate to all remaining (including infeasible for spatial context)\n    dm = distance_matrix[cand][:, unv].astype(float)\n    avgd = np.mean(dm, axis=1)\n    # tie-break by closer from current\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, avgd))\n    return int(cand[int(key[0])])\n",
  "min_k_nearest_sum_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Local k-median proxy: pick feasible node minimizing sum of distances to its k nearest unvisited customers.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    k = int(min(5, unv.size))\n\n    costs = np.empty(cand.size, dtype=float)\n    for i, u in enumerate(cand):\n        dist_u = distance_matrix[int(u), unv].astype(float)\n        idx = np.argpartition(dist_u, k - 1)[:k]\n        costs[i] = float(np.sum(dist_u[idx]))\n\n    # tie-break by distance from current\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, costs))\n    return int(cand[int(key[0])])\n",
  "max_feasible_density_within_percentile_radius": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Density rule: pick feasible node that has the most *feasible* neighbors within a distance radius (radius = 25th percentile of pairwise distances from that node).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n\n    best = int(cand[0])\n    best_cnt = -1\n    best_tb = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size == 0:\n            cnt = 0\n        else:\n            dist = distance_matrix[u, others].astype(float)\n            r = float(np.quantile(dist, 0.25)) if dist.size > 0 else 0.0\n            near = others[dist <= r]\n            if near.size == 0:\n                cnt = 0\n            else:\n                arr = t1 + distance_matrix[u, near]\n                start_v = np.maximum(arr, time_windows[near, 0])\n                feas_v = (demands[near] <= cap1) & (start_v <= time_windows[near, 1])\n                cnt = int(np.sum(feas_v))\n\n        tb = float(distance_matrix[int(current_node), u])\n        if (cnt > best_cnt) or (cnt == best_cnt and tb < best_tb):\n            best_cnt = cnt\n            best_tb = tb\n            best = u\n\n    return int(best)\n",
  "regret_two_step_best_vs_second": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"2-step regret: for each candidate u, compute best and 2nd-best next-step costs after u; pick u with largest regret (2nd-best - best).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n\n    best_u = int(cand[0])\n    best_regret = -np.inf\n    best_tb = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size < 2:\n            regret = -np.inf\n        else:\n            arr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(arr, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (start_v <= time_windows[others, 1])\n            feas_list = others[feas_v]\n            if feas_list.size < 2:\n                regret = -np.inf\n            else:\n                # next-step cost: travel + waiting\n                dv = distance_matrix[u, feas_list].astype(float)\n                arr2 = t1 + dv\n                wait2 = np.maximum(0.0, time_windows[feas_list, 0].astype(float) - arr2)\n                cost = dv + wait2\n                # regret = 2nd best - best\n                idx = np.argpartition(cost, 1)[:2]\n                a, b = float(np.min(cost[idx])), float(np.max(cost[idx]))\n                regret = b - a\n\n        tb = float(distance_matrix[int(current_node), u])\n        if (regret > best_regret) or (regret == best_regret and tb < best_tb):\n            best_regret = regret\n            best_tb = tb\n            best_u = u\n\n    if not np.isfinite(best_regret):\n        # fallback: nearest feasible\n        d2 = distance_matrix[int(current_node), cand].astype(float)\n        return int(cand[int(np.argmin(d2))])\n\n    return int(best_u)\n",
  "dynamic_lambda_distance_vs_slack_by_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Adaptive weighting: trade off distance vs urgency with lambda increasing as current time approaches median due time.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + dcur, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    due_med = float(np.median(time_windows[unv, 1].astype(float)))\n    # lambda in [0.2, 0.9] increases as time approaches (or exceeds) due_med\n    x = (t - due_med) / (abs(due_med) + 1.0)\n    lam = float(np.clip(0.55 + 0.35 * np.tanh(x), 0.2, 0.9))\n\n    # minimize: lam*distance + (1-lam)*(-urgency) where urgency = 1/(slack+1)\n    urgency = 1.0 / (slack2 + 1.0)\n    score = lam * d2 + (1.0 - lam) * urgency\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_wait_to_avoid_early_idle": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"If feasible, deliberately pick a customer that induces waiting (to align with later windows) while staying safe (nonnegative slack).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    # maximize wait, but keep some safety by adding small slack preference\n    score = wait2 + 1e-3 * slack2\n    return int(cand[int(np.argmax(score))])\n",
  "radial_continuity_to_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Radial continuity: pick feasible node whose depot-distance is closest to current_node's depot-distance (keeps radial band consistent).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    r0 = float(distance_matrix[int(depot), int(current_node)])\n    r = distance_matrix[int(depot), cand].astype(float)\n    band = np.abs(r - r0)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, band))\n    return int(cand[int(key[0])])\n",
  "min_distance_plus_quadratic_wait": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Convex waiting penalty: minimize distance + wait^2 among feasible nodes.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n\n    score = d2 + wait2 * wait2\n    return int(cand[int(np.argmin(score))])\n",
  "max_product_slack_and_postcap": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize (slack+1)*(remaining_capacity_after+1) among feasible (balances schedule flexibility and future capacity).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n    feas = (demands[unv] <= cap0) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    postcap = cap0 - demands[cand].astype(float)\n\n    score = (slack2 + 1.0) * (postcap + 1.0)\n    # tie-break by shorter distance\n    key = np.lexsort((d2, -score))\n    return int(cand[int(key[0])])\n",
  "min_distance_scaled_by_window_narrowness": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize distance * (1 + 1/(window_width+1)) (prioritizes constrained windows without pure deadline sorting).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    width = (time_windows[cand, 1] - time_windows[cand, 0]).astype(float)\n\n    scale = 1.0 + 1.0 / (width + 1.0)\n    score = d2 * scale\n    return int(cand[int(np.argmin(score))])\n",
  "earliest_open_time_then_shortest_travel": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Lexicographic: smallest time-window start first; tie-break by travel distance.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    open_t = time_windows[cand, 0].astype(float)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n\n    key = np.lexsort((d2, open_t))\n    return int(cand[int(key[0])])\n",
  "min_due_minus_start_gap": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible node minimizing (due - service_start) (i.e., smallest remaining room), but without explicit slack-only sorting by adding distance tie-break.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    gap = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (gap >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    gap2 = time_windows[cand, 1].astype(float) - start2\n\n    key = np.lexsort((d2, gap2))\n    return int(cand[int(key[0])])\n",
  "maximize_depot_return_margin_after_visit": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize flexibility to return to depot after visiting u: (depot_due - (start_u + dist(u,depot))). If depot_due is infinite, use -(dist to depot).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n\n    depot_due = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t0 + d2, time_windows[cand, 0].astype(float))\n    back = distance_matrix[cand, int(depot)].astype(float)\n\n    if np.isfinite(depot_due):\n        margin = depot_due - (start2 + back)\n        # maximize margin; tie-break shorter current->u\n        key = np.lexsort((d2, -margin))\n        return int(cand[int(key[0])])\n\n    # if no meaningful depot due, prefer closer to depot after visit, tie-break by current->u\n    key = np.lexsort((d2, back))\n    return int(cand[int(key[0])])\n",
  "two_stage_filter_by_open_quantile_then_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Two-stage: among feasible nodes, keep earliest-opening quantile (lowest 40% by open time), then pick max demand (tie by distance).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    opens = time_windows[cand, 0].astype(float)\n    thr = float(np.quantile(opens, 0.40)) if cand.size > 1 else float(opens[0])\n    filt = cand[opens <= thr]\n    if filt.size == 0:\n        filt = cand\n\n    dem = demands[filt].astype(float)\n    d2 = distance_matrix[int(current_node), filt].astype(float)\n    key = np.lexsort((d2, -dem))\n    return int(filt[int(key[0])])\n",
  "min_detour_minus_wait_credit": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Return-detour with waiting credit: minimize (cur->u + u->depot - cur->depot) - beta*wait(u).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + dcu\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d1 = distance_matrix[int(current_node), cand].astype(float)\n    d2 = distance_matrix[cand, int(depot)].astype(float)\n    direct = float(distance_matrix[int(current_node), int(depot)])\n\n    arr2 = t + d1\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n\n    detour = d1 + d2 - direct\n    beta = 0.7\n    score = detour - beta * wait2\n    return int(cand[int(np.argmin(score))])\n",
  "min_bottleneck_to_k_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Bottleneck minimization: pick feasible u minimizing max distance to its k nearest unvisited nodes (reduces local worst-case reach).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    k = int(min(5, unv.size))\n\n    bott = np.empty(cand.size, dtype=float)\n    for i, u in enumerate(cand):\n        dist_u = distance_matrix[int(u), unv].astype(float)\n        idx = np.argpartition(dist_u, k - 1)[:k]\n        bott[i] = float(np.max(dist_u[idx]))\n\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, bott))\n    return int(cand[int(key[0])])\n",
  "deadline_alignment_with_neighborhood": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Temporal clustering: pick feasible u whose due time is closest to the average due time of its k nearest unvisited neighbors.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + dcur, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    k = int(min(5, unv.size))\n\n    align = np.empty(cand.size, dtype=float)\n    due_all = time_windows[unv, 1].astype(float)\n\n    for i, u in enumerate(cand):\n        dist_u = distance_matrix[int(u), unv].astype(float)\n        idx = np.argpartition(dist_u, k - 1)[:k]\n        neigh_due_mean = float(np.mean(due_all[idx]))\n        align[i] = abs(float(time_windows[int(u), 1]) - neigh_due_mean)\n\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, align))\n    return int(cand[int(key[0])])\n",
  "capacity_smoothing_to_median_remaining_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Capacity smoothing: pick feasible u that makes post-visit remaining capacity close to median remaining demand (keeps flexibility).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    med_dem = float(np.median(demands[unv].astype(float))) if unv.size > 0 else 0.0\n\n    postcap = cap0 - demands[cand].astype(float)\n    diff = np.abs(postcap - med_dem)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, diff))\n    return int(cand[int(key[0])])\n",
  "maximize_slack_minus_distance_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize (slack - alpha*distance) among feasible nodes (explicit flexibility-seeking with travel penalty).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    alpha = 0.35\n    score = slack2 - alpha * d2\n    return int(cand[int(np.argmax(score))])\n",
  "min_distance_with_deadline_soft_barrier": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Nearest-feasible with soft deadline barrier: minimize distance + gamma*exp(-slack/scale).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    scale = max(1.0, float(np.median(slack2 + 1.0)))\n    gamma = 2.0\n    barrier = np.exp(-slack2 / scale)\n    score = d2 + gamma * barrier\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_demand_per_extra_time_budget": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Efficiency by time budget: maximize demand / (travel + wait + 1) among feasible nodes.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n\n    score = demands[cand].astype(float) / (d2 + wait2 + 1.0)\n    return int(cand[int(np.argmax(score))])\n",
  "median_due_time_proximity_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible node whose due time is closest to the median due time of remaining customers; tie-break by distance.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    med_due = float(np.median(time_windows[unv, 1].astype(float)))\n    diff = np.abs(time_windows[cand, 1].astype(float) - med_due)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, diff))\n    return int(cand[int(key[0])])\n",
  "depot_distance_balance_to_remaining_mean": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Balance depot radius: pick feasible u with depot-distance closest to mean depot-distance of remaining unvisited (stabilizes radial progression).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    depot_d_all = distance_matrix[int(depot), unv].astype(float)\n    target = float(np.mean(depot_d_all)) if depot_d_all.size > 0 else 0.0\n\n    depot_d = distance_matrix[int(depot), cand].astype(float)\n    diff = np.abs(depot_d - target)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n\n    key = np.lexsort((d2, diff))\n    return int(cand[int(key[0])])\n",
  "min_distance_with_postcap_parity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize distance, but prefer leaving an even-looking residual capacity (postcap close to half of current cap).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + dcur, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    postcap = cap0 - demands[cand].astype(float)\n\n    target = 0.5 * cap0\n    parity = np.abs(postcap - target)\n\n    score = d2 + 0.25 * parity\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_time_window_intersection_with_now": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Pick feasible u maximizing intersection length between [current_time, current_time + horizon] and u's time window (prefers windows active soon).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + dcur, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n\n    # horizon based on median remaining window width\n    width_all = (time_windows[unv, 1] - time_windows[unv, 0]).astype(float)\n    horizon = float(np.median(width_all)) if width_all.size > 0 else 0.0\n    horizon = max(1.0, horizon)\n\n    a = np.maximum(time_windows[cand, 0].astype(float), t)\n    b = np.minimum(time_windows[cand, 1].astype(float), t + horizon)\n    inter = np.maximum(0.0, b - a)\n\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, -inter))\n    return int(cand[int(key[0])])\n",
  "min_normalized_lateness_risk_index": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Risk index: minimize (travel+wait) / (slack+1) among feasible nodes (penalizes fragile long moves).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    risk = (d2 + wait2) / (slack2 + 1.0)\n    return int(cand[int(np.argmin(risk))])\n",
  "maximize_slack_to_window_width_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Flexibility density: maximize slack / (window_width+1) among feasible nodes (prefers extra room inside tighter windows).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n    width = (time_windows[unv, 1] - time_windows[unv, 0]).astype(float)\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    width2 = (time_windows[cand, 1] - time_windows[cand, 0]).astype(float)\n\n    score = slack2 / (width2 + 1.0)\n    return int(cand[int(np.argmax(score))])\n",
  "min_distance_with_capacity_urgency_coupling": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Coupled term: minimize distance + eta*(demand/cap)*(1/(slack+1)) (penalizes serving large-demand fragile-window far away).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap0) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    frac = demands[cand].astype(float) / (cap0 + 1e-9)\n    eta = 3.0\n    score = d2 + eta * frac * (1.0 / (slack2 + 1.0))\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_distance_then_feasibility_safety": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Exploration: pick the farthest feasible from current, but prefer higher slack as tie-break (diversifies route shapes).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    # farthest first, then larger slack\n    key = np.lexsort((-slack2, -d2))\n    return int(cand[int(key[0])])\n",
  "min_distance_to_depot_plus_slack_bonus": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize u->depot distance, but add a bonus for slack (encourages staging near depot when flexible).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    back = distance_matrix[cand, int(depot)].astype(float)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    score = back - 0.15 * slack2\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_joint_savings_and_time_alignment": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize [savings] * [time alignment], where alignment = exp(-|start-mid|/scale).\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t0 + d2, time_windows[cand, 0].astype(float))\n\n    mid = 0.5 * (time_windows[cand, 0].astype(float) + time_windows[cand, 1].astype(float))\n    scale = max(1.0, float(np.median(np.abs(start2 - mid) + 1.0)))\n    align = np.exp(-np.abs(start2 - mid) / scale)\n\n    savings = float(distance_matrix[int(current_node), int(depot)]) + distance_matrix[int(depot), cand].astype(float) - d2\n    score = savings * align\n\n    # tie-break by higher slack\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    key = np.lexsort((-slack2, -score))\n    return int(cand[int(key[0])])\n",
  "min_distance_with_future_capacity_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Nearest-feasible, but avoid using up too much capacity early: add penalty if postcap < q20 of remaining demands.\"\"\"\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    postcap = cap0 - demands[cand].astype(float)\n\n    q20 = float(np.quantile(demands[unv].astype(float), 0.20)) if unv.size > 0 else 0.0\n    penalty = np.where(postcap < q20, (q20 - postcap), 0.0)\n\n    score = d2 + 0.6 * penalty\n    return int(cand[int(np.argmin(score))])\n"
}


