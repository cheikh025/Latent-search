{
  "nearest_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    return int(feasible[np.argmin(distances)])\n",
  "earliest_deadline_first": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    deadlines = time_windows[feasible, 1]\n    return int(feasible[np.argmin(deadlines)])\n",
  "minimum_slack_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                slacks.append(slack)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(slacks)])\n",
  "earliest_start_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    start_times = time_windows[feasible, 0]\n    return int(feasible[np.argmin(start_times)])\n",
  "minimize_wait_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    wait_times = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                wait = max(0, time_windows[node][0] - arrival)\n                wait_times.append(wait)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(wait_times)])\n",
  "time_distance_weighted": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    slacks = np.array(slacks)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    slack_norm = slacks / (np.mean(slacks) + 1e-9)\n    \n    scores = 0.5 * dist_norm + 0.5 * (1.0 / (slack_norm + 1e-9))\n    return int(feasible[np.argmin(scores)])\n",
  "savings_with_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    return int(feasible[np.argmax(savings)])\n",
  "urgency_capacity_balance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    \n    demand_norm = demand_vals / (np.mean(demand_vals) + 1e-9)\n    urgency = 1.0 / (slacks + 1e-9)\n    urgency_norm = urgency / (np.mean(urgency) + 1e-9)\n    \n    scores = 0.6 * urgency_norm - 0.4 * demand_norm\n    return int(feasible[np.argmax(scores)])\n",
  "time_window_width": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    widths = time_windows[feasible, 1] - time_windows[feasible, 0]\n    return int(feasible[np.argmin(widths)])\n",
  "latest_acceptable_arrival": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    latest_arrivals = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                latest_arrivals.append(time_windows[node][1])\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmax(latest_arrivals)])\n",
  "minimal_detour_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    direct_time = distance_matrix[current_node, depot]\n    detour_times = (distance_matrix[current_node, feasible] + \n                    distance_matrix[feasible, depot] - direct_time)\n    \n    return int(feasible[np.argmin(detour_times)])\n",
  "demand_to_distance_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible] + 1e-9\n    demand_vals = demands[feasible]\n    ratios = demand_vals / distances\n    \n    return int(feasible[np.argmax(ratios)])\n",
  "composite_time_dist_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = 0.4 * norm(urgency) + 0.3 * norm(distances) - 0.3 * norm(demand_vals)\n    \n    return int(feasible[np.argmin(score)])\n",
  "adaptive_time_pressure": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    slacks = np.array(slacks)\n    avg_slack = np.mean(slacks)\n    \n    distances = distance_matrix[current_node, feasible]\n    \n    # Tight time windows: prioritize urgency; Loose: prioritize distance\n    if avg_slack < 5.0:\n        urgency = 1.0 / (slacks + 1e-9)\n        return int(feasible[np.argmax(urgency)])\n    else:\n        return int(feasible[np.argmin(distances)])\n",
  "regret_time_based": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    if len(feasible) == 1:\n        return int(feasible[0])\n    \n    slacks = np.array(slacks)\n    sorted_idx = np.argsort(slacks)\n    \n    if len(sorted_idx) > 1:\n        regret = slacks[sorted_idx[1]] - slacks[sorted_idx[0]]\n        return int(feasible[sorted_idx[0]])  # Most urgent\n    \n    return int(feasible[sorted_idx[0]])\n",
  "insertion_cost_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    time_to_depot = distance_matrix[current_node, depot]\n    time_via_node = (distance_matrix[current_node, feasible] + \n                     distance_matrix[feasible, depot])\n    \n    insertion_costs = time_via_node - time_to_depot\n    return int(feasible[np.argmin(insertion_costs)])\n",
  "time_proximity_cluster": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    # Prefer nodes with time windows close to current time\n    tw_starts = time_windows[feasible, 0]\n    time_proximity = np.abs(tw_starts - current_time)\n    \n    distances = distance_matrix[current_node, feasible]\n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    time_norm = time_proximity / (np.mean(time_proximity) + 1e-9)\n    \n    scores = 0.6 * dist_norm + 0.4 * time_norm\n    return int(feasible[np.argmin(scores)])\n",
  "wait_vs_travel_trade_off": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    wait_times = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                wait_times.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    travel_times = distance_matrix[current_node, feasible]\n    wait_times = np.array(wait_times)\n    \n    total_times = travel_times + wait_times\n    return int(feasible[np.argmin(total_times)])\n",
  "deadline_proximity_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    ratios = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            travel = distance_matrix[current_node, node]\n            arrival = current_time + travel\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                ratio = slack / (travel + 1e-9)\n                ratios.append(ratio)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(ratios)])  # Prefer low slack-to-travel ratio\n",
  "stochastic_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    urgencies = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                urgencies.append(1.0 / (slack + 1.0))\n    \n    if not feasible:\n        return depot\n    \n    urgencies = np.array(urgencies)\n    probs = urgencies / np.sum(urgencies)\n    \n    seed = int(current_node * 2654435761) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "time_window_midpoint": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    deviations = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                midpoint = (time_windows[node][0] + time_windows[node][1]) / 2.0\n                service_start = max(arrival, time_windows[node][0])\n                deviations.append(abs(service_start - midpoint))\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(deviations)])\n",
  "capacity_time_balance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    capacity_ratio = rest_capacity / (np.max(demands) + 1e-9)\n    slacks = np.array(slacks)\n    demand_vals = demands[feasible]\n    \n    # Low capacity: prefer small demand; High urgency: prefer urgent\n    if capacity_ratio < 0.3:\n        return int(feasible[np.argmin(demand_vals)])\n    else:\n        return int(feasible[np.argmin(slacks)])\n",
  "five_factor_composite": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    waits = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n                waits.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n    capacity_util = demand_vals / (rest_capacity + 1e-9)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = (0.25 * norm(distances) - \n             0.20 * norm(demand_vals) + \n             0.30 * norm(urgency) + \n             0.15 * norm(waits) + \n             0.10 * norm(capacity_util))\n    \n    return int(feasible[np.argmin(score)])\n",
  "random_time_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    seed = int(current_node * 73856093) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible))\n",
  "hybrid_savings_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    urgencies = 1.0 / (np.array(slacks) + 1.0)\n    \n    savings_norm = savings / (np.mean(np.abs(savings)) + 1e-9)\n    urgency_norm = urgencies / (np.mean(urgencies) + 1e-9)\n    \n    scores = 0.5 * savings_norm + 0.5 * urgency_norm\n    return int(feasible[np.argmax(scores)])\n",
  "time_density_routing": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    # Count how many other nodes have similar time windows\n    densities = []\n    for node in feasible:\n        tw_start = time_windows[node, 0]\n        tw_end = time_windows[node, 1]\n        # Count nodes with overlapping windows\n        overlaps = 0\n        for other in unvisited_nodes:\n            if other != node:\n                other_start = time_windows[other, 0]\n                other_end = time_windows[other, 1]\n                if not (tw_end < other_start or other_end < tw_start):\n                    overlaps += 1\n        densities.append(overlaps)\n    \n    distances = distance_matrix[current_node, feasible]\n    densities = np.array(densities)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    density_norm = densities / (np.max(densities) + 1e-9)\n    \n    scores = dist_norm - 0.6 * density_norm\n    return int(feasible[np.argmin(scores)])\n",
  "progressive_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    # Progress indicator\n    max_time = np.max(time_windows[:, 1])\n    progress = current_time / (max_time + 1e-9)\n    \n    distances = distance_matrix[current_node, feasible]\n    urgencies = 1.0 / (np.array(slacks) + 1.0)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    urgency_norm = urgencies / (np.mean(urgencies) + 1e-9)\n    \n    # Early: 70% distance, 30% urgency; Late: 30% distance, 70% urgency\n    weight = progress\n    scores = (1 - weight) * 0.7 * dist_norm + weight * 0.7 * urgency_norm\n    \n    return int(feasible[np.argmin(scores)])\n",
  "minmax_normalized_vrptw": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    waits = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n                waits.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n    \n    def minmax(x):\n        mn, mx = x.min(), x.max()\n        if mx - mn < 1e-9:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = (minmax(distances) - minmax(demand_vals) + \n             minmax(urgency) + minmax(waits))\n    \n    return int(feasible[np.argmin(score)])\n",
  "min_time_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    due = time_windows[unv, 1]\n    slack = due - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    slack2 = time_windows[u2, 1] - np.maximum(t + distance_matrix[int(current_node), u2], time_windows[u2, 0])\n    return int(u2[int(np.argmin(slack2))])\n",
  "max_demand_that_fits": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmax(demands[u2]))])\n",
  "capacity_tight_fill": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    left_cap = cap - demands[u2]\n    return int(u2[int(np.argmin(left_cap))])\n",
  "farthest_from_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmax(distance_matrix[int(depot), u2]))])\n",
  "nearest_to_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    start = np.maximum(t + distance_matrix[int(current_node), unv], time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    return int(u2[int(np.argmin(distance_matrix[int(depot), u2]))])\n",
  "urgent_then_near": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    slack2 = time_windows[u2, 1] - np.maximum(t + d2, time_windows[u2, 0])\n    key = np.lexsort((d2, slack2))\n    return int(u2[int(key[0])])\n",
  "normalized_tradeoff_dist_wait_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1] - start2\n\n    x = d2 + wait2\n    zx = (x - np.mean(x)) / (np.std(x) + 1e-12)\n    zs = (slack2 - np.mean(slack2)) / (np.std(slack2) + 1e-12)\n    score = zx - 0.8 * (-zs)  # penalize larger (less-urgent) slack\n    return int(u2[int(np.argmin(score))])\n",
  "regret2_slack_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    base = -slack2 + 0.05 * d2\n    order = np.argsort(base)\n    best = base[order[0]]\n    second = base[order[1]] if order.size > 1 else best\n    regret = second - best\n    # choose the node corresponding to best (lowest base) but if regret is large, lock it in\n    return int(u2[int(order[0])]) if regret >= 0 else int(u2[int(order[0])])\n",
  "exponential_lateness_risk": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    risk = np.exp(-slack2 / (np.std(slack2) + 1e-9))\n    score = d2 * (1.0 + 2.0 * risk)\n    return int(u2[int(np.argmin(score))])\n",
  "quadratic_wait_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    score = d2 + (wait2 ** 2)\n    return int(u2[int(np.argmin(score))])\n",
  "return_to_depot_aware": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n    u2 = unv[feas]\n    score = distance_matrix[int(current_node), u2] + distance_matrix[u2, int(depot)]\n    return int(u2[int(np.argmin(score))])\n",
  "mean_distance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    mean_to_others = np.mean(distance_matrix[u2][:, unv], axis=1)\n    score = 0.7 * distance_matrix[int(current_node), u2] + 0.3 * mean_to_others\n    return int(u2[int(np.argmin(score))])\n",
  "median_distance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    med_to_others = np.median(distance_matrix[u2][:, unv], axis=1)\n    score = 0.6 * distance_matrix[int(current_node), u2] + 0.4 * med_to_others\n    return int(u2[int(np.argmin(score))])\n",
  "clarke_wright_savings_like": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcu, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    savings = distance_matrix[int(current_node), int(depot)] + distance_matrix[int(depot), u2] - distance_matrix[int(current_node), u2]\n    # prefer higher savings, slight urgency tie-break\n    slack = time_windows[u2, 1] - np.maximum(t + distance_matrix[int(current_node), u2], time_windows[u2, 0])\n    score = savings + 1e-3 * (-slack)\n    return int(u2[int(np.argmax(score))])\n",
  "widest_time_window_then_near": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    width = time_windows[u2, 1] - time_windows[u2, 0]\n    best_width = np.max(width)\n    cand = u2[width == best_width]\n    if cand.size == 1:\n        return int(cand[0])\n    return int(cand[int(np.argmin(distance_matrix[int(current_node), cand]))])\n",
  "midpoint_service_target": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    mid = 0.5 * (time_windows[u2, 0] + time_windows[u2, 1])\n    score = np.abs(start2 - mid) + 0.1 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "demand_over_slack_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = demands[u2] / (slack2 + 1e-9)\n    return int(u2[int(np.argmax(score))])\n",
  "adaptive_distance_vs_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    # urgency signal: lower slack => higher urgency\n    urg = 1.0 / (slack2 + 1e-9)\n    # adaptive alpha based on how tight things are (relative slack)\n    rel = slack2 / (np.mean(slack2) + 1e-9)\n    alpha = float(np.clip(0.7 - 0.4 * np.mean(rel), 0.2, 0.8))\n    score = alpha * d2 + (1.0 - alpha) * (1.0 / (urg + 1e-9))\n    return int(u2[int(np.argmin(score))])\n",
  "lookahead_two_step_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n    best_u = int(cand[0])\n    best_score = np.inf\n\n    for u in cand:\n        cap1 = cap0 - float(demands[int(u)])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), int(u)], time_windows[int(u), 0]))\n        others = cand[cand != u]\n        if others.size == 0:\n            score = distance_matrix[int(current_node), int(u)]\n        else:\n            darr = t1 + distance_matrix[int(u), others]\n            start_v = np.maximum(darr, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (start_v <= time_windows[others, 1])\n            nxt = np.min(distance_matrix[int(u), others[feas_v]]) if np.any(feas_v) else distance_matrix[int(u), int(depot)]\n            score = distance_matrix[int(current_node), int(u)] + nxt\n        if score < best_score:\n            best_score = score\n            best_u = int(u)\n\n    return int(best_u)\n",
  "pseudo_randomized_tie_break_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    jitter = 1e-6 * np.sin((u2.astype(float) + 1.0) * (t + 1.2345))\n    return int(u2[int(np.argmin(d2 + jitter))])\n",
  "late_window_priority_latest_start": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    latest_start_margin = time_windows[unv, 1] - (t + d)\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    margin2 = time_windows[u2, 1] - (t + d2)\n    return int(u2[int(np.argmin(margin2))])\n",
  "min_distance_with_due_time_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    guard = np.maximum(0.0, (np.quantile(slack2, 0.25) - slack2))\n    score = d2 + 5.0 * guard\n    return int(u2[int(np.argmin(score))])\n",
  "demand_and_urgency_weighted": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1] - start2\n\n    dem = demands[u2].astype(float)\n    demN = (dem - np.min(dem)) / (np.ptp(dem) + 1e-12)\n    urg = 1.0 / (slack2 + 1e-9)\n    urgN = (urg - np.min(urg)) / (np.ptp(urg) + 1e-12)\n    distN = (d2 - np.min(d2)) / (np.ptp(d2) + 1e-12)\n    waitN = (wait2 - np.min(wait2)) / (np.ptp(wait2) + 1e-12)\n\n    score = 1.2 * urgN + 0.8 * demN - 0.9 * distN - 0.5 * waitN\n    return int(u2[int(np.argmax(score))])\n",
  "adaptive_farthest_early_nearest_late": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    n_total = int(max(1, time_windows.shape[0] - 1))\n    progress = 1.0 - (float(unv.size) / float(n_total))\n    alpha = float(np.clip(progress, 0.0, 1.0))\n\n    near = distance_matrix[int(current_node), u2]\n    far = distance_matrix[int(depot), u2]\n    score = (1.0 - alpha) * (-far) + alpha * (-near)\n    return int(u2[int(np.argmax(score))])\n",
  "depot_due_feasibility_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n    depot_due = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    back_time = start2 + distance_matrix[u2, int(depot)]\n    feas2 = back_time <= depot_due\n    if np.any(feas2):\n        u3 = u2[feas2]\n        return int(u3[int(np.argmin(distance_matrix[int(current_node), u3]))])\n    return int(u2[int(np.argmin(distance_matrix[int(current_node), u2]))])\n",
  "time_window_overlap_with_now": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t0 + d\n    start = np.maximum(arr, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t0 + d2\n    start2 = np.maximum(arr2, time_windows[u2, 0])\n    score = np.abs(start2 - t0) + 0.05 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "softmin_distance_times_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    k = 0.5 * (np.mean(slack2) + 1e-9)\n    score = d2 * (1.0 + (k / (slack2 + 1e-9)))\n    return int(u2[int(np.argmin(score))])\n",
  "capacity_and_depot_compactness": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    left_cap = cap - demands[u2].astype(float)\n    cap_term = -np.abs(left_cap)  # closer to 0 is better\n    depot_term = -distance_matrix[int(depot), u2]\n    dist_term = -distance_matrix[int(current_node), u2]\n    score = 0.6 * cap_term + 0.25 * depot_term + 0.15 * dist_term\n    return int(u2[int(np.argmax(score))])\n",
  "time_window_centerline_plus_savings": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    mid = 0.5 * (time_windows[u2, 0] + time_windows[u2, 1])\n    align = -np.abs(start2 - mid)\n    savings = distance_matrix[int(current_node), int(depot)] + distance_matrix[int(depot), u2] - d2\n    score = 0.7 * align + 0.3 * savings\n    return int(u2[int(np.argmax(score))])\n",
  "min_distance_subject_to_slack_quantile": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    thr = np.quantile(slack2, 0.30)\n    urgent = u2[slack2 <= thr]\n    if urgent.size > 0:\n        return int(urgent[int(np.argmin(distance_matrix[int(current_node), urgent]))])\n    return int(u2[int(np.argmin(d2))])\n",
  "maximize_service_start_soon": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n    return int(u2[int(np.argmin(start2))])\n",
  "max_slack_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    return int(u2[int(np.argmax(slack2))])\n",
  "min_demand_that_fits": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    return int(u2[int(np.argmin(demands[u2]))])\n",
  "min_detour_plus_wait": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    start = np.maximum(arr, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n    detour = d2 + distance_matrix[u2, int(depot)] - distance_matrix[int(current_node), int(depot)]\n    score = detour + wait2\n    return int(u2[int(np.argmin(score))])\n",
  "closest_unvisited_neighbor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    best = int(u2[0])\n    best_dist = np.inf\n    for node in u2:\n        others = unv[unv != node]\n        if others.size == 0:\n            return int(node)\n        dmin = float(np.min(distance_matrix[int(node), others]))\n        if dmin < best_dist:\n            best_dist = dmin\n            best = int(node)\n    return int(best)\n",
  "max_future_feasible_count": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    best = int(u2[0])\n    best_count = -1\n    best_dist = np.inf\n    for node in u2:\n        cap2 = cap - float(demands[int(node)])\n        t2 = float(np.maximum(t + distance_matrix[int(current_node), int(node)], time_windows[int(node), 0]))\n        others = unv[unv != node]\n        if others.size == 0:\n            return int(node)\n        d2 = distance_matrix[int(node), others]\n        start2 = np.maximum(t2 + d2, time_windows[others, 0])\n        feas2 = (demands[others] <= cap2) & (start2 <= time_windows[others, 1])\n        count = int(np.sum(feas2))\n        dist_now = float(distance_matrix[int(current_node), int(node)])\n        if (count > best_count) or (count == best_count and dist_now < best_dist):\n            best_count = count\n            best_dist = dist_now\n            best = int(node)\n    return int(best)\n",
  "due_time_proximity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    due = time_windows[u2, 1]\n    dist = distance_matrix[int(current_node), u2]\n    score = np.abs(due - t) + 1e-6 * dist\n    return int(u2[int(np.argmin(score))])\n",
  "travel_over_slack_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    slack = time_windows[unv, 1] - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t + d2, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = d2 / (slack2 + 1e-9)\n    return int(u2[int(np.argmin(score))])\n",
  "mean_distance_to_unvisited_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                        demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n    mean_to_others = np.mean(distance_matrix[u2][:, unv], axis=1)\n    score = mean_to_others - 0.15 * distance_matrix[int(current_node), u2]\n    return int(u2[int(np.argmax(score))])\n",
  "max_future_feasible_successors": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n    best_u = int(cand[0])\n    best_cnt = -1\n    best_tiebreak = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size == 0:\n            cnt = 0\n        else:\n            darr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(darr, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (start_v <= time_windows[others, 1])\n            cnt = int(np.sum(feas_v))\n\n        # tie-break: smaller immediate travel\n        tb = float(distance_matrix[int(current_node), u])\n        if (cnt > best_cnt) or (cnt == best_cnt and tb < best_tiebreak):\n            best_cnt = cnt\n            best_tiebreak = tb\n            best_u = u\n\n    return int(best_u)\n",
  "min_worstcase_next_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n\n    best_u = int(cand[0])\n    best_worst = -np.inf\n    best_tb = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size == 0:\n            worst_slack = np.inf\n        else:\n            arr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(arr, time_windows[others, 0])\n            slack_v = time_windows[others, 1] - start_v\n            feas_v = (demands[others] <= cap1) & (slack_v >= 0)\n            if not np.any(feas_v):\n                worst_slack = -np.inf\n            else:\n                worst_slack = float(np.min(slack_v[feas_v]))\n\n        tb = float(distance_matrix[int(current_node), u])\n        if (worst_slack > best_worst) or (worst_slack == best_worst and tb < best_tb):\n            best_worst = worst_slack\n            best_tb = tb\n            best_u = u\n\n    return int(best_u)\n",
  "savings_ratio_preference": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcu, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d_cur_depot = float(distance_matrix[int(current_node), int(depot)])\n    d_depot_u = distance_matrix[int(depot), u2]\n    d_cur_u = distance_matrix[int(current_node), u2]\n\n    savings = d_cur_depot + d_depot_u - d_cur_u\n    score = savings / (d_cur_u + 1e-9)\n\n    # mild penalty for tiny slack to avoid brittle picks\n    start2 = np.maximum(t + d_cur_u, time_windows[u2, 0])\n    slack2 = time_windows[u2, 1] - start2\n    score = score - 1e-3 * (1.0 / (slack2 + 1.0))\n\n    return int(u2[int(np.argmax(score))])\n",
  "overlap_length_density": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    s = time_windows[u2, 0].astype(float)\n    e = time_windows[u2, 1].astype(float)\n\n    # overlap length matrix (vectorized): sum_j max(0, min(e_i,e_j) - max(s_i,s_j))\n    min_end = np.minimum(e[:, None], e[None, :])\n    max_start = np.maximum(s[:, None], s[None, :])\n    overlap = np.maximum(0.0, min_end - max_start)\n    overlap_sum = np.sum(overlap, axis=1) - np.diag(overlap)  # exclude self\n\n    dist = distance_matrix[int(current_node), u2]\n    # prefer high overlap, tie-break by shorter distance\n    score = overlap_sum - 0.25 * dist\n    return int(u2[int(np.argmax(score))])\n",
  "capacity_quantile_switch_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    dem = demands[u2].astype(float)\n\n    # scarcity proxy: where does cap sit in the demand distribution of remaining customers?\n    all_dem = demands[unv].astype(float)\n    q80 = float(np.quantile(all_dem, 0.80)) if all_dem.size > 0 else 0.0\n\n    # if cap is below a high-demand quantile, conserve capacity; otherwise, fill aggressively\n    if cap <= q80:\n        # conserve: smallest demand, tie-break by travel\n        dm = dem\n        d2 = distance_matrix[int(current_node), u2]\n        key = np.lexsort((d2, dm))\n        return int(u2[int(key[0])])\n    else:\n        # fill: largest demand, tie-break by travel\n        dm = -dem\n        d2 = distance_matrix[int(current_node), u2]\n        key = np.lexsort((d2, dm))\n        return int(u2[int(key[0])])\n",
  "variance_to_unvisited_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    if u2.size == 1:\n        return int(u2[0])\n\n    # variance of distances from candidate to all unvisited (including infeasible ones as spatial context)\n    dist_mat = distance_matrix[u2][:, unv].astype(float)\n    var = np.var(dist_mat, axis=1)\n\n    # tie-break: shorter from current\n    d2 = distance_matrix[int(current_node), u2].astype(float)\n    score = var + 1e-3 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "deadline_weighted_by_wait": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0] - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0] - arr2)\n\n    due = time_windows[u2, 1].astype(float)\n\n    # smaller due is better, but large wait reduces priority\n    score = due + 0.8 * wait2 + 0.05 * d2\n    return int(u2[int(np.argmin(score))])\n",
  "k_nearest_feasible_then_best_slack": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n\n    k = int(min(5, u2.size))\n    rcl = u2[np.argpartition(d2, k - 1)[:k]]\n\n    d3 = distance_matrix[int(current_node), rcl]\n    start3 = np.maximum(t0 + d3, time_windows[rcl, 0])\n    slack3 = time_windows[rcl, 1] - start3\n\n    # smallest slack in RCL; tie-break by distance\n    key = np.lexsort((d3, slack3))\n    return int(rcl[int(key[0])])\n",
  "feasible_pareto_rank_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n\n    d2 = distance_matrix[int(current_node), u2].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[u2, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[u2, 1].astype(float) - start2\n    dem2 = demands[u2].astype(float)\n\n    # Objectives to minimize: [distance, wait, -demand, -slack] (i.e., prefer big demand and big slack)\n    obj = np.vstack([d2, wait2, -dem2, -slack2]).T\n\n    n = obj.shape[0]\n    rank = np.zeros(n, dtype=int)\n    for i in range(n):\n        dominated_by = 0\n        for j in range(n):\n            if i == j:\n                continue\n            # j dominates i if <= in all and < in at least one\n            le_all = np.all(obj[j] <= obj[i] + 1e-12)\n            lt_any = np.any(obj[j] < obj[i] - 1e-12)\n            if le_all and lt_any:\n                dominated_by += 1\n        rank[i] = dominated_by\n\n    best_rank = np.min(rank)\n    idx = np.where(rank == best_rank)[0]\n    if idx.size == 1:\n        return int(u2[int(idx[0])])\n\n    # tie-break within best front by smallest distance\n    pick = idx[int(np.argmin(d2[idx]))]\n    return int(u2[int(pick)])\n",
  "return_feasibility_margin_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    u2 = unv[feas]\n    d2 = distance_matrix[int(current_node), u2]\n    start2 = np.maximum(t0 + d2, time_windows[u2, 0])\n\n    # depot due might be finite (some instances encode it); if not, treat as infinity\n    depot_due = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n    back = distance_matrix[u2, int(depot)].astype(float)\n\n    # margin after serving u (ignores service times): depot_due - (service_start_u + travel_back)\n    margin_depot = depot_due - (start2 + back)\n\n    # if depot_due is inf, margin_depot is inf; then use own-due margin instead\n    if not np.isfinite(depot_due):\n        margin = time_windows[u2, 1].astype(float) - start2\n    else:\n        margin = margin_depot\n\n    # maximize margin; tie-break by shorter (to u + u to depot)\n    tie = (d2 + back)\n    key = np.lexsort((tie, -margin))\n    return int(u2[int(key[0])])\n",
  "min_avg_distance_to_remaining": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    # average distance from candidate to all remaining (including infeasible for spatial context)\n    dm = distance_matrix[cand][:, unv].astype(float)\n    avgd = np.mean(dm, axis=1)\n    # tie-break by closer from current\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, avgd))\n    return int(cand[int(key[0])])\n",
  "min_k_nearest_sum_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    k = int(min(5, unv.size))\n\n    costs = np.empty(cand.size, dtype=float)\n    for i, u in enumerate(cand):\n        dist_u = distance_matrix[int(u), unv].astype(float)\n        idx = np.argpartition(dist_u, k - 1)[:k]\n        costs[i] = float(np.sum(dist_u[idx]))\n\n    # tie-break by distance from current\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, costs))\n    return int(cand[int(key[0])])\n",
  "max_feasible_density_within_percentile_radius": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n\n    best = int(cand[0])\n    best_cnt = -1\n    best_tb = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size == 0:\n            cnt = 0\n        else:\n            dist = distance_matrix[u, others].astype(float)\n            r = float(np.quantile(dist, 0.25)) if dist.size > 0 else 0.0\n            near = others[dist <= r]\n            if near.size == 0:\n                cnt = 0\n            else:\n                arr = t1 + distance_matrix[u, near]\n                start_v = np.maximum(arr, time_windows[near, 0])\n                feas_v = (demands[near] <= cap1) & (start_v <= time_windows[near, 1])\n                cnt = int(np.sum(feas_v))\n\n        tb = float(distance_matrix[int(current_node), u])\n        if (cnt > best_cnt) or (cnt == best_cnt and tb < best_tb):\n            best_cnt = cnt\n            best_tb = tb\n            best = u\n\n    return int(best)\n",
  "regret_two_step_best_vs_second": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start_u = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas_u = (demands[unv] <= cap0) & (start_u <= time_windows[unv, 1])\n    if not np.any(feas_u):\n        return int(depot)\n\n    cand = unv[feas_u]\n\n    best_u = int(cand[0])\n    best_regret = -np.inf\n    best_tb = np.inf\n\n    for u in cand:\n        u = int(u)\n        cap1 = cap0 - float(demands[u])\n        t1 = float(np.maximum(t0 + distance_matrix[int(current_node), u], time_windows[u, 0]))\n\n        others = cand[cand != u]\n        if others.size < 2:\n            regret = -np.inf\n        else:\n            arr = t1 + distance_matrix[u, others]\n            start_v = np.maximum(arr, time_windows[others, 0])\n            feas_v = (demands[others] <= cap1) & (start_v <= time_windows[others, 1])\n            feas_list = others[feas_v]\n            if feas_list.size < 2:\n                regret = -np.inf\n            else:\n                # next-step cost: travel + waiting\n                dv = distance_matrix[u, feas_list].astype(float)\n                arr2 = t1 + dv\n                wait2 = np.maximum(0.0, time_windows[feas_list, 0].astype(float) - arr2)\n                cost = dv + wait2\n                # regret = 2nd best - best\n                idx = np.argpartition(cost, 1)[:2]\n                a, b = float(np.min(cost[idx])), float(np.max(cost[idx]))\n                regret = b - a\n\n        tb = float(distance_matrix[int(current_node), u])\n        if (regret > best_regret) or (regret == best_regret and tb < best_tb):\n            best_regret = regret\n            best_tb = tb\n            best_u = u\n\n    if not np.isfinite(best_regret):\n        # fallback: nearest feasible\n        d2 = distance_matrix[int(current_node), cand].astype(float)\n        return int(cand[int(np.argmin(d2))])\n\n    return int(best_u)\n",
  "dynamic_lambda_distance_vs_slack_by_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + dcur, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    due_med = float(np.median(time_windows[unv, 1].astype(float)))\n    # lambda in [0.2, 0.9] increases as time approaches (or exceeds) due_med\n    x = (t - due_med) / (abs(due_med) + 1.0)\n    lam = float(np.clip(0.55 + 0.35 * np.tanh(x), 0.2, 0.9))\n\n    # minimize: lam*distance + (1-lam)*(-urgency) where urgency = 1/(slack+1)\n    urgency = 1.0 / (slack2 + 1.0)\n    score = lam * d2 + (1.0 - lam) * urgency\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_wait_to_avoid_early_idle": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    # maximize wait, but keep some safety by adding small slack preference\n    score = wait2 + 1e-3 * slack2\n    return int(cand[int(np.argmax(score))])\n",
  "radial_continuity_to_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    r0 = float(distance_matrix[int(depot), int(current_node)])\n    r = distance_matrix[int(depot), cand].astype(float)\n    band = np.abs(r - r0)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, band))\n    return int(cand[int(key[0])])\n",
  "min_distance_plus_quadratic_wait": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n\n    score = d2 + wait2 * wait2\n    return int(cand[int(np.argmin(score))])\n",
  "max_product_slack_and_postcap": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n    feas = (demands[unv] <= cap0) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    postcap = cap0 - demands[cand].astype(float)\n\n    score = (slack2 + 1.0) * (postcap + 1.0)\n    # tie-break by shorter distance\n    key = np.lexsort((d2, -score))\n    return int(cand[int(key[0])])\n",
  "min_distance_scaled_by_window_narrowness": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    width = (time_windows[cand, 1] - time_windows[cand, 0]).astype(float)\n\n    scale = 1.0 + 1.0 / (width + 1.0)\n    score = d2 * scale\n    return int(cand[int(np.argmin(score))])\n",
  "earliest_open_time_then_shortest_travel": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv]\n    start = np.maximum(t + d, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    open_t = time_windows[cand, 0].astype(float)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n\n    key = np.lexsort((d2, open_t))\n    return int(cand[int(key[0])])\n",
  "min_due_minus_start_gap": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    gap = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (gap >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    gap2 = time_windows[cand, 1].astype(float) - start2\n\n    key = np.lexsort((d2, gap2))\n    return int(cand[int(key[0])])\n",
  "maximize_depot_return_margin_after_visit": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n\n    depot_due = float(time_windows[int(depot), 1]) if int(depot) < time_windows.shape[0] else np.inf\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t0 + d2, time_windows[cand, 0].astype(float))\n    back = distance_matrix[cand, int(depot)].astype(float)\n\n    if np.isfinite(depot_due):\n        margin = depot_due - (start2 + back)\n        # maximize margin; tie-break shorter current->u\n        key = np.lexsort((d2, -margin))\n        return int(cand[int(key[0])])\n\n    # if no meaningful depot due, prefer closer to depot after visit, tie-break by current->u\n    key = np.lexsort((d2, back))\n    return int(cand[int(key[0])])\n",
  "two_stage_filter_by_open_quantile_then_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    opens = time_windows[cand, 0].astype(float)\n    thr = float(np.quantile(opens, 0.40)) if cand.size > 1 else float(opens[0])\n    filt = cand[opens <= thr]\n    if filt.size == 0:\n        filt = cand\n\n    dem = demands[filt].astype(float)\n    d2 = distance_matrix[int(current_node), filt].astype(float)\n    key = np.lexsort((d2, -dem))\n    return int(filt[int(key[0])])\n",
  "min_detour_minus_wait_credit": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcu = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + dcu\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d1 = distance_matrix[int(current_node), cand].astype(float)\n    d2 = distance_matrix[cand, int(depot)].astype(float)\n    direct = float(distance_matrix[int(current_node), int(depot)])\n\n    arr2 = t + d1\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n\n    detour = d1 + d2 - direct\n    beta = 0.7\n    score = detour - beta * wait2\n    return int(cand[int(np.argmin(score))])\n",
  "min_bottleneck_to_k_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    k = int(min(5, unv.size))\n\n    bott = np.empty(cand.size, dtype=float)\n    for i, u in enumerate(cand):\n        dist_u = distance_matrix[int(u), unv].astype(float)\n        idx = np.argpartition(dist_u, k - 1)[:k]\n        bott[i] = float(np.max(dist_u[idx]))\n\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, bott))\n    return int(cand[int(key[0])])\n",
  "deadline_alignment_with_neighborhood": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + dcur, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    k = int(min(5, unv.size))\n\n    align = np.empty(cand.size, dtype=float)\n    due_all = time_windows[unv, 1].astype(float)\n\n    for i, u in enumerate(cand):\n        dist_u = distance_matrix[int(u), unv].astype(float)\n        idx = np.argpartition(dist_u, k - 1)[:k]\n        neigh_due_mean = float(np.mean(due_all[idx]))\n        align[i] = abs(float(time_windows[int(u), 1]) - neigh_due_mean)\n\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, align))\n    return int(cand[int(key[0])])\n",
  "capacity_smoothing_to_median_remaining_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    med_dem = float(np.median(demands[unv].astype(float))) if unv.size > 0 else 0.0\n\n    postcap = cap0 - demands[cand].astype(float)\n    diff = np.abs(postcap - med_dem)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, diff))\n    return int(cand[int(key[0])])\n",
  "maximize_slack_minus_distance_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    alpha = 0.35\n    score = slack2 - alpha * d2\n    return int(cand[int(np.argmax(score))])\n",
  "min_distance_with_deadline_soft_barrier": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    scale = max(1.0, float(np.median(slack2 + 1.0)))\n    gamma = 2.0\n    barrier = np.exp(-slack2 / scale)\n    score = d2 + gamma * barrier\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_demand_per_extra_time_budget": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n\n    score = demands[cand].astype(float) / (d2 + wait2 + 1.0)\n    return int(cand[int(np.argmax(score))])\n",
  "median_due_time_proximity_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    med_due = float(np.median(time_windows[unv, 1].astype(float)))\n    diff = np.abs(time_windows[cand, 1].astype(float) - med_due)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, diff))\n    return int(cand[int(key[0])])\n",
  "depot_distance_balance_to_remaining_mean": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv]\n    start = np.maximum(t0 + dcur, time_windows[unv, 0])\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1])\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    depot_d_all = distance_matrix[int(depot), unv].astype(float)\n    target = float(np.mean(depot_d_all)) if depot_d_all.size > 0 else 0.0\n\n    depot_d = distance_matrix[int(depot), cand].astype(float)\n    diff = np.abs(depot_d - target)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n\n    key = np.lexsort((d2, diff))\n    return int(cand[int(key[0])])\n",
  "min_distance_with_postcap_parity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + dcur, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    postcap = cap0 - demands[cand].astype(float)\n\n    target = 0.5 * cap0\n    parity = np.abs(postcap - target)\n\n    score = d2 + 0.25 * parity\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_time_window_intersection_with_now": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    dcur = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + dcur, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n\n    # horizon based on median remaining window width\n    width_all = (time_windows[unv, 1] - time_windows[unv, 0]).astype(float)\n    horizon = float(np.median(width_all)) if width_all.size > 0 else 0.0\n    horizon = max(1.0, horizon)\n\n    a = np.maximum(time_windows[cand, 0].astype(float), t)\n    b = np.minimum(time_windows[cand, 1].astype(float), t + horizon)\n    inter = np.maximum(0.0, b - a)\n\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    key = np.lexsort((d2, -inter))\n    return int(cand[int(key[0])])\n",
  "min_normalized_lateness_risk_index": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    arr = t + d\n    wait = np.maximum(0.0, time_windows[unv, 0].astype(float) - arr)\n    start = arr + wait\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    arr2 = t + d2\n    wait2 = np.maximum(0.0, time_windows[cand, 0].astype(float) - arr2)\n    start2 = arr2 + wait2\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    risk = (d2 + wait2) / (slack2 + 1.0)\n    return int(cand[int(np.argmin(risk))])\n",
  "maximize_slack_to_window_width_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n    width = (time_windows[unv, 1] - time_windows[unv, 0]).astype(float)\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    width2 = (time_windows[cand, 1] - time_windows[cand, 0]).astype(float)\n\n    score = slack2 / (width2 + 1.0)\n    return int(cand[int(np.argmax(score))])\n",
  "min_distance_with_capacity_urgency_coupling": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap0) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    frac = demands[cand].astype(float) / (cap0 + 1e-9)\n    eta = 3.0\n    score = d2 + eta * frac * (1.0 / (slack2 + 1.0))\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_distance_then_feasibility_safety": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    # farthest first, then larger slack\n    key = np.lexsort((-slack2, -d2))\n    return int(cand[int(key[0])])\n",
  "min_distance_to_depot_plus_slack_bonus": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    slack = time_windows[unv, 1].astype(float) - start\n\n    feas = (demands[unv] <= cap) & (slack >= 0)\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    back = distance_matrix[cand, int(depot)].astype(float)\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t + d2, time_windows[cand, 0].astype(float))\n    slack2 = time_windows[cand, 1].astype(float) - start2\n\n    score = back - 0.15 * slack2\n    return int(cand[int(np.argmin(score))])\n",
  "maximize_joint_savings_and_time_alignment": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t0 = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t0 + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    start2 = np.maximum(t0 + d2, time_windows[cand, 0].astype(float))\n\n    mid = 0.5 * (time_windows[cand, 0].astype(float) + time_windows[cand, 1].astype(float))\n    scale = max(1.0, float(np.median(np.abs(start2 - mid) + 1.0)))\n    align = np.exp(-np.abs(start2 - mid) / scale)\n\n    savings = float(distance_matrix[int(current_node), int(depot)]) + distance_matrix[int(depot), cand].astype(float) - d2\n    score = savings * align\n\n    # tie-break by higher slack\n    slack2 = time_windows[cand, 1].astype(float) - start2\n    key = np.lexsort((-slack2, -score))\n    return int(cand[int(key[0])])\n",
  "min_distance_with_future_capacity_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray,\n                     demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    if unv.size == 0:\n        return int(depot)\n\n    cap0 = float(np.asarray(rest_capacity).reshape(-1)[0])\n    t = float(np.asarray(current_time).reshape(-1)[0])\n\n    d = distance_matrix[int(current_node), unv].astype(float)\n    start = np.maximum(t + d, time_windows[unv, 0].astype(float))\n    feas = (demands[unv] <= cap0) & (start <= time_windows[unv, 1].astype(float))\n    if not np.any(feas):\n        return int(depot)\n\n    cand = unv[feas]\n    d2 = distance_matrix[int(current_node), cand].astype(float)\n    postcap = cap0 - demands[cand].astype(float)\n\n    q20 = float(np.quantile(demands[unv].astype(float), 0.20)) if unv.size > 0 else 0.0\n    penalty = np.where(postcap < q20, (q20 - postcap), 0.0)\n\n    score = d2 + 0.6 * penalty\n    return int(cand[int(np.argmin(score))])\n"
}
