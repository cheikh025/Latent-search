{
  "nearest_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Nearest neighbor considering time window and capacity constraints.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    return int(feasible[np.argmin(distances)])\n",
  "earliest_deadline_first": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with earliest deadline (time window end).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    deadlines = time_windows[feasible, 1]\n    return int(feasible[np.argmin(deadlines)])\n",
  "minimum_slack_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with minimum slack time (deadline - arrival).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                slacks.append(slack)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(slacks)])\n",
  "earliest_start_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node with earliest time window start.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    start_times = time_windows[feasible, 0]\n    return int(feasible[np.argmin(start_times)])\n",
  "minimize_wait_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize wait time before service can begin.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    wait_times = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                wait = max(0, time_windows[node][0] - arrival)\n                wait_times.append(wait)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(wait_times)])\n",
  "time_distance_weighted": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Weighted: 50% distance + 50% time urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    slacks = np.array(slacks)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    slack_norm = slacks / (np.mean(slacks) + 1e-9)\n    \n    scores = 0.5 * dist_norm + 0.5 * (1.0 / (slack_norm + 1e-9))\n    return int(feasible[np.argmin(scores)])\n",
  "savings_with_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Clarke-Wright savings adapted for time windows.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    return int(feasible[np.argmax(savings)])\n",
  "urgency_capacity_balance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Balance time urgency and capacity utilization.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    \n    demand_norm = demand_vals / (np.mean(demand_vals) + 1e-9)\n    urgency = 1.0 / (slacks + 1e-9)\n    urgency_norm = urgency / (np.mean(urgency) + 1e-9)\n    \n    scores = 0.6 * urgency_norm - 0.4 * demand_norm\n    return int(feasible[np.argmax(scores)])\n",
  "time_window_width": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer nodes with narrower time windows (more constrained).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    widths = time_windows[feasible, 1] - time_windows[feasible, 0]\n    return int(feasible[np.argmin(widths)])\n",
  "latest_acceptable_arrival": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Select node where we can arrive latest without violating constraints.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    latest_arrivals = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                latest_arrivals.append(time_windows[node][1])\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmax(latest_arrivals)])\n",
  "minimal_detour_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Minimize time detour from direct return to depot.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    direct_time = distance_matrix[current_node, depot]\n    detour_times = (distance_matrix[current_node, feasible] + \n                    distance_matrix[feasible, depot] - direct_time)\n    \n    return int(feasible[np.argmin(detour_times)])\n",
  "demand_to_distance_time": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Maximize demand per unit distance, considering time feasibility.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible] + 1e-9\n    demand_vals = demands[feasible]\n    ratios = demand_vals / distances\n    \n    return int(feasible[np.argmax(ratios)])\n",
  "composite_time_dist_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Composite: 40% urgency + 30% distance + 30% demand.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = 0.4 * norm(urgency) + 0.3 * norm(distances) - 0.3 * norm(demand_vals)\n    \n    return int(feasible[np.argmin(score)])\n",
  "adaptive_time_pressure": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Adapt strategy based on how tight time windows are becoming.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    slacks = np.array(slacks)\n    avg_slack = np.mean(slacks)\n    \n    distances = distance_matrix[current_node, feasible]\n    \n    # Tight time windows: prioritize urgency; Loose: prioritize distance\n    if avg_slack < 5.0:\n        urgency = 1.0 / (slacks + 1e-9)\n        return int(feasible[np.argmax(urgency)])\n    else:\n        return int(feasible[np.argmin(distances)])\n",
  "time_proximity_cluster": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Cluster nodes by time window similarity.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    # Prefer nodes with time windows close to current time\n    tw_starts = time_windows[feasible, 0]\n    time_proximity = np.abs(tw_starts - current_time)\n    \n    distances = distance_matrix[current_node, feasible]\n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    time_norm = time_proximity / (np.mean(time_proximity) + 1e-9)\n    \n    scores = 0.6 * dist_norm + 0.4 * time_norm\n    return int(feasible[np.argmin(scores)])\n",
  "wait_vs_travel_trade_off": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Balance wait time vs travel time.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    wait_times = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                wait_times.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    travel_times = distance_matrix[current_node, feasible]\n    wait_times = np.array(wait_times)\n    \n    total_times = travel_times + wait_times\n    return int(feasible[np.argmin(total_times)])\n",
  "deadline_proximity_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Ratio of slack time to travel time.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    ratios = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            travel = distance_matrix[current_node, node]\n            arrival = current_time + travel\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                ratio = slack / (travel + 1e-9)\n                ratios.append(ratio)\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(ratios)])  # Prefer low slack-to-travel ratio\n",
  "stochastic_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Probabilistic selection based on urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    urgencies = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slack = time_windows[node][1] - arrival\n                urgencies.append(1.0 / (slack + 1.0))\n    \n    if not feasible:\n        return depot\n    \n    urgencies = np.array(urgencies)\n    probs = urgencies / np.sum(urgencies)\n    \n    seed = int(current_node * 2654435761) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "time_window_midpoint": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Prefer arriving close to time window midpoint.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    deviations = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                midpoint = (time_windows[node][0] + time_windows[node][1]) / 2.0\n                service_start = max(arrival, time_windows[node][0])\n                deviations.append(abs(service_start - midpoint))\n    \n    if not feasible:\n        return depot\n    \n    return int(feasible[np.argmin(deviations)])\n",
  "capacity_time_balance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Balance capacity utilization with time urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    capacity_ratio = rest_capacity / (np.max(demands) + 1e-9)\n    slacks = np.array(slacks)\n    demand_vals = demands[feasible]\n    \n    # Low capacity: prefer small demand; High urgency: prefer urgent\n    if capacity_ratio < 0.3:\n        return int(feasible[np.argmin(demand_vals)])\n    else:\n        return int(feasible[np.argmin(slacks)])\n",
  "five_factor_composite": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Composite: distance + demand + urgency + wait + capacity.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    waits = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n                waits.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n    capacity_util = demand_vals / (rest_capacity + 1e-9)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = (0.25 * norm(distances) - \n             0.20 * norm(demand_vals) + \n             0.30 * norm(urgency) + \n             0.15 * norm(waits) + \n             0.10 * norm(capacity_util))\n    \n    return int(feasible[np.argmin(score)])\n",
  "random_time_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Random selection among time-feasible nodes.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    seed = int(current_node * 73856093) ^ int(current_time * 1000)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible))\n",
  "hybrid_savings_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Hybrid: 50% savings + 50% urgency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    urgencies = 1.0 / (np.array(slacks) + 1.0)\n    \n    savings_norm = savings / (np.mean(np.abs(savings)) + 1e-9)\n    urgency_norm = urgencies / (np.mean(urgencies) + 1e-9)\n    \n    scores = 0.5 * savings_norm + 0.5 * urgency_norm\n    return int(feasible[np.argmax(scores)])\n",
  "time_density_routing": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Route through time-dense regions (many nodes with similar time windows).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n    \n    if not feasible:\n        return depot\n    \n    # Count how many other nodes have similar time windows\n    densities = []\n    for node in feasible:\n        tw_start = time_windows[node, 0]\n        tw_end = time_windows[node, 1]\n        # Count nodes with overlapping windows\n        overlaps = 0\n        for other in unvisited_nodes:\n            if other != node:\n                other_start = time_windows[other, 0]\n                other_end = time_windows[other, 1]\n                if not (tw_end < other_start or other_end < tw_start):\n                    overlaps += 1\n        densities.append(overlaps)\n    \n    distances = distance_matrix[current_node, feasible]\n    densities = np.array(densities)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    density_norm = densities / (np.max(densities) + 1e-9)\n    \n    scores = dist_norm - 0.6 * density_norm\n    return int(feasible[np.argmin(scores)])\n",
  "progressive_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Increase urgency weight as time progresses.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n    \n    if not feasible:\n        return depot\n    \n    # Progress indicator\n    max_time = np.max(time_windows[:, 1])\n    progress = current_time / (max_time + 1e-9)\n    \n    distances = distance_matrix[current_node, feasible]\n    urgencies = 1.0 / (np.array(slacks) + 1.0)\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    urgency_norm = urgencies / (np.mean(urgencies) + 1e-9)\n    \n    # Early: 70% distance, 30% urgency; Late: 30% distance, 70% urgency\n    weight = progress\n    scores = (1 - weight) * 0.7 * dist_norm + weight * 0.7 * urgency_norm\n    \n    return int(feasible[np.argmin(scores)])\n",
  "minmax_normalized_vrptw": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, current_time: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray, time_windows: np.ndarray) -> int:\n    \"\"\"Min-max normalize all VRPTW factors equally.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = []\n    slacks = []\n    waits = []\n    for node in unvisited_nodes:\n        if demands[node] <= rest_capacity:\n            arrival = current_time + distance_matrix[current_node, node]\n            if arrival <= time_windows[node][1]:\n                feasible.append(node)\n                slacks.append(time_windows[node][1] - arrival)\n                waits.append(max(0, time_windows[node][0] - arrival))\n    \n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    slacks = np.array(slacks)\n    waits = np.array(waits)\n    \n    def minmax(x):\n        mn, mx = x.min(), x.max()\n        if mx - mn < 1e-9:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn)\n    \n    urgency = 1.0 / (slacks + 1.0)\n    score = (minmax(distances) - minmax(demand_vals) + \n             minmax(urgency) + minmax(waits))\n    \n    return int(feasible[np.argmin(score)])\n"
}
