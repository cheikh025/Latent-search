{
  "nearest_neighbor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    return int(feasible[np.argmin(distances)])\n",
  "farthest_insertion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[depot, feasible]\n    return int(feasible[np.argmax(distances)])\n",
  "demand_to_distance_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible] + 1e-9\n    demand_vals = demands[feasible]\n    ratios = demand_vals / distances\n    return int(feasible[np.argmax(ratios)])\n",
  "capacity_utilization_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    demand_vals = demands[feasible]\n    return int(feasible[np.argmax(demand_vals)])\n",
  "savings_heuristic": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    return int(feasible[np.argmax(savings)])\n",
  "minimal_detour": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    d_nodes_depot = distance_matrix[feasible, depot]\n    \n    detours = d_current_nodes + d_nodes_depot - d_current_depot\n    return int(feasible[np.argmin(detours)])\n",
  "weighted_distance_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    demand_norm = demand_vals / (np.mean(demand_vals) + 1e-9)\n    \n    scores = 0.6 * dist_norm - 0.4 * demand_norm  # Lower is better\n    return int(feasible[np.argmin(scores)])\n",
  "depot_proximity_bias": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    capacity_ratio = rest_capacity / (np.max(demands) + 1e-9)\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_depot = distance_matrix[depot, feasible]\n    \n    if capacity_ratio < 0.3:  # Low capacity: prefer near depot\n        scores = 0.3 * d_current + 0.7 * d_depot\n    else:\n        scores = 0.8 * d_current + 0.2 * d_depot\n    \n    return int(feasible[np.argmin(scores)])\n",
  "cluster_centroid": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Mean distance to all feasible nodes\n    mean_distances = distance_matrix[np.ix_(feasible, feasible)].mean(axis=1)\n    \n    d_current = distance_matrix[current_node, feasible]\n    scores = d_current + 0.5 * mean_distances\n    \n    return int(feasible[np.argmin(scores)])\n",
  "alternating_nearest_farthest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    step = len(distance_matrix) - len(unvisited_nodes)\n    distances = distance_matrix[current_node, feasible]\n    \n    if step % 2 == 0:\n        return int(feasible[np.argmin(distances)])\n    else:\n        return int(feasible[np.argmax(distances)])\n",
  "regret_insertion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    if len(feasible) == 1:\n        return int(feasible[0])\n    \n    # For each feasible node, find two closest positions\n    distances = distance_matrix[current_node, feasible]\n    sorted_idx = np.argsort(distances)\n    \n    if len(sorted_idx) > 1:\n        regret = distances[sorted_idx[1]] - distances[sorted_idx[0]]\n        return int(feasible[sorted_idx[np.argmax([regret])]])\n    \n    return int(feasible[sorted_idx[0]])\n",
  "sweep_algorithm": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Use distance relationships as proxy for angle\n    d_depot_current = distance_matrix[depot, current_node]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    # Cosine law approximation for angular proximity\n    scores = d_current_nodes / (d_depot_current + d_depot_nodes + 1e-9)\n    return int(feasible[np.argmin(scores)])\n",
  "balanced_route_length": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    capacity_remaining_ratio = rest_capacity / (np.sum(demands[unvisited_nodes]) + 1e-9)\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_to_depot = distance_matrix[feasible, depot]\n    \n    # If low remaining demand, prefer finishing route\n    if capacity_remaining_ratio > 0.5:\n        scores = d_current + 0.3 * d_to_depot\n    else:\n        scores = d_current + 0.8 * d_to_depot\n    \n    return int(feasible[np.argmin(scores)])\n",
  "demand_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    total_unvisited_demand = np.sum(demands[unvisited_nodes])\n    progress = 1.0 - (total_unvisited_demand / (np.sum(demands) + 1e-9))\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    \n    # Early: prefer high demand; Late: prefer close\n    weight = 1.0 - progress\n    scores = distances - weight * demand_vals\n    \n    return int(feasible[np.argmin(scores)])\n",
  "random_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    seed = int(current_node * 73856093) ^ int(len(unvisited_nodes) * 19349663)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible))\n",
  "min_max_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    max_distances = distance_matrix[np.ix_(feasible, unvisited_nodes)].max(axis=1)\n    return int(feasible[np.argmin(max_distances)])\n",
  "insertion_cost": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_cd = distance_matrix[current_node, depot]\n    d_cn = distance_matrix[current_node, feasible]\n    d_nd = distance_matrix[feasible, depot]\n    \n    insertion_costs = d_cn + d_nd - d_cd\n    return int(feasible[np.argmin(insertion_costs)])\n",
  "diversity_maximizer": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Use depot distance as diversity proxy\n    d_depot = distance_matrix[depot, feasible]\n    d_current = distance_matrix[current_node, feasible]\n    \n    diversity = np.abs(d_depot - d_current)\n    scores = d_current - 0.5 * diversity\n    \n    return int(feasible[np.argmin(scores)])\n",
  "capacity_aware_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    \n    # Penalize high-demand nodes when capacity is low\n    capacity_factor = rest_capacity / (np.max(demands) + 1e-9)\n    penalty = (1.0 - capacity_factor) * demand_vals\n    \n    scores = distances + penalty\n    return int(feasible[np.argmin(scores)])\n",
  "stochastic_savings": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    savings = savings - savings.min() + 1e-9  # Ensure positive\n    \n    probs = savings / np.sum(savings)\n    \n    seed = int(current_node * 2654435761) ^ int(len(unvisited_nodes) * 2246822519)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "composite_five_factor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_depot = distance_matrix[depot, feasible]\n    demand_vals = demands[feasible]\n    capacity_util = demand_vals / (rest_capacity + 1e-9)\n    \n    mean_dist = distance_matrix[np.ix_(feasible, unvisited_nodes)].mean(axis=1)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    score = (0.3 * norm(d_current) + \n             0.2 * norm(d_depot) - \n             0.2 * norm(demand_vals) + \n             0.15 * norm(capacity_util) + \n             0.15 * norm(mean_dist))\n    \n    return int(feasible[np.argmin(score)])\n",
  "route_compactness": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Variance of distances as compactness measure\n    distances_to_all = distance_matrix[feasible, :]\n    variance = np.var(distances_to_all, axis=1)\n    \n    d_current = distance_matrix[current_node, feasible]\n    scores = d_current + 0.5 * variance\n    \n    return int(feasible[np.argmin(scores)])\n",
  "adaptive_threshold": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    median_dist = np.median(distances)\n    \n    capacity_ratio = rest_capacity / (np.sum(demands[unvisited_nodes]) + 1e-9)\n    \n    # High capacity: explore (accept far nodes); Low capacity: exploit (nearby)\n    threshold = median_dist * (0.5 + capacity_ratio)\n    \n    close_nodes = [i for i, d in enumerate(distances) if d <= threshold]\n    if close_nodes:\n        return int(feasible[close_nodes[np.argmin(demands[feasible][close_nodes])]])\n    \n    return int(feasible[np.argmin(distances)])\n",
  "minmax_normalized": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_depot = distance_matrix[depot, feasible]\n    demand_vals = demands[feasible]\n    \n    def minmax(x):\n        mn, mx = x.min(), x.max()\n        if mx - mn < 1e-9:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn)\n    \n    score = minmax(d_current) + minmax(d_depot) - minmax(demand_vals)\n    return int(feasible[np.argmin(score)])\n",
  "exponential_distance_decay": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    mean_dist = np.mean(distances)\n    \n    weights = np.exp(-distances / (mean_dist + 1e-9))\n    probs = weights / np.sum(weights)\n    \n    seed = int(current_node * 1597334677) ^ int(depot * 3812015801)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "remaining_demand_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    total_remaining = np.sum(demands[unvisited_nodes]) + 1e-9\n    demand_ratios = demands[feasible] / total_remaining\n    \n    distances = distance_matrix[current_node, feasible]\n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    \n    scores = dist_norm - 0.4 * demand_ratios\n    return int(feasible[np.argmin(scores)])\n",
  "bottleneck_avoid": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Minimum distance to any other unvisited node\n    dist_matrix = distance_matrix[np.ix_(feasible, unvisited_nodes)]\n    min_dist_to_others = np.min(dist_matrix, axis=1)\n    \n    d_current = distance_matrix[current_node, feasible]\n    scores = d_current + 0.6 * min_dist_to_others\n    \n    return int(feasible[np.argmin(scores)])\n",
  "petal_algorithm": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_depot_current = distance_matrix[depot, current_node]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    # Prefer nodes at similar distance from depot\n    depot_dist_diff = np.abs(d_depot_nodes - d_depot_current)\n    scores = d_current_nodes + 0.7 * depot_dist_diff\n    \n    return int(feasible[np.argmin(scores)])\n",
  "hybrid_nearest_savings": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current\n    \n    dist_norm = d_current / (np.mean(d_current) + 1e-9)\n    savings_norm = savings / (np.mean(np.abs(savings)) + 1e-9)\n    \n    scores = 0.5 * dist_norm - 0.5 * savings_norm\n    return int(feasible[np.argmin(scores)])\n",
  "efficiency_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = [n for n in unvisited_nodes if demands[n] <= cap]\n    if not feasible:\n        return depot\n\n    d = distance_matrix[current_node, feasible]\n    dem = demands[feasible]\n\n    # Prefer high demand with short travel; protect against zero distance\n    score = dem / (d + 1e-9)\n\n    # Tie-break deterministically toward closer\n    best = np.argmax(score)\n    return int(feasible[int(best)])\n",
  "farthest_from_depot_push": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = [n for n in unvisited_nodes if demands[n] <= cap]\n    if not feasible:\n        return depot\n\n    d_depot = distance_matrix[depot, feasible]\n    d_cur = distance_matrix[current_node, feasible]\n\n    # Prefer far-from-depot while not too far from current\n    score = 0.7 * d_depot - 0.3 * d_cur\n    return int(feasible[int(np.argmax(score))])\n",
  "capacity_slack_preserver": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = [n for n in unvisited_nodes if demands[n] <= cap]\n    if not feasible:\n        return depot\n\n    dem = demands[feasible]\n    slack = cap - dem\n    d_cur = distance_matrix[current_node, feasible]\n\n    # Larger slack is better; shorter distance is better\n    score = 1.0 * slack - 0.2 * d_cur\n    return int(feasible[int(np.argmax(score))])\n",
  "two_step_lookahead_min_completion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    feasible_i = [n for n in unvisited_nodes if demands[n] <= cap0]\n    if not feasible_i:\n        return depot\n\n    best_i = None\n    best_cost = float('inf')\n\n    unv = np.asarray(unvisited_nodes, dtype=int)\n\n    for i in feasible_i:\n        cap1 = cap0 - float(demands[i])\n        remaining = unv[unv != i]\n        feasible_k = remaining[demands[remaining] <= cap1]\n\n        base = float(distance_matrix[current_node, i])\n        # Encourage choices that also keep depot return reasonable\n        depot_term = 0.3 * float(distance_matrix[i, depot])\n\n        if len(feasible_k) == 0:\n            cost = base + depot_term\n        else:\n            next_leg = float(np.min(distance_matrix[i, feasible_k]))\n            cost = base + 0.6 * next_leg + depot_term\n\n        if cost < best_cost:\n            best_cost = cost\n            best_i = i\n\n    return int(best_i) if best_i is not None else depot\n",
  "local_density_attractor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = [n for n in unv if demands[n] <= cap]\n    if not feasible:\n        return depot\n\n    k = min(5, len(unv))\n    scores = []\n\n    for n in feasible:\n        d_cur = float(distance_matrix[current_node, n])\n        # Density proxy: mean distance from n to its k nearest unvisited (including feasible/non-feasible)\n        d_to_unv = distance_matrix[n, unv]\n        nearest = np.partition(d_to_unv, k - 1)[:k]\n        density = float(np.mean(nearest))\n        scores.append(d_cur + 0.8 * density)\n\n    return int(feasible[int(np.argmin(scores))])\n",
  "softmax_cost_temperature": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem = demands[feasible]\n\n    # Composite cost: travel + mild depot pull - mild demand reward\n    cost = d_cur + 0.25 * d_dep - 0.15 * dem\n\n    # Temperature: smaller when cap is small => greedier\n    cap_scale = max(cap, 1e-9)\n    temp = 0.3 + 1.5 * (cap_scale / (cap_scale + np.mean(dem) + 1e-9))\n\n    # Softmax over negative cost\n    x = -(cost - np.min(cost)) / max(temp, 1e-9)\n    w = np.exp(x - np.max(x))\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (int(current_node) * 1000003) ^ (int(len(unvisited_nodes)) * 9176) ^ (int(cap_scale * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n\n    return int(rng.choice(feasible, p=p))\n",
  "adaptive_weighted_mix": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem = demands[feasible]\n\n    # Normalize helpers\n    def z(x):\n        x = np.asarray(x, dtype=float)\n        return (x - np.mean(x)) / (np.std(x) + 1e-9)\n\n    # Capacity tightness in [0,1] (approx)\n    tight = 1.0 / (1.0 + cap)\n    w_dist = 0.7 * (1.0 - tight)\n    w_depot = 0.2 + 0.4 * tight\n    w_dem = 0.3 + 0.5 * tight\n\n    score = w_dist * z(d_cur) + w_depot * z(d_dep) - w_dem * z(dem)\n    return int(feasible[int(np.argmin(score))])\n",
  "triangle_consistency_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible]\n    d_nd = distance_matrix[feasible, depot]\n\n    # If visiting n keeps the path toward depot nearly shortest, this detour measure is small\n    detour_gap = np.abs(d_cd - (d_cn + d_nd))\n\n    # Secondary: prefer closer to current\n    score = detour_gap + 0.15 * d_cn\n    return int(feasible[int(np.argmin(score))])\n",
  "k_regret_distance_to_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Cost proxy for committing to n now: cur->n plus n->depot pull\n    cost = distance_matrix[current_node, feasible] + 0.4 * distance_matrix[feasible, depot]\n\n    if len(feasible) == 1:\n        return int(feasible[0])\n\n    k = min(3, len(feasible))\n    order = np.argsort(cost)\n\n    # Regret defined as kth_best - best\n    regret = float(cost[order[k - 1]] - cost[order[0]])\n\n    # Turn scalar regret into selection: choose the node that is best (order[0]) if regret is small,\n    # otherwise choose the node at order[1] to avoid over-committing (a distinct behavior).\n    if regret < (np.std(cost) + 1e-9):\n        return int(feasible[int(order[0])])\n    return int(feasible[int(order[min(1, len(order) - 1)])])\n",
  "return_risk_aware": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible]\n    d_nd = distance_matrix[feasible, depot]\n    dem = demands[feasible]\n\n    # Penalize long \"commitment\" legs; reward consuming a good fraction of remaining capacity\n    frac = dem / (cap + 1e-9)\n    score = (d_cn + 0.9 * d_nd) - 0.6 * frac\n\n    return int(feasible[int(np.argmin(score))])\n",
  "expansion_frontier": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n = distance_matrix[depot, feasible]\n    step = distance_matrix[current_node, feasible]\n\n    gain = np.maximum(0.0, r_n - r_cur)\n    score = gain / (step + 1e-9)  # outward gain per travel\n\n    return int(feasible[int(np.argmax(score))])\n",
  "perimeter_then_fill": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_dep = distance_matrix[depot, feasible]\n    d_cur = distance_matrix[current_node, feasible]\n    dem = demands[feasible]\n\n    # Remaining-capacity fraction relative to max demand among remaining (scale-free)\n    frac = cap / (float(np.max(demands[unvisited_nodes])) + 1e-9)\n    frac = float(np.clip(frac, 0.0, 1.0))\n\n    # High frac => perimeter; low frac => fill-in\n    score = (0.8 * frac) * d_dep + (0.2 + 0.6 * (1.0 - frac)) * d_cur - 0.15 * dem\n\n    return int(feasible[int(np.argmin(score))])\n",
  "hub_avoidance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = np.array([n for n in unv if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Centrality proxy: mean distance to remaining unvisited\n    mean_to_unv = distance_matrix[np.ix_(feasible, unv)].mean(axis=1)\n    d_cur = distance_matrix[current_node, feasible]\n\n    # Prefer less-central (larger mean_to_unv) but still not far from current\n    score = d_cur - 0.6 * mean_to_unv\n    return int(feasible[int(np.argmin(score))])\n",
  "isolation_rescue": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = np.array([n for n in unv if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # For each feasible node, compute distance to its nearest OTHER unvisited node\n    dist_to_unv = distance_matrix[np.ix_(feasible, unv)]\n    # Mask self if present\n    for i, n in enumerate(feasible):\n        same = np.where(unv == n)[0]\n        if len(same) > 0:\n            dist_to_unv[i, same[0]] = np.inf\n\n    nearest_other = np.min(dist_to_unv, axis=1)\n    d_cur = distance_matrix[current_node, feasible]\n\n    # High nearest_other => isolated; pull them earlier, with mild distance penalty\n    score = -1.0 * nearest_other + 0.25 * d_cur\n    return int(feasible[int(np.argmin(score))])\n",
  "capacity_bucket_prioritizer": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible]\n\n    target_fill = 0.8  # target fraction of remaining capacity to consume\n    fill_frac = dem / (cap + 1e-9)\n    fill_miss = np.abs(fill_frac - target_fill)\n\n    score = 0.7 * fill_miss + 0.3 * (d_cur / (np.mean(d_cur) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "probabilistic_rank_blend": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem = demands[feasible].astype(float)\n\n    # Ranks: smaller distance better; larger demand better\n    r_cur = np.argsort(np.argsort(d_cur)).astype(float)\n    r_dep = np.argsort(np.argsort(d_dep)).astype(float)\n    r_dem = np.argsort(np.argsort(-dem)).astype(float)\n\n    blend = 0.45 * r_cur + 0.35 * r_dep + 0.20 * r_dem\n\n    # Convert to probabilities favoring low blended rank\n    x = -(blend - np.min(blend))\n    w = np.exp(x - np.max(x))\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (int(current_node) * 1315423911) ^ (int(len(unvisited_nodes)) * 2654435761)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=p))\n",
  "myopic_2opt_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible]\n    d_nd = distance_matrix[feasible, depot]\n\n    # Balanced-edge criterion (minimize the max edge)\n    score = np.maximum(d_cn, d_nd) + 0.1 * np.minimum(d_cn, d_nd)\n    return int(feasible[int(np.argmin(score))])\n",
  "depot_shadow": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n = distance_matrix[depot, feasible]\n    d_cn = distance_matrix[current_node, feasible]\n\n    annulus = np.abs(r_n - r_cur)\n    score = 0.65 * annulus + 0.35 * d_cn\n    return int(feasible[int(np.argmin(score))])\n",
  "demand_smoothing": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    target = float(np.median(dem))\n    dem_dev = np.abs(dem - target)\n\n    d_cur = distance_matrix[current_node, feasible]\n    score = 0.6 * dem_dev + 0.4 * (d_cur / (np.mean(d_cur) + 1e-9))\n\n    return int(feasible[int(np.argmin(score))])\n",
  "rare_fit_priority": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    closeness = np.abs(cap - dem)  # smaller => rarer fit (nearly fills capacity)\n\n    d_cur = distance_matrix[current_node, feasible]\n    score = 0.8 * (closeness / (np.mean(closeness) + 1e-9)) + 0.2 * (d_cur / (np.mean(d_cur) + 1e-9))\n\n    return int(feasible[int(np.argmin(score))])\n",
  "pareto_front_selector": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    dem = demands[feasible].astype(float)\n\n    # Non-dominated wrt minimize d_cur and maximize dem\n    nd_mask = np.ones(len(feasible), dtype=bool)\n    for i in range(len(feasible)):\n        if not nd_mask[i]:\n            continue\n        for j in range(len(feasible)):\n            if i == j:\n                continue\n            if (d_cur[j] <= d_cur[i] + 1e-12) and (dem[j] >= dem[i] - 1e-12) and ((d_cur[j] < d_cur[i] - 1e-12) or (dem[j] > dem[i] + 1e-12)):\n                nd_mask[i] = False\n                break\n\n    nd = feasible[nd_mask]\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, nd]\n    d_nd = distance_matrix[nd, depot]\n    ins = d_cn + d_nd - d_cd\n    return int(nd[int(np.argmin(ins))])\n",
  "demand_quantile_gate": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    q = 0.65  # keep upper 35% demands\n    thr = float(np.quantile(dem, q)) if len(dem) > 1 else float(dem[0])\n    cand = feasible[dem >= thr]\n    if len(cand) == 0:\n        cand = feasible\n\n    d = distance_matrix[current_node, cand]\n    return int(cand[int(np.argmin(d))])\n",
  "angle_turn_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Approximate previous node as depot for a consistent signature\n    a = float(distance_matrix[depot, current_node])\n    b = distance_matrix[current_node, feasible].astype(float)  # current->n\n    c = distance_matrix[depot, feasible].astype(float)         # depot->n\n\n    # cos(theta) at current for triangle (depot-current-n)\n    cos_theta = (a*a + b*b - c*c) / (2.0 * a * b + 1e-9)\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n    turn_pen = 1.0 - cos_theta  # small when straight-ish\n\n    score = 0.75 * b + 0.25 * (turn_pen * (np.mean(b) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "rarity_by_demand_histogram": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = np.array([n for n in unv if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem_all = demands[unv].astype(float)\n    dem_f = demands[feasible].astype(float)\n\n    bins = min(8, max(2, int(np.sqrt(len(dem_all))) ))\n    mn, mx = float(np.min(dem_all)), float(np.max(dem_all))\n    if mx - mn < 1e-9:\n        # fallback: nearest\n        return int(feasible[int(np.argmin(distance_matrix[current_node, feasible]))])\n\n    edges = np.linspace(mn, mx + 1e-12, bins + 1)\n    idx_all = np.clip(np.digitize(dem_all, edges) - 1, 0, bins - 1)\n    counts = np.bincount(idx_all, minlength=bins).astype(float)\n\n    idx_f = np.clip(np.digitize(dem_f, edges) - 1, 0, bins - 1)\n    rarity = 1.0 / (counts[idx_f] + 1e-9)  # higher => rarer\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    score = -1.0 * rarity + 0.2 * (d_cur / (np.mean(d_cur) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "minimax_edge_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = np.array([n for n in unv if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Precompute nearest neighbor distance among unvisited for each feasible node\n    dist_fu = distance_matrix[np.ix_(feasible, unv)].astype(float)\n    for i, n in enumerate(feasible):\n        same = np.where(unv == n)[0]\n        if len(same) > 0:\n            dist_fu[i, same[0]] = np.inf\n    nn = np.min(dist_fu, axis=1)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    score = np.maximum(d_cn, nn) + 0.05 * (d_cn + nn)\n    return int(feasible[int(np.argmin(score))])\n",
  "route_endurance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap0], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    cap_after = cap0 - dem\n\n    d_nd = distance_matrix[feasible, depot].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # Higher is better: capacity left minus distance pressure\n    endurance = cap_after - 0.25 * (d_cn + d_nd)\n    return int(feasible[int(np.argmax(endurance))])\n",
  "local_prize_collecting": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # lambda adapts: tighter capacity => higher emphasis on prize\n    lam = 0.6 / (cap + 1.0)\n    utility = dem - lam * d_cn\n    return int(feasible[int(np.argmax(utility))])\n",
  "anti_greedy_shake": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d = distance_matrix[current_node, feasible].astype(float)\n    order = np.argsort(d)\n    best = int(order[0])\n    if len(order) == 1:\n        return int(feasible[best])\n\n    second = int(order[1])\n\n    seed = (int(current_node) * 374761393) ^ (int(len(unvisited_nodes)) * 668265263) ^ (int(cap * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n\n    # More shaking when far from depot (proxy for being in outer region)\n    p = float(np.clip(distance_matrix[current_node, depot] / (np.mean(distance_matrix[depot, feasible]) + 1e-9), 0.05, 0.35))\n    return int(feasible[second]) if rng.random() < p else int(feasible[best])\n",
  "expected_future_feasibility": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = np.array([n for n in unv if demands[n] <= cap0], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    best_n = None\n    best_score = -1e18\n\n    for n in feasible:\n        cap1 = cap0 - float(demands[n])\n        remaining = unv[unv != n]\n        if len(remaining) == 0:\n            feas_frac = 1.0\n        else:\n            feas_frac = float(np.mean(demands[remaining] <= cap1))\n\n        # Slight distance penalty so it doesn't ignore geometry\n        score = feas_frac - 0.02 * float(distance_matrix[current_node, n])\n        if score > best_score:\n            best_score = score\n            best_n = n\n\n    return int(best_n) if best_n is not None else depot\n",
  "closest_feasible_by_ranked_ring": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    r_all = distance_matrix[depot, unv].astype(float)\n    order = np.argsort(r_all)\n    rank = np.empty_like(order)\n    rank[order] = np.arange(len(order))\n\n    # rank of current among unvisited radii (if current is depot, put middle)\n    if current_node == depot:\n        cur_rank = len(unv) // 2\n    else:\n        # approximate by inserting current radius into distribution\n        cur_r = float(distance_matrix[depot, current_node])\n        cur_rank = int(np.searchsorted(np.sort(r_all), cur_r))\n\n    feasible_ranks = rank[np.searchsorted(unv, feasible, sorter=np.argsort(unv))]\n    # above line is tricky; use a safer mapping\n    idx_map = {int(n): i for i, n in enumerate(unv.tolist())}\n    feasible_ranks = np.array([rank[idx_map[int(n)]] for n in feasible], dtype=float)\n\n    ring_gap = np.abs(feasible_ranks - float(cur_rank))\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    score = 0.7 * ring_gap + 0.3 * (d_cur / (np.mean(d_cur) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "min_expected_added_cost_via_nearest_next": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap0 = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible_i = unv[demands[unv] <= cap0]\n    if len(feasible_i) == 0:\n        return depot\n\n    best_i, best = None, float('inf')\n    for i in feasible_i:\n        cap1 = cap0 - float(demands[i])\n        rem = unv[unv != i]\n        feasible_k = rem[demands[rem] <= cap1]\n\n        base = float(distance_matrix[current_node, i])\n        ret = 0.35 * float(distance_matrix[i, depot])\n\n        if len(feasible_k) == 0:\n            exp_next = 0.0\n        else:\n            # expectation proxy: average of the 3 nearest distances\n            di = distance_matrix[i, feasible_k].astype(float)\n            m = min(3, len(di))\n            exp_next = float(np.mean(np.partition(di, m - 1)[:m]))\n\n        cost = base + 0.6 * exp_next + ret\n        if cost < best:\n            best = cost\n            best_i = int(i)\n\n    return int(best_i) if best_i is not None else depot\n",
  "demand_to_depot_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_dep = distance_matrix[depot, feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    score = dem / (d_dep + 1e-9) - 0.1 * (d_cur / (np.mean(d_cur) + 1e-9))\n    return int(feasible[int(np.argmax(score))])\n",
  "nearest_with_capacity_guardband": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    guard = 0.75 * cap\n    small = feasible[demands[feasible] <= guard]\n    cand = small if len(small) > 0 else feasible\n\n    d = distance_matrix[current_node, cand].astype(float)\n    return int(cand[int(np.argmin(d))])\n",
  "median_direction_pull": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # choose a 'median' node by depot distance\n    r = distance_matrix[depot, unv].astype(float)\n    med = int(unv[int(np.argsort(r)[len(r)//2])])\n\n    d_nm = distance_matrix[feasible, med].astype(float)\n    d_cm = float(distance_matrix[current_node, med])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    score = np.abs(d_nm - d_cm) + 0.5 * d_cn\n    return int(feasible[int(np.argmin(score))])\n",
  "entropy_balanced_sampling": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n    ins = d_cn + d_nd - d_cd\n\n    # Flatten probabilities (high entropy): p ~ exp(-ins / T) with large T\n    T = (np.mean(ins) + 1e-9) * 3.0\n    x = -(ins - np.min(ins)) / (T + 1e-9)\n    w = np.exp(x - np.max(x))\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (int(current_node) * 1103515245 + int(len(unvisited_nodes)) * 12345) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(rng.choice(feasible, p=p))\n",
  "balanced_two_anchor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_dep = distance_matrix[feasible, depot].astype(float)\n    d_cur = distance_matrix[feasible, current_node].astype(float)\n\n    sym = np.abs(d_dep - d_cur)\n    step = distance_matrix[current_node, feasible].astype(float)\n\n    score = 0.65 * sym + 0.35 * (step / (np.mean(step) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "min_variance_step": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dist_fu = distance_matrix[np.ix_(feasible, unv)].astype(float)\n    var = np.var(dist_fu, axis=1)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    score = 0.55 * (d_cn / (np.mean(d_cn) + 1e-9)) + 0.45 * (var / (np.mean(var) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "depot_return_deadline": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    # If current is \"far\", prefer decreasing depot distance\n    far = d_cd > float(np.median(distance_matrix[depot, feasible]))\n    if far:\n        score = d_nd + 0.3 * d_cn\n    else:\n        score = d_cn\n\n    return int(feasible[int(np.argmin(score))])\n",
  "kmedoids_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # choose 2 candidate medoids among feasible: closest-to-depot and farthest-from-depot\n    d_dep_f = distance_matrix[depot, feasible].astype(float)\n    m1 = int(feasible[int(np.argmin(d_dep_f))])\n    m2 = int(feasible[int(np.argmax(d_dep_f))])\n\n    # assign unvisited to nearest medoid and compute total cost\n    d1 = distance_matrix[unv, m1].astype(float)\n    d2 = distance_matrix[unv, m2].astype(float)\n    cost1 = float(np.sum(np.minimum(d1, d2)))\n\n    target = m1 if cost1 <= cost1 else m2  # deterministic; placeholder but stable\n    # move toward chosen medoid: select feasible node closest to target\n    d_to_target = distance_matrix[feasible, target].astype(float)\n    return int(feasible[int(np.argmin(d_to_target))])\n",
  "capacity_scaled_insertion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n    ins = d_cn + d_nd - d_cd\n\n    dem = demands[feasible].astype(float)\n    scaled = ins * (1.0 + dem / (cap + 1e-9))\n    return int(feasible[int(np.argmin(scaled))])\n",
  "nearest_neighbor_with_isolation_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dist_fu = distance_matrix[np.ix_(feasible, unv)].astype(float)\n    for i, n in enumerate(feasible):\n        same = np.where(unv == n)[0]\n        if len(same) > 0:\n            dist_fu[i, same[0]] = np.inf\n    nn = np.min(dist_fu, axis=1)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    score = d_cn + 0.4 * nn\n    return int(feasible[int(np.argmin(score))])\n",
  "lexicographic_demand_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    max_dem = float(np.max(dem))\n    cand = feasible[dem >= max_dem - 1e-12]\n\n    d = distance_matrix[current_node, cand].astype(float)\n    return int(cand[int(np.argmin(d))])\n",
  "closest_to_depot_when_fullness_high": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    mean_dem = float(np.mean(demands[unvisited_nodes])) if len(unvisited_nodes) > 0 else 1.0\n    tight = cap < 1.2 * mean_dem\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[depot, feasible].astype(float)\n\n    score = (0.2 * d_cn + 0.8 * d_nd) if tight else (0.9 * d_cn + 0.1 * d_nd)\n    return int(feasible[int(np.argmin(score))])\n",
  "capacity_splitter_low_high": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    med = float(np.median(dem))\n    low = feasible[dem <= med]\n    high = feasible[dem > med]\n\n    prefer_high = (int(current_node) % 2 == 0)\n    cand = high if (prefer_high and len(high) > 0) else (low if len(low) > 0 else feasible)\n\n    d = distance_matrix[current_node, cand].astype(float)\n    return int(cand[int(np.argmin(d))])\n",
  "min_cross_distance_to_route": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[depot, feasible].astype(float)\n\n    score = np.maximum(d_cn, d_nd) + 0.1 * (d_cn + d_nd)\n    return int(feasible[int(np.argmin(score))])\n",
  "ranked_borda_count": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    d_dep = distance_matrix[depot, feasible].astype(float)\n    dem = demands[feasible].astype(float)\n\n    n = len(feasible)\n    r1 = np.argsort(np.argsort(d_cur))\n    r2 = np.argsort(np.argsort(d_dep))\n    r3 = np.argsort(np.argsort(-dem))\n\n    # Borda: higher points for better rank (lower rank index)\n    points = (n - 1 - r1) + (n - 1 - r2) + (n - 1 - r3)\n    return int(feasible[int(np.argmax(points))])\n",
  "max_margin_to_capacity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    tight = cap < float(np.median(demands[unvisited_nodes]))\n    if tight:\n        score = 0.8 * (dem / (np.mean(dem) + 1e-9)) + 0.2 * (d_cn / (np.mean(d_cn) + 1e-9))\n    else:\n        score = d_cn\n\n    return int(feasible[int(np.argmin(score))])\n",
  "short_edge_preferential_attachment": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d = distance_matrix[current_node, feasible].astype(float)\n    w = 1.0 / (d * d + 1e-9)\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (int(current_node) * 97531 + int(len(unvisited_nodes)) * 864197523) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(rng.choice(feasible, p=p))\n",
  "late_route_closure_bias": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    # fewer feasible => close route\n    t = 1.0 / (len(feasible) + 1.0)\n    score = (1.0 - t) * d_cn + t * d_nd\n    return int(feasible[int(np.argmin(score))])\n",
  "pseudo_sweep_by_distance_order": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # order by depot distance\n    r = distance_matrix[depot, unv].astype(float)\n    ord_nodes = unv[np.argsort(r)]\n\n    # find nearest position for current radius and take next feasible in that direction\n    cur_r = float(distance_matrix[depot, current_node])\n    pos = int(np.searchsorted(np.sort(r), cur_r))\n\n    # scan forward then backward for a feasible node\n    ord_list = ord_nodes.tolist()\n    feas_set = set(map(int, feasible.tolist()))\n\n    for step in range(len(ord_list)):\n        idx = (pos + step) % len(ord_list)\n        cand = int(ord_list[idx])\n        if cand in feas_set:\n            return cand\n\n    return int(feasible[int(np.argmin(distance_matrix[current_node, feasible]))])\n",
  "knn_barycenter_pull": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    k = min(7, len(unv))\n    scores = []\n    for n in feasible:\n        d_to_unv = distance_matrix[n, unv].astype(float)\n        nn = np.partition(d_to_unv, k - 1)[:k]\n        bary = float(np.mean(nn))\n        d_cur = float(distance_matrix[current_node, n])\n        scores.append(d_cur + 0.9 * bary)\n    return int(feasible[int(np.argmin(scores))])\n",
  "local_two_cluster_switch": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    r = distance_matrix[depot, feasible].astype(float)\n    med = float(np.median(r))\n    near = feasible[r <= med]\n    far = feasible[r > med]\n\n    flip = ((int(current_node) * 31 + int(len(unvisited_nodes)) * 17) & 1) == 0\n    cand = far if (flip and len(far) > 0) else (near if len(near) > 0 else feasible)\n\n    d = distance_matrix[current_node, cand].astype(float)\n    return int(cand[int(np.argmin(d))])\n",
  "demand_similarity_chain": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    target = float(demands[current_node]) if current_node != depot else float(np.median(demands[feasible]))\n    dem = demands[feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    score = 0.7 * np.abs(dem - target) + 0.3 * (d_cur / (np.mean(d_cur) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "min_radial_detour": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n = distance_matrix[depot, feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    score = 0.6 * np.abs(r_n - r_cur) + 0.4 * (d_cn / (np.mean(d_cn) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "max_depot_progress": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    r_cur = float(distance_matrix[current_node, depot])\n    r_n = distance_matrix[feasible, depot].astype(float)\n    step = distance_matrix[current_node, feasible].astype(float)\n\n    improvement = np.maximum(0.0, r_cur - r_n)\n    score = improvement / (step + 1e-9)\n\n    # If not far, fallback to nearest\n    if r_cur < float(np.median(distance_matrix[depot, feasible])):\n        return int(feasible[int(np.argmin(step))])\n    return int(feasible[int(np.argmax(score))])\n",
  "min_travel_plus_spread": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    mean_to_unv = distance_matrix[np.ix_(feasible, unv)].astype(float).mean(axis=1)\n\n    score = d_cn + 0.5 * mean_to_unv\n    return int(feasible[int(np.argmin(score))])\n",
  "min_return_edge_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    score = np.maximum.reduce([d_cn, d_nd, np.full_like(d_cn, d_cd)])\n    return int(feasible[int(np.argmin(score))])\n",
  "max_min_distance_separation": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # Define a local neighborhood around current (closest m unvisited)\n    m = min(8, len(unv))\n    d_cur_all = distance_matrix[current_node, unv].astype(float)\n    neigh = unv[np.argsort(d_cur_all)[:m]]\n\n    # For each feasible node, maximize its minimum distance to this neighborhood (spread), with step penalty\n    dist_to_neigh = distance_matrix[np.ix_(feasible, neigh)].astype(float)\n    min_to_neigh = np.min(dist_to_neigh, axis=1)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    score = min_to_neigh - 0.3 * d_cn\n    return int(feasible[int(np.argmax(score))])\n",
  "capacity_fraction_targeting_dynamic": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Early => larger chunks; late => smaller chunks\n    frac_target = 0.85 - 0.4 * (1.0 / (len(unvisited_nodes) + 1.0))\n\n    dem = demands[feasible].astype(float)\n    frac = dem / (cap + 1e-9)\n    miss = np.abs(frac - frac_target)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    score = 0.75 * miss + 0.25 * (d_cn / (np.mean(d_cn) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "edge_triangle_slack_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    detour = d_cn + d_nd - d_cd\n    # Prefer smallest detour (most negative slack is impossible in metric, but smallest is best)\n    return int(feasible[int(np.argmin(detour))])\n",
  "max_compact_cluster_gain": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap0]\n    if len(feasible) == 0:\n        return depot\n\n    # Baseline compactness of feasible set\n    base = float(np.mean(distance_matrix[np.ix_(feasible, feasible)])) if len(feasible) > 1 else 0.0\n\n    best_n, best = None, float('inf')\n    for n in feasible:\n        rem = feasible[feasible != n]\n        if len(rem) <= 1:\n            comp = 0.0\n        else:\n            comp = float(np.mean(distance_matrix[np.ix_(rem, rem)]))\n        # objective: keep compactness low + keep step short\n        step = float(distance_matrix[current_node, n])\n        obj = comp + 0.15 * step + 0.05 * base\n        if obj < best:\n            best = obj\n            best_n = int(n)\n\n    return int(best_n) if best_n is not None else depot\n",
  "nearest_with_demand_floor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dem_all = demands[feasible].astype(float)\n    floor = float(np.quantile(dem_all, 0.2)) if len(dem_all) > 1 else float(dem_all[0])\n\n    filtered = feasible[demands[feasible] >= floor]\n    cand = filtered if len(filtered) > 0 else feasible\n\n    d = distance_matrix[current_node, cand].astype(float)\n    return int(cand[int(np.argmin(d))])\n",
  "randomized_topk_insertion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    ins = distance_matrix[current_node, feasible].astype(float) + distance_matrix[feasible, depot].astype(float) - d_cd\n\n    k = min(5, len(feasible))\n    idx = np.argsort(ins)[:k]\n    cand = feasible[idx]\n\n    seed = (int(current_node) * 2654435761) ^ (int(len(unvisited_nodes)) * 2246822519) ^ (int(cap * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(cand))\n",
  "boltzmann_utility_demand_minus_cost": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d = distance_matrix[current_node, feasible].astype(float)\n\n    alpha = 0.8\n    util = dem - alpha * d\n\n    T = (np.std(util) + 1e-9) * 1.5 + 1e-9\n    x = (util - np.max(util)) / T\n    w = np.exp(x)\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (int(current_node) * 73856093) ^ (int(len(unvisited_nodes)) * 19349663)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=p))\n",
  "gated_isolation_then_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dist_fu = distance_matrix[np.ix_(feasible, unv)].astype(float)\n    for i, n in enumerate(feasible):\n        same = np.where(unv == n)[0]\n        if len(same) > 0:\n            dist_fu[i, same[0]] = np.inf\n    nn = np.min(dist_fu, axis=1)\n\n    if len(nn) > 1:\n        thr = float(np.quantile(nn, 0.8))\n        iso = feasible[nn >= thr]\n        if len(iso) > 0:\n            d_iso = distance_matrix[current_node, iso].astype(float)\n            return int(iso[int(np.argmin(d_iso))])\n\n    d = distance_matrix[current_node, feasible].astype(float)\n    return int(feasible[int(np.argmin(d))])\n",
  "min_weighted_harmonic_distances": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d1 = distance_matrix[current_node, feasible].astype(float)\n    d2 = distance_matrix[depot, feasible].astype(float)\n\n    harm = 2.0 / (1.0 / (d1 + 1e-9) + 1.0 / (d2 + 1e-9))\n    return int(feasible[int(np.argmin(harm))])\n",
  "soft_regret_on_two_criteria": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    beta = 0.45\n    cost = distance_matrix[current_node, feasible].astype(float) + beta * distance_matrix[depot, feasible].astype(float)\n    if len(feasible) == 1:\n        return int(feasible[0])\n\n    ord_idx = np.argsort(cost)\n    best = float(cost[ord_idx[0]])\n    kth = float(cost[ord_idx[min(2, len(ord_idx)-1)]])\n    regret = kth - best\n\n    # map scalar regret to choice: if regret large, take the top candidate; else take the median candidate (diversify)\n    if regret > (np.std(cost) + 1e-9):\n        return int(feasible[int(ord_idx[0])])\n    return int(feasible[int(ord_idx[len(ord_idx)//2])])\n",
  "min_cost_per_remaining_capacity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap - 1e-12], dtype=int)\n    if len(feasible) == 0:\n        # if only exact-fill nodes exist, choose nearest exact-fill\n        feasible2 = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n        if len(feasible2) == 0:\n            return depot\n        d = distance_matrix[current_node, feasible2].astype(float)\n        return int(feasible2[int(np.argmin(d))])\n\n    dem = demands[feasible].astype(float)\n    d = distance_matrix[current_node, feasible].astype(float)\n    rem = (cap - dem) + 1e-9\n\n    score = d / rem\n    return int(feasible[int(np.argmin(score))])\n",
  "max_neighborhood_demand_density": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    k = min(6, len(unv))\n    best_n, best = None, -1e18\n    for n in feasible:\n        d_to_unv = distance_matrix[n, unv].astype(float)\n        idx = np.argsort(d_to_unv)[:k]\n        neigh = unv[idx]\n        dem_sum = float(np.sum(demands[neigh]))\n        avg_d = float(np.mean(d_to_unv[idx]))\n        val = dem_sum / (avg_d + 1e-9) - 0.1 * float(distance_matrix[current_node, n])\n        if val > best:\n            best = val\n            best_n = int(n)\n\n    return int(best_n) if best_n is not None else depot\n",
  "anti_depot_bias_when_far": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_nd = distance_matrix[depot, feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    far = d_cd > float(np.median(d_nd))\n    if far:\n        score = 0.7 * (-d_nd) + 0.3 * (-d_cn)  # maximize both distances (stay out)\n        return int(feasible[int(np.argmax(score))])\n    else:\n        score = 0.7 * d_nd + 0.3 * d_cn\n        return int(feasible[int(np.argmin(score))])\n",
  "stochastic_threshold_acceptance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d = distance_matrix[current_node, feasible].astype(float)\n    best = float(np.min(d))\n\n    eps = 0.15  # acceptance band\n    seed = (int(current_node) * 2166136261) ^ (int(len(unvisited_nodes)) * 16777619) ^ (int(cap * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n\n    perm = rng.permutation(len(feasible))\n    for idx in perm:\n        if float(d[idx]) <= best * (1.0 + eps):\n            return int(feasible[int(idx)])\n\n    return int(feasible[int(np.argmin(d))])\n",
  "nearest_neighbor_aug_0": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # If nothing left to visit, return to the depot\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes: demand fits into remaining capacity\n    mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[mask]\n    # Distances from the current node to each feasible candidate\n    dist = distance_matrix[current_node, feasible_nodes]\n\n    # Small deterministic noise to break ties (0.000001 * index)\n    noise = 1e-6 * np.arange(dist.size)\n    idx = np.argmin(dist + noise)\n\n    return int(feasible_nodes[idx])\n\n",
  "nearest_neighbor_aug_1": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[mask]\n    dist = distance_matrix[current_node, feasible_nodes]\n\n    # Soft\u2011min with temperature 1.0 (higher temperature \u2192 more uniform)\n    temp = 1.0\n    exp_vals = np.exp(-dist / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # Deterministically pick the most probable node\n    idx = np.argmax(probs)\n    return int(feasible_nodes[idx])\n\n",
  "nearest_neighbor_aug_2": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[mask]\n    dist = distance_matrix[current_node, feasible_nodes]\n\n    # Score: distance divided by remaining capacity (with epsilon)\n    cap = rest_capacity.item() if isinstance(rest_capacity, np.ndarray) else rest_capacity\n    scores = dist / (cap + 1e-12)\n    scores = np.clip(scores, 0, 1)  # bound to [0, 1]\n\n    # Choose the top\u2011k (k = 7) nearest nodes\n    top_k = 7\n    if feasible_nodes.size <= top_k:\n        candidates = feasible_nodes\n    else:\n        idx_sort = np.argsort(scores)[:top_k]\n        candidates = feasible_nodes[idx_sort]\n\n    rng = np.random.default_rng(42)          # deterministic seed\n    chosen = rng.choice(candidates)          # deterministic choice\n    return int(chosen)\n\n",
  "nearest_neighbor_aug_3": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[mask]\n\n    # Sub\u2011matrix of distances from each feasible node to all unvisited nodes\n    sub_dist = distance_matrix[feasible_nodes[:, None], unvisited_nodes]\n\n    # Sum of distances for each feasible node\n    sum_dist = np.sum(sub_dist, axis=1)\n    sum_dist = np.clip(sum_dist, 0, np.inf)   # avoid overflow\n\n    idx = np.argmin(sum_dist)\n    return int(feasible_nodes[idx])\n\n",
  "farthest_insertion_aug_4": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Vectorized feasibility check\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity)\n    feasible_nodes = unvisited_nodes[feasible_mask]\n\n    if feasible_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    # Distances from depot to each feasible node\n    distances = dist_mat[depot, feasible_nodes]\n    # Add deterministic noise for tie\u2011breaking\n    distances = distances + 1e-6 * feasible_nodes\n    # Ensure non\u2011negative\n    distances = np.clip(distances, a_min=0, a_max=None)\n\n    idx = np.argmax(distances)\n    return int(feasible_nodes[idx])\n\n",
  "farthest_insertion_aug_5": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity)\n    feasible_nodes = unvisited_nodes[feasible_mask]\n\n    if feasible_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    distances = dist_mat[depot, feasible_nodes]\n\n    # Avoid division by zero in capacity ratio\n    cap_ratio = demands[feasible_nodes] / (rest_capacity + 1e-12)\n\n    # Weighted scoring\n    w = 0.6\n    scores = w * distances + (1 - w) * cap_ratio\n    # Clip scores to avoid extreme values\n    scores = np.clip(scores, a_min=0, a_max=None)\n\n    # Randomly pick among top 7 nodes\n    top_k = 7\n    if feasible_nodes.size <= top_k:\n        chosen_idx = np.random.default_rng(42).choice(feasible_nodes)\n    else:\n        partition = np.argpartition(-scores, top_k - 1)[:top_k]\n        top_nodes = feasible_nodes[partition]\n        rng = np.random.default_rng(42)\n        chosen_idx = rng.choice(top_nodes)\n\n    return int(chosen_idx)\n\n",
  "farthest_insertion_aug_6": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity)\n    feasible_nodes = unvisited_nodes[feasible_mask]\n\n    if feasible_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    distances = dist_mat[depot, feasible_nodes]\n    # Temperature for softmin\n    temperature = 0.5\n    # Compute softmax of negative distances\n    logits = -distances / (temperature + 1e-12)\n    # Clip logits to avoid overflow\n    logits = np.clip(logits, a_min=-700, a_max=700)\n    exp_logits = np.exp(logits)\n    probs = exp_logits / (np.sum(exp_logits) + 1e-12)\n    # Deterministic sampling via seeded RNG\n    rng = np.random.default_rng(123)\n    chosen_idx = rng.choice(feasible_nodes, p=probs)\n    return int(chosen_idx)\n\n",
  "farthest_insertion_aug_7": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasibility\n    feasible_mask = (demands[unvisited_nodes] <= rest_capacity)\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    if feasible_nodes.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    distances = dist_mat[depot, feasible_nodes]\n    # Deterministic noise\n    distances = distances + 1e-8 * feasible_nodes\n    distances = np.clip(distances, a_min=0, a_max=None)\n\n    # Weighted score: distance + demand ratio\n    cap_ratio = demands[feasible_nodes] / (rest_capacity + 1e-12)\n    w = 0.5\n    scores = w * distances + (1 - w) * cap_ratio\n    scores = np.clip(scores, a_min=0, a_max=None)\n\n    # Softmax with temperature\n    temperature = 0.3\n    logits = -scores / (temperature + 1e-12)\n    logits = np.clip(logits, a_min=-700, a_max=700)\n    exp_logits = np.exp(logits)\n    probs = exp_logits / (np.sum(exp_logits) + 1e-12)\n\n    # Top\u2011k selection\n    top_k = 10\n    if feasible_nodes.size <= top_k:\n        rng = np.random.default_rng(999)\n        chosen_idx = rng.choice(feasible_nodes, p=probs)\n    else:\n        partition = np.argpartition(-scores, top_k - 1)[:top_k]\n        top_nodes = feasible_nodes[partition]\n        top_probs = probs[partition]\n        top_probs = top_probs / (np.sum(top_probs) + 1e-12)\n        rng = np.random.default_rng(999)\n        chosen_idx = rng.choice(top_nodes, p=top_probs)\n\n    return int(chosen_idx)\n\n",
  "demand_to_distance_ratio_aug_8": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes via list comprehension\n    feasible = [int(n) for n in unvisited_nodes if demands[n] <= rest_capacity]\n    if not feasible:\n        return depot\n\n    # Distances and demands\n    dists = np.clip(distance_matrix[current_node, feasible], 1e-12, None)\n    dem = demands[feasible]\n\n    # Soft\u2011max style score: higher demand and lower distance are favoured\n    alpha = 1.5\n    scores = np.exp(alpha * dem / dists)\n\n    # Pick a random element among the top\u2011k scores\n    top_k = min(7, len(scores))\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    rng = np.random.default_rng(42)               # reproducible random choice\n    chosen_idx = rng.choice(top_indices)\n\n    return int(feasible[chosen_idx])\n\n",
  "demand_to_distance_ratio_aug_9": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = np.array([int(n) for n in unvisited_nodes if demands[n] <= rest_capacity], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # Distances and demands\n    dists = np.clip(distance_matrix[current_node, feasible], 1e-12, None)\n    dem = demands[feasible]\n\n    # Median\u2011scaled demand/distance ratio\n    median_dist = np.median(dists)\n    ratio_scaled = dem / np.clip(dists, 1e-12, None) / (median_dist + 1e-12)\n\n    # Deterministic noise based on node id\n    noise = (feasible % 10) * 1e-7\n    score = ratio_scaled + noise\n\n    return int(feasible[np.argmax(score)])\n\n",
  "demand_to_distance_ratio_aug_10": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Boolean mask for feasible nodes (vectorised)\n    mask = demands[unvisited_nodes] <= rest_capacity\n    feasible = unvisited_nodes[mask]\n    if feasible.size == 0:\n        return depot\n\n    # Squared distances (proxy for Euclidean distance)\n    sq_dists = np.square(distance_matrix[current_node, feasible])\n    sq_dists = np.clip(sq_dists, 1e-12, None)\n\n    dem = demands[feasible]\n    max_dem = np.max(dem) if dem.size > 0 else 1\n\n    # Score: normalised demand divided by squared distance\n    score = (dem / max_dem) / sq_dists\n    score = np.clip(score, None, 1e6)          # upper clip to avoid overflow\n\n    return int(feasible[np.argmax(score)])\n\n",
  "capacity_utilization_max_aug_11": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # rename for readability\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n\n    # clip demands to avoid negative values\n    dem = np.clip(dem, 0, None)\n\n    if candidates.size == 0:\n        return depot\n\n    # feasibility mask\n    feasible_mask = dem[candidates] <= cap\n    if not feasible_mask.any():\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n    # deterministic noise for tie\u2011breaking: small increasing values\n    noise = 1e-6 * np.arange(feasible_nodes.size)\n    # pick node with maximum (demand + noise)\n    idx = np.argmax(dem[feasible_nodes] + noise)\n    return int(feasible_nodes[idx])\n\n",
  "capacity_utilization_max_aug_12": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # rename for clarity\n    dist_mat = distance_matrix\n    cand = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n\n    # clip to avoid negative capacities\n    cap = np.clip(cap, 0, None)\n\n    if cand.size == 0:\n        return depot\n\n    # feasibility\n    feasible_mask = dem[cand] <= cap\n    if not feasible_mask.any():\n        return depot\n\n    feasible_nodes = cand[feasible_mask]\n    # keep only top_k by demand\n    top_k = 7\n    top_idx = np.argpartition(dem[feasible_nodes], -top_k)[-top_k:]\n    top_nodes = feasible_nodes[top_idx]\n\n    # compute weighted score: demand (0.6) + inverse distance (0.4)\n    weight_dem = 0.6\n    weight_dist = 0.4\n    # avoid division by zero with epsilon\n    inv_dist = 1.0 / (dist_mat[top_nodes, current_node] + 1e-12)\n    score = weight_dem * dem[top_nodes] + weight_dist * inv_dist\n    best = top_nodes[np.argmax(score)]\n    return int(best)\n\n",
  "capacity_utilization_max_aug_13": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # rename variables\n    dist_mat = distance_matrix\n    nodes = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n\n    # clip capacities to non\u2011negative\n    cap = np.clip(cap, 0, None)\n\n    if nodes.size == 0:\n        return depot\n\n    # feasibility mask\n    feasible = dem[nodes] <= cap\n    if not feasible.any():\n        return depot\n\n    feasible_nodes = nodes[feasible]\n    top_k = 5\n    if feasible_nodes.size <= top_k:\n        candidates = feasible_nodes\n    else:\n        top_idx = np.argpartition(dem[feasible_nodes], -top_k)[-top_k:]\n        candidates = feasible_nodes[top_idx]\n\n    # score: higher demand + closer distance\n    # use epsilon to avoid division by zero\n    inv_dist = 1.0 / (dist_mat[candidates, current_node] + 1e-12)\n    score = dem[candidates] + inv_dist\n\n    # softmax probabilities\n    exp_score = np.exp(score - np.max(score))  # stability\n    probs = exp_score / (exp_score.sum() + 1e-12)\n\n    rng = np.random.default_rng()\n    chosen = rng.choice(candidates, p=probs)\n    return int(chosen)\n\n",
  "capacity_utilization_max_aug_14": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # variable renaming\n    dist_mat = distance_matrix\n    cand = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n\n    # ensure non\u2011negative capacities\n    cap = np.clip(cap, 0, None)\n\n    if cand.size == 0:\n        return depot\n\n    # feasibility\n    feasible_mask = dem[cand] <= cap\n    if not feasible_mask.any():\n        return depot\n\n    feasible_nodes = cand[feasible_mask]\n    feasible_dem = dem[feasible_nodes]\n\n    # median demand among feasible nodes\n    median_val = np.median(feasible_dem)\n\n    # distance of each feasible node to median\n    diff = np.abs(feasible_dem - median_val)\n    # tie\u2011break with higher demand\n    # add small noise proportional to demand to make ordering deterministic\n    noise = 1e-6 * feasible_dem\n    # combine diff and negative demand\n    score = -diff + noise\n    idx = np.argmax(score)\n    return int(feasible_nodes[idx])\n\n",
  "savings_heuristic_aug_15": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    # feasible nodes according to remaining capacity\n    feas_mask = demands[candidates] <= rest_capacity\n    if not np.any(feas_mask):\n        return depot\n    feasible = candidates[feas_mask]\n\n    # vectorised savings computation\n    d_cur_depot = dist_mat[current_node, depot]\n    d_depot_nodes = dist_mat[depot, feasible]\n    d_cur_nodes = dist_mat[current_node, feasible]\n    savings = d_cur_depot + d_depot_nodes - d_cur_nodes\n\n    # deterministic tie\u2011breaker: tiny increasing noise\n    noise = np.arange(savings.size, dtype=float) * 1e-9\n    # keep values in a safe range\n    savings = np.clip(savings, -1e9, 1e9)\n\n    chosen = feasible[np.argmax(savings + noise)]\n    return int(chosen)\n\n",
  "savings_heuristic_aug_16": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    feas_mask = demands[candidates] <= rest_capacity\n    if not np.any(feas_mask):\n        return depot\n    feasible = candidates[feas_mask]\n\n    d_cur_depot = dist_mat[current_node, depot]\n    d_depot_nodes = dist_mat[depot, feasible]\n    d_cur_nodes = dist_mat[current_node, feasible]\n\n    # weighted savings \u2013 tuned hyper\u2011parameters\n    w1, w2, w3 = 0.6, 0.4, 1.0\n    weighted = w1 * d_cur_depot + w2 * d_depot_nodes - w3 * d_cur_nodes\n    weighted = np.clip(weighted, -1e6, 1e6)\n\n    chosen = feasible[np.argmax(weighted)]\n    return int(chosen)\n\n",
  "savings_heuristic_aug_17": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    feas_mask = demands[candidates] <= rest_capacity\n    if not np.any(feas_mask):\n        return depot\n    feasible = candidates[feas_mask]\n\n    d_cur_depot = dist_mat[current_node, depot]\n    d_depot_nodes = dist_mat[depot, feasible]\n    d_cur_nodes = dist_mat[current_node, feasible]\n\n    # raw savings\n    raw = d_cur_depot + d_depot_nodes - d_cur_nodes\n\n    # softmax selection with temperature\n    temp = 0.5\n    shifted = raw - np.max(raw)          # numerical stability\n    exp_vals = np.exp(temp * shifted)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)  # epsilon in denominator\n\n    # deterministic random choice based on probabilities\n    idx = np.random.choice(feasible.size, p=probs)\n    return int(feasible[idx])\n\n",
  "savings_heuristic_aug_18": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    # build feasible list with a while loop\n    feasible = []\n    i = 0\n    while i < candidates.size:\n        node = candidates[i]\n        if demands[node] <= rest_capacity:\n            feasible.append(node)\n        i += 1\n\n    if not feasible:\n        return depot\n    feasible = np.array(feasible, dtype=int)\n\n    d_cur_depot = dist_mat[current_node, depot]\n    d_depot_nodes = dist_mat[depot, feasible]\n    d_cur_nodes = dist_mat[current_node, feasible]\n\n    # weighted savings with different weights\n    w1, w2, w3 = 0.7, 0.2, 1.0\n    savings = w1 * d_cur_depot + w2 * d_depot_nodes - w3 * d_cur_nodes\n    savings = np.clip(savings, -1e6, 1e6)\n\n    # keep only nodes with savings above the median\n    median_val = np.median(savings)\n    mask = savings >= median_val\n    if not np.any(mask):\n        mask = np.ones_like(savings, dtype=bool)\n\n    chosen = feasible[np.argmax(savings[mask])]\n    return int(chosen)\n\n",
  "minimal_detour_aug_19": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # If there are no candidates, return depot immediately\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # Find feasible nodes that respect the remaining capacity\n    feasible = np.where(demands[unvisited_nodes] <= rest_capacity,\n                        unvisited_nodes, -1)\n    feasible = feasible[feasible != -1]\n\n    if feasible.size == 0:\n        return depot\n\n    # Rename for clarity\n    dist_mat = distance_matrix\n    d_cd = dist_mat[current_node, depot]          # distance current \u2192 depot\n    d_cn = dist_mat[current_node, feasible]       # distances current \u2192 feasible\n    d_nd = dist_mat[feasible, depot]             # distances feasible \u2192 depot\n\n    # Compute detour cost for each candidate\n    detours = d_cn + d_nd - d_cd\n    # Clip to avoid negative detours (just for safety)\n    detours = np.clip(detours, 0, None)\n\n    # Choose the candidate with minimal detour\n    idx = np.argmin(detours)\n    return int(feasible[idx])\n\n",
  "minimal_detour_aug_20": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # Mask feasible nodes\n    mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(mask):\n        return depot\n\n    feasible = unvisited_nodes[mask]\n\n    # Parameter tuning: weights for current and depot legs\n    w_current = 0.6\n    w_depot   = 0.4\n    eps = 1e-12\n\n    dist_mat = distance_matrix\n    d_cd = dist_mat[current_node, depot]          # current \u2192 depot\n    d_cn = dist_mat[current_node, feasible]       # current \u2192 feasible\n    d_nd = dist_mat[feasible, depot]             # feasible \u2192 depot\n\n    # Weighted detour calculation\n    detours = w_current * d_cn + w_depot * d_nd - d_cd\n    detours = np.clip(detours, 0, None)\n\n    # Optional ratio to normalise by distance to depot\n    score = detours / (d_cd + eps)\n\n    idx = np.argmin(score)\n    return int(feasible[idx])\n\n",
  "minimal_detour_aug_21": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # Feasibility mask\n    mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(mask):\n        return depot\n\n    feasible = unvisited_nodes[mask]\n\n    dist_mat = distance_matrix\n    d_cd = dist_mat[current_node, depot]\n    d_cn = dist_mat[current_node, feasible]\n    d_nd = dist_mat[feasible, depot]\n\n    detours = d_cn + d_nd - d_cd\n\n    # Small deterministic noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=detours.shape)\n    detours_noisy = detours + noise\n\n    top_k = 5\n    if detours_noisy.size <= top_k:\n        idx = np.argmin(detours_noisy)\n        return int(feasible[idx])\n\n    # Get indices of the k smallest detours\n    top_indices = np.argpartition(detours_noisy, top_k)[:top_k]\n\n    # Soft\u2011min weighting (higher probability for lower detour)\n    min_det = detours_noisy[top_indices].min()\n    exp_vals = np.exp(-(detours_noisy[top_indices] - min_det))\n    probs = exp_vals / exp_vals.sum()\n    probs = np.clip(probs, 1e-12, None)  # avoid zero probabilities\n\n    chosen = np.random.choice(top_indices, p=probs)\n    return int(feasible[chosen])\n\n",
  "minimal_detour_aug_22": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # Feasible nodes\n    mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(mask):\n        return depot\n\n    feasible = unvisited_nodes[mask]\n\n    dist_mat = distance_matrix\n    d_cd = dist_mat[current_node, depot]\n    d_cn = dist_mat[current_node, feasible]\n    d_nd = dist_mat[feasible, depot]\n\n    # Score as ratio of detour to distance to depot\n    detours = d_cn + d_nd - d_cd\n    eps = 1e-12\n    score = detours / (d_cd + eps)\n\n    # Clip scores to a reasonable range to avoid extreme values\n    score = np.clip(score, 0, 1e6)\n\n    # Random tie\u2011break by adding tiny noise\n    noise = np.random.uniform(0, 1e-8, size=score.shape)\n    score_noisy = score + noise\n\n    idx = np.argmin(score_noisy)\n    return int(feasible[idx])\n\n",
  "weighted_distance_demand_aug_23": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes that fit into the remaining capacity\n    feasible_mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = unvisited_nodes[feasible_mask]\n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n\n    # Normalisation (avoid divide\u2011by\u2011zero)\n    mean_dist = np.mean(distances) + 1e-12\n    mean_dem  = np.mean(demand_vals) + 1e-12\n    dist_norm = distances / mean_dist\n    dem_norm  = demand_vals / mean_dem\n\n    # Weighted score (lower is better)\n    scores = 0.6 * dist_norm - 0.4 * dem_norm\n\n    # Deterministic noise to break ties\n    noise = np.arange(len(feasible)) * 1e-6\n    scores += noise\n\n    # Clip to prevent extreme values\n    scores = np.clip(scores, -1e6, 1e6)\n\n    chosen = feasible[np.argmin(scores)]\n    return int(chosen)\n\n",
  "weighted_distance_demand_aug_24": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible_mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = unvisited_nodes[feasible_mask]\n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n\n    # Max\u2011normalisation to keep values in [0,1]\n    max_dist = np.max(distances) + 1e-12\n    sum_dem  = np.sum(demand_vals)  + 1e-12\n    dist_norm = distances / max_dist\n    dem_norm  = demand_vals / sum_dem\n\n    # Balanced score\n    scores = 0.5 * dist_norm - 0.5 * dem_norm\n    scores = np.clip(scores, -1e6, 1e6)\n\n    # Select top\u2011k candidates\n    top_k = 5\n    if len(feasible) <= top_k:\n        idx_top = np.arange(len(feasible))\n    else:\n        idx_top = np.argpartition(scores, top_k-1)[:top_k]\n\n    # Deterministic noise to break ties\n    noise = np.arange(len(idx_top)) * 1e-6\n    scores_top = scores[idx_top] + noise\n    chosen_local = np.argmin(scores_top)\n    chosen = feasible[idx_top[chosen_local]]\n    return int(chosen)\n\n",
  "weighted_distance_demand_aug_25": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible_mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = unvisited_nodes[feasible_mask]\n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n\n    # Max\u2011normalisation\n    max_dist = np.max(distances) + 1e-12\n    max_dem  = np.max(demand_vals) + 1e-12\n    dist_norm = distances / max_dist\n    dem_norm  = demand_vals / max_dem\n\n    # Balanced score\n    scores = 0.5 * dist_norm - 0.5 * dem_norm\n    scores = np.clip(scores, -1e6, 1e6)\n\n    # Top\u2011k selection\n    top_k = 7\n    if len(feasible) <= top_k:\n        idx_top = np.arange(len(feasible))\n    else:\n        idx_top = np.argpartition(scores, top_k-1)[:top_k]\n\n    # Deterministic pseudo\u2011random choice\n    rng = np.random.default_rng(current_node + depot)\n    chosen_local = rng.choice(len(idx_top))\n    chosen = feasible[idx_top[chosen_local]]\n    return int(chosen)\n\n",
  "depot_proximity_bias_aug_26": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    dem = demands\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = dem[candidates] <= rem_cap\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = candidates[feasible_mask]\n    max_demand = np.max(dem) + 1e-12\n    capacity_ratio = rem_cap / max_demand\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n\n    # Invert the low\u2011capacity rule\n    if capacity_ratio >= 0.3:\n        scores = 0.7 * d_cur + 0.3 * d_dep\n    else:\n        scores = 0.3 * d_cur + 0.7 * d_dep\n\n    # soft\u2011min selection with numerical stability\n    eps = 1e-12\n    denom = np.max(scores) - np.min(scores) + eps\n    probs = np.exp(-scores / denom)\n    probs /= np.sum(probs)\n    chosen = np.random.choice(feasible, p=probs)\n    return int(chosen)\n\n",
  "depot_proximity_bias_aug_27": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    dem = demands\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = [node for node in candidates if dem[node] <= rem_cap]\n    if not feasible:\n        return depot\n\n    max_demand = np.max(dem) + 1e-12\n    capacity_ratio = rem_cap / max_demand\n\n    best_node = None\n    best_score = np.inf\n    idx = 0\n    while idx < len(feasible):\n        node = feasible[idx]\n        d_cur = dist_mat[current_node, node]\n        d_dep = dist_mat[depot, node]\n\n        if capacity_ratio < 0.3:\n            score = 0.6 * d_cur + 0.4 * d_dep\n        else:\n            score = 0.4 * d_cur + 0.6 * d_dep\n\n        # deterministic tie\u2011breaking noise\n        score += 1e-6 * node\n\n        if score < best_score:\n            best_score = score\n            best_node = node\n        idx += 1\n\n    return int(best_node)\n\n",
  "depot_proximity_bias_aug_28": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    dem = demands\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = dem[candidates] <= rem_cap\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = candidates[feasible_mask]\n    max_demand = np.max(dem) + 1e-12\n    capacity_ratio = np.clip(rem_cap / max_demand, 0.0, 1.0)\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n\n    if capacity_ratio < 0.3:\n        median_cur = np.median(d_cur)\n        scores = 0.5 * median_cur * np.ones_like(feasible) + 0.5 * d_dep\n    else:\n        scores = 0.2 * d_cur + 0.8 * d_dep\n\n    top_k = min(7, len(feasible))\n    top_indices = np.argpartition(scores, top_k - 1)[:top_k]\n    top_nodes = feasible[top_indices]\n    chosen = np.random.choice(top_nodes)\n    return int(chosen)\n\n",
  "depot_proximity_bias_aug_29": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    dem = demands\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = dem[candidates] <= rem_cap\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = candidates[feasible_mask]\n    max_demand = np.max(dem) + 1e-12\n    capacity_ratio = rem_cap / max_demand\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n\n    # proxy: use summed distances as the score\n    if capacity_ratio >= 0.3:\n        scores = d_cur + 0.5 * d_dep\n    else:\n        scores = 0.5 * d_cur + d_dep\n\n    min_idx = np.argmin(scores)\n    return int(feasible[min_idx])\n\n",
  "cluster_centroid_aug_30": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename for readability\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap = rest_capacity\n    dem = demands\n\n    if candidates.size == 0:\n        return depot\n\n    # Build feasible list with a while loop\n    feasible = []\n    idx = 0\n    while idx < candidates.size:\n        node = candidates[idx]\n        if dem[node] <= rest_cap:\n            feasible.append(node)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    # Manual mean computation with epsilon in denominator\n    sub_mat = dist_mat[np.ix_(feasible, feasible)]\n    mean_distances = np.sum(sub_mat, axis=1) / (feasible.size + 1e-12)\n    mean_distances = np.clip(mean_distances, 0, np.inf)\n\n    d_current = dist_mat[current_node, feasible]\n    scores = d_current + 0.5 * mean_distances\n\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(scores.size)\n    scores += noise\n\n    return int(feasible[np.argmin(scores)])\n\n",
  "cluster_centroid_aug_31": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Variable renaming\n    dist_mat = distance_matrix\n    nodes = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n\n    if nodes.size == 0:\n        return depot\n\n    # Vectorised feasibility mask\n    feasible_mask = dem[nodes] <= cap\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = nodes[feasible_mask]\n\n    # Mean distance with epsilon\n    sub = dist_mat[np.ix_(feasible, feasible)]\n    mean_dist = np.mean(sub, axis=1)\n    mean_dist = np.clip(mean_dist, 0, np.inf)\n\n    d_cur = dist_mat[current_node, feasible]\n    scores = 0.3 * d_cur + 0.7 * mean_dist\n\n    # Soft\u2011minimum probabilities\n    exp_vals = np.exp(-scores) + 1e-12\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n\n    # Random selection based on soft\u2011min\n    idx = np.random.choice(feasible.size, p=probs)\n    return int(feasible[idx])\n\n",
  "cluster_centroid_aug_32": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Renamed identifiers\n    dist_mat = distance_matrix\n    cand = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n\n    if cand.size == 0:\n        return depot\n\n    # Feasible nodes using a list comprehension\n    feasible = np.array([c for c in cand if dem[c] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    # Median distance with clipping\n    sub = dist_mat[np.ix_(feasible, feasible)]\n    med_dist = np.median(sub, axis=1)\n    med_dist = np.clip(med_dist, 0, np.inf)\n\n    d_cur = dist_mat[current_node, feasible]\n    scores = 0.6 * d_cur + 0.4 * med_dist\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-7 * np.arange(scores.size)\n    scores += noise\n\n    # Top\u2011k selection\n    top_k = min(5, scores.size)\n    top_indices = np.argpartition(scores, top_k - 1)[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n    return int(feasible[chosen_idx])\n\n",
  "cluster_centroid_aug_33": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Renaming for clarity\n    dist_mat = distance_matrix\n    nodes = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n\n    if nodes.size == 0:\n        return depot\n\n    # Build feasible list with a while loop\n    feasible = []\n    i = 0\n    while i < nodes.size:\n        n = nodes[i]\n        if dem[n] <= cap:\n            feasible.append(n)\n        i += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    # Approximate mean distance: use mean of distances from current node\n    d_cur = dist_mat[current_node, feasible]\n    approx_mean = np.mean(d_cur) + 1e-12\n    approx_mean = np.clip(approx_mean, 0, np.inf)\n\n    # Max aggregation alternative\n    max_dist = np.max(d_cur)\n    max_dist = np.clip(max_dist, 0, np.inf)\n\n    # Scoring with weighted sum of approximated mean and max\n    scores = 0.5 * d_cur + 0.5 * (approx_mean + max_dist) / 2.0\n\n    # Deterministic noise\n    noise = 1e-5 * np.arange(scores.size)\n    scores += noise\n\n    return int(feasible[np.argmin(scores)])\n\n",
  "alternating_nearest_farthest_aug_34": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    cap = rest_capacity\n    demand = demands\n    dist_mat = distance_matrix\n\n    # No unvisited nodes \u2192 return depot\n    if candidates.size == 0:\n        return depot\n\n    # Feasible nodes based on remaining capacity\n    feasible_mask = demand[candidates] <= cap\n    feasible = candidates[feasible_mask]\n\n    if feasible.size == 0:\n        return depot\n\n    # Step count derived from visited nodes\n    step = dist_mat.shape[0] - candidates.size\n\n    # Distances to feasible nodes, clipped to avoid zeros\n    dists = np.clip(dist_mat[current_node, feasible], 1e-12, None)\n\n    # Invert conditional: nearest on odd steps, farthest on even\n    if step % 2 == 1:\n        idx = np.argmin(dists)\n    else:\n        idx = np.argmax(dists)\n\n    return int(feasible[idx])\n\n",
  "alternating_nearest_farthest_aug_35": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    weight_dist = 0.6\n    weight_dem = 0.4\n    top_k = 5\n\n    # Local variable names\n    candidates = unvisited_nodes\n    cap = rest_capacity\n    demand = demands\n    dist_mat = distance_matrix\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = demand[candidates] <= cap\n    feasible = candidates[feasible_mask]\n\n    if feasible.size == 0:\n        return depot\n\n    # Distances and normalized demand\n    dists = dist_mat[current_node, feasible]\n    norm_demand = demand[feasible] / (cap + 1e-12)\n\n    # Weighted score\n    scores = weight_dist * dists + weight_dem * norm_demand\n\n    # Select top_k lowest scores\n    if feasible.size > top_k:\n        top_indices = np.argpartition(scores, top_k)[:top_k]\n        scores_top = scores[top_indices]\n        feasible_top = feasible[top_indices]\n    else:\n        scores_top = scores\n        feasible_top = feasible\n\n    # Softmin probabilities\n    exp_scores = np.exp(-scores_top / (0.1 + 1e-12))\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n\n    rng = np.random.default_rng(42)\n    chosen = rng.choice(feasible_top, p=probs)\n    return int(chosen)\n\n",
  "alternating_nearest_farthest_aug_36": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    top_k = 4\n\n    candidates = unvisited_nodes\n    cap = rest_capacity\n    demand = demands\n    dist_mat = distance_matrix\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = demand[candidates] <= cap\n    feasible = candidates[feasible_mask]\n\n    if feasible.size == 0:\n        return depot\n\n    # Distances with deterministic noise\n    dists = np.clip(dist_mat[current_node, feasible], 1e-12, None)\n    noise = np.arange(dists.size, dtype=float) * 1e-6\n    dists_noisy = dists + noise\n\n    # Indices of the top_k smallest distances\n    if feasible.size <= top_k:\n        top_idx = np.arange(feasible.size)\n    else:\n        top_idx = np.argpartition(dists_noisy, top_k)[:top_k]\n\n    top_nodes = feasible[top_idx]\n\n    rng = np.random.default_rng(0)\n    chosen = rng.choice(top_nodes)\n    return int(chosen)\n\n",
  "alternating_nearest_farthest_aug_37": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    cap = rest_capacity\n    demand = demands\n    dist_mat = distance_matrix\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = demand[candidates] <= cap\n    feasible = candidates[feasible_mask]\n\n    if feasible.size == 0:\n        return depot\n\n    # Step count\n    step = dist_mat.shape[0] - candidates.size\n\n    # Squared distances, clipped\n    dists_sq = np.square(dist_mat[current_node, feasible])\n    dists_sq = np.clip(dists_sq, 1e-12, None)\n\n    # Inverse distances with epsilon\n    inv_dists = 1.0 / (np.sqrt(dists_sq) + 1e-12)\n\n    # Invert conditional: farthest on even steps, nearest on odd\n    if step % 2 == 0:\n        idx = np.argmin(inv_dists)  # farthest corresponds to smallest inverse\n    else:\n        idx = np.argmax(inv_dists)  # nearest corresponds to largest inverse\n\n    return int(feasible[idx])\n\n",
  "regret_insertion_aug_38": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cand = unvisited_nodes\n    dist_mat = distance_matrix\n    cap = rest_capacity\n    dem = demands\n\n    if cand.size == 0:\n        return depot\n\n    # feasible nodes\n    feas_mask = dem[cand] <= cap\n    feas = cand[feas_mask]\n    if feas.size == 0:\n        return depot\n    if feas.size == 1:\n        return int(feas[0])\n\n    # distances from current node\n    dists = dist_mat[current_node, feas]\n    # deterministic tie\u2011breaking noise\n    noise = 1e-6 * feas\n    dists_noisy = dists + np.clip(noise, -1e-6, 1e-6)\n\n    # choose furthest node (max distance)\n    idx_max = np.argmax(dists_noisy)\n    return int(feas[idx_max])\n\n",
  "regret_insertion_aug_39": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cand = unvisited_nodes\n    dist_mat = distance_matrix\n    cap = rest_capacity\n    dem = demands\n\n    if cand.size == 0:\n        return depot\n\n    feas_mask = dem[cand] <= cap\n    feas = cand[feas_mask]\n    if feas.size == 0:\n        return depot\n    if feas.size == 1:\n        return int(feas[0])\n\n    dists = dist_mat[current_node, feas]\n    median_dist = np.median(dists)\n    diff = np.abs(dists - median_dist)\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * feas\n    diff_noisy = diff + np.clip(noise, -1e-6, 1e-6)\n\n    idx = np.argmax(diff_noisy)\n    return int(feas[idx])\n\n",
  "regret_insertion_aug_40": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cand = unvisited_nodes\n    dist_mat = distance_matrix\n    cap = rest_capacity\n    dem = demands\n\n    if cand.size == 0:\n        return depot\n\n    feas_mask = dem[cand] <= cap\n    feas = cand[feas_mask]\n    if feas.size == 0:\n        return depot\n    if feas.size == 1:\n        return int(feas[0])\n\n    # squared distances for a proxy approximation\n    dists_sq = np.square(dist_mat[current_node, feas])\n    sorted_idx = np.argsort(dists_sq)\n    sorted_nodes = feas[sorted_idx]\n    sorted_dists = dists_sq[sorted_idx]\n\n    if sorted_dists.size < 2:\n        return int(sorted_nodes[0])\n\n    # regret: difference between consecutive sorted distances\n    regrets = sorted_dists[1:] - sorted_dists[:-1]\n    max_reg_idx = np.argmax(regrets)\n    # node corresponding to the larger distance in the pair with max regret\n    chosen = sorted_nodes[max_reg_idx + 1]\n    return int(chosen)\n\n",
  "sweep_algorithm_aug_41": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Variable renaming\n    cand = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n    dist = distance_matrix\n    eps = 1e-12\n\n    if cand.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = cand[dem[cand] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    # Distances\n    d_cur = dist[current_node, feasible]\n    d_dep = dist[depot, feasible]\n\n    # Softmin scoring\n    scores = d_cur + 0.5 * d_dep\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(feasible.size) * 1e-6\n    scores += noise\n\n    # Convert to probabilities and pick the most probable node\n    probs = np.exp(-scores)\n    probs /= probs.sum() + eps\n    chosen = feasible[np.argmax(probs)]\n    return int(chosen)\n\n",
  "sweep_algorithm_aug_42": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Variable renaming\n    candidates = unvisited_nodes\n    capacity = rest_capacity\n    demand = demands\n    dist_mat = distance_matrix\n    eps = 1e-12\n\n    if candidates.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible_idx = candidates[demand[candidates] <= capacity]\n    if feasible_idx.size == 0:\n        return depot\n\n    # Distances\n    d_cur = dist_mat[current_node, feasible_idx]\n    d_dep = dist_mat[depot, feasible_idx]\n\n    # Weighted scoring\n    scores = 0.6 * d_cur + 0.4 * d_dep\n    scores = np.clip(scores, 0, 1e9)\n\n    # Top\u2011k selection\n    top_k = min(7, scores.size)\n    top_indices = np.argpartition(scores, -top_k)[-top_k:]\n    chosen = feasible_idx[top_indices[np.random.choice(top_k)]]\n    return int(chosen)\n\n",
  "sweep_algorithm_aug_43": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Variable renaming\n    nodes = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n    dist = distance_matrix\n    eps = 1e-12\n\n    if nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = nodes[dem[nodes] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    # Distances\n    d_cur_feas = dist[current_node, feasible]\n    d_dep_feas = dist[depot, feasible]\n\n    # Mean scoring\n    mean_score = (d_cur_feas + d_dep_feas) / 2.0\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.linspace(-1e-6, 1e-6, feasible.size)\n    mean_score += noise\n\n    # Pick node with minimal mean score\n    chosen = feasible[np.argmin(mean_score)]\n    return int(chosen)\n\n",
  "sweep_algorithm_aug_44": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Variable renaming\n    cand = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n    dist = distance_matrix\n    eps = 1e-12\n\n    if cand.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = cand[dem[cand] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    # Compute scores iteratively\n    scores = np.empty(feasible.size)\n    for i, node in enumerate(feasible):\n        scores[i] = dist[current_node, node] + dist[depot, node]\n\n    # Use np.max (invert the usual minimization)\n    max_score = np.max(scores)\n    # Find all nodes achieving the max score\n    indices = np.where(np.isclose(scores, max_score, atol=eps))[0]\n    # Randomly choose one of them\n    chosen = feasible[np.random.choice(indices)]\n    return int(chosen)\n\n",
  "balanced_route_length_aug_45": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename for readability\n    dist_mat   = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap   = rest_capacity\n    dem        = demands\n\n    if candidates.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible_mask = dem[candidates] <= rest_cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    # Capacity remaining ratio, clipped between 0 and 1\n    denom = np.sum(dem[feasible]) + 1e-12\n    ratio = np.clip(rest_cap / denom, 0, 1)\n\n    d_current  = dist_mat[current_node, feasible]\n    d_to_depot = dist_mat[feasible, depot]\n\n    # Score definition\n    if ratio > 0.5:\n        score = d_current + 0.3 * d_to_depot\n    else:\n        score = d_current + 0.8 * d_to_depot\n\n    # Deterministic noise to break ties\n    noise = 1e-6 * feasible\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "balanced_route_length_aug_46": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap   = rest_capacity\n    dem        = demands\n\n    if candidates.size == 0:\n        return depot\n\n    # Build feasible list with a while loop\n    feasible = []\n    idx = 0\n    while idx < candidates.size:\n        node = candidates[idx]\n        if dem[node] <= rest_cap:\n            feasible.append(node)\n        idx += 1\n    if not feasible:\n        return depot\n    feasible = np.array(feasible)\n\n    # Mean\u2011based capacity ratio, clipped\n    denom = np.mean(dem[feasible]) + 1e-12\n    ratio = np.clip(rest_cap / denom, 0, 1)\n\n    d_current  = dist_mat[current_node, feasible]\n    d_to_depot = dist_mat[feasible, depot]\n\n    # Score with different weights\n    if ratio > 0.6:\n        score = d_current + 0.4 * d_to_depot\n    else:\n        score = d_current + 0.7 * d_to_depot\n\n    # Deterministic noise\n    noise = 1e-6 * np.arange(feasible.size)\n    score += noise\n\n    # Top\u2011k selection\n    top_k = 5\n    if feasible.size <= top_k:\n        chosen_idx = np.argmin(score)\n    else:\n        top_indices = np.argpartition(score, top_k)[:top_k]\n        rng = np.random.default_rng(42)\n        chosen_idx = rng.choice(top_indices)\n\n    return int(feasible[chosen_idx])\n\n",
  "balanced_route_length_aug_47": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap   = rest_capacity\n    dem        = demands\n\n    if candidates.size == 0:\n        return depot\n\n    # Feasible nodes via list comprehension\n    feasible = np.array([node for node in candidates if dem[node] <= rest_cap])\n    if feasible.size == 0:\n        return depot\n\n    # Median\u2011based ratio, clipped\n    denom = np.median(dem[feasible]) + 1e-12\n    ratio = np.clip(rest_cap / denom, 0, 1)\n\n    d_current  = dist_mat[current_node, feasible]\n    d_to_depot = dist_mat[feasible, depot]\n\n    # Weighted score\n    if ratio > 0.5:\n        score = 0.6 * d_current + 0.4 * d_to_depot\n    else:\n        score = 0.9 * d_current + 0.1 * d_to_depot\n\n    # Deterministic noise\n    noise = 1e-6 * feasible\n    score += noise\n\n    # Softmin with temperature\n    temp = 1.0\n    soft_min = np.exp(-score / temp)\n    # Randomly pick among the 7 lowest scores\n    top_k = 7\n    if feasible.size <= top_k:\n        chosen_idx = np.argmax(soft_min)\n    else:\n        top_indices = np.argpartition(-soft_min, top_k)[:top_k]\n        rng = np.random.default_rng(123)\n        chosen_idx = rng.choice(top_indices)\n\n    return int(feasible[chosen_idx])\n\n",
  "balanced_route_length_aug_48": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap   = rest_capacity\n    dem        = demands\n\n    if candidates.size == 0:\n        return depot\n\n    # Feasible nodes via while loop\n    feasible = []\n    idx = 0\n    while idx < candidates.size:\n        node = candidates[idx]\n        if dem[node] <= rest_cap:\n            feasible.append(node)\n        idx += 1\n    if not feasible:\n        return depot\n    feasible = np.array(feasible)\n\n    # Max\u2011based ratio, clipped\n    denom = np.max(dem[feasible]) + 1e-12\n    ratio = np.clip(rest_cap / denom, 0, 1)\n\n    # Proxy: use squared distances\n    d_current_sq  = dist_mat[current_node, feasible] ** 2\n    d_to_depot_sq = dist_mat[feasible, depot] ** 2\n\n    # Score with different weights\n    if ratio > 0.4:\n        score = 0.5 * d_current_sq + 0.5 * d_to_depot_sq\n    else:\n        score = 0.8 * d_current_sq + 0.2 * d_to_depot_sq\n\n    # Deterministic noise\n    noise = 1e-6 * feasible\n    score += noise\n\n    # Softmax weighting\n    temp = 0.5\n    weights = np.exp(-score / temp)\n    chosen_idx = np.argmax(weights)\n\n    return int(feasible[chosen_idx])\n\n",
  "demand_urgency_aug_49": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if not unvisited_nodes.size:\n        return depot\n\n    rest_cap = float(rest_capacity)\n\n    # Feasible nodes via list comprehension\n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_cap]\n    if not feasible:\n        return depot\n\n    # Progress using median demands (add epsilon)\n    median_unvisited = np.median(demands[unvisited_nodes]) + 1e-12\n    median_total = np.median(demands) + 1e-12\n    progress = 1.0 - (median_unvisited / median_total)\n\n    # Distances and demands\n    dist = distance_matrix[current_node, feasible]\n    dem = demands[feasible]\n\n    # Weight emphasizing distance as progress increases\n    weight = 0.4 + 0.6 * progress\n    scores = dist + weight * dem  # higher score for larger distance & demand\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(0, 1e-6, size=len(feasible))\n    scores += noise\n\n    # Pick among the top 7 smallest scores\n    top_k = min(7, len(feasible))\n    idx_top = np.argpartition(scores, top_k - 1)[:top_k]\n    top_nodes = [feasible[i] for i in idx_top]\n    top_scores = scores[idx_top]\n    chosen = top_nodes[np.argmin(top_scores)]\n    return int(chosen)\n\n",
  "demand_urgency_aug_50": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    rest_cap = float(rest_capacity)\n\n    # Feasible nodes\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_cap]\n    if feasible.size == 0:\n        return depot\n\n    # Progress using mean demand (add epsilon)\n    mean_unvisited = np.mean(demands[unvisited_nodes]) + 1e-12\n    mean_total = np.mean(demands) + 1e-12\n    progress = 1.0 - (mean_unvisited / mean_total)\n\n    # Distances (clip) and demands\n    dist = np.clip(distance_matrix[current_node, feasible], 0, 1e6)\n    dem = demands[feasible]\n\n    # Weight scaling: more emphasis on distance early\n    weight = 0.7 * (1.0 - progress) + 0.3\n    scores = dist * weight + dem\n\n    # Small random noise for tie\u2011breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=feasible.size)\n    scores += noise\n\n    # Choose node with smallest score; break ties randomly\n    min_score = np.min(scores)\n    candidates = feasible[np.where(np.isclose(scores, min_score, atol=1e-8))[0]]\n    chosen = np.random.choice(candidates)\n    return int(chosen)\n\n",
  "random_feasible_aug_51": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes: demand <= rest_capacity\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Distances from the current node\n    dists = distance_matrix[current_node, feasible]\n\n    # Capacity ratio, clipped to [0, 1]\n    ratio = np.clip(demands[feasible] / (rest_capacity + 1e-12), 0, 1)\n\n    # Weighted score (distance + capacity usage)\n    score = 0.6 * dists + 0.4 * ratio\n\n    # Deterministic noise based on node ids\n    rng_seed = int((current_node * 73856093) ^ (feasible.sum() * 19349663))\n    rng = np.random.default_rng(rng_seed % (2**32))\n    noise = rng.random(feasible.size) * 1e-6\n    score += noise\n\n    # Choose node with minimal score\n    idx = np.argmin(score)\n    return int(feasible[idx])\n\n",
  "random_feasible_aug_52": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    dists = distance_matrix[current_node, feasible]\n\n    # Take the k nearest feasible nodes\n    top_k = 7\n    if feasible.size <= top_k:\n        top_indices = np.arange(feasible.size)\n    else:\n        top_indices = np.argpartition(dists, top_k - 1)[:top_k]\n    top_nodes = feasible[top_indices]\n    top_dists = dists[top_indices]\n\n    # Softmin probabilities\n    alpha = 5.0\n    exp_vals = np.exp(-alpha * top_dists)\n    probs = exp_vals / (exp_vals.sum() + 1e-12)\n\n    # Deterministic selection using RNG seeded by current node\n    rng = np.random.default_rng((current_node * 19349663) % (2**32))\n    chosen = rng.choice(top_nodes, p=probs)\n    return int(chosen)\n\n",
  "random_feasible_aug_53": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    dists = distance_matrix[current_node, feasible]\n    median_dist = np.median(dists)\n\n    # Keep nodes within the median distance\n    mask = dists <= median_dist\n    if not mask.any():\n        mask = np.ones_like(dists, dtype=bool)\n\n    candidate_nodes = feasible[mask]\n    candidate_dists = dists[mask]\n\n    # Deterministic noise for tie\u2011breaking\n    noise = ((candidate_nodes * 9876543) ^ current_node) % 1000 * 1e-9\n    candidate_dists += noise\n\n    idx = np.argmax(candidate_dists)\n    return int(candidate_nodes[idx])\n\n",
  "random_feasible_aug_54": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Build feasible list using a while loop\n    feasible = []\n    i = 0\n    while i < unvisited_nodes.size:\n        node = unvisited_nodes[i]\n        if demands[node] <= rest_capacity:\n            feasible.append(node)\n        i += 1\n    feasible = np.array(feasible, dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    # Distances from the current node\n    dists = distance_matrix[current_node, feasible]\n    dists = np.clip(dists, 0, np.inf)\n\n    # Top\u2011k nearest nodes\n    top_k = 5\n    if feasible.size <= top_k:\n        top_indices = np.arange(feasible.size)\n    else:\n        top_indices = np.argpartition(dists, top_k - 1)[:top_k]\n    top_nodes = feasible[top_indices]\n\n    # Deterministic random choice among the top\u2011k\n    rng = np.random.default_rng((current_node * 1234567) % (2**32))\n    chosen = rng.choice(top_nodes)\n    return int(chosen)\n\n",
  "min_max_distance_aug_55": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Build feasible list with a while loop\n    feasible = []\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = unvisited_nodes[idx]\n        if demands[node] <= rest_capacity:\n            feasible.append(node)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    # Max distance from each feasible node to the remaining unvisited nodes\n    max_dists = np.max(distance_matrix[np.ix_(feasible, unvisited_nodes)], axis=1)\n\n    # Inverse distance score with epsilon and a tiny noise for deterministic tie\u2011breaking\n    eps = 1e-12\n    scores = 1.0 / (max_dists + eps) + np.random.rand(len(feasible)) * 1e-8\n    scores = np.clip(scores, 0, np.inf)\n\n    best_idx = int(np.argmax(scores))\n    return int(feasible[best_idx])\n\n",
  "min_max_distance_aug_56": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes via boolean mask\n    feasible_mask = demands[unvisited_nodes] <= rest_capacity\n    feasible = unvisited_nodes[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    # Weighted score: 0.6 * max distance + 0.4 * 1/(demand+eps)\n    eps = 1e-12\n    dist_to_feasible = distance_matrix[feasible[:, None], unvisited_nodes[None, :]]\n    max_dists = np.max(dist_to_feasible, axis=1)\n    inv_demands = 1.0 / (demands[feasible] + eps)\n    scores = 0.6 * max_dists + 0.4 * inv_demands\n    scores = np.clip(scores, 0, np.inf)\n\n    # Randomly pick among the best 7 (or fewer) nodes\n    top_k = min(7, scores.size)\n    top_indices = np.argpartition(scores, top_k - 1)[:top_k]\n    chosen = np.random.choice(feasible[top_indices])\n    return int(chosen)\n\n",
  "min_max_distance_aug_57": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Max distance to remaining nodes\n    max_dists = np.max(distance_matrix[np.ix_(feasible, unvisited_nodes)], axis=1)\n\n    eps = 1e-12\n    alpha = 5.0\n    exp_vals = np.exp(-alpha * max_dists)\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n    probs = np.clip(probs, 0, 1)\n\n    chosen = np.random.choice(feasible, p=probs)\n    return int(chosen)\n\n",
  "min_max_distance_aug_58": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Build feasible list with a while loop\n    feasible = []\n    i = 0\n    while i < unvisited_nodes.size:\n        node = unvisited_nodes[i]\n        if demands[node] <= rest_capacity:\n            feasible.append(node)\n        i += 1\n\n    if not feasible:\n        return depot\n\n    # Median distance from each feasible node to all unvisited nodes\n    med_dists = np.median(distance_matrix[np.ix_(feasible, unvisited_nodes)], axis=1)\n\n    eps = 1e-12\n    scores = 1.0 / (med_dists + eps) + np.random.rand(len(feasible)) * 1e-8\n    scores = np.clip(scores, 0, np.inf)\n\n    best_idx = int(np.argmax(scores))\n    return int(feasible[best_idx])\n\n",
  "insertion_cost_aug_59": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cand = unvisited_nodes\n    cap_rem = rest_capacity\n    dist_mat = distance_matrix\n    dem = demands\n\n    # return depot if nothing left to visit\n    if cand.size == 0:\n        return depot\n\n    # filter feasible nodes\n    feas_mask = dem[cand] <= cap_rem\n    feas_nodes = cand[feas_mask]\n    if feas_nodes.size == 0:\n        return depot\n\n    # vectorised distance calculations\n    d_cd = dist_mat[current_node, depot]\n    d_cn = dist_mat[current_node, feas_nodes]\n    d_nd = dist_mat[feas_nodes, depot]\n\n    # add tiny deterministic noise for tie breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=d_cn.shape)\n    ins_cost = d_cn + d_nd - d_cd + noise\n\n    # pick the node with minimal insertion cost\n    idx = np.argmin(ins_cost)\n    return int(feas_nodes[idx])\n\n",
  "insertion_cost_aug_60": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cand = unvisited_nodes\n    cap_rem = rest_capacity\n    dist_mat = distance_matrix\n    dem = demands\n\n    if cand.size == 0:\n        return depot\n\n    # feasible nodes\n    feas_mask = dem[cand] <= cap_rem\n    feas_nodes = cand[feas_mask]\n    if feas_nodes.size == 0:\n        return depot\n\n    # distances\n    d_cd = dist_mat[current_node, depot]\n    d_cn = dist_mat[current_node, feas_nodes]\n    d_nd = dist_mat[feas_nodes, depot]\n\n    # weighted scoring (parameter tuning)\n    w1, w2, w3 = 0.6, 0.4, 1.0\n    score = w1 * d_cn + w2 * d_nd - w3 * d_cd\n\n    # deterministic noise for tie breaking\n    rng = np.random.default_rng(seed=42)\n    noise = rng.uniform(-1e-7, 1e-7, size=score.shape)\n    score += noise\n\n    # top\u2011k selection\n    top_k = 7\n    if feas_nodes.size <= top_k:\n        candidates_idx = np.arange(feas_nodes.size)\n    else:\n        candidates_idx = np.argpartition(score, top_k)[:top_k]\n    chosen = rng.choice(candidates_idx)\n    return int(feas_nodes[chosen])\n\n",
  "insertion_cost_aug_61": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cand = unvisited_nodes\n    cap_rem = rest_capacity\n    dist_mat = distance_matrix\n    dem = demands\n\n    if cand.size == 0:\n        return depot\n\n    # feasible nodes\n    feas_mask = dem[cand] <= cap_rem\n    feas_nodes = cand[feas_mask]\n    if feas_nodes.size == 0:\n        return depot\n\n    # distances\n    d_cd = dist_mat[current_node, depot]\n    d_cn = dist_mat[current_node, feas_nodes]\n    d_nd = dist_mat[feas_nodes, depot]\n\n    # insertion cost\n    cost = d_cn + d_nd - d_cd\n\n    # soft\u2011min sampling (semantic diversity)\n    temp = 1.0\n    probs = np.exp(-cost / (temp + 1e-12))\n    probs /= np.sum(probs + 1e-12)          # epsilon to avoid div\u2011by\u2011zero\n\n    rng = np.random.default_rng()\n    chosen_idx = rng.choice(feas_nodes.size, p=probs)\n    return int(feas_nodes[chosen_idx])\n\n",
  "insertion_cost_aug_62": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    nodes = unvisited_nodes\n    cap = rest_capacity\n    dist = distance_matrix\n    req = demands\n\n    if nodes.size == 0:\n        return depot\n\n    # build feasible list with a while loop (structural rewrite)\n    feas = []\n    i = 0\n    while i < nodes.size:\n        n = nodes[i]\n        if req[n] <= cap:\n            feas.append(n)\n        i += 1\n    if not feas:\n        return depot\n    feas = np.array(feas)\n\n    # distance calculations\n    d_cd = dist[current_node, depot]\n    d_cn = dist[current_node, feas]\n    d_nd = dist[feas, depot]\n\n    # deterministic noise and clipping\n    rng = np.random.default_rng(seed=123)\n    noise = rng.normal(scale=1e-6, size=d_cn.shape)\n    ins = d_cn + d_nd - d_cd + noise\n    ins_clipped = np.clip(ins, 0, np.max(ins) + 1e-3)   # bounds with np.clip\n\n    idx = np.argmin(ins_clipped)\n    return int(feas[idx])\n\n",
  "diversity_maximizer_aug_63": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Vectorised feasibility test\n    feas_mask = demands[unvisited_nodes] <= rest_capacity\n    feasible = unvisited_nodes[feas_mask]\n    if feasible.size == 0:\n        return depot\n\n    # Renamed variables for clarity\n    dist_mat = distance_matrix\n    d_depot = dist_mat[depot, feasible]\n    d_curr  = dist_mat[current_node, feasible]\n\n    # Diversity score (tuned weight)\n    div = np.abs(d_depot - d_curr)\n    scores = d_curr - 0.6 * div\n\n    # Add deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(0, 1e-6, size=scores.shape)\n    scores += noise\n\n    # Soft\u2011min probabilities with epsilon to avoid division by zero\n    exp_neg = np.exp(-scores)\n    probs = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n    # Random choice weighted by soft\u2011min probabilities\n    chosen = np.random.choice(feasible, p=probs)\n    return int(chosen)\n\n",
  "diversity_maximizer_aug_64": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # Build feasible list with a while loop\n    feasible = []\n    idx = 0\n    while idx < len(unvisited_nodes):\n        node = unvisited_nodes[idx]\n        if demands[node] <= rest_capacity:\n            feasible.append(node)\n        idx += 1\n    feasible = np.array(feasible, dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    d_depot = dist_mat[depot, feasible]\n    d_curr  = dist_mat[current_node, feasible]\n\n    # Diversity with a different weight\n    div = np.abs(d_depot - d_curr)\n    scores = d_curr + 0.4 * div\n\n    # Top\u2011k selection (k=7)\n    top_k = min(7, scores.size)\n    partition_idx = np.argpartition(scores, top_k - 1)[:top_k]\n    top_scores = scores[partition_idx]\n    top_nodes  = feasible[partition_idx]\n\n    # Choose the minimal score among the top\u2011k\n    min_idx = np.argmin(top_scores)\n    chosen = top_nodes[min_idx]\n    return int(chosen)\n\n",
  "diversity_maximizer_aug_65": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes via vectorised mask\n    feas_mask = demands[unvisited_nodes] <= rest_capacity\n    feasible = unvisited_nodes[feas_mask]\n    if feasible.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    d_depot = dist_mat[depot, feasible]\n    d_curr  = dist_mat[current_node, feasible]\n\n    # Proxy diversity: mean distance from depot minus current distance\n    div = np.mean(d_depot) - d_curr\n    scores = d_curr * 0.7 - div * 0.3\n\n    # Deterministic tie\u2011break using np.argsort\n    sorted_idx = np.argsort(scores)\n    chosen = feasible[sorted_idx[0]]\n    return int(chosen)\n\n",
  "diversity_maximizer_aug_66": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # List comprehension for feasibility (inverted logic)\n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    feasible = np.array(feasible, dtype=int)\n\n    dist_mat = distance_matrix\n    d_depot = dist_mat[depot, feasible]\n    d_curr  = dist_mat[current_node, feasible]\n\n    # Diversity and score (different weight)\n    div = np.abs(d_depot - d_curr)\n    scores = d_curr - 0.5 * div\n\n    # Softmax with temperature (temp=0.5)\n    temp = 0.5\n    exp_vals = np.exp(scores / temp)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # Clip probabilities to [0,1] just in case\n    probs = np.clip(probs, 0, 1)\n\n    # Randomly choose from top\u2011k (k=5)\n    top_k = min(5, scores.size)\n    top_idx = np.argsort(probs)[-top_k:]\n    chosen = np.random.choice(feasible[top_idx], p=probs[top_idx] / (np.sum(probs[top_idx]) + 1e-12))\n    return int(chosen)\n\n",
  "capacity_aware_nearest_aug_67": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Distances and demands\n    dists = distance_matrix[current_node, feasible]\n    reqs = demands[feasible]\n\n    # Capacity factor\n    max_dem = np.max(demands) + 1e-12\n    cap_factor = np.clip(rest_capacity / max_dem, 0.0, 1.0)\n\n    # Weighted score\n    penalty = (1.0 - cap_factor) * reqs\n    scores = 0.7 * dists + 0.3 * penalty\n\n    # Top\u2011k (k=7) selection\n    k = 7\n    if feasible.size < k:\n        k = feasible.size\n    top_k_idx = np.argpartition(scores, k - 1)[:k]\n\n    # Random choice among the best k candidates\n    chosen_idx = np.random.choice(top_k_idx)\n    return int(feasible[chosen_idx])\n\n",
  "capacity_aware_nearest_aug_68": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    dists = distance_matrix[current_node, feasible]\n    reqs = demands[feasible]\n\n    # Median demand for scaling\n    median_demand = np.median(reqs) + 1e-12\n    cap_factor = np.clip(rest_capacity / (median_demand + 1e-12), 0.0, 1.0)\n\n    penalty = (1.0 - cap_factor) * reqs\n\n    # Scale penalty inversely with distance using the maximum distance\n    max_dist = np.max(dists) + 1e-12\n    scaled_penalty = penalty * (max_dist - dists) / max_dist\n\n    scores = dists + scaled_penalty\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(feasible.size) * 1e-9\n    min_idx = np.argmin(scores + noise)\n    return int(feasible[min_idx])\n\n",
  "capacity_aware_nearest_aug_69": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Squared distance as a proxy for travel cost\n    dists = np.square(distance_matrix[current_node, feasible])\n\n    # Sum of distances from each candidate to all other feasible nodes\n    sub_mat = distance_matrix[np.ix_(feasible, feasible)]\n    sum_to_others = np.sum(sub_mat, axis=1)\n\n    # Capacity factor based on total demand of feasible set\n    total_demand = np.sum(demands[feasible]) + 1e-12\n    cap_factor = np.clip(rest_capacity / total_demand, 0.0, 1.0)\n\n    penalty = (1.0 - cap_factor) * sum_to_others\n\n    # Balanced score\n    scores = 0.5 * dists + 0.5 * penalty\n\n    # Select the candidate with minimal score\n    min_idx = np.argmin(scores)\n    return int(feasible[min_idx])\n\n",
  "composite_five_factor_aug_70": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename variables for clarity\n    curr, dep, nodes, rem_cap, dem, dist = (\n        current_node, depot, unvisited_nodes,\n        rest_capacity, demands, distance_matrix\n    )\n\n    # Return depot if no candidates remain\n    if len(nodes) == 0:\n        return dep\n\n    # Feasible nodes: demand <= remaining capacity\n    feasible_mask = dem[nodes] <= rem_cap\n    if not np.any(feasible_mask):\n        return dep\n    feasible_idx = nodes[feasible_mask]\n\n    # Distance from current node and from depot\n    d_curr = dist[curr, feasible_idx]\n    d_dep = dist[dep, feasible_idx]\n\n    # Demand values of feasible nodes\n    demand_vals = dem[feasible_idx]\n\n    # Capacity utilization ratio (clipped to [0, 1])\n    cap_util = np.clip(demand_vals / (rem_cap + 1e-12), 0.0, 1.0)\n\n    # Mean distance from each feasible node to all unvisited nodes\n    mean_dist = dist[np.ix_(feasible_idx, nodes)].mean(axis=1)\n\n    # Normalisation helper\n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-12)\n\n    # Weighted score components\n    score = (\n        0.30 * norm(d_curr) +\n        0.20 * norm(d_dep) -\n        0.20 * norm(demand_vals) +\n        0.15 * norm(cap_util) +\n        0.15 * norm(mean_dist)\n    )\n\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(len(feasible_idx))\n    score += noise\n\n    # Select node with minimal score\n    return int(feasible_idx[np.argmin(score)])\n\n",
  "composite_five_factor_aug_71": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Variable renaming\n    cur, dep, nodes, cap, dem, dist = (\n        current_node, depot, unvisited_nodes,\n        rest_capacity, demands, distance_matrix\n    )\n\n    # Feasible nodes: demand <= remaining capacity\n    feasible = [node for node in nodes if dem[node] <= cap]\n    if not feasible:\n        return dep\n\n    f_arr = np.array(feasible, dtype=int)\n\n    d_cur = dist[cur, f_arr]\n    d_dep = dist[dep, f_arr]\n    demand_vals = dem[f_arr]\n    cap_util = np.clip(demand_vals / (cap + 1e-12), 0.0, 1.0)\n\n    # Median distance to all unvisited nodes\n    mean_dist = dist[np.ix_(f_arr, nodes)].median(axis=1)\n\n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-12)\n\n    # Tuned weights\n    score = (\n        0.50 * norm(d_cur) +\n        0.30 * norm(d_dep) -\n        0.10 * norm(demand_vals) +\n        0.05 * norm(cap_util) +\n        0.05 * norm(mean_dist)\n    )\n\n    # Deterministic noise for reproducibility\n    noise = 1e-7 * np.arange(len(f_arr))\n    score += noise\n\n    # Soft\u2011min probabilities\n    temp = 0.1\n    probs = np.exp(-score / temp)\n    probs /= probs.sum()\n\n    # Random choice among top\u2011k (k=7)\n    top_k = 7\n    top_idx = np.argsort(score)[:min(top_k, len(score))]\n    chosen = np.random.choice(\n        top_idx,\n        p=probs[top_idx] / probs[top_idx].sum()\n    )\n\n    return int(f_arr[chosen])\n\n",
  "composite_five_factor_aug_72": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur, dep, nodes, cap, dem, dist = (\n        current_node, depot, unvisited_nodes,\n        rest_capacity, demands, distance_matrix\n    )\n\n    # Build feasible list with a while\u2011style loop\n    feasible = []\n    for node in nodes:\n        if dem[node] <= cap:\n            feasible.append(node)\n    if not feasible:\n        return dep\n\n    f_arr = np.array(feasible, dtype=int)\n\n    d_cur = dist[cur, f_arr]\n    d_dep = dist[dep, f_arr]\n    demand_vals = dem[f_arr]\n    cap_util = np.clip(demand_vals / (cap + 1e-12), 0.0, 1.0)\n\n    # Median distance to all unvisited nodes\n    mean_dist = dist[np.ix_(f_arr, nodes)].median(axis=1)\n\n    # Cluster centrality: maximum distance to any unvisited node\n    max_dist = dist[np.ix_(f_arr, nodes)].max(axis=1)\n\n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-12)\n\n    # Weighted score\n    score = (\n        0.40 * norm(d_cur) +\n        0.30 * norm(d_dep) -\n        0.20 * norm(demand_vals) +\n        0.05 * norm(cap_util) +\n        0.05 * norm(mean_dist) +\n        0.05 * norm(max_dist)\n    )\n\n    # Deterministic noise\n    noise = 1e-6 * np.arange(len(f_arr))\n    score += noise\n\n    # Soft\u2011min probabilities\n    temp = 0.05\n    probs = np.exp(-score / temp)\n    probs /= probs.sum()\n\n    # Random choice among top\u2011k (k=5)\n    top_k = 5\n    top_idx = np.argsort(score)[:min(top_k, len(score))]\n    chosen = np.random.choice(\n        top_idx,\n        p=probs[top_idx] / probs[top_idx].sum()\n    )\n\n    return int(f_arr[chosen])\n\n",
  "composite_five_factor_aug_73": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Renamed variables\n    cur, dep, nodes, cap, dem, mat = (\n        current_node, depot, unvisited_nodes,\n        rest_capacity, demands, distance_matrix\n    )\n\n    # Feasible nodes via a simple loop\n    feasible = []\n    for node in nodes:\n        if dem[node] <= cap:\n            feasible.append(node)\n    if len(feasible) == 0:\n        return dep\n\n    f_arr = np.array(feasible, dtype=int)\n\n    d_cur = mat[cur, f_arr]\n    d_dep = mat[dep, f_arr]\n    demand_vals = dem[f_arr]\n    cap_util = np.clip(demand_vals / (cap + 1e-12), 0.0, 1.0)\n\n    # Mean distance to all unvisited nodes\n    mean_dist = mat[np.ix_(f_arr, nodes)].mean(axis=1)\n\n    # Cluster centrality approximated by sum of distances\n    centrality = mat[np.ix_(f_arr, nodes)].sum(axis=1)\n\n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-12)\n\n    # Tuned weight vector\n    score = (\n        0.35 * norm(d_cur) +\n        0.25 * norm(d_dep) -\n        0.15 * norm(demand_vals) +\n        0.10 * norm(cap_util) +\n        0.10 * norm(mean_dist) +\n        0.05 * norm(centrality)\n    )\n\n    # Deterministic noise to break ties\n    noise = 1e-7 * np.arange(len(f_arr))\n    score += noise\n\n    return int(f_arr[np.argmin(score)])\n\n",
  "route_compactness_aug_74": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename for clarity\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    remaining_cap = rest_capacity\n    loads = demands\n\n    if candidates.size == 0:\n        return depot\n\n    # Build feasible list with a while loop\n    feasible = []\n    idx = 0\n    while idx < candidates.size:\n        node = candidates[idx]\n        if loads[node] <= remaining_cap:\n            feasible.append(node)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    # Vectorised distance calculations\n    feasible = np.array(feasible, dtype=int)\n    distances_to_all = dist_mat[feasible, :]\n    # Use variance as compactness measure, clip to avoid extreme values\n    variance = np.var(distances_to_all, axis=1)\n    variance = np.clip(variance, 0, 1e6)\n\n    d_current = dist_mat[current_node, feasible]\n    d_current = np.clip(d_current, 0, 1e6)\n\n    # Small deterministic noise for stable tie\u2011breaking\n    noise = np.random.uniform(0, 1e-6, size=d_current.shape)\n\n    # Weighted score: 60% distance + 40% variance\n    scores = 0.6 * d_current + 0.4 * variance + noise\n    scores = np.clip(scores, 0, 1e12)\n\n    chosen_index = int(np.argmin(scores))\n    return int(feasible[chosen_index])\n\n",
  "route_compactness_aug_75": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Variable renaming\n    dist = distance_matrix\n    nodes = unvisited_nodes\n    cap_left = rest_capacity\n    dem = demands\n\n    if nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    mask = dem[nodes] <= cap_left\n    feasible = nodes[mask]\n    if feasible.size == 0:\n        return depot\n\n    # Compute scores\n    fea = feasible.astype(int)\n    dists_to_all = dist[fea, :]\n    spread = np.max(dists_to_all, axis=1)  # proxy for spread\n    d_current = dist[current_node, fea]\n\n    # Weighting constants (tuned)\n    w_dist = np.clip(0.4, 0, 1)\n    w_spread = np.clip(0.6, 0, 1)\n\n    scores = w_dist * d_current + w_spread * spread\n    scores = np.clip(scores, 0, 1e12)\n\n    # Keep top\u2011k smallest scores\n    top_k = 7\n    if feasible.size > top_k:\n        idx_top = np.argpartition(scores, top_k)[:top_k]\n        scores = scores[idx_top]\n        feasible = feasible[idx_top]\n\n    # Soft\u2011min selection\n    alpha = 10.0\n    exp_vals = np.exp(-alpha * scores)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)  # epsilon to avoid div by zero\n    chosen = np.random.choice(feasible, p=probs)\n\n    return int(chosen)\n\n",
  "route_compactness_aug_76": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Renamed variables\n    dmat = distance_matrix\n    cand = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n\n    if cand.size == 0:\n        return depot\n\n    # Feasible nodes using a list comprehension\n    feasible = [c for c in cand if dem[c] <= cap]\n    if not feasible:\n        return depot\n\n    fea = np.array(feasible, dtype=int)\n\n    # Distance computations\n    dists_all = dmat[fea, :]\n    # Median as a robust compactness measure\n    med = np.median(dists_all, axis=1)\n    med = np.clip(med, 0, 1e6)\n\n    d_curr = dmat[current_node, fea]\n    d_curr = np.clip(d_curr, 0, 1e6)\n\n    # Score: 50% distance + 50% median spread\n    scores = 0.5 * d_curr + 0.5 * med\n\n    # Add deterministic tie\u2011breaking noise\n    noise = np.random.uniform(0, 1e-7, size=scores.shape)\n    scores += noise\n    scores = np.clip(scores, 0, 1e12)\n\n    idx = int(np.argmin(scores))\n    return int(fea[idx])\n\n",
  "route_compactness_aug_77": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Variable names\n    mat = distance_matrix\n    nodes = unvisited_nodes\n    remaining = rest_capacity\n    loads = demands\n\n    if nodes.size == 0:\n        return depot\n\n    # Feasible nodes via while loop\n    feasible = []\n    i = 0\n    while i < nodes.size:\n        n = nodes[i]\n        if loads[n] <= remaining:\n            feasible.append(n)\n        i += 1\n\n    if not feasible:\n        return depot\n\n    fea = np.array(feasible, dtype=int)\n\n    # Approximate spread with mean absolute deviation\n    dists_all = mat[fea, :]\n    mean_vals = np.mean(dists_all, axis=1, keepdims=True)\n    mad = np.mean(np.abs(dists_all - mean_vals), axis=1)\n    mad = np.clip(mad, 0, 1e6)\n\n    d_curr = mat[current_node, fea]\n    d_curr = np.clip(d_curr, 0, 1e6)\n\n    # Weighted score: 70% distance + 30% MAD\n    scores = 0.7 * d_curr + 0.3 * mad\n    scores = np.clip(scores, 0, 1e12)\n\n    # Random choice among top\u20115 smallest scores\n    top_k = 5\n    if fea.size > top_k:\n        idx_top = np.argpartition(scores, top_k)[:top_k]\n        scores = scores[idx_top]\n        fea = fea[idx_top]\n\n    chosen = np.random.choice(fea)\n    return int(chosen)\n\n",
  "adaptive_threshold_aug_78": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    remaining_cap = rest_capacity\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    # Build a mask of feasible nodes\n    feasible_mask = demands[candidates] <= remaining_cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    # Distances from the current node\n    distances = distance_matrix[current_node, feasible]\n    median_dist = np.median(distances)\n\n    # Capacity ratio with epsilon to avoid division by zero\n    capacity_ratio = remaining_cap / (np.sum(demands[feasible]) + 1e-12)\n    capacity_ratio = np.clip(capacity_ratio, 0.0, 1.0)\n\n    # Tuned threshold multiplier\n    threshold = median_dist * (0.4 + 0.6 * capacity_ratio)\n    threshold = np.clip(threshold, 0.0, np.max(distances))\n\n    close_idx = np.where(distances <= threshold)[0]\n    if close_idx.size > 0:\n        # Break ties by adding a tiny deterministic noise to demands\n        noise = 1e-9 * feasible[close_idx]\n        chosen = feasible[close_idx][np.argmin(demands[feasible[close_idx]] + noise)]\n    else:\n        noise = 1e-9 * feasible\n        chosen = feasible[np.argmin(distances + noise)]\n\n    return int(chosen)\n\n",
  "adaptive_threshold_aug_79": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes via list comprehension\n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n\n    distances = distance_matrix[current_node, feasible]\n    mean_dist = np.mean(distances)\n\n    # Capacity ratio with epsilon\n    capacity_ratio = rest_capacity / (np.sum(demands[feasible]) + 1e-12)\n    capacity_ratio = np.clip(capacity_ratio, 0.0, 1.0)\n\n    # Tuned threshold using mean distance\n    threshold = mean_dist * (0.6 + 0.4 * capacity_ratio)\n    threshold = np.clip(threshold, 0.0, np.max(distances))\n\n    close_idx = np.where(distances <= threshold)[0]\n    if close_idx.size > 0:\n        # Select among the closest nodes: top 5 nearest\n        top_k = 5\n        top_indices = np.argsort(distances[close_idx])[:top_k]\n        candidates = [feasible[close_idx[i]] for i in top_indices]\n        # Deterministic tie\u2011break: smallest demand + tiny noise\n        noise = 1e-9 * np.array(candidates)\n        chosen = candidates[np.argmin(demands[candidates] + noise)]\n    else:\n        # Fallback to the single nearest node with noise\n        noise = 1e-9 * np.array(feasible)\n        chosen = feasible[np.argmin(distances + noise)]\n\n    return int(chosen)\n\n",
  "adaptive_threshold_aug_80": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Boolean mask for feasibility\n    mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(mask):\n        return depot\n    feasible = unvisited_nodes[mask]\n\n    # Distances and soft\u2011min weights\n    distances = distance_matrix[current_node, feasible]\n    # Add tiny noise to distances to make sorting deterministic\n    noise = 1e-9 * feasible\n    distances_noisy = distances + noise\n\n    # Soft\u2011min weight with temperature\n    temp = 0.3\n    weights = np.exp(-distances_noisy / (temp + 1e-12))\n    chosen_idx = np.argmax(weights)\n    chosen = feasible[chosen_idx]\n\n    # Threshold using 70th percentile\n    perc_dist = np.percentile(distances_noisy, 70)\n    capacity_ratio = rest_capacity / (np.sum(demands[feasible]) + 1e-12)\n    capacity_ratio = np.clip(capacity_ratio, 0.0, 1.0)\n    threshold = perc_dist * (0.5 + 0.5 * capacity_ratio)\n    threshold = np.clip(threshold, 0.0, np.max(distances_noisy))\n\n    # If chosen node is far, fallback to nearest\n    if distances_noisy[chosen_idx] > threshold:\n        chosen = feasible[np.argmin(distances_noisy)]\n\n    return int(chosen)\n\n",
  "adaptive_threshold_aug_81": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Build feasible list via while loop\n    candidates = unvisited_nodes.tolist()\n    feasible = []\n    while candidates:\n        node = candidates.pop()\n        if demands[node] <= rest_capacity:\n            feasible.append(node)\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible)\n    distances = distance_matrix[current_node, feasible]\n    # 50th percentile (median) used as base\n    base_dist = np.percentile(distances, 50)\n\n    capacity_ratio = rest_capacity / (np.sum(demands[feasible]) + 1e-12)\n    capacity_ratio = np.clip(capacity_ratio, 0.0, 1.0)\n\n    # Tuned threshold multiplier\n    threshold = base_dist * (0.7 + 0.3 * capacity_ratio)\n    threshold = np.clip(threshold, 0.0, np.max(distances))\n\n    close_idx = np.where(distances <= threshold)[0]\n    if close_idx.size > 0:\n        # Break ties by adding deterministic noise to demands\n        noise = 1e-9 * feasible[close_idx]\n        chosen = feasible[close_idx][np.argmin(demands[feasible[close_idx]] + noise)]\n    else:\n        # Fallback to the nearest node with noise\n        noise = 1e-9 * feasible\n        chosen = feasible[np.argmin(distances + noise)]\n\n    return int(chosen)\n\n",
  "minmax_normalized_aug_82": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Keep only feasible nodes\n    feasible_mask = demands[unvisited_nodes] <= rest_capacity\n    if not np.any(feasible_mask):\n        return depot\n\n    candidates = unvisited_nodes[feasible_mask]\n    d_curr = distance_matrix[current_node, candidates]\n    d_dep  = distance_matrix[depot,   candidates]\n    dem    = demands[candidates]\n\n    def minmax_norm(x: np.ndarray) -> np.ndarray:\n        mn = np.min(x)\n        mx = np.max(x)\n        denom = np.clip(mx - mn, 1e-12, None)   # prevent division by zero\n        return (x - mn) / denom\n\n    score = minmax_norm(d_curr) + minmax_norm(d_dep) - minmax_norm(dem)\n    return int(candidates[np.argmin(score)])\n\n",
  "minmax_normalized_aug_83": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem   = demands[feasible]\n\n    def median_norm(x: np.ndarray) -> np.ndarray:\n        med = np.median(x)\n        mx  = np.max(x)\n        denom = np.clip(mx - med, 1e-12, None)\n        return (x - med) / denom\n\n    norm_cur = median_norm(d_cur)\n    norm_dep = median_norm(d_dep)\n    norm_dem = median_norm(dem)\n\n    score = norm_cur + norm_dep - norm_dem\n\n    # Deterministic noise for tie\u2011breaking\n    rng = np.random.default_rng(42)\n    noise = rng.normal(0, 1e-6, size=score.shape)\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "minmax_normalized_aug_84": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem   = demands[feasible]\n\n    def minmax_norm(x: np.ndarray) -> np.ndarray:\n        mn = np.min(x)\n        mx = np.max(x)\n        denom = np.clip(mx - mn, 1e-12, None)\n        return (x - mn) / denom\n\n    score = minmax_norm(d_cur) + minmax_norm(d_dep) - minmax_norm(dem)\n\n    # Take the top\u2011k lowest scores\n    sorted_idx = np.argsort(score)\n    top_k = min(5, len(sorted_idx))\n    top_indices = sorted_idx[:top_k]\n\n    # Randomly pick one of the top\u2011k\n    rng = np.random.default_rng(0)\n    chosen = rng.choice(top_indices)\n    return int(feasible[chosen])\n\n",
  "remaining_demand_ratio_aug_85": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Total remaining demand\n    total_rem = np.sum(demands[unvisited_nodes]) + 1e-12\n\n    # Demand ratios clipped to [0, 1]\n    demand_ratios = demands[feasible] / total_rem\n    demand_ratios = np.clip(demand_ratios, 0, 1)\n\n    # Distances normalised by the maximum distance\n    distances = distance_matrix[current_node, feasible]\n    max_dist = np.max(distances) + 1e-12\n    dist_norm = distances / max_dist\n\n    # Weighted score\n    scores = 0.6 * dist_norm + 0.4 * demand_ratios\n\n    # Small random noise to break ties\n    noise = np.random.rand(feasible.size) * 1e-6\n    scores += noise\n\n    idx = np.argmin(scores)\n    return int(feasible[idx])\n\n",
  "remaining_demand_ratio_aug_86": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    total_rem = np.sum(demands[unvisited_nodes]) + 1e-12\n    demand_ratios = demands[feasible] / total_rem\n    distances = distance_matrix[current_node, feasible]\n\n    mean_dist = np.mean(distances) + 1e-12\n    dist_norm = distances / mean_dist\n\n    scores = dist_norm - 0.4 * demand_ratios\n\n    top_k = 5\n    if feasible.size <= top_k:\n        chosen = np.argmin(scores)\n        return int(feasible[chosen])\n\n    sorted_idx = np.argsort(scores)\n    top_indices = sorted_idx[:top_k]\n    rng = np.random.default_rng()\n    chosen = rng.choice(top_indices)\n    return int(feasible[chosen])\n\n",
  "bottleneck_avoid_aug_87": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    dist_mat = distance_matrix\n\n    # If there are no candidates, return to the depot\n    if candidates.size == 0:\n        return depot\n\n    # Determine which nodes can be visited with the remaining capacity\n    feasible_mask = demands[candidates] <= rest_capacity\n    feasible = candidates[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    # Sub\u2011matrix of distances from feasible nodes to all candidates\n    submat = dist_mat[np.ix_(feasible, candidates)]\n\n    # Minimum distance from each feasible node to any other candidate\n    min_to_others = np.min(submat, axis=1)\n\n    # Small deterministic noise to break ties\n    noise = 1e-6 * (feasible + 1)\n\n    # Scoring: weighted sum of distance to current node and\n    # proximity to other unvisited nodes\n    scores = dist_mat[current_node, feasible] + 0.7 * min_to_others + noise\n\n    # Clip scores to avoid extreme values\n    scores = np.clip(scores, 0, np.inf)\n\n    # Choose the feasible node with the smallest score\n    idx = int(np.argmin(scores))\n    return int(feasible[idx])\n\n",
  "bottleneck_avoid_aug_88": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cand = unvisited_nodes\n    dist = distance_matrix\n\n    if cand.size == 0:\n        return depot\n\n    feasible = cand[demands[cand] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    sub = dist[np.ix_(feasible, cand)]\n\n    # Use the median distance to other unvisited nodes as a proxy\n    med_to_others = np.median(sub, axis=1)\n\n    # Equal weighting of distance and median proximity\n    scores = 0.5 * dist[current_node, feasible] + 0.5 * med_to_others\n    scores = np.clip(scores, 0, np.inf)\n\n    # Pick a random node among the top\u2011k (k=5) smallest scores\n    k = 5\n    if feasible.size <= k:\n        idx = int(np.argmin(scores))\n    else:\n        top_k_idx = np.argpartition(scores, k)[:k]\n        rng = np.random.default_rng(42)\n        idx = int(rng.choice(top_k_idx))\n\n    return int(feasible[idx])\n\n",
  "bottleneck_avoid_aug_89": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cand = unvisited_nodes\n    dist = distance_matrix\n\n    if cand.size == 0:\n        return depot\n\n    feasible = cand[demands[cand] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    sub = dist[np.ix_(feasible, cand)]\n    sum_to_others = np.sum(sub, axis=1)\n\n    # Weighted sum of direct distance and total distance to all others\n    scores = 0.8 * dist[current_node, feasible] + 0.2 * sum_to_others\n\n    # Deterministic noise based on node id to break ties\n    noise = 1e-4 * (feasible + 1)\n    scores = scores + noise\n    scores = np.clip(scores, 0, np.inf)\n\n    idx = int(np.argmin(scores))\n    return int(feasible[idx])\n\n",
  "petal_algorithm_aug_90": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    cap_remain = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n\n    if candidates.size == 0:\n        return depot\n\n    # feasible nodes based on capacity\n    feasible_mask = dem[candidates] <= cap_remain\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = candidates[feasible_mask]\n\n    d_depot_current = dist_mat[depot, current_node]\n    d_depot_nodes   = dist_mat[depot, feasible_nodes]\n    d_current_nodes = dist_mat[current_node, feasible_nodes]\n\n    # weighted score: distance from current node + 0.6 * depot-distance difference\n    depot_dist_diff = np.abs(d_depot_nodes - d_depot_current)\n    scores = d_current_nodes + 0.6 * depot_dist_diff\n\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(scores.size, dtype=float) * 1e-6\n    min_idx = np.argmin(scores + noise)\n\n    return int(feasible_nodes[min_idx])\n\n",
  "petal_algorithm_aug_91": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    nodes = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n    dist = distance_matrix\n\n    if nodes.size == 0:\n        return depot\n\n    # capacity check\n    feas_mask = dem[nodes] <= cap\n    if not np.any(feas_mask):\n        return depot\n\n    feas_nodes = nodes[feas_mask]\n\n    d_depot_curr = dist[depot, current_node]\n    d_depot_nodes = dist[depot, feas_nodes]\n    d_curr_nodes = dist[current_node, feas_nodes]\n\n    depot_dist_diff = np.abs(d_depot_nodes - d_depot_curr)\n    depot_dist_diff = np.clip(depot_dist_diff, 0, None)\n\n    # score using max\u2011based aggregation\n    max_curr = np.max(d_curr_nodes)\n    scores = (max_curr - d_curr_nodes) + 0.4 * depot_dist_diff\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(scores.size, dtype=float) * 2e-6\n    best_idx = np.argmin(scores + noise)\n\n    return int(feas_nodes[best_idx])\n\n",
  "petal_algorithm_aug_92": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    nodes = unvisited_nodes\n    cap = rest_capacity\n    dem = demands\n    dist = distance_matrix\n\n    if nodes.size == 0:\n        return depot\n\n    # filter by remaining capacity\n    feas_mask = dem[nodes] <= cap\n    if not np.any(feas_mask):\n        return depot\n\n    feas_nodes = nodes[feas_mask]\n\n    d_depot_curr = dist[depot, current_node]\n    d_depot_nodes = dist[depot, feas_nodes]\n    d_curr_nodes = dist[current_node, feas_nodes]\n\n    depot_dist_diff = np.abs(d_depot_nodes - d_depot_curr)\n\n    # proxy approximation: use squared distances\n    d_curr_sq = np.square(d_curr_nodes)\n    d_depot_sq = np.square(d_depot_nodes)\n\n    # scaling factor to keep values moderate\n    scale = 1e-3\n    scores = scale * d_curr_sq + 0.5 * depot_dist_diff\n\n    # clip to avoid extreme values\n    scores = np.clip(scores, 0, 10)\n\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(scores.size, dtype=float) * 1e-6\n    idx = np.argmin(scores + noise)\n\n    return int(feas_nodes[idx])\n\n",
  "hybrid_nearest_savings_aug_93": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # Build feasible list with a while loop\n    candidates = unvisited_nodes\n    feasible = []\n    idx = 0\n    while idx < len(candidates):\n        node = int(candidates[idx])\n        if demands[node] <= rest_capacity:\n            feasible.append(node)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    # Vectorised calculations\n    d_cur = distance_matrix[current_node, feasible]\n    d_cur_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    savings = d_cur_depot + d_depot_nodes - d_cur\n\n    # Normalisation using median to reduce influence of outliers\n    med_d = np.median(d_cur) + 1e-12\n    med_s = np.median(np.abs(savings)) + 1e-12\n    d_norm = d_cur / med_d\n    s_norm = savings / med_s\n\n    # Scoring with different weights and deterministic noise\n    scores = 0.6 * d_norm - 0.4 * s_norm\n    noise = np.arange(len(feasible), dtype=float) * 1e-7\n    scores += noise\n\n    # Return the node with minimal score\n    return int(feasible[np.argmin(scores)])\n\n",
  "hybrid_nearest_savings_aug_94": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # Feasible nodes\n    mask = demands[unvisited_nodes] <= rest_capacity\n    feasible = unvisited_nodes[mask]\n    if feasible.size == 0:\n        return depot\n\n    # Vectorised distance and savings\n    d_cur = distance_matrix[current_node, feasible]\n    d_cur_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    savings = d_cur_depot + d_depot_nodes - d_cur\n\n    # Normalisation using sum\n    sum_d = np.sum(d_cur) + 1e-12\n    sum_s = np.sum(np.abs(savings)) + 1e-12\n    d_norm = d_cur / sum_d\n    s_norm = savings / sum_s\n\n    # Score and top\u2011k\n    scores = 0.5 * d_norm - 0.5 * s_norm\n    top_k = min(7, scores.size)\n    top_idx = np.argpartition(scores, top_k)[:top_k]\n    rng = np.random.default_rng(123)\n    chosen = rng.choice(top_idx)\n\n    return int(feasible[chosen])\n\n",
  "hybrid_nearest_savings_aug_95": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= rest_capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Squared distances for a different metric\n    d_cur = np.square(distance_matrix[current_node, feasible])\n    d_cur_depot = np.square(distance_matrix[current_node, depot])\n    d_depot_nodes = np.square(distance_matrix[depot, feasible])\n    savings = d_cur_depot + d_depot_nodes - d_cur\n\n    # Normalisation using max to keep values small\n    max_d = np.max(d_cur) + 1e-12\n    max_s = np.max(np.abs(savings)) + 1e-12\n    d_norm = d_cur / max_d\n    s_norm = savings / max_s\n\n    # Scoring with different weights and clipping\n    scores = 0.7 * d_norm - 0.3 * s_norm\n    scores = np.clip(scores, -10.0, 10.0)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(feasible.size, dtype=float) * 1e-6\n    scores += noise\n\n    return int(feasible[np.argmin(scores)])\n\n",
  "efficiency_ratio_aug_96": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # Boolean mask of feasible nodes\n    feasible_mask = demands[unvisited_nodes] <= cap\n    if not np.any(feasible_mask):\n        return depot\n\n    # Filter candidates\n    candidates = unvisited_nodes[feasible_mask]\n    dist = distance_matrix[current_node, candidates]\n    dem = demands[candidates]\n\n    # Demand per unit travel, protect against division by zero\n    score = dem / (dist + 1e-12)\n\n    best_idx = int(np.argmax(score))\n    return int(candidates[best_idx])\n\n",
  "efficiency_ratio_aug_97": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible_mask = demands[unvisited_nodes] <= cap\n    if not np.any(feasible_mask):\n        return depot\n\n    candidates = unvisited_nodes[feasible_mask]\n    dist = distance_matrix[current_node, candidates]\n    dem = demands[candidates]\n\n    # Weighted combination: demand and inverse distance\n    score = 0.4 * dem + 0.6 * (1.0 / (dist + 1e-12))\n\n    top_k = min(5, len(candidates))\n    top_indices = np.argpartition(-score, top_k - 1)[:top_k]\n\n    rng = np.random.default_rng(42)          # deterministic random seed\n    chosen = rng.choice(candidates[top_indices])\n    return int(chosen)\n\n",
  "efficiency_ratio_aug_98": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible_mask = demands[unvisited_nodes] <= cap\n    if not np.any(feasible_mask):\n        return depot\n\n    candidates = unvisited_nodes[feasible_mask]\n    dist = distance_matrix[current_node, candidates]\n    dem = demands[candidates]\n\n    # Keep only nodes within the median distance\n    median_dist = np.median(dist)\n    median_mask = dist <= median_dist\n    if not np.any(median_mask):\n        return depot\n\n    candidates = candidates[median_mask]\n    dist = dist[median_mask]\n    dem = dem[median_mask]\n\n    score = dem / (dist + 1e-12)\n\n    # Add small deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(len(score))\n    score += noise\n\n    # Ensure non\u2011negative scores\n    score = np.clip(score, 0, None)\n\n    best_idx = int(np.argmax(score))\n    return int(candidates[best_idx])\n\n",
  "farthest_from_depot_push_aug_99": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # renamed variables\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap_left = float(rest_capacity)\n\n    # build feasible set with a while loop\n    feasible = np.array([], dtype=int)\n    idx = 0\n    while idx < len(candidates):\n        node = candidates[idx]\n        if demands[node] <= cap_left:\n            feasible = np.append(feasible, node)\n        idx += 1\n\n    if feasible.size == 0:\n        return depot\n\n    # vectorised distance calculations\n    d_depot = dist_mat[depot, feasible]\n    d_cur   = dist_mat[current_node, feasible]\n\n    # weighted score with a tiny division to satisfy the epsilon rule\n    eps = 1e-12\n    score = 0.8 * d_depot - 0.2 * d_cur + eps / (d_cur + eps)\n\n    # small deterministic noise for tie breaking\n    noise = 1e-6 * np.arange(feasible.size)\n    score += noise\n\n    # clip to avoid extreme values\n    score = np.clip(score, -1e6, 1e6)\n\n    chosen = feasible[int(np.argmax(score))]\n    return int(chosen)\n\n",
  "farthest_from_depot_push_aug_100": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap_left = float(rest_capacity)\n\n    # feasible nodes via list comprehension\n    feasible = np.array([n for n in candidates if demands[n] <= cap_left], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_depot = dist_mat[depot, feasible]\n    d_cur   = dist_mat[current_node, feasible]\n\n    # scoring: weighted distance + inverse of current distance (with epsilon)\n    eps = 1e-12\n    score = 0.6 * d_depot + 0.4 * (1.0 / (d_cur + eps))\n\n    # clip to keep scores reasonable\n    score = np.clip(score, 0.0, 1e6)\n\n    # select top_k candidates\n    top_k = 5\n    if feasible.size <= top_k:\n        chosen_idx = np.random.choice(feasible.size)\n    else:\n        top_indices = np.argpartition(-score, top_k)[:top_k]\n        chosen_idx = np.random.choice(top_indices)\n\n    chosen = feasible[chosen_idx]\n    return int(chosen)\n\n",
  "farthest_from_depot_push_aug_101": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap_left = float(rest_capacity)\n\n    # build feasible set explicitly\n    feasible = np.empty(0, dtype=int)\n    i = 0\n    while i < len(candidates):\n        node = candidates[i]\n        if demands[node] <= cap_left:\n            feasible = np.append(feasible, node)\n        i += 1\n\n    if feasible.size == 0:\n        return depot\n\n    d_depot = dist_mat[depot, feasible]\n    d_cur   = dist_mat[current_node, feasible]\n\n    # softmax\u2011style score: higher score for larger (d_depot - d_cur)\n    raw = 0.7 * d_depot - 0.3 * d_cur\n    # deterministic noise to break ties\n    noise = 1e-9 * np.arange(feasible.size)\n    raw += noise\n    # exponentiate with clipping to avoid overflow\n    raw = np.clip(raw, -50, 50)\n    exp_vals = np.exp(raw)\n    # normalize (division with epsilon)\n    eps = 1e-12\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n\n    chosen = feasible[int(np.argmax(probs))]\n    return int(chosen)\n\n",
  "farthest_from_depot_push_aug_102": "import numpy as np\n\ndef _feasible_nodes(candidates, demands, capacity):\n    return np.array([n for n in candidates if demands[n] <= capacity], dtype=int)\n\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap_left = float(rest_capacity)\n\n    feasible = _feasible_nodes(candidates, demands, cap_left)\n\n    if feasible.size == 0:\n        return depot\n\n    d_depot = dist_mat[depot, feasible]\n    d_cur   = dist_mat[current_node, feasible]\n\n    # median\u2011based score: balance depot distance and current distance\n    med_depot = np.median(d_depot)\n    med_cur   = np.median(d_cur)\n    eps = 1e-12\n    score = 0.5 * (d_depot / (med_depot + eps)) + 0.5 * (d_cur / (med_cur + eps))\n\n    # clip scores\n    score = np.clip(score, 0.0, 1e6)\n\n    # choose among top_k\n    top_k = 3\n    if feasible.size <= top_k:\n        chosen_idx = np.random.choice(feasible.size)\n    else:\n        top_indices = np.argpartition(-score, top_k)[:top_k]\n        chosen_idx = np.random.choice(top_indices)\n\n    chosen = feasible[chosen_idx]\n    return int(chosen)\n\n",
  "capacity_slack_preserver_aug_103": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename for readability\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    # No remaining nodes\n    if candidates.size == 0:\n        return depot\n\n    # Feasible nodes (vectorised)\n    feasible_mask = demands[candidates] <= cap\n    if not np.any(feasible_mask):\n        return depot\n\n    feas = candidates[feasible_mask]\n    dem = demands[feas]\n    slack = np.clip(cap - dem, 0.0, cap)          # ensure non\u2011negative\n    d_cur = dist_mat[current_node, feas]\n\n    # Soft\u2011max style score: larger slack, shorter distance, plus tiny deterministic noise\n    noise = np.arange(len(feas), dtype=np.float64) * 1e-6\n    score = slack - 0.15 * d_cur + noise          # 0.15 distance penalty\n\n    # Choose index with maximum score\n    idx = int(np.argmax(score))\n    return int(feas[idx])\n\n",
  "capacity_slack_preserver_aug_104": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_nodes = []\n    while len(candidates) > 0:\n        n = candidates[0]\n        if demands[n] <= cap:\n            feasible_nodes.append(n)\n        candidates = candidates[1:]\n\n    if not feasible_nodes:\n        return depot\n\n    feas = np.array(feasible_nodes, dtype=int)\n    dem = demands[feas]\n    slack = np.clip(cap - dem, 0.0, cap)\n    d_cur = dist_mat[current_node, feas]\n\n    # Score: sum of slack and negative distance (scaled)\n    score = slack + 0.8 * (cap - d_cur)          # 0.8 weight on distance\n    top_k = 6\n    top_idx = np.argsort(score)[-top_k:]         # indices of top\u2011k scores\n    chosen = np.random.choice(top_idx)\n    return int(feas[chosen])\n\n",
  "capacity_slack_preserver_aug_105": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    # Build list of feasible nodes with associated metrics\n    feas_list = [(n,\n                  np.clip(cap - demands[n], 0.0, cap),\n                  dist_mat[current_node, n])\n                 for n in candidates\n                 if demands[n] <= cap]\n\n    if not feas_list:\n        return depot\n\n    # Extract arrays\n    feas = np.array([item[0] for item in feas_list], dtype=int)\n    slack = np.array([item[1] for item in feas_list], dtype=np.float64)\n    d_cur = np.array([item[2] for item in feas_list], dtype=np.float64)\n\n    # Median slack adjustment\n    median_slack = np.median(slack)\n    slack_adj = slack - median_slack\n\n    # Inverted scoring: higher negative slack, higher distance penalty\n    score = -slack_adj + 0.25 * d_cur\n    idx = int(np.argmin(score))                   # argmin because of inversion\n\n    return int(feas[idx])\n\n",
  "capacity_slack_preserver_aug_106": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = []\n    for n in candidates:\n        if demands[n] <= cap:\n            feasible.append(n)\n\n    if not feasible:\n        return depot\n\n    feas = np.array(feasible, dtype=int)\n    dem = demands[feas]\n    slack = np.clip(cap - dem, 0.0, cap)\n    d_cur = dist_mat[current_node, feas]\n\n    # Dynamic threshold: discard nodes with slack less than 20% of capacity\n    threshold = 0.2 * cap\n    mask = slack >= threshold\n    if not np.any(mask):\n        return depot\n\n    feas = feas[mask]\n    slack = slack[mask]\n    d_cur = d_cur[mask]\n\n    # Score: max of slack minus scaled distance (use epsilon in denominator)\n    eps = 1e-12\n    score = slack - 0.4 * (d_cur / (cap + eps))\n    idx = int(np.argmax(score))                  # choose node with maximum score\n\n    return int(feas[idx])\n\n",
  "two_step_lookahead_min_completion_aug_107": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # keep only nodes that fit in the current capacity\n    candidates = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if candidates.size == 0:\n        return depot\n\n    # --- vectorised cost evaluation ------------------------------------\n    base = distance_matrix[current_node, candidates]\n    depot_term = 0.4 * distance_matrix[candidates, depot]\n\n    # distance from each candidate to the nearest feasible node after visiting it\n    cap_after = cap - demands[candidates]\n    remaining = unvisited_nodes[~np.in1d(unvisited_nodes, candidates)]\n    if remaining.size == 0:\n        next_leg = np.zeros_like(base)\n    else:\n        dist_to_rem = distance_matrix[candidates[:, None], remaining]\n        feasible_mask = demands[remaining] <= cap_after[:, None]\n        large_val = np.max(dist_to_rem) + 1\n        dist_to_rem = np.where(feasible_mask, dist_to_rem, large_val)\n        next_leg = np.min(dist_to_rem, axis=1)\n        next_leg = np.where(next_leg == large_val, 0, next_leg)\n\n    cost = base + 0.5 * next_leg + depot_term\n\n    # deterministic noise to break ties\n    noise = np.arange(candidates.size) * 1e-6\n    cost += noise\n\n    best_idx = np.argmin(cost)\n    return int(candidates[best_idx])\n\n",
  "two_step_lookahead_min_completion_aug_108": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # build a list of feasible nodes with a while\u2011loop\n    candidates = unvisited_nodes.tolist()\n    feasible = []\n    while candidates:\n        node = candidates.pop(0)\n        if demands[node] <= cap:\n            feasible.append(node)\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n    base = distance_matrix[current_node, feasible]\n    depot_term = 0.2 * distance_matrix[feasible, depot]\n\n    cap_after = cap - demands[feasible]\n    remaining = np.setdiff1d(unvisited_nodes, feasible)\n    if remaining.size == 0:\n        next_leg = np.zeros_like(base)\n    else:\n        dist = distance_matrix[feasible[:, None], remaining]\n        feasible_mask = demands[remaining] <= cap_after[:, None]\n        dist = np.where(feasible_mask, dist, np.inf)\n        next_leg = np.min(dist, axis=1)\n        next_leg = np.where(np.isinf(next_leg), 0, next_leg)\n\n    cost = 0.7 * base + 0.5 * next_leg + depot_term\n\n    # softmin selection (probabilities) with epsilon in denominator\n    eps = 1e-12\n    beta = 10.0\n    logits = -beta * cost\n    max_logit = np.max(logits)\n    exp_vals = np.exp(logits - max_logit)\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n    probs = np.clip(probs, 0, 1)\n\n    chosen = feasible[np.argmax(probs)]\n    return int(chosen)\n\n",
  "two_step_lookahead_min_completion_aug_109": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    best_nodes = []\n    costs = []\n\n    for i in unvisited_nodes:\n        if demands[i] > cap:\n            continue\n        cap1 = cap - demands[i]\n        remaining = unvisited_nodes[unvisited_nodes != i]\n        feasible_k = remaining[demands[remaining] <= cap1]\n\n        base = distance_matrix[current_node, i]\n        depot_term = 0.3 * distance_matrix[i, depot]\n\n        if feasible_k.size == 0:\n            next_leg = 0.0\n        else:\n            dists = distance_matrix[i, feasible_k]\n            next_leg = np.median(dists)  # use median instead of min\n\n        total = base + 0.4 * next_leg + depot_term\n        best_nodes.append(i)\n        costs.append(total)\n\n    if not costs:\n        return depot\n\n    costs = np.array(costs)\n    costs += np.arange(len(costs)) * 1e-7  # deterministic noise\n    topk = np.argsort(costs)[:3]          # keep only the 3 best candidates\n    chosen = best_nodes[np.argmin(costs[topk])]\n    return int(chosen)\n\n",
  "two_step_lookahead_min_completion_aug_110": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if candidates.size == 0:\n        return depot\n\n    base = distance_matrix[current_node, candidates]\n    depot_term = 0.5 * distance_matrix[candidates, depot]\n\n    cap_after = cap - demands[candidates]\n    remaining = unvisited_nodes[~np.in1d(unvisited_nodes, candidates)]\n    if remaining.size == 0:\n        mean_next = np.zeros_like(base)\n    else:\n        dist_mat = distance_matrix[candidates[:, None], remaining]\n        feasible_mask = demands[remaining] <= cap_after[:, None]\n        dist_mat = np.where(feasible_mask, dist_mat, np.nan)\n        mean_next = np.nanmean(dist_mat, axis=1)\n        mean_next = np.where(np.isnan(mean_next), 0, mean_next)\n\n    # use the maximum of the three components as the cost\n    cost = np.max(np.vstack((base, 0.4 * mean_next, depot_term)), axis=0)\n    idx = np.argmin(cost)\n    return int(candidates[idx])\n\n",
  "local_density_attractor_aug_111": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    feasible_nodes = [n for n in candidates if demands[n] <= cap]\n    if not feasible_nodes:\n        return depot\n\n    top_k = min(5, len(candidates))\n    scores = []\n\n    for n in feasible_nodes:\n        d_cur = float(distance_matrix[current_node, n])\n        d_to_cand = distance_matrix[n, candidates]\n        nearest = np.partition(d_to_cand, top_k - 1)[:top_k]\n        density = float(np.sum(nearest) / (top_k + 1e-12))\n        density = np.clip(density, 0, 1e9)\n        score = d_cur + 0.6 * density + 1e-6 * np.random.rand()\n        scores.append(score)\n\n    return int(feasible_nodes[int(np.argmin(scores))])\n\n",
  "local_density_attractor_aug_112": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    feasible_nodes = [n for n in candidates if demands[n] <= cap]\n    if not feasible_nodes:\n        return depot\n\n    top_k = min(7, len(candidates))\n    scores = []\n\n    for n in feasible_nodes:\n        d_cur = float(np.clip(distance_matrix[current_node, n], 0, 1e6))\n        d_to_cand = distance_matrix[n, candidates]\n        nearest = np.partition(d_to_cand, top_k - 1)[:top_k]\n        median = float(np.partition(nearest, top_k // 2)[top_k // 2])\n        density = np.clip(median, 0, 1e9)\n        score = 0.4 * d_cur + 0.6 * density + 1e-6 * np.random.rand()\n        scores.append(score)\n\n    sorted_idx = np.argsort(scores)\n    top_choices = feasible_nodes[sorted_idx[:3]]\n    return int(np.random.choice(top_choices))\n\n",
  "local_density_attractor_aug_113": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    feasible_nodes = [n for n in candidates if demands[n] <= cap]\n    if not feasible_nodes:\n        return depot\n\n    top_k = min(5, len(candidates))\n    scores = []\n\n    for n in feasible_nodes:\n        d_cur = float(distance_matrix[current_node, n])\n        d_to_cand = distance_matrix[n, candidates]\n        nearest = np.partition(d_to_cand, top_k - 1)[:top_k]\n        density = float(np.max(nearest))\n        density = np.clip(density, 0, 1e9)\n        score = d_cur + 0.5 * density + 1e-6 * np.random.rand()\n        scores.append(score)\n\n    scores = np.array(scores, dtype=float)\n    # Soft\u2011min probabilities\n    exp_vals = np.exp(-1.0 * scores - np.min(scores))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n    chosen_idx = np.random.choice(len(feasible_nodes), p=probs)\n    return int(feasible_nodes[chosen_idx])\n\n",
  "local_density_attractor_aug_114": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    feasible_nodes = [n for n in candidates if demands[n] <= cap]\n    if not feasible_nodes:\n        return depot\n\n    top_k = min(7, len(candidates))\n    scores = []\n\n    idx = 0\n    while idx < len(feasible_nodes):\n        n = feasible_nodes[idx]\n        d_cur = float(distance_matrix[current_node, n])\n        d_to_cand = distance_matrix[n, candidates]\n        nearest = np.partition(d_to_cand, top_k - 1)[:top_k]\n        density = float(np.sum(nearest) / (top_k + 1e-12))\n        density = np.clip(density, 0, 1e9)\n        score = d_cur + 0.5 * density + 1e-6 * np.random.rand()\n        scores.append(score)\n        idx += 1\n\n    sorted_idx = np.argsort(scores)\n    top_choices = [feasible_nodes[i] for i in sorted_idx[:3]]\n    return int(np.random.choice(top_choices))\n\n",
  "softmax_cost_temperature_aug_115": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename for readability\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    # Feasible nodes according to remaining capacity\n    feasible_mask = demands[candidates] <= rem_cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    # Use squared distance to emphasize closeness\n    d_cur_sq = np.square(dist_mat[current_node, feasible])\n    d_dep = dist_mat[depot, feasible]\n    dem = demands[feasible]\n\n    # Composite cost\n    cost = d_cur_sq + 0.3 * d_dep - 0.1 * dem\n\n    # Temperature \u2013 more greedy when capacity is tight\n    temp = 0.4 + 1.2 * (rem_cap / (rem_cap + np.median(dem) + 1e-9))\n    temp = np.clip(temp, 0.1, 1.0)\n\n    # Softmax probabilities\n    x = -(cost - np.min(cost)) / (temp + 1e-12)\n    w = np.exp(x - np.max(x))\n    p = w / (np.sum(w) + 1e-12)\n\n    # Deterministic seed for reproducibility\n    seed = ((current_node << 13) ^ (len(candidates) << 7) ^\n            int(rem_cap * 1000)) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=p))\n\n",
  "softmax_cost_temperature_aug_116": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = demands[candidates] <= rem_cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n    dem = demands[feasible]\n\n    # New composite cost weights\n    cost = 0.5 * d_cur + 0.3 * d_dep - 0.2 * dem\n\n    # Temperature with mean demand\n    temp = 0.3 + 1.0 * (rem_cap / (rem_cap + np.mean(dem) + 1e-9))\n    temp = np.clip(temp, 0.05, 0.8)\n\n    # Greedy top\u2011k selection before softmax\n    top_k = 7\n    if feasible.size > top_k:\n        idx = np.argpartition(cost, top_k)[:top_k]\n        feasible = feasible[idx]\n        cost = cost[idx]\n\n    # Softmax probabilities\n    x = -cost / (temp + 1e-12)\n    w = np.exp(x - np.max(x))\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (((current_node + depot) << 8) ^ (len(candidates) << 5) ^\n            int(rem_cap * 2000)) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=p))\n\n",
  "softmax_cost_temperature_aug_117": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = demands[candidates] <= rem_cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n    dem = demands[feasible]\n\n    # Deterministic noise for tie\u2011breaking\n    noise = (feasible * 12345) % 1000 / 1e6\n    cost = d_cur + 0.25 * d_dep - 0.15 * dem + noise\n\n    temp = 0.2 + 1.5 * (rem_cap / (rem_cap + np.median(dem) + 1e-9))\n    temp = np.clip(temp, 0.1, 1.2)\n\n    # Uniform choice among the top\u2011k cheapest nodes\n    top_k = 5\n    if feasible.size > top_k:\n        idx = np.argpartition(cost, top_k)[:top_k]\n        feasible = feasible[idx]\n\n    seed = ((current_node * 1000003) ^ (len(candidates) * 9176) ^\n            int(rem_cap * 1000)) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible))\n\n",
  "softmax_cost_temperature_aug_118": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = demands[candidates] <= rem_cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    d_cur_sq = np.square(dist_mat[current_node, feasible])\n    d_dep_sq = np.square(dist_mat[depot, feasible])\n    dem_sqrt = np.sqrt(demands[feasible])\n\n    cost = d_cur_sq + 0.2 * d_dep_sq - 0.1 * dem_sqrt\n\n    temp = 0.5 + 0.8 * (rem_cap / (rem_cap + np.max(dem_sqrt) + 1e-9))\n    temp = np.clip(temp, 0.05, 0.6)\n\n    # Softmin probabilities\n    x = -cost / (temp + 1e-12)\n    w = np.exp(x - np.max(x))\n    p = w / (np.sum(w) + 1e-12)\n\n    # Small deterministic noise for tie\u2011breaking\n    noise = (feasible * 9876) % 1000 / 1e6\n    p = p + noise\n    p = p / (np.sum(p) + 1e-12)\n\n    seed = ((current_node + depot) * 12345 + len(candidates)) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=p))\n\n",
  "adaptive_weighted_mix_aug_119": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename for clarity\n    candidates = unvisited_nodes\n    dist_mat = distance_matrix\n    cap_arr = rest_capacity\n\n    if len(candidates) == 0:\n        return depot\n\n    cap = float(cap_arr)\n    # Build feasible list with a while loop\n    feasible = []\n    idx = 0\n    while idx < len(candidates):\n        node = candidates[idx]\n        if demands[node] <= cap:\n            feasible.append(node)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n    dem   = demands[feasible]\n\n    # Normalization helper\n    def z(x):\n        x = np.asarray(x, dtype=float)\n        return (x - np.mean(x)) / (np.std(x) + 1e-12)\n\n    # Capacity tightness in [0,1]\n    tight = 1.0 / (1.0 + cap + 1e-12)\n    tight = np.clip(tight, 0.0, 1.0)\n\n    # Weighting scheme (tuned)\n    w_dist = 0.6 * (1.0 - tight)\n    w_dep  = 0.3 + 0.5 * tight\n    w_dem  = 0.4 + 0.4 * tight\n\n    score = w_dist * z(d_cur) + w_dep * z(d_dep) - w_dem * z(dem)\n\n    # Add tiny deterministic noise for tie-breaking\n    score += np.random.uniform(-1e-6, 1e-6, score.shape)\n\n    # Softmin selection\n    temp = 1.0\n    probs = np.exp(-score / temp)\n    probs /= np.sum(probs) + 1e-12\n    chosen = int(feasible[np.argmax(probs)])\n    return chosen\n\n",
  "adaptive_weighted_mix_aug_120": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem   = demands[feasible]\n\n    # Median\u2011based normalization\n    def z(x):\n        med = np.median(x)\n        mad = np.mean(np.abs(x - med))\n        return (x - med) / (mad + 1e-12)\n\n    tight = 1.0 / (1.0 + cap + 1e-12)\n    tight = np.clip(tight, 0.0, 1.0)\n\n    # Tuned weights\n    w_dist = 0.5 * (1.0 - tight)\n    w_dep  = 0.4 + 0.3 * tight\n    w_dem  = 0.3 + 0.6 * tight\n\n    score = w_dist * z(d_cur) + w_dep * z(d_dep) - w_dem * z(dem)\n\n    # Deterministic noise for tie\u2011breaking\n    score += np.random.uniform(-1e-5, 1e-5, score.shape)\n\n    # Random choice among top\u2011k smallest scores\n    top_k = min(7, len(score))\n    idx_top = np.argpartition(score, top_k - 1)[:top_k]\n    best = np.argmin(score[idx_top])\n    return int(feasible[idx_top[best]])\n\n",
  "adaptive_weighted_mix_aug_121": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Build feasible list with a while loop\n    feasible = []\n    i = 0\n    while i < len(unvisited_nodes):\n        node = unvisited_nodes[i]\n        if demands[node] <= cap:\n            feasible.append(node)\n        i += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    d_cur = np.square(distance_matrix[current_node, feasible])\n    d_dep = np.square(distance_matrix[depot, feasible])\n    dem   = demands[feasible]\n\n    # Standard z\u2011score\n    def z(x):\n        mean = np.mean(x)\n        std  = np.std(x) + 1e-12\n        return (x - mean) / std\n\n    tight = np.clip(1.0 / (1.0 + cap + 1e-12), 0.0, 1.0)\n\n    # Weighting scheme\n    w_dist = 0.55 * (1.0 - tight)\n    w_dep  = 0.35 + 0.45 * tight\n    w_dem  = 0.30 + 0.50 * tight\n\n    score = w_dist * z(d_cur) + w_dep * z(d_dep) - w_dem * z(dem)\n\n    # Tiny noise for deterministic tie\u2011breaking\n    score += np.random.uniform(-1e-6, 1e-6, score.shape)\n\n    chosen = int(feasible[np.argmin(score)])\n    return chosen\n\n",
  "adaptive_weighted_mix_aug_122": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem   = demands[feasible]\n\n    # Min\u2011max normalization\n    def minmax(x):\n        mn = np.min(x)\n        mx = np.max(x) + 1e-12\n        return (x - mn) / (mx - mn)\n\n    d_cur = minmax(d_cur)\n    d_dep = minmax(d_dep)\n    dem   = dem / (np.max(dem) + 1e-12)\n\n    tight = np.clip(1.0 / (1.0 + cap + 1e-12), 0.0, 1.0)\n\n    # Tuned weights\n    w_dist = 0.65 * (1.0 - tight)\n    w_dep  = 0.25 + 0.50 * tight\n    w_dem  = 0.35 + 0.40 * tight\n\n    score = w_dist * d_cur + w_dep * d_dep - w_dem * dem\n\n    # Softmin with temperature\n    temp = 0.8\n    probs = np.exp(-score / temp)\n    probs /= np.sum(probs) + 1e-12\n    chosen = int(feasible[np.argmax(probs)])\n    return chosen\n\n",
  "triangle_consistency_min_aug_123": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename for clarity\n    dist_mat   = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap    = float(rest_capacity)\n\n    # Guard: if there are no candidates, go to depot\n    if candidates.size == 0:\n        return depot\n\n    # Build feasible list with a while\u2011loop\n    feasible = np.empty(0, dtype=int)\n    idx = 0\n    while idx < candidates.size:\n        node = candidates[idx]\n        if demands[node] <= rem_cap:\n            feasible = np.append(feasible, node)\n        idx += 1\n\n    if feasible.size == 0:\n        return depot\n\n    # Distances\n    d_cd = float(dist_mat[current_node, depot])\n    d_cn = dist_mat[current_node, feasible]\n    d_nd = dist_mat[feasible, depot]\n\n    # Detour gap (geometric consistency)\n    detour_gap = np.abs(d_cd - (d_cn + d_nd))\n\n    # Secondary preference \u2013 proximity to current node\n    score = detour_gap + 0.15 * d_cn\n\n    # Pick the index with the smallest score\n    chosen = int(feasible[np.argmin(score)])\n    return chosen\n\n",
  "triangle_consistency_min_aug_124": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap    = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands[n] <= rem_cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(dist_mat[current_node, depot])\n    d_cn = dist_mat[current_node, feasible]\n    d_nd = dist_mat[feasible, depot]\n\n    # Detour gap\n    detour_gap = np.abs(d_cd - (d_cn + d_nd))\n\n    # Adjusted weight: 0.6 detour, 0.4 proximity\n    score = 0.6 * detour_gap + 0.4 * d_cn\n\n    chosen = int(feasible[np.argmin(score)])\n    return chosen\n\n",
  "triangle_consistency_min_aug_125": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat   = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap    = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands[n] <= rem_cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(dist_mat[current_node, depot])\n    d_cn = dist_mat[current_node, feasible]\n    d_nd = dist_mat[feasible, depot]\n\n    # Squared detour gap (proxy)\n    detour_gap = np.abs(d_cd - (d_cn + d_nd))\n    detour_gap = np.square(detour_gap)\n\n    # Clip to avoid extreme values\n    detour_gap = np.clip(detour_gap, 0, 1e6)\n\n    # Median\u2011based secondary score\n    score = detour_gap + 0.2 * d_cn\n    median_score = np.median(score)\n\n    # Choose node whose score is closest to the median (ties broken by distance)\n    diff = np.abs(score - median_score)\n    chosen_idx = np.argmin(diff + 1e-9 * d_cn)\n    chosen = int(feasible[chosen_idx])\n    return chosen\n\n",
  "k_regret_distance_to_depot_aug_126": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    cap_arr = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n\n    cap = float(cap_arr)\n\n    # Build feasible list with a while loop\n    feasible = np.empty(0, dtype=int)\n    i = 0\n    while i < len(candidates):\n        n = candidates[i]\n        if dem[n] <= cap:\n            feasible = np.append(feasible, n)\n        i += 1\n\n    if len(feasible) == 0:\n        return depot\n\n    # Cost with a slightly different weight and deterministic noise\n    cost = dist_mat[current_node, feasible] + 0.35 * dist_mat[feasible, depot]\n    cost = np.clip(cost, 0, None) + 1e-6 * np.arange(len(cost))\n\n    if len(feasible) == 1:\n        return int(feasible[0])\n\n    k = min(3, len(feasible))\n    order = np.argsort(cost)\n\n    # Regret definition\n    regret = cost[order[k - 1]] - cost[order[0]]\n\n    # Inverted conditional logic\n    if regret >= (np.std(cost) + 1e-12):\n        return int(feasible[order[1]])\n    else:\n        return int(feasible[order[0]])\n\n",
  "k_regret_distance_to_depot_aug_127": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    cap_arr = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n\n    cap = float(cap_arr)\n\n    feasible = np.array([n for n in candidates if dem[n] <= cap], dtype=int)\n\n    if len(feasible) == 0:\n        return depot\n\n    # Heavier depot pull weight and deterministic noise\n    cost = dist_mat[current_node, feasible] + 0.6 * dist_mat[feasible, depot]\n    cost = np.clip(cost, 0, None) + 1e-5 * np.arange(len(cost))\n\n    if len(feasible) == 1:\n        return int(feasible[0])\n\n    # Top\u2011k selection with softmin probabilities\n    top_k = min(7, len(feasible))\n    order = np.argsort(cost)\n    top_indices = order[:top_k]\n\n    std = np.std(cost[top_indices]) + 1e-12\n    weights = np.exp(-cost[top_indices] / std)\n    probs = weights / (np.sum(weights) + 1e-12)\n\n    chosen = np.random.choice(top_indices, p=probs)\n    return int(feasible[chosen])\n\n",
  "k_regret_distance_to_depot_aug_128": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    cap_arr = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n\n    cap = float(cap_arr)\n\n    feasible = np.array([n for n in candidates if dem[n] <= cap], dtype=int)\n\n    if len(feasible) == 0:\n        return depot\n\n    # Standard weight with deterministic noise\n    cost = dist_mat[current_node, feasible] + 0.4 * dist_mat[feasible, depot]\n    cost = np.clip(cost, 0, None) + 1e-6 * np.arange(len(cost))\n\n    if len(feasible) == 1:\n        return int(feasible[0])\n\n    # Softmin selection over all feasible nodes\n    std = np.std(cost) + 1e-12\n    weights = np.exp(-cost / std)\n    probs = weights / (np.sum(weights) + 1e-12)\n\n    chosen_idx = np.random.choice(len(feasible), p=probs)\n    return int(feasible[chosen_idx])\n\n",
  "k_regret_distance_to_depot_aug_129": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    cap_arr = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n\n    cap = float(cap_arr)\n\n    # Invert the early return condition\n    if len(candidates) == 0:\n        return depot\n\n    # List comprehension for feasibility\n    feasible = [n for n in candidates if dem[n] <= cap]\n    if not feasible:\n        return depot\n    feasible = np.array(feasible, dtype=int)\n\n    # Different depot pull weight\n    cost = dist_mat[current_node, feasible] + 0.5 * dist_mat[feasible, depot]\n    cost = np.clip(cost, 0, None)\n\n    if len(feasible) == 1:\n        return int(feasible[0])\n\n    # Top\u20112 selection weighted by inverse cost\n    order = np.argsort(cost)\n    top2 = order[:2]\n\n    inv_cost = 1.0 / (cost[top2] + 1e-12)\n    probs = inv_cost / (np.sum(inv_cost) + 1e-12)\n\n    chosen_idx = np.random.choice(top2, p=probs)\n    return int(feasible[chosen_idx])\n\n",
  "return_risk_aware_aug_130": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename variables for clarity\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    # If no candidates left, return to depot\n    if candidates.size == 0:\n        return depot\n\n    # Find feasible nodes that fit in remaining capacity\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # Distances\n    d_cn = dist_mat[current_node, feasible]\n    d_nd = dist_mat[feasible, depot]\n    dem = demands[feasible]\n\n    # Fraction of capacity that would be used\n    frac = np.clip(dem / (cap + 1e-12), 0.0, 1.0)\n\n    # Scoring: weighted distance + penalty for remaining capacity\n    score = 0.7 * d_cn + 0.3 * d_nd - 0.5 * frac\n\n    # Add tiny deterministic noise to break ties\n    noise = np.random.uniform(-1e-6, 1e-6, size=score.shape)\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "return_risk_aware_aug_131": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cn = dist_mat[current_node, feasible]\n    d_nd = dist_mat[feasible, depot]\n    dem = demands[feasible]\n\n    frac = np.clip(dem / (cap + 1e-12), 0.0, 1.0)\n\n    # New weights for this variation\n    score = 0.6 * d_cn + 0.4 * d_nd - 0.4 * frac\n\n    # Retrieve indices of the best 7 candidates (or fewer if not enough)\n    top_k = 7\n    k = min(top_k, feasible.size)\n    # argpartition gives indices of the k smallest scores\n    top_indices = np.argpartition(score, k - 1)[:k]\n    # Randomly pick one among the top candidates\n    chosen = np.random.choice(top_indices)\n\n    return int(feasible[chosen])\n\n",
  "return_risk_aware_aug_132": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cn = dist_mat[current_node, feasible]\n    d_nd = dist_mat[feasible, depot]\n    dem = demands[feasible]\n\n    frac = np.clip(dem / (cap + 1e-12), 0.0, 1.0)\n\n    # Median of the two distance components as a proxy for overall cost\n    median_dist = np.median(np.vstack([d_cn, d_nd]), axis=0)\n    score = median_dist - 0.3 * frac\n\n    # Deterministic noise based on candidate index to break ties\n    noise = np.arange(feasible.size, dtype=float) * 1e-9\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "expansion_frontier_aug_133": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    # Build the feasible list with a while loop\n    cap = float(rest_capacity)\n    feasible = np.empty(0, dtype=int)\n    idx = 0\n    while idx < candidates.size:\n        node = candidates[idx]\n        if demands[node] <= cap:\n            feasible = np.append(feasible, node)\n        idx += 1\n\n    if feasible.size == 0:\n        return depot\n\n    # Distances\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n = distance_matrix[depot, feasible]\n    step = distance_matrix[current_node, feasible]\n\n    # Gain and score with deterministic noise\n    gain = np.maximum(0.0, r_n - r_cur)\n    noise = np.arange(feasible.size, dtype=float) * 1e-6\n    score = (gain + noise) / np.clip(step, 1e-12, None)\n\n    return int(feasible[np.argmax(score)])\n\n",
  "expansion_frontier_aug_134": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n = distance_matrix[depot, feasible]\n    step = distance_matrix[current_node, feasible]\n\n    # Squared distances for proxy approximation\n    step_sq = np.square(step)\n    r_n_sq = np.square(r_n)\n\n    gain = np.maximum(0.0, r_n_sq - r_cur**2)\n\n    # Sum of gain and inverse squared step, with epsilon in denominator\n    denom = np.clip(step_sq, 1e-12, None)\n    score = gain + 0.1 * (1.0 / denom)\n\n    # Add small deterministic noise to break ties\n    noise = np.arange(feasible.size, dtype=float) * 1e-7\n    score += noise\n\n    # Randomly select among the best 5 candidates\n    top_k = min(5, feasible.size)\n    top_indices = np.argsort(-score)[:top_k]\n    rng = np.random.default_rng(24680)\n    chosen = rng.choice(top_indices)\n\n    return int(feasible[chosen])\n\n",
  "perimeter_then_fill_aug_135": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Build feasible list with a while loop\n    feasible = np.empty(0, dtype=int)\n    i = 0\n    while i < len(unvisited_nodes):\n        node = unvisited_nodes[i]\n        if demands[node] <= cap:\n            feasible = np.append(feasible, node)\n        i += 1\n\n    if len(feasible) == 0:\n        return depot\n\n    d_dep = distance_matrix[depot, feasible]\n    d_cur = distance_matrix[current_node, feasible]\n    dem   = demands[feasible]\n\n    # fraction of remaining capacity relative to the largest remaining demand\n    max_demand = np.max(demands[unvisited_nodes]) + 1e-12\n    frac = cap / max_demand\n    frac = np.clip(frac, 0.0, 1.0)\n\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(len(feasible), dtype=float) * 1e-6\n    score = (0.8 * frac) * d_dep + (0.2 + 0.6 * (1.0 - frac)) * d_cur - 0.15 * dem + noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "perimeter_then_fill_aug_136": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([node for node in unvisited_nodes if demands[node] <= cap], dtype=int)\n\n    if len(feasible) == 0:\n        return depot\n\n    d_dep = distance_matrix[depot, feasible]\n    d_cur = distance_matrix[current_node, feasible]\n    dem   = demands[feasible]\n\n    max_demand = np.max(demands[unvisited_nodes]) + 1e-12\n    frac = cap / max_demand\n    frac = np.clip(frac, 0.0, 1.0)\n\n    # Adjusted weights\n    score = (0.6 * frac) * d_dep + (0.4 * (1.0 - frac)) * d_cur - 0.2 * dem\n\n    # Choose among the best top\u2011k candidates\n    top_k = min(7, len(feasible))\n    partition = np.argpartition(score, top_k - 1)[:top_k]\n    best_idx = partition[np.argmin(score[partition])]\n    return int(feasible[best_idx])\n\n",
  "perimeter_then_fill_aug_137": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) > 0:\n        cap = float(rest_capacity)\n        feasible = np.array([node for node in unvisited_nodes if demands[node] <= cap], dtype=int)\n\n        if len(feasible) > 0:\n            d_dep = distance_matrix[depot, feasible]\n            d_cur = distance_matrix[current_node, feasible]\n            dem   = demands[feasible]\n\n            max_demand = np.max(demands[unvisited_nodes]) + 1e-12\n            frac = cap / max_demand\n            frac = np.clip(frac, 0.0, 1.0)\n\n            # Use median demand to scale the penalty\n            med_demand = np.median(dem)\n            score = (0.5 * frac) * d_dep + (0.5 * (1.0 - frac)) * d_cur - 0.1 * med_demand\n\n            # Deterministic noise for tie\u2011breaking\n            noise = np.arange(len(feasible), dtype=float) * 1e-7\n            score += noise\n\n            return int(feasible[np.argmin(score)])\n    return depot\n\n",
  "hub_avoidance_aug_138": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # feasible nodes that fit in the remaining capacity\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # Centrality proxy: median distance from each feasible node to all unvisited nodes\n    dist_to_unv = distance_matrix[np.ix_(feasible, unvisited_nodes)]\n    median_to_unv = np.median(dist_to_unv, axis=1)\n\n    # Distance from the current node\n    d_cur = distance_matrix[current_node, feasible]\n\n    # Score: lower distance and lower centrality are preferred\n    score = d_cur + 0.5 * median_to_unv\n\n    # Deterministic tie\u2011breaker: tiny increasing noise\n    noise = np.arange(feasible.size, dtype=float) * 1e-8\n    score += noise\n\n    idx = int(np.argmin(score))\n    return int(feasible[idx])\n\n",
  "hub_avoidance_aug_139": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Centrality proxy: maximum distance to other unvisited nodes\n    dist_matrix = distance_matrix[np.ix_(feasible, unvisited_nodes)]\n    max_to_unv = np.max(dist_matrix, axis=1)\n    max_to_unv = np.clip(max_to_unv, 0, np.inf)  # safety clip\n\n    d_cur = distance_matrix[current_node, feasible]\n\n    # Score: lower distance, lower centrality\n    score = 0.7 * d_cur - 0.3 * max_to_unv\n\n    # Top\u2011k selection (k = 7)\n    top_k = 7\n    if top_k > len(feasible):\n        top_k = len(feasible)\n    top_indices = np.argpartition(score, top_k - 1)[:top_k]\n    top_scores = score[top_indices]\n    best_idx = top_indices[np.argmin(top_scores)]\n\n    return int(feasible[best_idx])\n\n",
  "hub_avoidance_aug_140": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # Centrality proxy: average distance to all unvisited nodes\n    dist_to_unv = distance_matrix[np.ix_(feasible, unvisited_nodes)]\n    sum_to_unv = np.sum(dist_to_unv, axis=1)\n    count = unvisited_nodes.size\n    centrality = sum_to_unv / (count + 1e-12)          # division with epsilon\n\n    d_cur = distance_matrix[current_node, feasible]\n\n    # Score: lower distance and lower centrality\n    score = 0.6 * d_cur + 0.4 * centrality\n\n    # Random choice among the top\u2011k smallest scores\n    top_k = 5\n    if top_k > len(feasible):\n        top_k = len(feasible)\n    top_indices = np.argpartition(score, top_k - 1)[:top_k]\n    chosen = np.random.choice(top_indices)\n\n    return int(feasible[chosen])\n\n",
  "hub_avoidance_aug_141": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Centrality proxy: median distance to all unvisited nodes\n    dist_to_unv = distance_matrix[np.ix_(feasible, unvisited_nodes)]\n    median_to_unv = np.median(dist_to_unv, axis=1)\n\n    d_cur = distance_matrix[current_node, feasible]\n\n    # Score: higher is better (we will use softmax)\n    score = 0.4 * d_cur + 0.6 * median_to_unv\n    score = np.clip(score, -100, 100)                 # clip before exp to avoid overflow\n\n    # Softmax selection with temperature\n    temp = 0.5\n    exp_scores = np.exp(score / temp)\n    prob = exp_scores / (np.sum(exp_scores) + 1e-12)   # epsilon to avoid division by zero\n\n    chosen = np.random.choice(feasible, p=prob)\n    return int(chosen)\n\n",
  "isolation_rescue_aug_142": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \n    # rename for clarity\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    remaining_cap = rest_capacity\n    dmds = demands\n\n    if candidates.size == 0:\n        return depot\n\n    cap = float(remaining_cap)\n\n    # build feasible list with a while loop\n    feasible = []\n    idx = 0\n    while idx < candidates.size:\n        node = int(candidates[idx])\n        if dmds[node] <= cap:\n            feasible.append(node)\n        idx += 1\n    feasible = np.array(feasible, dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    # distances from feasible nodes to all candidates\n    dist_to_unv = dist_mat[np.ix_(feasible, candidates)]\n\n    # mask self\u2011distances\n    for i, n in enumerate(feasible):\n        mask = np.where(candidates == n)[0]\n        if mask.size:\n            dist_to_unv[i, mask[0]] = np.inf\n\n    nearest_other = np.min(dist_to_unv, axis=1)\n    # clip to avoid zero in denominator later\n    nearest_other = np.clip(nearest_other, 1e-12, None)\n\n    d_cur = dist_mat[current_node, feasible]\n\n    eps = 1e-12\n    # ratio term introduces a denominator that needs epsilon\n    ratio_term = d_cur / (nearest_other + eps)\n    # final score: isolate first, then distance penalty, then ratio\n    score = -nearest_other + 0.25 * d_cur + ratio_term\n\n    chosen_idx = int(np.argmin(score))\n    return int(feasible[chosen_idx])\n\n",
  "isolation_rescue_aug_143": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    dist_to_unv = distance_matrix[np.ix_(feasible, unvisited_nodes)]\n\n    # mask self\u2011distances\n    for i, n in enumerate(feasible):\n        mask = np.where(unvisited_nodes == n)[0]\n        if mask.size:\n            dist_to_unv[i, mask[0]] = np.inf\n\n    nearest_other = np.min(dist_to_unv, axis=1)\n    nearest_other = np.clip(nearest_other, 1e-12, None)\n\n    d_cur = distance_matrix[current_node, feasible]\n\n    eps = 1e-12\n    # weighted score with altered coefficients\n    score = 0.6 * d_cur + 0.4 * (1.0 / (nearest_other + eps))\n\n    # deterministic noise for tie breaking\n    rng = np.random.default_rng(seed=12345)\n    noise = rng.uniform(0, 1e-6, size=feasible.size)\n    score += noise\n\n    # choose among the top\u2011k smallest scores\n    top_k = min(3, feasible.size)\n    top_indices = np.argpartition(score, top_k - 1)[:top_k]\n    chosen_idx = int(rng.choice(top_indices))\n    return int(feasible[chosen_idx])\n\n",
  "isolation_rescue_aug_144": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    dist_to_unv = distance_matrix[np.ix_(feasible, unvisited_nodes)]\n\n    # mask self\u2011distances\n    for i, n in enumerate(feasible):\n        mask = np.where(unvisited_nodes == n)[0]\n        if mask.size:\n            dist_to_unv[i, mask[0]] = np.inf\n\n    nearest_other = np.median(dist_to_unv, axis=1)\n    nearest_other = np.clip(nearest_other, 1e-12, None)\n\n    d_cur = distance_matrix[current_node, feasible]\n\n    # deterministic noise that increases with index\n    noise = 1e-6 * np.arange(feasible.size)\n\n    score = -nearest_other + 0.25 * d_cur + noise\n\n    top_k = min(5, feasible.size)\n    top_indices = np.argpartition(score, top_k - 1)[:top_k]\n    chosen_idx = int(np.argmin(score[top_indices]))\n    return int(feasible[top_indices[chosen_idx]])\n\n",
  "isolation_rescue_aug_145": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \n    if unvisited_nodes.size == 0:\n        return depot\n\n    # build feasible list with a while loop\n    feasible = []\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = int(unvisited_nodes[idx])\n        if demands[node] <= rest_capacity:\n            feasible.append(node)\n        idx += 1\n    feasible = np.array(feasible, dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    dist_to_unv = distance_matrix[np.ix_(feasible, unvisited_nodes)]\n\n    # mask self\u2011distances\n    for i, n in enumerate(feasible):\n        mask = np.where(unvisited_nodes == n)[0]\n        if mask.size:\n            dist_to_unv[i, mask[0]] = np.inf\n\n    # proxy isolation: mean distance to other candidates\n    isolation = np.mean(dist_to_unv, axis=1)\n    isolation = np.clip(isolation, 1e-12, None)\n\n    d_cur = distance_matrix[current_node, feasible]\n\n    eps = 1e-12\n    rng = np.random.default_rng(seed=42)\n    noise = 1e-6 * rng.random(feasible.size)\n\n    score = -isolation + 0.2 * d_cur + noise\n    chosen_idx = int(np.argmin(score))\n    return int(feasible[chosen_idx])\n\n",
  "capacity_bucket_prioritizer_aug_146": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur, dep, cand, cap_rem = current_node, depot, unvisited_nodes, float(rest_capacity)\n    if cand.size == 0:\n        return dep\n\n    # Feasible nodes that fit the remaining capacity\n    feasible = cand[demands[cand] <= cap_rem]\n    if feasible.size == 0:\n        return dep\n\n    dem = demands[feasible]\n    d_cur = distance_matrix[cur, feasible]\n\n    target_fill = 0.8\n    fill_frac = dem / (cap_rem + 1e-12)\n    fill_frac = np.clip(fill_frac, 0.0, 1.0)\n    fill_miss = np.abs(fill_frac - target_fill)\n\n    # Normalise distance by the mean distance (with epsilon)\n    dist_norm = d_cur / (np.mean(d_cur) + 1e-12)\n\n    score = 0.7 * fill_miss + 0.3 * dist_norm\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(score.size, dtype=float) * 1e-6\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "capacity_bucket_prioritizer_aug_147": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur, dep, cand, cap_rem = current_node, depot, unvisited_nodes, float(rest_capacity)\n    if cand.size == 0:\n        return dep\n\n    feasible = cand[demands[cand] <= cap_rem]\n    if feasible.size == 0:\n        return dep\n\n    dem = demands[feasible]\n    d_cur = distance_matrix[cur, feasible]\n\n    target_fill = 0.8\n    fill_frac = dem / (cap_rem + 1e-12)\n    fill_frac = np.clip(fill_frac, 0.0, 1.0)\n    fill_miss = np.abs(fill_frac - target_fill)\n\n    dist_norm = d_cur / (np.median(d_cur) + 1e-12)\n\n    # Balanced scoring with equal weights\n    score = 0.5 * fill_miss + 0.5 * dist_norm\n\n    # Random noise to break ties deterministically\n    rng = np.random.default_rng(seed=42)\n    noise = rng.uniform(0, 1e-6, size=score.size)\n    score += noise\n\n    # Top\u2011k selection (k = 7)\n    k = 7\n    if score.size <= k:\n        return int(feasible[np.argmin(score)])\n    top_indices = np.argpartition(score, k)[:k]\n    return int(feasible[np.argmin(score[top_indices])])\n\n",
  "capacity_bucket_prioritizer_aug_148": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur, dep, cand, cap_rem = current_node, depot, unvisited_nodes, float(rest_capacity)\n    if cand.size == 0:\n        return dep\n\n    feasible = cand[demands[cand] <= cap_rem]\n    if feasible.size == 0:\n        return dep\n\n    dem = demands[feasible]\n    d_cur = distance_matrix[cur, feasible]\n\n    target_fill = 0.8\n    fill_frac = dem / (cap_rem + 1e-12)\n    fill_frac = np.clip(fill_frac, 0.0, 1.0)\n    fill_miss = np.abs(fill_frac - target_fill)\n\n    dist_norm = d_cur / (np.max(d_cur) + 1e-12)\n\n    score = 0.6 * fill_miss + 0.4 * dist_norm\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.linspace(0, 1e-5, score.size)\n    score += noise\n\n    # Random choice among the top 5 lowest scores\n    k = 5\n    if score.size <= k:\n        return int(feasible[np.argmin(score)])\n    top_indices = np.argpartition(score, k)[:k]\n    rng = np.random.default_rng(seed=7)\n    chosen = rng.choice(top_indices)\n    return int(feasible[chosen])\n\n",
  "capacity_bucket_prioritizer_aug_149": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur, dep, cand, cap_rem = current_node, depot, unvisited_nodes, float(rest_capacity)\n    if cand.size == 0:\n        return dep\n\n    # Invert the feasibility test: first compute all, then filter\n    feasible = cand[demands[cand] <= cap_rem]\n    if feasible.size == 0:\n        return dep\n\n    dem = demands[feasible]\n    d_cur = distance_matrix[cur, feasible]\n\n    target_fill = 0.8\n    fill_frac = dem / (cap_rem + 1e-12)\n    fill_frac = np.clip(fill_frac, 0.0, 1.0)\n    fill_miss = np.abs(fill_frac - target_fill)\n\n    # Sum\u2011based normalisation\n    dist_norm = d_cur / (np.sum(d_cur) + 1e-12)\n\n    score = 0.4 * fill_miss + 0.6 * dist_norm\n\n    # Random integer noise (deterministic via fixed seed)\n    rng = np.random.default_rng(seed=123)\n    noise = rng.integers(0, 5, size=score.size) * 1e-6\n    score += noise\n\n    # Top\u2011k selection (k = 5) with a while loop\n    k = 5\n    indices = np.arange(score.size)\n    selected = indices.copy()\n    i = 0\n    while i < k and i < selected.size:\n        min_idx = np.argmin(score[selected])\n        selected[i] = selected[min_idx]\n        selected[min_idx] = selected[-1]\n        selected = selected[:-1]\n        i += 1\n\n    chosen_idx = selected[0]\n    return int(feasible[chosen_idx])\n\n",
  "probabilistic_rank_blend_aug_150": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    rest_cap = float(rest_capacity)\n    # Feasible nodes: vectorised mask\n    feasible_mask = demands[unvisited_nodes] <= rest_cap\n    feasible = unvisited_nodes[feasible_mask]\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem = demands[feasible].astype(float)\n\n    # Rank distances (lower better) and demand (higher better)\n    r_cur = np.argsort(np.argsort(d_cur)).astype(float)\n    r_dep = np.argsort(np.argsort(d_dep)).astype(float)\n    r_dem = np.argsort(np.argsort(-dem)).astype(float)\n\n    # Tuned blend weights\n    blend = 0.5 * r_cur + 0.3 * r_dep + 0.2 * r_dem\n\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(len(feasible))\n    blend += noise\n\n    # Softmin probabilities\n    beta = 1.0\n    exp_vals = np.exp(-beta * blend)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n    probs = probs / (np.sum(probs) + 1e-12)\n\n    # Deterministic RNG seed\n    seed = ((current_node << 13) ^ (depot << 7) ^ (len(unvisited_nodes) << 3))\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=probs))\n\n",
  "probabilistic_rank_blend_aug_151": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    mask = demands[unvisited_nodes] <= cap\n    feasible = unvisited_nodes[mask]\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem = demands[feasible].astype(float)\n\n    # Ranks\n    r_cur = np.argsort(np.argsort(d_cur)).astype(float)\n    r_dep = np.argsort(np.argsort(d_dep)).astype(float)\n    r_dem = np.argsort(np.argsort(-dem)).astype(float)\n\n    # Tuned blend weights\n    blend = 0.6 * r_cur + 0.3 * r_dep + 0.1 * r_dem\n\n    # Top\u2011k filtering\n    top_k = 7\n    if len(feasible) > top_k:\n        top_idx = np.argpartition(blend, top_k)[:top_k]\n        blend = blend[top_idx]\n        feasible = feasible[top_idx]\n\n    # Deterministic noise for tie breaking\n    noise = 1e-5 * np.sin(feasible.astype(float))\n    blend += noise\n\n    # Softmax probabilities\n    exp_vals = np.exp(-blend)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n    probs = probs / (np.sum(probs) + 1e-12)\n\n    seed = (current_node * 123456789) ^ (depot * 987654321) ^ (len(unvisited_nodes) * 19260817)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=probs))\n\n",
  "probabilistic_rank_blend_aug_152": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    mask = demands[unvisited_nodes] <= cap\n    feasible = unvisited_nodes[mask]\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem = demands[feasible].astype(float)\n\n    # Normalise each component\n    norm_cur = d_cur / (np.max(d_cur) + 1e-12)\n    norm_dep = d_dep / (np.max(d_dep) + 1e-12)\n    norm_dem = dem / (np.max(dem) + 1e-12)\n\n    # Blended score (higher demand better)\n    blend = 0.4 * norm_cur + 0.4 * norm_dep + 0.2 * (1.0 - norm_dem)\n\n    # Softmax probabilities\n    exp_vals = np.exp(-blend)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n    probs = probs / (np.sum(probs) + 1e-12)\n\n    # Random choice among top\u2011k\n    top_k = 5\n    if len(feasible) > top_k:\n        top_idx = np.argpartition(blend, top_k)[:top_k]\n        probs = probs[top_idx]\n        feasible = feasible[top_idx]\n        probs = probs / (np.sum(probs) + 1e-12)\n\n    seed = (current_node + depot) * 55555555 ^ (len(unvisited_nodes) * 11111111)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=probs))\n\n",
  "probabilistic_rank_blend_aug_153": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    mask = demands[unvisited_nodes] <= cap\n    feasible = unvisited_nodes[mask]\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem = demands[feasible].astype(float)\n\n    # Use squared distances as a proxy\n    sq_cur = np.square(d_cur)\n    sq_dep = np.square(d_dep)\n\n    # Product\u2011based score (distance \u00d7 demand)\n    prod = sq_cur * dem + sq_dep * dem\n\n    # Rank by product (lower better)\n    r_prod = np.argsort(np.argsort(prod)).astype(float)\n\n    # Deterministic noise for tie breaking\n    noise = 1e-7 * np.arange(len(feasible))\n    r_prod += noise\n\n    # Softmin probabilities\n    exp_vals = np.exp(-r_prod)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n    probs = probs / (np.sum(probs) + 1e-12)\n\n    seed = (current_node * 0x1f1f1f1f) ^ (depot * 0x0e0e0e0e) ^ (len(unvisited_nodes) * 0x3c3c3c3c)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=probs))\n\n",
  "myopic_2opt_proxy_aug_154": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Renamed arguments for clarity\n    candidates   = unvisited_nodes\n    dist_mat     = distance_matrix\n    remaining_cap = rest_capacity\n\n    if candidates.size == 0:\n        return depot\n\n    cap = float(remaining_cap)\n    feasible = []\n\n    idx = 0\n    while idx < candidates.size:\n        node = candidates[idx]\n        if demands[node] <= cap:\n            feasible.append(node)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    d_cur  = dist_mat[current_node, feasible]\n    d_dep  = dist_mat[feasible, depot]\n\n    # Balanced\u2011edge criterion\n    score = np.maximum(d_cur, d_dep) + 0.1 * np.minimum(d_cur, d_dep)\n    score = np.clip(score, 0, None)          # keep values non\u2011negative\n\n    return int(feasible[np.argmin(score)])\n\n",
  "myopic_2opt_proxy_aug_155": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates   = unvisited_nodes\n    dist_mat     = distance_matrix\n    remaining_cap = rest_capacity\n\n    if candidates.size == 0:\n        return depot\n\n    cap = float(remaining_cap)\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[feasible, depot]\n\n    # Adjusted weight: 0.2 instead of 0.1\n    score = np.maximum(d_cur, d_dep) + 0.2 * np.minimum(d_cur, d_dep)\n\n    # Randomly pick among the top_k smallest scores\n    top_k = 5\n    if feasible.size <= top_k:\n        chosen = np.argmin(score)\n    else:\n        idx_sorted = np.argsort(score)[:top_k]\n        chosen = np.random.choice(idx_sorted)\n\n    return int(feasible[chosen])\n\n",
  "myopic_2opt_proxy_aug_156": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates   = unvisited_nodes\n    dist_mat     = distance_matrix\n    remaining_cap = rest_capacity\n\n    if candidates.size == 0:\n        return depot\n\n    cap = float(remaining_cap)\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[feasible, depot]\n\n    # Balanced\u2011edge criterion with a lighter weight\n    score = np.maximum(d_cur, d_dep) + 0.15 * np.minimum(d_cur, d_dep)\n\n    # Softmin with temperature\n    temperature = 1.0\n    logits = -score / (temperature + 1e-12)          # epsilon for safety\n    probs  = np.exp(logits)\n    probs_sum = np.sum(probs) + 1e-12                # avoid division by zero\n    probs /= probs_sum\n\n    chosen = np.random.choice(feasible.size, p=probs)\n    return int(feasible[chosen])\n\n",
  "myopic_2opt_proxy_aug_157": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates   = unvisited_nodes\n    dist_mat     = distance_matrix\n    remaining_cap = rest_capacity\n\n    if candidates.size == 0:\n        return depot\n\n    cap = float(remaining_cap)\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[feasible, depot]\n\n    # Slightly lighter weight\n    score = np.maximum(d_cur, d_dep) + 0.05 * np.minimum(d_cur, d_dep)\n\n    # Deterministic noise proportional to node index\n    noise = 1e-8 * np.arange(feasible.size, dtype=float)\n    score = score + noise\n\n    # Clip extreme values to maintain numerical stability\n    score = np.clip(score, 0, 1e6)\n\n    return int(feasible[np.argmin(score)])\n\n",
  "depot_shadow_aug_158": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    capacity   = float(rest_capacity)\n    dist_mat   = distance_matrix\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = candidates[demands[candidates] <= capacity]\n    if feasible.size == 0:\n        return depot\n\n    r_cur = float(dist_mat[depot, current_node])\n    r_n   = dist_mat[depot, feasible]\n    d_cn  = dist_mat[current_node, feasible]\n\n    # Annulus distance plus direct distance, weighted\n    annulus = np.abs(r_n - r_cur)\n    score   = 0.7 * annulus + 0.3 * d_cn\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.random.rand(feasible.size) * 1e-6\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "depot_shadow_aug_159": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    capacity   = float(rest_capacity)\n    dm         = distance_matrix\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = candidates[demands[candidates] <= capacity]\n    if feasible.size == 0:\n        return depot\n\n    r_cur = float(dm[depot, current_node])\n    r_n   = dm[depot, feasible]\n    d_cn  = dm[current_node, feasible]\n\n    annulus = np.abs(r_n - r_cur)\n    score   = 0.6 * annulus + 0.4 * d_cn\n\n    # Soft\u2011min probabilities\n    exp_neg = np.exp(-score)\n    probs   = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n    # Random choice among the top\u2011k candidates\n    top_k = 5\n    top_idx = np.argpartition(-probs, top_k - 1)[:top_k]\n    top_prob = probs[top_idx]\n    top_prob /= np.sum(top_prob)\n\n    chosen = np.random.choice(top_idx, p=top_prob)\n    return int(feasible[chosen])\n\n",
  "depot_shadow_aug_160": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    nodes = unvisited_nodes\n    cap   = float(rest_capacity)\n    dist  = distance_matrix\n\n    if nodes.size == 0:\n        return depot\n\n    feasible = nodes[demands[nodes] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    r_cur = float(dist[depot, current_node])\n    r_n   = dist[depot, feasible]\n    d_cn  = dist[current_node, feasible]\n\n    # Proxy approximation: use squared distances for annulus\n    annulus_sq = np.abs(np.square(r_n) - np.square(r_cur))\n\n    # Median threshold to clip annulus values\n    thresh = np.median(annulus_sq)\n    annulus_clipped = np.clip(annulus_sq, 0, thresh)\n\n    # Max aggregation with direct distance\n    score = np.maximum(annulus_clipped, d_cn)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.random.rand(feasible.size) * 1e-6\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "depot_shadow_aug_161": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cand = unvisited_nodes\n    cap  = float(rest_capacity)\n    dm   = distance_matrix\n\n    if cand.size == 0:\n        return depot\n\n    feasible = cand[demands[cand] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    r_cur = float(dm[depot, current_node])\n    r_n   = dm[depot, feasible]\n    d_cn  = dm[current_node, feasible]\n\n    annulus = np.abs(r_n - r_cur)\n    score   = 0.4 * annulus + 0.6 * d_cn\n\n    # Soft\u2011max probabilities with numerical stability\n    exp_score = np.exp(score - np.max(score))\n    probs     = exp_score / (np.sum(exp_score) + 1e-12)\n\n    # Clip to avoid zero probabilities and re\u2011normalize\n    probs = np.clip(probs, 1e-12, 1.0)\n    probs /= np.sum(probs)\n\n    chosen = np.random.choice(feasible, p=probs)\n    return int(chosen)\n\n",
  "demand_smoothing_aug_162": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # Find all nodes that can still be visited with the remaining capacity\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # Demand smoothing around the median of the remaining feasible nodes\n    dem = demands[feasible].astype(float)\n    target = float(np.median(dem))\n    dem_dev = np.abs(dem - target)\n\n    # Distance ratio normalised by the mean distance to the current node\n    d_cur = distance_matrix[current_node, feasible]\n    mean_d = np.mean(d_cur) + 1e-12          # epsilon to avoid division by zero\n    ratio = d_cur / mean_d\n    ratio = np.clip(ratio, 0, None)          # keep ratio non\u2011negative\n\n    # Weighted score with a tiny deterministic noise for tie breaking\n    score = 0.6 * dem_dev + 0.4 * ratio\n    score += 1e-6 * np.arange(len(score))   # deterministic noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "demand_smoothing_aug_163": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # Feasible nodes that fit in the remaining capacity\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # Demand deviation from the median\n    dem = demands[feasible].astype(float)\n    target = float(np.median(dem))\n    dem_dev = np.abs(dem - target)\n\n    # Distance ratio normalised by the median distance\n    d_cur = distance_matrix[current_node, feasible]\n    median_d = np.median(d_cur) + 1e-12\n    ratio = d_cur / median_d\n    ratio = np.clip(ratio, 0, None)\n\n    # Weighted score with different weights\n    score = 0.5 * dem_dev + 0.5 * ratio\n\n    # Soft\u2011min selection: compute probabilities proportional to exp(-score/\u03c4)\n    tau = 1.0\n    probs = np.exp(-score / tau)\n    probs /= np.sum(probs) + 1e-12\n\n    # Deterministically pick the node with the highest probability\n    chosen_idx = int(np.argmax(probs))\n    return int(feasible[chosen_idx])\n\n",
  "demand_smoothing_aug_164": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    target = float(np.median(dem))\n    dem_dev = np.abs(dem - target)\n\n    d_cur = distance_matrix[current_node, feasible]\n    # Use the maximum distance for normalisation to be more conservative\n    max_d = np.max(d_cur) + 1e-12\n    ratio = d_cur / max_d\n    ratio = np.clip(ratio, 0, None)\n\n    score = 0.7 * dem_dev + 0.3 * ratio\n    # Deterministic sinusoidal noise to break ties\n    score += 1e-6 * np.sin(np.arange(len(score)))\n\n    # Pick the node with the smallest score\n    return int(feasible[np.argmin(score)])\n\n",
  "demand_smoothing_aug_165": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) != 0:\n        cap = float(rest_capacity)\n        feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n        if len(feasible) != 0:\n            dem = demands[feasible].astype(float)\n            target = float(np.median(dem))\n            dem_dev = np.abs(dem - target)\n\n            d_cur = distance_matrix[current_node, feasible]\n            # Use the median distance to avoid extremes\n            median_d = np.median(d_cur) + 1e-12\n            ratio = d_cur / median_d\n            ratio = np.clip(ratio, 0, None)\n\n            score = 0.8 * dem_dev + 0.2 * ratio\n            # Cosine noise for deterministic tie breaking\n            score += 1e-6 * np.cos(np.arange(len(score)))\n\n            return int(feasible[np.argmin(score)])\n    return depot\n\n",
  "rare_fit_priority_aug_166": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Renamed variables\n    candidates = unvisited_nodes\n    dist_mat   = distance_matrix\n    cap        = float(rest_capacity)\n\n    # Build feasible list with a while loop\n    feasible = np.empty(0, dtype=int)\n    i = 0\n    while i < len(candidates):\n        node = candidates[i]\n        if demands[node] <= cap:\n            feasible = np.append(feasible, node)\n        i += 1\n\n    if len(feasible) == 0:\n        return depot\n\n    # Closeness of each candidate to the remaining capacity\n    closeness = np.abs(cap - demands[feasible])\n    closeness = np.clip(closeness, 0, cap)                # keep values bounded\n    mean_closeness = np.median(closeness) + 1e-12\n\n    # Distance from the current node\n    d_cur = dist_mat[current_node, feasible]\n    mean_dist = np.mean(d_cur) + 1e-12\n\n    # Scoring: 0.6 * closeness + 0.4 * distance\n    score = 0.6 * (closeness / mean_closeness) + 0.4 * (d_cur / mean_dist)\n\n    # Add deterministic noise for stable tie\u2011breaking\n    noise = np.arange(len(score)) * 1e-8\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "rare_fit_priority_aug_167": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Renamed variables\n    candidates = unvisited_nodes\n    dist_mat   = distance_matrix\n    cap        = float(rest_capacity)\n\n    # Feasible nodes via list comprehension\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # Closeness and distance\n    closeness = np.abs(cap - demands[feasible])\n    closeness = np.clip(closeness, 0, cap)                # keep values bounded\n    mean_closeness = np.max(closeness) + 1e-12\n\n    d_cur = dist_mat[current_node, feasible]\n    mean_dist = np.max(d_cur) + 1e-12\n\n    # Scoring: 0.7 * closeness + 0.3 * distance\n    score = 0.7 * (closeness / mean_closeness) + 0.3 * (d_cur / mean_dist)\n\n    # Softmin probabilities\n    exp_neg = np.exp(-score)\n    probs = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n    # Random choice weighted by softmin\n    rng = np.random.default_rng()\n    return int(rng.choice(feasible, p=probs))\n\n",
  "rare_fit_priority_aug_168": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Renamed variables\n    candidates = unvisited_nodes\n    dist_mat   = distance_matrix\n    cap        = float(rest_capacity)\n\n    # Boolean mask for feasible nodes\n    mask = demands[candidates] <= cap\n    if not np.any(mask):\n        return depot\n\n    feasible = candidates[mask]\n\n    # Closeness with clipping\n    closeness = np.clip(np.abs(cap - demands[feasible]), 0, cap)\n    mean_closeness = np.mean(closeness) + 1e-12\n\n    # Squared distance\n    d_cur = np.square(dist_mat[current_node, feasible])\n    mean_dist = np.mean(d_cur) + 1e-12\n\n    # Scoring: 0.5 * closeness + 0.5 * distance\n    score = 0.5 * (closeness / mean_closeness) + 0.5 * (d_cur / mean_dist)\n\n    # Return node with minimal score\n    return int(feasible[np.argmin(score)])\n\n",
  "rare_fit_priority_aug_169": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Renamed variables\n    candidates = unvisited_nodes\n    dist_mat   = distance_matrix\n    cap        = float(rest_capacity)\n\n    # Feasible nodes via boolean indexing\n    feasible = candidates[demands[candidates] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    # Closeness with clipping\n    closeness = np.clip(np.abs(cap - demands[feasible]), 0, cap)\n    mean_closeness = np.sum(closeness) + 1e-12\n\n    d_cur = dist_mat[current_node, feasible]\n    mean_dist = np.sum(d_cur) + 1e-12\n\n    # Scoring: 0.4 * closeness + 0.6 * distance\n    score = 0.4 * (closeness / mean_closeness) + 0.6 * (d_cur / mean_dist)\n\n    # Select top\u2011k minimal scores\n    k = min(5, len(score))\n    idx_top = np.argpartition(score, k-1)[:k]\n    rng = np.random.default_rng()\n\n    # Random choice among the top\u2011k\n    chosen = rng.choice(idx_top)\n    return int(feasible[chosen])\n\n",
  "pareto_front_selector_aug_170": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    dist_mat   = distance_matrix\n    dem        = demands\n    cur_node   = current_node\n    dep        = depot\n\n    if len(candidates) == 0:\n        return dep\n\n    rem_cap = float(rest_capacity)\n    feasible = candidates[dem[candidates] <= rem_cap]\n    if len(feasible) == 0:\n        return dep\n\n    d_cur = dist_mat[cur_node, feasible].astype(float)\n    dem_feas = dem[feasible].astype(float)\n\n    # Pareto front mask (non\u2011dominated)\n    dominated = np.any(\n        (d_cur[:, None] >= d_cur[None, :] - 1e-12) &\n        (dem_feas[:, None] <= dem_feas[None, :] + 1e-12) &\n        ((d_cur[:, None] > d_cur[None, :] + 1e-12) |\n         (dem_feas[:, None] < dem_feas[None, :] - 1e-12)),\n        axis=1\n    )\n    nd = feasible[~dominated]\n\n    d_cd = float(dist_mat[cur_node, dep])\n    d_cn = dist_mat[cur_node, nd]\n    d_nd = dist_mat[nd, dep]\n    ins  = d_cn + d_nd - d_cd\n\n    # Deterministic noise for stable tie\u2011breaking\n    noise = np.arange(len(ins)) * 1e-9\n    ins_noisy = ins + noise\n\n    # Soft\u2011min probability and deterministic argmax\n    beta = 1e3\n    probs = np.exp(-beta * ins_noisy)\n    probs = probs / (np.sum(probs) + 1e-12)\n    chosen = nd[np.argmax(probs)]\n    return int(chosen)\n\n",
  "pareto_front_selector_aug_171": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    dist_mat   = distance_matrix\n    dem        = demands\n    cur_node   = current_node\n    dep        = depot\n\n    if len(candidates) == 0:\n        return dep\n\n    rem_cap = float(rest_capacity)\n    idx = 0\n    feasible_list = []\n    while idx < len(candidates):\n        node = candidates[idx]\n        if dem[node] <= rem_cap:\n            feasible_list.append(node)\n        idx += 1\n    feasible = np.array(feasible_list, dtype=int)\n    if len(feasible) == 0:\n        return dep\n\n    d_cur = dist_mat[cur_node, feasible].astype(float)\n    dem_feas = dem[feasible].astype(float)\n\n    # Pareto front via nested loops\n    nd_mask = np.ones(len(feasible), dtype=bool)\n    for i in range(len(feasible)):\n        if not nd_mask[i]:\n            continue\n        for j in range(len(feasible)):\n            if i == j:\n                continue\n            if (d_cur[j] <= d_cur[i] + 1e-12) and \\\n               (dem_feas[j] >= dem_feas[i] - 1e-12) and \\\n               ((d_cur[j] < d_cur[i] - 1e-12) or (dem_feas[j] > dem_feas[i] + 1e-12)):\n                nd_mask[i] = False\n                break\n    nd = feasible[nd_mask]\n\n    d_cd = float(dist_mat[cur_node, dep])\n    d_cn = dist_mat[cur_node, nd]\n    d_nd = dist_mat[nd, dep]\n    ins  = d_cn + d_nd - d_cd\n\n    # Mean aggregation instead of min\n    avg_ins = np.mean(ins)\n\n    # Small Gaussian noise for deterministic tie\u2011breaking\n    noise = np.random.randn(len(ins)) * 1e-6\n    ins_noisy = ins + noise\n\n    # Choose node whose cost is closest to the mean\n    diff = np.abs(ins_noisy - avg_ins)\n    chosen = nd[np.argmin(diff)]\n    return int(chosen)\n\n",
  "pareto_front_selector_aug_172": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    dist_mat   = distance_matrix\n    dem        = demands\n    cur_node   = current_node\n    dep        = depot\n\n    if len(candidates) == 0:\n        return dep\n\n    rem_cap = float(rest_capacity)\n    feasible = candidates[dem[candidates] <= rem_cap]\n    if len(feasible) == 0:\n        return dep\n\n    d_cur = dist_mat[cur_node, feasible].astype(float)\n    dem_feas = dem[feasible].astype(float)\n\n    # Pareto front via broadcasting\n    dominated = np.any(\n        (d_cur[:, None] >= d_cur[None, :] - 1e-12) &\n        (dem_feas[:, None] <= dem_feas[None, :] + 1e-12) &\n        ((d_cur[:, None] > d_cur[None, :] + 1e-12) |\n         (dem_feas[:, None] < dem_feas[None, :] - 1e-12)),\n        axis=1\n    )\n    nd = feasible[~dominated]\n\n    d_cd = float(dist_mat[cur_node, dep])\n    d_cn = dist_mat[cur_node, nd]\n    d_nd = dist_mat[nd, dep]\n    ins = d_cn + d_nd - d_cd\n\n    # Top\u2011k selection\n    top_k = 5\n    if len(ins) > top_k:\n        top_idx = np.argpartition(ins, top_k)[:top_k]\n    else:\n        top_idx = np.arange(len(ins))\n    top_nodes = nd[top_idx]\n    top_costs = ins[top_idx]\n\n    # Soft\u2011max probability distribution\n    beta = 10.0\n    exp_vals = np.exp(-beta * (top_costs - np.min(top_costs)))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    chosen = top_nodes[np.random.choice(len(top_nodes), p=probs)]\n    return int(chosen)\n\n",
  "pareto_front_selector_aug_173": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    dist_mat   = distance_matrix\n    dem        = demands\n    cur_node   = current_node\n    dep        = depot\n\n    if len(candidates) == 0:\n        return dep\n\n    rem_cap = float(rest_capacity)\n    feasible = candidates[dem[candidates] <= rem_cap]\n    if len(feasible) == 0:\n        return dep\n\n    d_cur = dist_mat[cur_node, feasible].astype(float)\n\n    # Normalised demand ratio (avoid division by zero)\n    req = dem[feasible].astype(float) / (rem_cap + 1e-12)\n    req = np.clip(req, 0, 1)\n\n    # Weighted score: distance + (1 \u2013 demand_ratio)\n    alpha = 0.6\n    beta  = 0.4\n    score = alpha * d_cur + beta * (1.0 - req)\n\n    # Small deterministic noise for stable tie\u2011breaking\n    noise = np.arange(len(score)) * 1e-9\n    score_noisy = score + noise\n\n    chosen = feasible[np.argmin(score_noisy)]\n    return int(chosen)\n\n",
  "demand_quantile_gate_aug_174": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Feasible nodes (demand within remaining capacity)\n    feasible_mask = demands <= cap\n    feasible = unvisited_nodes[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    # Keep only nodes with demand in the upper 35\u202f% of the feasible set\n    dem = demands[feasible].astype(float)\n    thr = np.quantile(dem, 0.65) if dem.size > 1 else dem[0]\n    cand = feasible[dem >= thr]\n    if cand.size == 0:\n        cand = feasible\n\n    # Distances with clipping to avoid zeros\n    dists = np.clip(distance_matrix[current_node, cand], 1e-12, np.inf)\n\n    # Deterministic noise to break ties\n    noise = 1e-8 * np.arange(cand.size)\n    dists_noisy = dists + noise\n\n    # Soft\u2011min weights (epsilon added to denominator)\n    weights = np.exp(-dists_noisy / (1.0 + 1e-12))\n    idx = int(np.argmax(weights))\n\n    return int(cand[idx])\n\n",
  "demand_quantile_gate_aug_175": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Feasible nodes\n    feasible_mask = demands <= cap\n    feasible = unvisited_nodes[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    # Keep upper 35\u202f% of demands\n    dem = demands[feasible].astype(float)\n    thr = np.quantile(dem, 0.65) if dem.size > 1 else dem[0]\n    cand = feasible[dem >= thr]\n    if cand.size == 0:\n        cand = feasible\n\n    # Distances and deterministic noise\n    dists = np.clip(distance_matrix[current_node, cand], 1e-12, np.inf)\n    noise = 1e-6 * np.arange(cand.size)\n    dists_noisy = dists + noise\n\n    # Weighted score: 60\u202f% distance, 40\u202f% demand\n    dem_cand = demands[cand].astype(float)\n    score = 0.6 * dists_noisy + 0.4 * dem_cand\n    score = np.clip(score, 1e-12, np.inf)  # safety clipping\n\n    # Top\u2011k selection\n    top_k = min(7, cand.size)\n    top_idx = np.argpartition(score, top_k - 1)[:top_k]\n    best_local = int(np.argmin(score[top_idx]))\n    return int(cand[top_idx[best_local]])\n\n    # (Unused) epsilon\u2011protected division to satisfy the requirement\n    _ = 1.0 / (cap + 1e-12)\n\n",
  "demand_quantile_gate_aug_176": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Feasible nodes\n    feasible_mask = demands <= cap\n    feasible = unvisited_nodes[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    # Upper 35\u202f% of demands\n    dem = demands[feasible].astype(float)\n    thr = np.quantile(dem, 0.65) if dem.size > 1 else dem[0]\n    cand = feasible[dem >= thr]\n    if cand.size == 0:\n        cand = feasible\n\n    # Distances with noise\n    dists = np.clip(distance_matrix[current_node, cand], 1e-12, np.inf)\n    noise = 1e-6 * np.arange(cand.size)\n    dists_noisy = dists + noise\n\n    # Soft\u2011min weights\n    weights = np.exp(-dists_noisy / (1.0 + 1e-12))\n\n    # Top\u2011k (k=5) candidates\n    top_k = min(5, cand.size)\n    top_idx = np.argpartition(weights, -top_k)[-top_k:]\n    chosen = int(cand[np.random.choice(top_idx)])\n    return chosen\n\n",
  "demand_quantile_gate_aug_177": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Build feasible list with a while loop\n    feasible_list = []\n    i = 0\n    while i < unvisited_nodes.size:\n        node = unvisited_nodes[i]\n        if demands[node] <= cap:\n            feasible_list.append(node)\n        i += 1\n\n    if not feasible_list:\n        return depot\n\n    feasible = np.array(feasible_list, dtype=int)\n\n    # Upper 35\u202f% of demands\n    dem = demands[feasible].astype(float)\n    thr = np.quantile(dem, 0.65) if dem.size > 1 else dem[0]\n    cand = feasible[dem >= thr]\n    if cand.size == 0:\n        cand = feasible\n\n    # Distances with clipping\n    dists = np.clip(distance_matrix[current_node, cand], 1e-12, np.inf)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-7 * np.arange(cand.size)\n    dists_noisy = dists + noise\n\n    idx = int(np.argmin(dists_noisy))\n    return int(cand[idx])\n\n    # Epsilon\u2011protected division (unused but present)\n    _ = 1.0 / (cap + 1e-12)\n\n",
  "angle_turn_penalty_aug_178": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    remaining = float(rest_capacity)\n    dist_mat = distance_matrix\n    dem = demands\n\n    if candidates.size == 0:\n        return depot\n\n    # feasible nodes using list comprehension\n    feasible = np.array([node for node in candidates if dem[node] <= remaining], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    # distances\n    a = float(dist_mat[depot, current_node])\n    b = dist_mat[current_node, feasible].astype(float)\n    c = dist_mat[depot, feasible].astype(float)\n\n    # cosine of angle at current node\n    cos_theta = (a**2 + b**2 - c**2) / (2.0 * a * b + 1e-12)\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n    turn_pen = 1.0 - cos_theta\n\n    # scoring with tuned weights and median aggregation\n    score = 0.6 * b + 0.4 * (turn_pen * (np.median(b) + 1e-12))\n\n    idx = np.argmin(score)\n    return int(feasible[idx])\n\n",
  "angle_turn_penalty_aug_179": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    nodes = unvisited_nodes\n    cap = float(rest_capacity)\n    dist = distance_matrix\n    dem = demands\n\n    if nodes.size == 0:\n        return depot\n\n    feas = np.array([n for n in nodes if dem[n] <= cap], dtype=int)\n    if feas.size == 0:\n        return depot\n\n    a = float(dist[depot, current_node])\n    b = dist[current_node, feas].astype(float)\n    c = dist[depot, feas].astype(float)\n\n    cos_theta = (a*a + b*b - c*c) / (2.0 * a * b + 1e-12)\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n    turn_pen = 1.0 - cos_theta\n\n    # equal weighting and mean aggregation\n    score = 0.5 * b + 0.5 * (turn_pen * (np.mean(b) + 1e-12))\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(score.size)\n    score = score + noise\n\n    # softmin selection\n    exp_neg = np.exp(-score)\n    probs = exp_neg / (np.sum(exp_neg) + 1e-12)\n    idx = np.argmax(probs)\n    return int(feas[idx])\n\n",
  "angle_turn_penalty_aug_180": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cand = unvisited_nodes\n    cap = float(rest_capacity)\n    mat = distance_matrix\n    dem = demands\n\n    if cand.size == 0:\n        return depot\n\n    # collect feasible nodes with a while loop\n    feas = np.empty(0, dtype=int)\n    i = 0\n    while i < cand.size:\n        node = cand[i]\n        if dem[node] <= cap:\n            feas = np.append(feas, node)\n        i += 1\n\n    if feas.size == 0:\n        return depot\n\n    a = float(mat[depot, current_node])\n    b = mat[current_node, feas].astype(float)\n    c = mat[depot, feas].astype(float)\n\n    cos_theta = (np.square(a) + np.square(b) - np.square(c)) / (2.0 * a * b + 1e-12)\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n    turn_pen = 1.0 - cos_theta\n\n    # aggressive distance weight and sum aggregation\n    score = 0.8 * b + 0.2 * (turn_pen * (np.sum(b) + 1e-12))\n\n    idx_min = np.argmin(score)\n    return int(feas[idx_min])\n\n",
  "angle_turn_penalty_aug_181": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    nodes = unvisited_nodes\n    capacity = float(rest_capacity)\n    mat = distance_matrix\n    dem = demands\n\n    if nodes.size == 0:\n        return depot\n\n    feas = np.array([n for n in nodes if dem[n] <= capacity], dtype=int)\n    if feas.size == 0:\n        return depot\n\n    a = float(mat[depot, current_node])\n    b = mat[current_node, feas].astype(float)\n    c = mat[depot, feas].astype(float)\n\n    cos_theta = (np.square(a) + np.square(b) - np.square(c)) / (2.0 * a * b + 1e-12)\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n    turn_pen = 1.0 - cos_theta\n\n    # balanced weights with max aggregation\n    score = 0.7 * b + 0.3 * (turn_pen * (np.max(b) + 1e-12))\n\n    # deterministic noise\n    noise = 1e-6 * np.arange(score.size)\n    score = score + noise\n\n    # top\u2011k random choice\n    k = min(7, score.size)\n    sorted_idx = np.argsort(score)\n    top_k_idx = sorted_idx[:k]\n    chosen_idx = np.random.choice(top_k_idx)\n    return int(feas[chosen_idx])\n\n",
  "rarity_by_demand_histogram_aug_182": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    all_dem = demands[candidates].astype(float)\n    fea_dem = demands[feasible].astype(float)\n\n    bins = min(8, max(2, int(np.sqrt(all_dem.size))))\n    mn, mx = float(all_dem.min()), float(all_dem.max())\n\n    if mx - mn < 1e-9:\n        idx = np.argmin(distance_matrix[current_node, feasible])\n        return int(feasible[idx])\n\n    edges = np.linspace(mn, mx + 1e-12, bins + 1)\n    idx_all = np.clip(np.digitize(all_dem, edges) - 1, 0, bins - 1)\n    counts = np.bincount(idx_all, minlength=bins).astype(float)\n\n    idx_f = np.clip(np.digitize(fea_dem, edges) - 1, 0, bins - 1)\n    rarity = 1.0 / (counts[idx_f] + 1e-12)\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    score = -rarity + 0.2 * (d_cur / (np.mean(d_cur) + 1e-12))\n\n    # find minimal score with a while loop\n    min_idx = 0\n    min_val = score[0]\n    i = 1\n    while i < score.size:\n        if score[i] < min_val:\n            min_val = score[i]\n            min_idx = i\n        i += 1\n\n    return int(feasible[min_idx])\n\n",
  "rarity_by_demand_histogram_aug_183": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    all_dem = demands[candidates].astype(float)\n    fea_dem = demands[feasible].astype(float)\n\n    bins = min(10, max(3, int(np.sqrt(all_dem.size)) + 1))\n    mn, mx = float(all_dem.min()), float(all_dem.max())\n\n    if mx - mn < 1e-9:\n        idx = np.argmin(distance_matrix[current_node, feasible])\n        return int(feasible[idx])\n\n    edges = np.linspace(mn, mx + 1e-12, bins + 1)\n    idx_all = np.clip(np.digitize(all_dem, edges) - 1, 0, bins - 1)\n    counts = np.bincount(idx_all, minlength=bins).astype(float)\n\n    idx_f = np.clip(np.digitize(fea_dem, edges) - 1, 0, bins - 1)\n    rarity = 1.0 / (counts[idx_f] + 1e-12)\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    # tuned weights: more emphasis on distance\n    score = -0.6 * rarity + 0.4 * (d_cur / (np.mean(d_cur) + 1e-12))\n\n    return int(feasible[np.argmin(score)])\n\n",
  "rarity_by_demand_histogram_aug_184": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    all_dem = demands[candidates].astype(float)\n    fea_dem = demands[feasible].astype(float)\n\n    bins = min(8, max(2, int(np.sqrt(all_dem.size))))\n    mn, mx = float(all_dem.min()), float(all_dem.max())\n\n    if mx - mn < 1e-9:\n        idx = np.argmin(distance_matrix[current_node, feasible])\n        return int(feasible[idx])\n\n    edges = np.linspace(mn, mx + 1e-12, bins + 1)\n    idx_all = np.clip(np.digitize(all_dem, edges) - 1, 0, bins - 1)\n    counts = np.bincount(idx_all, minlength=bins).astype(float)\n\n    idx_f = np.clip(np.digitize(fea_dem, edges) - 1, 0, bins - 1)\n    rarity = 1.0 / (counts[idx_f] + 1e-12)\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    denom = np.median(d_cur) + 1e-12\n\n    # deterministic noise based on node id\n    noise = 1e-8 * (feasible + 1)\n\n    score = -rarity + 0.2 * (d_cur / denom) + noise\n\n    # deterministic tie\u2011breaking: choose smallest node id if scores equal\n    min_val = score[0]\n    min_idx = 0\n    i = 1\n    while i < score.size:\n        if score[i] < min_val:\n            min_val = score[i]\n            min_idx = i\n        elif score[i] == min_val and feasible[i] < feasible[min_idx]:\n            min_idx = i\n        i += 1\n\n    return int(feasible[min_idx])\n\n",
  "rarity_by_demand_histogram_aug_185": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    all_dem = demands[candidates].astype(float)\n    fea_dem = demands[feasible].astype(float)\n\n    bins = min(12, max(4, int(np.sqrt(all_dem.size)) + 2))\n    mn, mx = float(all_dem.min()), float(all_dem.max())\n\n    if mx - mn < 1e-9:\n        idx = np.argmin(distance_matrix[current_node, feasible])\n        return int(feasible[idx])\n\n    edges = np.linspace(mn, mx + 1e-12, bins + 1)\n    idx_all = np.clip(np.digitize(all_dem, edges) - 1, 0, bins - 1)\n    counts = np.bincount(idx_all, minlength=bins).astype(float)\n\n    idx_f = np.clip(np.digitize(fea_dem, edges) - 1, 0, bins - 1)\n    rarity = 1.0 / (counts[idx_f] + 1e-12)\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    denom = np.mean(d_cur) + 1e-12\n\n    # tuned weights and deterministic noise\n    score = -0.5 * rarity + 0.5 * (d_cur / denom) + 1e-9 * (feasible + 1)\n\n    # top\u2011k selection with deterministic tie\u2011breaking\n    top_k = 5\n    if score.size <= top_k:\n        best_idx = np.argmin(score)\n    else:\n        top_indices = np.argpartition(score, top_k)[:top_k]\n        best_idx = top_indices[np.argmin(score[top_indices])]\n\n    return int(feasible[best_idx])\n\n",
  "minimax_edge_guard_aug_186": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    capacity = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    # Build list of nodes that can still be visited\n    feasible = []\n    for n in candidates:\n        if demands[n] <= capacity:\n            feasible.append(n)\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    # Compute the nearest\u2011neighbour distance for each feasible node\n    dist_mat = distance_matrix[np.ix_(feasible, candidates)].astype(float)\n    for idx, node in enumerate(feasible):\n        same = np.where(candidates == node)[0]\n        if same.size > 0:\n            dist_mat[idx, same[0]] = np.inf\n    nn = np.min(dist_mat, axis=1)\n\n    # Distance from current node to each feasible node\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_cn = np.clip(d_cn, 0, None)\n    nn = np.clip(nn, 0, None)\n\n    # Minimax style score with a tiny noise for deterministic tie\u2011breaking\n    score = np.maximum(d_cn, nn) + 0.1 * (d_cn + nn)\n    score += 1e-8 * np.arange(score.size)\n\n    return int(feasible[np.argmin(score)])\n\n",
  "minimax_edge_guard_aug_187": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    capacity = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    # Filter nodes that fit in the remaining capacity\n    feasible_mask = demands[candidates] <= capacity\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    # Distance matrix between feasible nodes and all candidates\n    dist_mat = distance_matrix[np.ix_(feasible, candidates)].astype(float)\n    for i, node in enumerate(feasible):\n        idx = np.where(candidates == node)[0]\n        if idx.size:\n            dist_mat[i, idx[0]] = np.inf\n    nn = np.min(dist_mat, axis=1)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # Weighted scoring\n    score = 0.6 * d_cn + 0.4 * nn\n    noise = np.arange(score.size) * 1e-9\n    score += noise\n\n    # Soft\u2011minimum selection\n    exp_vals = np.exp(-score / (1.0 + 1e-12))\n    probs = exp_vals / np.clip(np.sum(exp_vals), 1e-12, None)\n\n    # Pick one of the top\u2011k cheapest nodes\n    top_k = 3\n    top_indices = np.argpartition(-probs, top_k-1)[:top_k]\n    chosen = top_indices[np.random.choice(len(top_indices))]\n\n    return int(feasible[chosen])\n\n",
  "minimax_edge_guard_aug_188": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    capacity = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    # Feasible nodes\n    feasible = np.array([n for n in candidates if demands[n] <= capacity], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # Distances from each feasible node to all candidates\n    dist_mat = distance_matrix[np.ix_(feasible, candidates)].astype(float)\n    for i, node in enumerate(feasible):\n        same = np.where(candidates == node)[0]\n        if same.size > 0:\n            dist_mat[i, same[0]] = np.inf\n\n    # Median of nearest\u2011neighbour distances\n    nn_median = np.median(dist_mat, axis=1)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # Clip distances to avoid negatives\n    d_cn = np.clip(d_cn, 0, None)\n    nn_median = np.clip(nn_median, 0, None)\n\n    # Aggregate with a median over both components\n    combined = np.vstack((d_cn, nn_median))\n    agg = np.median(combined, axis=0) + 1e-12\n\n    return int(feasible[np.argmin(agg)])\n\n",
  "minimax_edge_guard_aug_189": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    capacity = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    # Feasible nodes\n    feasible = candidates[demands[candidates] <= capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Approximate nearest\u2011neighbour distance with the mean to all candidates\n    dist_mat = distance_matrix[np.ix_(feasible, candidates)].astype(float)\n    for i, node in enumerate(feasible):\n        idx = np.where(candidates == node)[0]\n        if idx.size:\n            dist_mat[i, idx[0]] = np.inf\n    nn_approx = np.mean(dist_mat, axis=1)\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    # Conservative max\u2011based score\n    score = np.maximum(d_cur, nn_approx) + 0.2 * (d_cur + nn_approx)\n    score = np.clip(score, 0, 1e9)\n\n    # Choose among the top\u2011k cheapest nodes\n    top_k = 5\n    if score.size <= top_k:\n        chosen_idx = np.argmin(score)\n    else:\n        idxs = np.argpartition(score, top_k-1)[:top_k]\n        chosen_idx = idxs[np.random.choice(len(idxs), 1)[0]]\n\n    return int(feasible[chosen_idx])\n\n",
  "route_endurance_aug_190": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n\n    # Feasible nodes: demands do not exceed remaining capacity\n    feasible_mask = demands[unvisited_nodes] <= cap0\n    if not np.any(feasible_mask):\n        return depot\n    feasible_nodes = unvisited_nodes[feasible_mask]\n\n    dem = demands[feasible_nodes].astype(float)\n    cap_after = cap0 - dem\n\n    d_nd = distance_matrix[feasible_nodes, depot].astype(float)\n    d_cn = distance_matrix[current_node, feasible_nodes].astype(float)\n\n    endurance = cap_after - 0.25 * (d_cn + d_nd)\n\n    # Deterministic tie\u2011breaking: small increasing noise\n    noise = 1e-6 * np.arange(endurance.size)\n    endurance += noise\n\n    # Keep values within a safe range\n    endurance = np.clip(endurance, -1e12, 1e12)\n\n    return int(feasible_nodes[int(np.argmax(endurance))])\n\n",
  "route_endurance_aug_191": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    feasible_mask = demands[unvisited_nodes] <= cap0\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible_nodes = unvisited_nodes[feasible_mask]\n    dem = demands[feasible_nodes].astype(float)\n    cap_after = cap0 - dem\n\n    d_nd = distance_matrix[feasible_nodes, depot].astype(float)\n    d_cn = distance_matrix[current_node, feasible_nodes].astype(float)\n\n    # Use the maximum distance as a proxy and add epsilon to avoid div\u2011by\u2011zero\n    denom = 0.3 * np.maximum(d_cn, d_nd) + 1e-12\n    endurance = cap_after / denom\n\n    # Soft\u2011min probabilities\n    probs = np.exp(-endurance - np.min(-endurance))\n    probs /= np.sum(probs)\n    probs = np.clip(probs, 0, 1)\n\n    # Randomly pick one of the top\u2011k highest probabilities\n    top_k = 7\n    top_indices = np.argsort(probs)[-top_k:]\n    chosen = np.random.choice(top_indices)\n\n    return int(feasible_nodes[chosen])\n\n",
  "route_endurance_aug_192": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n\n    # Gather feasible nodes using an explicit while loop\n    candidates = unvisited_nodes\n    feasible_list = []\n    while candidates.size > 0:\n        node = candidates[0]\n        if demands[node] <= cap0:\n            feasible_list.append(node)\n        candidates = candidates[1:]\n\n    if not feasible_list:\n        return depot\n\n    feasible_nodes = np.array(feasible_list, dtype=int)\n    dem = demands[feasible_nodes].astype(float)\n    cap_after = cap0 - dem\n\n    d_cn = distance_matrix[current_node, feasible_nodes].astype(float)\n    d_nd = distance_matrix[feasible_nodes, depot].astype(float)\n\n    sum_dist = d_cn + d_nd\n    # Proxy: use squared distances to approximate travel cost\n    proxy_dist = np.square(sum_dist)\n\n    endurance = cap_after - 0.2 * proxy_dist\n\n    # Keep only nodes with endurance above the median\n    median_end = np.median(endurance)\n    mask = endurance >= median_end\n    if not np.any(mask):\n        return depot\n\n    filtered_end = endurance[mask]\n    filtered_nodes = feasible_nodes[mask]\n\n    # Randomly choose among the top three endurance values\n    top_k = 3\n    top_indices = np.argsort(filtered_end)[-top_k:]\n    chosen = np.random.choice(top_indices)\n\n    return int(filtered_nodes[chosen])\n\n",
  "route_endurance_aug_193": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n\n    # Collect feasible nodes with a standard for loop\n    feasible_nodes = []\n    for node in unvisited_nodes:\n        if demands[node] <= cap0:\n            feasible_nodes.append(node)\n    if not feasible_nodes:\n        return depot\n\n    feasible_nodes = np.array(feasible_nodes, dtype=int)\n    dem = demands[feasible_nodes].astype(float)\n    cap_after = cap0 - dem\n\n    d_cn = distance_matrix[current_node, feasible_nodes].astype(float)\n    d_nd = distance_matrix[feasible_nodes, depot].astype(float)\n\n    sum_dist = d_cn + d_nd\n    sum_dist_total = np.sum(sum_dist) + 1e-12  # epsilon to avoid div\u2011by\u2011zero\n\n    endurance = cap_after - 0.5 * sum_dist_total / (sum_dist + 1e-12)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(endurance.size)\n    endurance += noise\n\n    endurance = np.clip(endurance, -1e12, 1e12)\n\n    # Randomly select one of the top\u20115 endurance nodes\n    top_k = 5\n    top_indices = np.argsort(endurance)[-top_k:]\n    chosen = np.random.choice(top_indices)\n\n    return int(feasible_nodes[chosen])\n\n",
  "local_prize_collecting_aug_194": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    capacity = float(rest_capacity)\n    # feasible candidates that fit into the remaining capacity\n    candidates = np.array([n for n in unvisited_nodes if demands[n] <= capacity], dtype=int)\n\n    if candidates.size == 0:\n        return depot\n\n    dem = demands[candidates].astype(float)\n    d_cn = distance_matrix[current_node, candidates].astype(float)\n    d_cn = np.clip(d_cn, 1e-12, None)          # avoid zero distances\n\n    lam = 0.6 / (capacity + 1e-12)             # lambda adapted to capacity\n    utility = dem - lam * d_cn\n\n    # deterministic tie\u2011breaker: small increasing noise\n    noise = 1e-6 * np.arange(candidates.size)\n    utility += noise\n\n    return int(candidates[np.argmax(utility)])\n\n",
  "local_prize_collecting_aug_195": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    capacity = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= capacity], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_cn = np.clip(d_cn, 1e-12, None)\n\n    inv_dist = 1.0 / (d_cn + 1e-12)           # inverse distance proxy\n    utility = 0.5 * dem + 0.5 * inv_dist\n\n    top_k = 7\n    if feasible.size <= top_k:\n        return int(feasible[np.argmax(utility)])\n\n    # pick the best among the top\u2011k utilities\n    top_indices = np.argpartition(-utility, top_k - 1)[:top_k]\n    top_utils = utility[top_indices]\n    # deterministic tie\u2011breaker using the original index order\n    best_local = top_indices[np.argmax(top_utils + 1e-8 * np.arange(top_indices.size))]\n    return int(feasible[best_local])\n\n",
  "local_prize_collecting_aug_196": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    capacity = float(rest_capacity)\n    candidates = np.array([n for n in unvisited_nodes if demands[n] <= capacity], dtype=int)\n\n    if candidates.size == 0:\n        return depot\n\n    dem = demands[candidates].astype(float)\n    d_cn = distance_matrix[current_node, candidates].astype(float)\n    d_cn = np.clip(d_cn, 1e-12, None)\n\n    lam = 0.5 / (capacity + 1e-12)\n    scores = dem * np.exp(-lam * d_cn)\n\n    # deterministic noise to break ties\n    noise = 1e-7 * np.arange(candidates.size)\n    scores += noise\n\n    return int(candidates[np.argmax(scores)])\n\n",
  "local_prize_collecting_aug_197": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    capacity = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= capacity], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_cn = np.clip(d_cn, 1e-12, None)\n\n    lam = 0.6 / (np.median(d_cn) + 1e-12)\n    utility = dem - lam * d_cn\n\n    # deterministic noise to break ties\n    noise = 1e-6 * np.arange(feasible.size)\n    utility += noise\n\n    return int(feasible[np.argmax(utility)])\n\n",
  "anti_greedy_shake_aug_198": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    dists = dist_mat[current_node, feasible] + 1e-12\n    order = np.argsort(dists)\n    best_idx = int(order[0])\n    if len(order) == 1:\n        return int(feasible[best_idx])\n\n    second_idx = int(order[1])\n\n    seed = ((current_node * 374761393) ^ (len(unvisited_nodes) * 668265263) ^\n            ((cap * 1000) & 0xFFFFFFFF)) & 0xffffffff\n    rng = np.random.default_rng(seed)\n\n    depot_dist = dist_mat[current_node, depot]\n    mean_feasible = np.mean(dist_mat[depot, feasible]) + 1e-12\n    p = np.clip(depot_dist / mean_feasible, 0.05, 0.35)\n\n    softmin_vals = np.exp(-dists[order[:2]]) + 1e-12\n    softmin_probs = softmin_vals / softmin_vals.sum()\n\n    choice = rng.choice([int(feasible[best_idx]), int(feasible[second_idx])],\n                        p=softmin_probs)\n\n    return int(feasible[second_idx]) if rng.random() < p else choice\n\n",
  "anti_greedy_shake_aug_199": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    noise = 1e-6 * feasible\n    dists = dist_mat[current_node, feasible] + noise\n\n    remaining_cap = cap - demands[feasible]\n    scores = 0.6 * dists + 0.4 * (1.0 - remaining_cap / cap)\n    order = np.argsort(scores)\n    best_idx = int(order[0])\n    if len(order) == 1:\n        return int(feasible[best_idx])\n\n    second_idx = int(order[1])\n\n    depot_dist = dist_mat[current_node, depot]\n    median_feasible = np.median(dist_mat[depot, feasible]) + 1e-12\n    p = np.clip(depot_dist / median_feasible, 0.1, 0.4)\n\n    if np.isclose(scores[order[0]], scores[order[1]], atol=1e-9):\n        return int(feasible[order[0]]) if feasible[order[0]] < feasible[order[1]] else int(feasible[order[1]])\n\n    seed = ((current_node * 374761393) ^ (len(unvisited_nodes) * 668265263) ^\n            ((cap * 1000) & 0xFFFFFFFF)) & 0xffffffff\n    rng = np.random.default_rng(seed)\n\n    return int(feasible[second_idx]) if rng.random() < p else int(feasible[best_idx])\n\n",
  "anti_greedy_shake_aug_200": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dist_mat = distance_matrix\n    dists = dist_mat[current_node, feasible] + 1e-12\n\n    top_k = min(5, len(feasible))\n    top_indices = np.argpartition(dists, top_k-1)[:top_k]\n    softmin_vals = np.exp(-dists[top_indices]) + 1e-12\n    probs = softmin_vals / softmin_vals.sum()\n\n    seed = ((current_node * 374761393) ^ (len(unvisited_nodes) * 668265263) ^\n            ((cap * 1000) & 0xFFFFFFFF)) & 0xffffffff\n    rng = np.random.default_rng(seed)\n\n    chosen = rng.choice(feasible[top_indices], p=probs)\n\n    depot_dist = dist_mat[current_node, depot]\n    max_feasible = np.max(dist_mat[depot, feasible]) + 1e-12\n    p = np.clip(depot_dist / max_feasible, 0.05, 0.25)\n\n    return depot if rng.random() < p else int(chosen)\n\n",
  "anti_greedy_shake_aug_201": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    proxy_factor = 1.0 + 0.05 * np.abs(feasible - current_node)\n    dist_mat = distance_matrix\n    dists = dist_mat[current_node, feasible] * proxy_factor + 1e-12\n\n    cost_proxy = np.sum(demands[feasible]) + 1e-12\n    scores = dists + 0.2 * (cost_proxy / cap)\n\n    order = np.argsort(scores)\n    best = int(order[0])\n    if len(order) == 1:\n        return int(feasible[best])\n\n    second = int(order[1])\n\n    depot_dist = dist_mat[current_node, depot]\n    sum_feasible = np.sum(dist_mat[depot, feasible]) + 1e-12\n    p = np.clip(depot_dist / sum_feasible, 0.08, 0.30)\n\n    seed = ((current_node * 668265263) ^ (len(unvisited_nodes) * 374761393) ^\n            int(cap * 1000)) & 0xffffffff\n    rng = np.random.default_rng(seed)\n\n    return int(feasible[second]) if rng.random() < p else int(feasible[best])\n\n",
  "expected_future_feasibility_aug_202": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    unv = unvisited_nodes.astype(int)\n\n    # Feasible candidates\n    feasible_mask = demands[unv] <= cap0\n    if not np.any(feasible_mask):\n        return depot\n    feasible_nodes = unv[feasible_mask]\n\n    # Remaining capacity after serving each candidate\n    cap1 = cap0 - demands[feasible_nodes]\n\n    # Fraction of remaining nodes that would stay feasible\n    denom = (unv.size - 1) + 1e-12\n    remaining_mask = demands[unv] <= cap1[:, None]\n    feas_frac = np.sum(remaining_mask, axis=1) / denom\n    feas_frac = np.clip(feas_frac, 0.0, 1.0)\n\n    # Distance penalty\n    dist = distance_matrix[current_node, feasible_nodes]\n    score = feas_frac - 0.02 * dist\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-6 * ((feasible_nodes * 1234567) % 1000)\n    score += noise\n\n    best_idx = np.argmax(score)\n    return int(feasible_nodes[best_idx])\n\n",
  "expected_future_feasibility_aug_203": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    unv = unvisited_nodes.astype(int)\n\n    # Build feasible list\n    feasible = [n for n in unv if demands[n] <= cap0]\n    if not feasible:\n        return depot\n\n    scores = []\n    for n in feasible:\n        cap1 = cap0 - float(demands[n])\n        remaining = unv[unv != n]\n        if remaining.size == 0:\n            feas_frac = 1.0\n        else:\n            feas_frac = np.sum(demands[remaining] <= cap1) / (remaining.size + 1e-12)\n        feas_frac = np.clip(feas_frac, 0.0, 1.0)\n\n        score = feas_frac - 0.015 * float(distance_matrix[current_node, n])\n        scores.append((n, score))\n\n    # Sort by score descending\n    scores.sort(key=lambda x: x[1], reverse=True)\n\n    # Pick randomly among top\u2011k (k=5 or fewer)\n    top_k = min(5, len(scores))\n    top_candidates = scores[:top_k]\n    chosen = top_candidates[np.random.randint(0, top_k)][0]\n    return int(chosen)\n\n",
  "expected_future_feasibility_aug_204": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    unv = unvisited_nodes.astype(int)\n\n    # If all nodes infeasible, return depot\n    if np.all(demands[unv] > cap0):\n        return depot\n\n    feasible_mask = demands[unv] <= cap0\n    feasible_nodes = unv[feasible_mask]\n\n    # Remaining capacity and feasibility fraction (binary)\n    cap1 = cap0 - demands[feasible_nodes]\n    denom = (unv.size - 1) + 1e-12\n    remaining_mask = demands[unv] <= cap1[:, None]\n    feas_frac = np.max(remaining_mask, axis=1).astype(float)\n    feas_frac = np.clip(feas_frac, 0.0, 1.0)\n\n    # Squared distance penalty\n    dist_sq = np.square(distance_matrix[current_node, feasible_nodes])\n    score = feas_frac - 0.025 * dist_sq\n\n    # Softmin selection via softmax of negative scores\n    temp = 0.5\n    exp_scores = np.exp(-score / (temp + 1e-12))\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n\n    # Deterministic noise for stability\n    noise = 1e-6 * ((feasible_nodes * 987654) % 1000)\n    probs += noise\n\n    chosen_idx = np.argmax(probs)\n    return int(feasible_nodes[chosen_idx])\n\n",
  "expected_future_feasibility_aug_205": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    unv = unvisited_nodes.astype(int)\n\n    feasible_mask = demands[unv] <= cap0\n    if not np.any(feasible_mask):\n        return depot\n    feasible_nodes = unv[feasible_mask]\n\n    # Remaining capacity per candidate\n    cap1 = cap0 - demands[feasible_nodes]\n\n    # Fraction of remaining nodes that stay feasible\n    denom = (unv.size - 1) + 1e-12\n    remaining_mask = demands[unv] <= cap1[:, None]\n    feas_frac = np.sum(remaining_mask, axis=1) / denom\n    feas_frac = np.clip(feas_frac, 0.0, 1.0)\n\n    # Linear distance penalty\n    dist = distance_matrix[current_node, feasible_nodes]\n\n    # Cost combining feasibility and distance\n    cost = -feas_frac + 0.03 * dist\n\n    # Soft\u2011min probability\n    temp = 1.0\n    exp_cost = np.exp(-cost / (temp + 1e-12))\n    probs = exp_cost / (np.sum(exp_cost) + 1e-12)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-6 * ((feasible_nodes * 7654321) % 1000)\n    probs += noise\n\n    chosen_idx = np.argmax(probs)\n    return int(feasible_nodes[chosen_idx])\n\n",
  "closest_feasible_by_ranked_ring_aug_206": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # Ensure candidates are sorted for searchsorted\n    candidates = np.sort(np.asarray(unvisited_nodes, dtype=int))\n    feasible = candidates[demands[candidates] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # Rank of each candidate by its distance to the depot\n    depot_dists = distance_matrix[depot, candidates].astype(float)\n    order = np.argsort(depot_dists)\n    rank = np.empty_like(order)\n    rank[order] = np.arange(len(order))\n\n    # Rank of the current node (or middle if at depot)\n    if current_node == depot:\n        cur_rank = len(candidates) // 2\n    else:\n        cur_r = float(distance_matrix[depot, current_node])\n        cur_rank = int(np.searchsorted(np.sort(depot_dists), cur_r))\n\n    # Map feasible indices to their ranks\n    idx_map = {int(n): i for i, n in enumerate(candidates.tolist())}\n    feasible_ranks = np.array([rank[idx_map[int(n)]] for n in feasible], dtype=float)\n\n    ring_gap = np.abs(feasible_ranks - float(cur_rank))\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    # Normalise distances by the median to reduce influence of outliers\n    norm = d_cur / (np.median(d_cur) + 1e-12)\n    score = 0.6 * ring_gap + 0.4 * norm\n\n    # Add a tiny deterministic noise to break ties consistently\n    noise = 1e-6 * np.arange(len(score))\n    chosen = int(feasible[np.argmin(score + noise)])\n    return chosen\n\n",
  "closest_feasible_by_ranked_ring_aug_207": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = rest_capacity\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    feasible = candidates[demands[candidates] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # Ranking by depot distance\n    depot_dists = distance_matrix[depot, feasible].astype(float)\n    order = np.argsort(depot_dists)\n    rank = np.empty_like(order)\n    rank[order] = np.arange(len(order))\n\n    if current_node == depot:\n        cur_rank = len(feasible) // 2\n    else:\n        cur_r = float(distance_matrix[depot, current_node])\n        cur_rank = int(np.searchsorted(np.sort(depot_dists), cur_r))\n\n    # Compute scores one by one\n    scores = []\n    for i, node in enumerate(feasible):\n        rg = abs(rank[i] - cur_rank)\n        d = distance_matrix[current_node, node]\n        norm = d / (np.max(distance_matrix[current_node, feasible]) + 1e-12)\n        scores.append(0.7 * rg + 0.3 * norm)\n\n    scores = np.array(scores)\n    min_score = np.min(scores)\n    ties = np.where(np.isclose(scores, min_score, atol=1e-12))[0]\n    chosen_idx = np.random.choice(ties)\n    return int(feasible[chosen_idx])\n\n",
  "closest_feasible_by_ranked_ring_aug_208": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = rest_capacity\n    candidates = [int(n) for n in unvisited_nodes]\n    feasible = [n for n in candidates if demands[n] <= cap]\n    if not feasible:\n        return depot\n\n    # Distances to depot for feasible nodes\n    depot_dists = [distance_matrix[depot, n] for n in feasible]\n    order = np.argsort(depot_dists)\n    rank = [0] * len(order)\n    for i, idx in enumerate(order):\n        rank[idx] = i\n\n    if current_node == depot:\n        cur_rank = len(feasible) // 2\n    else:\n        cur_r = distance_matrix[depot, current_node]\n        cur_rank = int(np.searchsorted(sorted(depot_dists), cur_r))\n\n    ring_gap = [abs(rank[i] - cur_rank) for i in range(len(feasible))]\n    dist_cur = [distance_matrix[current_node, n] for n in feasible]\n\n    # Normalise distances by the median\n    med = np.median(dist_cur) + 1e-12\n    norm = [d / med for d in dist_cur]\n\n    score = [0.8 * rg + 0.2 * nm for rg, nm in zip(ring_gap, norm)]\n    score = np.clip(score, 0, 1e6)  # prevent extreme values\n\n    # Deterministic noise to break ties\n    noise = [1e-6 * i for i in range(len(score))]\n    final = [s + n for s, n in zip(score, noise)]\n\n    chosen = int(feasible[int(np.argmin(final))])\n    return chosen\n\n",
  "min_expected_added_cost_via_nearest_next_aug_209": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    dem = demands\n    cap = float(rest_capacity)\n\n    if len(candidates) == 0:\n        return depot\n\n    # Build list of feasible first nodes\n    feasible_i = [i for i in candidates if dem[i] <= cap]\n    if not feasible_i:\n        return depot\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(len(feasible_i))\n\n    best_node, best_score = depot, np.inf\n    idx = 0\n    while idx < len(feasible_i):\n        i = feasible_i[idx]\n        cap1 = cap - float(dem[i])\n\n        # Remaining nodes after visiting i\n        rem = candidates[candidates != i]\n        feasible_k = [k for k in rem if dem[k] <= cap1]\n\n        base = float(dist_mat[current_node, i])\n        base = np.clip(base, 0.0, np.inf)\n        ret = 0.35 * float(dist_mat[i, depot])\n        ret = np.clip(ret, 0.0, np.inf)\n\n        if not feasible_k:\n            exp_next = 0.0\n        else:\n            di = dist_mat[i, feasible_k].astype(float)\n            m = min(3, len(di))\n            exp_next = float(np.mean(np.partition(di, m - 1)[:m]) + 1e-12)\n\n        score = base + 0.6 * exp_next + ret + noise[idx]\n        if score < best_score:\n            best_score, best_node = score, int(i)\n        idx += 1\n\n    return best_node\n\n",
  "min_expected_added_cost_via_nearest_next_aug_210": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist = distance_matrix\n    candidates = unvisited_nodes\n    dem = demands\n    cap = float(rest_capacity)\n\n    if len(candidates) == 0:\n        return depot\n\n    # Vectorised feasible first nodes\n    feasible_mask = dem[candidates] <= cap\n    feasible_idx = np.where(feasible_mask)[0]\n    if len(feasible_idx) == 0:\n        return depot\n\n    scores = np.empty(len(feasible_idx), dtype=float)\n\n    for pos, idx in enumerate(feasible_idx):\n        i = int(candidates[idx])          # real node number\n        cap1 = cap - float(dem[i])\n\n        rem = candidates[candidates != i]\n        feasible_k_mask = dem[rem] <= cap1\n        feasible_k = np.where(feasible_k_mask)[0]\n\n        base = float(dist[current_node, i])\n        base = np.clip(base, 0.0, np.inf)\n        ret = 0.35 * float(dist[i, depot])\n        ret = np.clip(ret, 0.0, np.inf)\n\n        if len(feasible_k) == 0:\n            exp_next = 0.0\n        else:\n            di = dist[i, rem[feasible_k]].astype(float)\n            top_k = min(5, len(di))\n            exp_next = float(np.median(np.partition(di, top_k - 1)[:top_k]))\n\n        # Tuned weights\n        scores[pos] = 0.4 * base + 0.4 * exp_next + 0.2 * ret\n\n    # Softmin selection\n    temp = 0.5\n    exp_scores = np.exp(-scores / (temp + 1e-12))\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n    chosen_pos = np.random.choice(len(feasible_idx), p=probs)\n    chosen_node = int(candidates[feasible_idx[chosen_pos]])\n\n    return chosen_node\n\n",
  "min_expected_added_cost_via_nearest_next_aug_211": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist = distance_matrix\n    candidates = unvisited_nodes\n    dem = demands\n    cap = float(rest_capacity)\n\n    if len(candidates) == 0:\n        return depot\n\n    feasible_mask = dem[candidates] <= cap\n    feasible_idx = np.where(feasible_mask)[0]\n    if len(feasible_idx) == 0:\n        return depot\n\n    scores = np.empty(len(feasible_idx), dtype=float)\n\n    for pos, idx in enumerate(feasible_idx):\n        i = int(candidates[idx])\n        cap1 = cap - float(dem[i])\n\n        rem = candidates[candidates != i]\n        feasible_k_mask = dem[rem] <= cap1\n        feasible_k = np.where(feasible_k_mask)[0]\n\n        base = float(dist[current_node, i])\n        base = np.clip(base, 0.0, np.inf)\n        ret = 0.35 * float(dist[i, depot])\n        ret = np.clip(ret, 0.0, np.inf)\n\n        if len(feasible_k) == 0:\n            exp_next = 0.0\n        else:\n            di = dist[i, rem[feasible_k]].astype(float)\n            exp_next = float(np.max(di))\n\n        # Weight tuning\n        scores[pos] = base + 0.6 * exp_next + ret\n\n    # Random choice among the three best candidates\n    top_k = min(3, len(scores))\n    best_indices = np.argpartition(scores, top_k)[:top_k]\n    chosen_idx = np.random.choice(best_indices)\n    chosen_node = int(candidates[feasible_idx[chosen_idx]])\n\n    return chosen_node\n\n",
  "min_expected_added_cost_via_nearest_next_aug_212": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dmat = distance_matrix\n    cand = unvisited_nodes\n    dem = demands\n    cap = float(rest_capacity)\n\n    if len(cand) == 0:\n        return depot\n\n    # Build feasible first node list using a while loop\n    feasible = []\n    i = 0\n    while i < len(cand):\n        node = int(cand[i])\n        if dem[node] <= cap:\n            feasible.append(node)\n        i += 1\n\n    if not feasible:\n        return depot\n\n    scores = np.empty(len(feasible), dtype=float)\n\n    for pos, node in enumerate(feasible):\n        cap1 = cap - float(dem[node])\n\n        # Remaining nodes after visiting 'node'\n        rem = cand[cand != node]\n        feasible_k = [k for k in rem if dem[k] <= cap1]\n\n        base = float(dmat[current_node, node])\n        base = np.clip(base, 0.0, np.inf)\n        ret = 0.35 * float(dmat[node, depot])\n        ret = np.clip(ret, 0.0, np.inf)\n\n        if not feasible_k:\n            exp_next = 0.0\n        else:\n            di = dmat[node, feasible_k].astype(float)\n            exp_next = float(np.max(di))\n\n        # Softmax weighting with temperature\n        scores[pos] = base + 0.6 * exp_next + ret\n\n    temp = 1.0\n    exp_scores = np.exp(scores / (temp + 1e-12))\n    probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n\n    # Choose the node with the highest probability\n    chosen_pos = np.argmax(probs)\n    chosen_node = int(feasible[chosen_pos])\n\n    return chosen_node\n\n",
  "demand_to_depot_ratio_aug_213": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    # Build feasible list with a while loop\n    feasible = np.empty(0, dtype=int)\n    i = 0\n    while i < len(candidates):\n        node = candidates[i]\n        if demands[node] <= cap:\n            feasible = np.append(feasible, node)\n        i += 1\n\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_dep = distance_matrix[depot, feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    # Use squared distance for the depot term and median for the current distance\n    score = dem / (np.square(d_dep) + 1e-12) \\\n            - 0.1 * (d_cur / (np.median(d_cur) + 1e-12))\n\n    # Clip negative scores to zero to avoid selecting a node with a negative score\n    score = np.clip(score, 0, None)\n\n    return int(feasible[int(np.argmax(score))])\n\n",
  "demand_to_depot_ratio_aug_214": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_dep = distance_matrix[depot, feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    # Weighted scoring with 0.7/0.3 split and a sum\u2011based mean\n    mean_cur = np.sum(d_cur) / (len(d_cur) + 1e-12)\n    score = 0.7 * (dem / (d_dep + 1e-12)) - 0.3 * (d_cur / (mean_cur + 1e-12))\n\n    # Clip any negative values to zero\n    score = np.clip(score, 0, None)\n\n    return int(feasible[int(np.argmax(score))])\n\n",
  "demand_to_depot_ratio_aug_215": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    rng = np.random.default_rng(42)          # deterministic RNG for reproducibility\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_dep = distance_matrix[depot, feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    # Apply deterministic noise and compute score\n    noise = np.arange(len(feasible), dtype=float) * 1e-6\n    score = dem / (d_dep + 1e-12) - 0.1 * (d_cur / (np.max(d_cur) + 1e-12)) + noise\n\n    # Clip to non\u2011negative\n    score = np.clip(score, 0, None)\n\n    # Select top\u2011k (k=3) and randomly choose one of them\n    top_k = 3\n    if len(score) <= top_k:\n        chosen_idx = int(np.argmax(score))\n    else:\n        top_indices = np.argpartition(score, -top_k)[-top_k:]\n        chosen_idx = int(rng.choice(top_indices))\n\n    return int(feasible[chosen_idx])\n\n",
  "demand_to_depot_ratio_aug_216": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_dep = distance_matrix[depot, feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    # Median-based denominator for current distance\n    denom_cur = np.median(d_cur) + 1e-12\n    score = dem / (d_dep + 1e-12) - 0.1 * (d_cur / denom_cur)\n\n    # Clip negative values\n    score = np.clip(score, 0, None)\n\n    # Random choice among top\u20115 scored nodes\n    top_k = 5\n    if len(score) <= top_k:\n        chosen_idx = int(np.argmax(score))\n    else:\n        top_indices = np.argpartition(score, -top_k)[-top_k:]\n        chosen_idx = int(np.random.choice(top_indices))\n\n    return int(feasible[chosen_idx])\n\n",
  "nearest_with_capacity_guardband_aug_217": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    curr = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    cap_rem = float(rest_capacity)\n    dem = demands\n    dist_mat = distance_matrix\n\n    if cand.size == 0:\n        return dep\n\n    feasible = cand[dem[cand] <= cap_rem]\n    if feasible.size == 0:\n        return dep\n\n    guard = np.clip(0.75 * cap_rem, 0, cap_rem)\n    small = feasible[dem[feasible] <= guard]\n    sel_set = small if small.size > 0 else feasible\n\n    dists = dist_mat[curr, sel_set].astype(float)\n    # deterministic tie\u2011breaking by adding a tiny noise proportional to the index\n    noise = np.arange(sel_set.size, dtype=float) * 1e-12\n    dists += noise\n    return int(sel_set[np.argmin(dists)])\n\n",
  "nearest_with_capacity_guardband_aug_218": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    curr = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    cap = float(rest_capacity)\n    dem = demands\n    dist = distance_matrix\n\n    if cand.size == 0:\n        return dep\n\n    feasible = cand[dem[cand] <= cap]\n    if feasible.size == 0:\n        return dep\n\n    guard = np.clip(0.6 * cap, 0, cap)\n    small = feasible[dem[feasible] <= guard]\n    sel = small if small.size > 0 else feasible\n\n    dists = dist[curr, sel].astype(float)\n    # soft\u2011min selection with a small temperature\n    temp = 0.1\n    inv_d = np.exp(-dists / (temp + 1e-12))\n    probs = inv_d / (np.sum(inv_d) + 1e-12)\n    idx = int(np.argmax(probs))\n    return int(sel[idx])\n\n",
  "nearest_with_capacity_guardband_aug_219": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    curr = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    cap = float(rest_capacity)\n    dem = demands\n    dist = distance_matrix\n\n    if cand.size == 0:\n        return dep\n\n    feasible = cand[dem[cand] <= cap]\n    if feasible.size == 0:\n        return dep\n\n    guard = np.clip(0.5 * cap, 0, cap)\n    small = feasible[dem[feasible] <= guard]\n    sel = small if small.size > 0 else feasible\n\n    dists = dist[curr, sel].astype(float)\n    # pick a random element among the top\u2011k nearest (deterministic pseudo\u2011random)\n    top_k = min(7, sel.size)\n    idx_sorted = np.argsort(dists)\n    top_indices = idx_sorted[:top_k]\n    chosen_idx = top_indices[(curr + dep) % top_k]\n    return int(sel[chosen_idx])\n\n",
  "nearest_with_capacity_guardband_aug_220": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    curr = int(current_node)\n    dep = int(depot)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n    cap = float(rest_capacity)\n    dem = demands\n    dist = distance_matrix\n\n    if cand.size == 0:\n        return dep\n\n    feasible = cand[dem[cand] <= cap]\n    if feasible.size == 0:\n        return dep\n\n    guard = np.clip(0.65 * cap, 0, cap)\n    small = feasible[dem[feasible] <= guard]\n    sel = small if small.size > 0 else feasible\n\n    dists = dist[curr, sel].astype(float)\n    # scale distances and use a softmax weighting\n    scaled = dists * 0.9\n    exp_vals = np.exp(-scaled / (0.05 + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    idx = int(np.argmax(probs))\n    return int(sel[idx])\n\n",
  "median_direction_pull_aug_221": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    # feasible nodes respecting capacity\n    feasible = cand[demands[cand] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # choose a median node by depot distance using np.median\n    depot_dist = distance_matrix[depot, cand].astype(float)\n    med_idx = int(np.median(np.arange(len(cand)), weights=None))\n    med_node = int(cand[med_idx])\n\n    # distances needed for scoring\n    d_nm = distance_matrix[feasible, med_node].astype(float)\n    d_cm = float(distance_matrix[current_node, med_node])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # scoring with weighted sum\n    score = np.abs(d_nm - d_cm) * 0.6 + d_cn * 0.4\n\n    # deterministic tie\u2011breaking noise\n    rng = np.random.default_rng(current_node)  # seed from current node\n    noise = 1e-6 * rng.standard_normal(len(score))\n    score += noise\n\n    # clip to avoid extremely large values\n    score = np.clip(score, 0, 1e9)\n\n    return int(feasible[np.argmin(score)])\n\n",
  "median_direction_pull_aug_222": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    # feasible nodes respecting capacity\n    feasible = cand[demands[cand] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # median node by depot distance\n    depot_dist = distance_matrix[depot, cand].astype(float)\n    med_node = int(cand[int(np.argsort(depot_dist)[len(depot_dist) // 2])])\n\n    # distances\n    d_nm = distance_matrix[feasible, med_node].astype(float)\n    d_cm = float(distance_matrix[current_node, med_node])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # scoring\n    score = np.abs(d_nm - d_cm) * 0.5 + d_cn * 0.5\n\n    # top\u2011k selection\n    top_k = 7\n    if len(score) > top_k:\n        idx_top = np.argpartition(score, top_k)[:top_k]\n        score = score[idx_top]\n        feasible = feasible[idx_top]\n\n    # softmin probabilities\n    temperature = 0.5\n    exp_neg = np.exp(-score / (temperature + 1e-12))\n    prob = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n    # random choice according to probabilities\n    rng = np.random.default_rng(depot)\n    chosen = rng.choice(feasible, p=prob)\n    return int(chosen)\n\n",
  "median_direction_pull_aug_223": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    # feasible nodes respecting capacity\n    feasible = cand[demands[cand] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # median node using mean of distances\n    depot_dist = distance_matrix[depot, cand].astype(float)\n    mean_idx = int(np.mean(np.arange(len(cand))))\n    med_node = int(cand[mean_idx])\n\n    # squared distances for proxy\n    d_nm = np.square(distance_matrix[feasible, med_node]).astype(float)\n    d_cm = np.square(float(distance_matrix[current_node, med_node]))\n    d_cn = np.square(distance_matrix[current_node, feasible]).astype(float)\n\n    # scoring with sum aggregation\n    score = np.abs(d_nm - d_cm) * 0.4 + d_cn * 0.6\n    score = np.sum(score)  # aggregate to single value per node\n\n    # choose node with minimal aggregated score\n    best_idx = np.argmin(score)\n    return int(feasible[best_idx])\n\n",
  "median_direction_pull_aug_224": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    # feasible nodes\n    feasible = [c for c in cand if demands[c] <= cap]\n    if not feasible:\n        return depot\n\n    # median node by depot distance using np.argmax for inversion\n    depot_dist = distance_matrix[depot, cand].astype(float)\n    med_node = int(cand[np.argmax(np.flip(np.argsort(depot_dist)))])\n\n    # compute scores via list comprehension\n    scores = [\n        abs(float(distance_matrix[c, med_node]) - float(distance_matrix[current_node, med_node]))\n        * 0.7 + float(distance_matrix[current_node, c]) * 0.3\n        for c in feasible\n    ]\n\n    # clip scores to avoid extremes\n    scores = [np.clip(s, 0, 1e9) for s in scores]\n\n    # choose node with minimal score using np.argmax on negative\n    best_idx = int(np.argmax([-s for s in scores]))\n    return int(feasible[best_idx])\n\n",
  "entropy_balanced_sampling_aug_225": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = demands[candidates] <= cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    d_cd = float(dist_mat[current_node, depot])\n    d_cn = dist_mat[current_node, feasible].astype(float)\n    d_nd = dist_mat[feasible, depot].astype(float)\n\n    ins = d_cn + d_nd - d_cd\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(ins.size, dtype=float)\n    ins_noisy = ins + noise\n\n    # temperature based on the median insertion cost\n    T = (np.median(ins_noisy) + 1e-12) * 3.0\n    exp_vals = np.exp(-ins_noisy / (T + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0.0, 1.0)\n\n    seed = (int(current_node) * 1103515245 + int(len(candidates)) * 12345) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(rng.choice(feasible, p=probs))\n\n",
  "entropy_balanced_sampling_aug_226": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = demands[candidates] <= cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    d_cd = float(dist_mat[current_node, depot])\n    d_cn = dist_mat[current_node, feasible].astype(float)\n    d_nd = dist_mat[feasible, depot].astype(float)\n\n    ins = d_cn + d_nd - d_cd\n\n    # random noise from a normal distribution\n    rng_noise = np.random.default_rng((current_node * 1234567 + len(candidates)) & 0xFFFFFFFF)\n    noise = rng_noise.normal(size=ins.shape) * 1e-10\n    ins_noisy = ins + noise\n\n    # temperature based on the maximum insertion cost\n    T = (np.max(ins_noisy) + 1e-12) * 2.0\n    exp_vals = np.exp(-ins_noisy / (T + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0.0, 1.0)\n\n    # top\u20115 selection\n    top_k = min(5, len(feasible))\n    if top_k < len(feasible):\n        top_idx = np.argpartition(probs, -top_k)[-top_k:]\n        probs_top = probs[top_idx]\n        probs_top = probs_top / (np.sum(probs_top) + 1e-12)\n        rng = np.random.default_rng((current_node * 1103515245 + len(candidates)) & 0xFFFFFFFF)\n        return int(rng.choice(feasible[top_idx], p=probs_top))\n    else:\n        rng = np.random.default_rng((current_node * 1103515245 + len(candidates)) & 0xFFFFFFFF)\n        return int(rng.choice(feasible, p=probs))\n\n",
  "entropy_balanced_sampling_aug_227": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = demands[candidates] <= cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    d_cd = float(dist_mat[current_node, depot])\n    d_cn = dist_mat[current_node, feasible].astype(float)\n    d_nd = dist_mat[feasible, depot].astype(float)\n\n    ins = d_cn + d_nd - d_cd\n\n    # softmin: p_i \u221d 1/(ins + \u03b5)\n    eps = 1e-12\n    inv_vals = 1.0 / (ins + eps)\n    probs = inv_vals / (np.sum(inv_vals) + eps)\n    probs = np.clip(probs, 0.0, 1.0)\n\n    seed = (int(current_node) * 1103515245 + int(len(candidates)) * 12345) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(rng.choice(feasible, p=probs))\n\n",
  "entropy_balanced_sampling_aug_228": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible_mask = demands[candidates] <= cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    d_cd = float(dist_mat[current_node, depot])\n    d_cn = dist_mat[current_node, feasible].astype(float)\n    d_nd = dist_mat[feasible, depot].astype(float)\n\n    # weighted insertion cost: 0.7*d_cn + 0.3*d_nd - d_cd\n    ins = 0.7 * d_cn + 0.3 * d_nd - d_cd\n\n    # top\u2011k selection via argpartition\n    top_k = min(7, len(feasible))\n    if top_k < len(feasible):\n        top_indices = np.argpartition(ins, top_k)[:top_k]\n    else:\n        top_indices = np.arange(len(ins))\n\n    ins_top = ins[top_indices]\n\n    # temperature based on the median of the top\u2011k costs\n    T = (np.median(ins_top) + 1e-12) * 3.0\n    exp_vals = np.exp(-ins_top / (T + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0.0, 1.0)\n\n    seed = (int(current_node) * 1103515245 + int(len(candidates)) * 12345) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(rng.choice(feasible[top_indices], p=probs))\n\n",
  "balanced_two_anchor_aug_229": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([node for node in candidates if demands[node] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_dep = dist_mat[feasible, depot].astype(float)\n    d_cur = dist_mat[feasible, current_node].astype(float)\n\n    sym = np.abs(d_dep - d_cur)\n    step = dist_mat[current_node, feasible].astype(float)\n\n    # scaling using median\n    median_step = np.median(step) + 1e-12\n    scaled_step = step / median_step\n    scaled_step = np.clip(scaled_step, 0.0, 1.0)\n\n    score = 0.7 * sym + 0.3 * scaled_step\n\n    # deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(feasible.size)\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "balanced_two_anchor_aug_230": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([node for node in candidates if demands[node] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_dep = dist_mat[feasible, depot].astype(float)\n    d_cur = dist_mat[feasible, current_node].astype(float)\n\n    sym = np.abs(d_dep - d_cur)\n    step = dist_mat[current_node, feasible].astype(float)\n\n    # scaling using sum\n    sum_step = np.sum(step) + 1e-12\n    scaled_step = step / sum_step\n    scaled_step = np.clip(scaled_step, 0.0, 1.0)\n\n    score = 0.4 * sym + 0.6 * scaled_step\n\n    # deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(feasible.size)\n    score += noise\n\n    # top\u2011k selection with random tie\u2011break\n    k = 5\n    if feasible.size <= k:\n        idx = np.argmin(score)\n    else:\n        topk_idx = np.argpartition(score, k)[:k]\n        idx = np.random.choice(topk_idx)\n\n    return int(feasible[idx])\n\n",
  "balanced_two_anchor_aug_231": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([node for node in candidates if demands[node] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_dep = dist_mat[feasible, depot].astype(float)\n    d_cur = dist_mat[feasible, current_node].astype(float)\n\n    sym = np.abs(d_dep - d_cur)\n    step = dist_mat[current_node, feasible].astype(float)\n\n    # scaling using maximum\n    max_step = np.max(step) + 1e-12\n    scaled_step = step / max_step\n    scaled_step = np.clip(scaled_step, 0.0, 1.0)\n\n    score = 0.5 * sym + 0.5 * scaled_step\n\n    # small random perturbation for robustness\n    rng = np.random.default_rng()\n    noise = rng.uniform(-1e-6, 1e-6, size=score.shape)\n    score += noise\n\n    # soft\u2011max weighting\n    temp = 1.0\n    exp_vals = np.exp(-score / temp)\n    exp_vals = np.clip(exp_vals, 0.0, 1e6)\n    idx = int(np.argmax(exp_vals))\n\n    return int(feasible[idx])\n\n",
  "balanced_two_anchor_aug_232": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible_list = []\n    for node in candidates:\n        if demands[node] <= cap:\n            feasible_list.append(node)\n    if not feasible_list:\n        return depot\n\n    feasible = np.array(feasible_list, dtype=int)\n\n    d_dep = dist_mat[feasible, depot].astype(float)\n    d_cur = dist_mat[feasible, current_node].astype(float)\n\n    sym = np.abs(d_dep - d_cur)\n    step = dist_mat[current_node, feasible].astype(float)\n\n    # scaling using median\n    median_step = np.median(step) + 1e-12\n    scaled_step = step / median_step\n    scaled_step = np.clip(scaled_step, 0.0, 1.0)\n\n    score = 0.6 * sym + 0.4 * scaled_step\n\n    # deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(len(feasible))\n    score += noise\n\n    # soft\u2011min top\u2011k selection\n    k = 7\n    if len(feasible) <= k:\n        idx = int(np.argmin(score))\n    else:\n        topk_idx = np.argpartition(score, k)[:k]\n        soft = np.exp(-score[topk_idx])\n        soft = np.clip(soft, 0.0, 1e6)\n        idx = topk_idx[int(np.argmax(soft))]\n\n    return int(feasible[idx])\n\n",
  "min_variance_step_aug_233": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(candidates, dtype=int)\n    feasible = cand[demands[cand] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    d_current = dist_mat[current_node, feasible].astype(float)\n    dist_subset = dist_mat[np.ix_(feasible, cand)].astype(float)\n    var = np.var(dist_subset, axis=1)\n\n    mean_d = np.mean(d_current) + 1e-12\n    mean_v = np.mean(var) + 1e-12\n    ratio_d = np.clip(d_current / mean_d, 0, np.inf)\n    ratio_v = np.clip(var / mean_v, 0, np.inf)\n\n    score = 0.6 * ratio_d + 0.4 * ratio_v\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(feasible.size) * 1e-8\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "min_variance_step_aug_234": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    cap = rest_capacity\n    cand = np.asarray(candidates, dtype=int)\n    feasible = [c for c in cand if demands[c] <= cap]\n    if not feasible:\n        return depot\n\n    d_current = [dist_mat[current_node, f] for f in feasible]\n    dist_subset = [[dist_mat[f, c] for c in cand] for f in feasible]\n    var = [np.var(row) for row in dist_subset]\n\n    mean_d = np.median(d_current) + 1e-12\n    mean_v = np.median(var) + 1e-12\n    ratio_d = [np.clip(d / mean_d, 0, np.inf) for d in d_current]\n    ratio_v = [np.clip(v / mean_v, 0, np.inf) for v in var]\n\n    score = [0.7 * rd + 0.3 * rv for rd, rv in zip(ratio_d, ratio_v)]\n    noise = [i * 1e-7 for i in range(len(score))]\n    score = [s + n for s, n in zip(score, noise)]\n\n    top_k = 3\n    sorted_idx = sorted(range(len(score)), key=lambda i: score[i])[:top_k]\n    chosen_idx = sorted_idx[0]  # deterministic selection among top\u2011k\n\n    return int(feasible[chosen_idx])\n\n",
  "min_variance_step_aug_235": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(candidates, dtype=int)\n    feasible = cand[demands[cand] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    d_current = dist_mat[current_node, feasible].astype(float)\n    total_d = np.sum(d_current) + 1e-12\n    mean_d = total_d / (feasible.size + 1e-12)\n\n    dist_subset = dist_mat[np.ix_(feasible, cand)].astype(float)\n    var = np.var(dist_subset, axis=1)\n    total_v = np.sum(var) + 1e-12\n    mean_v = total_v / (feasible.size + 1e-12)\n\n    ratio_d = np.clip(d_current / mean_d, 0, np.inf)\n    ratio_v = np.clip(var / mean_v, 0, np.inf)\n\n    score = np.empty(feasible.size, dtype=float)\n    i = 0\n    while i < feasible.size:\n        score[i] = 0.5 * ratio_d[i] + 0.5 * ratio_v[i]\n        i += 1\n\n    noise = np.arange(feasible.size) * 1e-6\n    score += noise\n\n    top_k = 5\n    if top_k > feasible.size:\n        top_k = feasible.size\n    top_indices = np.argsort(score)[:top_k]\n    chosen = top_indices[0]\n\n    return int(feasible[chosen])\n\n",
  "min_variance_step_aug_236": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    if candidates.size == 0:\n        return depot\n\n    cap = rest_capacity\n    cand = np.asarray(candidates, dtype=int)\n    feasible = cand[demands[cand] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    d_current = dist_mat[current_node, feasible].astype(float)\n    median_d = np.median(d_current) + 1e-12\n\n    dist_subset = dist_mat[np.ix_(feasible, cand)].astype(float)\n    var = np.var(dist_subset, axis=1)\n    max_v = np.max(var) + 1e-12\n\n    ratio_d = np.clip(d_current / median_d, 0, np.inf)\n    ratio_v = np.clip(var / max_v, 0, np.inf)\n\n    score = 0.8 * ratio_d + 0.2 * ratio_v\n    noise = np.arange(feasible.size) * 1e-9\n    score += noise\n\n    top_k = 4\n    if top_k > feasible.size:\n        top_k = feasible.size\n    top_indices = np.argpartition(score, top_k - 1)[:top_k]\n    chosen = top_indices[np.argmin(score[top_indices])]\n\n    return int(feasible[chosen])\n\n",
  "depot_return_deadline_aug_237": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # feasible nodes given remaining capacity\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= rest_capacity], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # clip distances to avoid negative values\n    d_cd = float(np.clip(distance_matrix[current_node, depot], 0, None))\n    d_cn = np.clip(distance_matrix[current_node, feasible], 0, None).astype(float)\n    d_nd = np.clip(distance_matrix[feasible, depot], 0, None).astype(float)\n\n    # use mean as threshold and invert the far condition\n    mean_to_depot = float(np.mean(distance_matrix[depot, feasible]) + 1e-12)\n    far = d_cd < mean_to_depot\n\n    if far:                     # node is close \u2192 prefer decreasing depot distance\n        score = d_cn + 0.3 * d_nd\n    else:                       # node is far \u2192 prefer nearest neighbor\n        score = d_nd\n\n    # add tiny deterministic noise to break ties\n    noise = np.random.default_rng(42).uniform(-1e-6, 1e-6, size=score.shape)\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "depot_return_deadline_aug_238": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Find first feasible node by iterating\n    idx = 0\n    feasible = np.empty((0,), dtype=int)\n    while idx < unvisited_nodes.size:\n        node = unvisited_nodes[idx]\n        if demands[node] <= rest_capacity:\n            feasible = np.append(feasible, node)\n        idx += 1\n\n    if feasible.size == 0:\n        return depot\n\n    # Distances clipped to non\u2011negative\n    d_cd = float(np.clip(distance_matrix[current_node, depot], 0, None))\n    d_cn = np.clip(distance_matrix[current_node, feasible], 0, None).astype(float)\n    d_nd = np.clip(distance_matrix[feasible, depot], 0, None).astype(float)\n\n    # Choose top 5 nearest by current node distance\n    top_k = min(5, feasible.size)\n    top_indices = np.argpartition(d_cn, top_k - 1)[:top_k]\n    top_nodes = feasible[top_indices]\n    top_d_cn = d_cn[top_indices]\n    top_d_nd = d_nd[top_indices]\n\n    # Weighted score: 60% current distance, 40% depot distance\n    score = 0.6 * top_d_cn + 0.4 * top_d_nd\n\n    # Deterministic tie\u2011breaker: add small uniform noise\n    rng = np.random.default_rng(7)\n    score += rng.uniform(-1e-6, 1e-6, size=score.shape)\n\n    chosen = top_nodes[np.argmin(score)]\n    return int(chosen)\n\n",
  "depot_return_deadline_aug_239": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible mask\n    feasible_mask = demands[unvisited_nodes] <= rest_capacity\n    feasible = unvisited_nodes[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    # Use squared distances as proxy\n    d_cd = float(np.clip(distance_matrix[current_node, depot], 0, None))\n    d_cn = np.clip(distance_matrix[current_node, feasible], 0, None).astype(float)\n    d_nd = np.clip(distance_matrix[feasible, depot], 0, None).astype(float)\n\n    # Invert far condition: close nodes get higher weight\n    far = d_cd > float(np.median(distance_matrix[depot, feasible]) + 1e-12)\n    if far:\n        score = d_nd + 0.3 * d_cn\n    else:\n        score = d_cn\n\n    # Soft\u2011min with temperature\n    temperature = 0.5  # small temperature \u2192 more greedy\n    denom = temperature + 1e-12\n    weights = np.exp(-score / denom)\n    probs = weights / np.clip(np.sum(weights), 1e-12, None)\n\n    # Deterministic random choice using fixed seed\n    rng = np.random.default_rng(123)\n    chosen_idx = rng.choice(feasible.size, p=probs)\n    return int(feasible[chosen_idx])\n\n",
  "depot_return_deadline_aug_240": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= rest_capacity], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # Clip distances\n    d_cd = float(np.clip(distance_matrix[current_node, depot], 0, None))\n    d_cn = np.clip(distance_matrix[current_node, feasible], 0, None).astype(float)\n    d_nd = np.clip(distance_matrix[feasible, depot], 0, None).astype(float)\n\n    # Use max distance to depot as threshold (more aggressive)\n    max_to_depot = float(np.max(distance_matrix[depot, feasible]) + 1e-12)\n    far = d_cd > max_to_depot\n\n    if far:\n        score = d_cn + 0.3 * d_nd\n    else:\n        score = d_nd + 0.3 * d_cn\n\n    # Sum\u2011based aggregation\n    agg = np.sum(score) + 1e-12  # epsilon to avoid zero division\n\n    # Softmax probabilities\n    exp_scores = np.exp(-score / (0.7 + 1e-12))   # temperature 0.7\n    probs = exp_scores / np.clip(np.sum(exp_scores), 1e-12, None)\n\n    # Deterministic random pick\n    rng = np.random.default_rng(9)\n    chosen_idx = rng.choice(feasible.size, p=probs)\n    return int(feasible[chosen_idx])\n\n",
  "kmedoids_proxy_aug_241": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # rename for clarity\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    # feasible nodes that fit in remaining capacity\n    feasible = cand[demands[cand] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # distances from depot to each feasible node\n    d_dep = distance_matrix[depot, feasible].astype(float)\n    d_dep = np.clip(d_dep, 0, None)  # ensure non\u2011negative\n\n    # choose two medoid candidates: closest and farthest from depot\n    idx_closest = int(np.argmin(d_dep))\n    idx_farthest = int(np.argmax(d_dep))\n    m1 = int(feasible[idx_closest])\n    m2 = int(feasible[idx_farthest])\n\n    # assign all unvisited nodes to nearest of the two medoids\n    d_to_m1 = distance_matrix[cand, m1].astype(float)\n    d_to_m2 = distance_matrix[cand, m2].astype(float)\n    cost1 = float(np.sum(np.minimum(d_to_m1, d_to_m2)))\n\n    # pick the medoid with smaller cost (deterministic)\n    target = m1 if cost1 <= cost1 else m2\n\n    # move toward the chosen medoid: pick feasible node closest to target\n    d_to_target = distance_matrix[feasible, target].astype(float)\n    next_idx = int(np.argmin(d_to_target))\n    return int(feasible[next_idx])\n\n",
  "kmedoids_proxy_aug_242": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    feasible = cand[demands[cand] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # distances from depot to feasible nodes\n    d_dep = distance_matrix[depot, feasible].astype(float)\n\n    # two medoid candidates\n    m1 = int(feasible[np.argmin(d_dep)])\n    m2 = int(feasible[np.argmax(d_dep)])\n\n    # compute weighted cost for all unvisited nodes\n    w = 0.6  # weight for distance, 0.4 for assignment cost\n    d1 = distance_matrix[cand, m1].astype(float)\n    d2 = distance_matrix[cand, m2].astype(float)\n    assign_cost = np.minimum(d1, d2)\n    weighted_cost = w * d_dep[np.argmin(d_dep)] + (1 - w) * np.sum(assign_cost)\n\n    target = m1 if weighted_cost <= weighted_cost else m2  # deterministic placeholder\n\n    # softmin over distances to the chosen target\n    d_target = distance_matrix[feasible, target].astype(float)\n    # temperature controls softness\n    temp = 0.5\n    exp_vals = np.exp(-d_target / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n\n    # top\u2011k selection (k=7)\n    top_k = min(7, len(feasible))\n    top_indices = np.argpartition(-probs, top_k - 1)[:top_k]\n    top_probs = probs[top_indices]\n    top_probs /= np.sum(top_probs) + 1e-12\n\n    # random choice weighted by top\u2011k probabilities\n    chosen = np.random.choice(feasible[top_indices], p=top_probs)\n    return int(chosen)\n\n",
  "kmedoids_proxy_aug_243": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    feasible = cand[demands[cand] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # distances from depot\n    d_dep = distance_matrix[depot, feasible].astype(float)\n\n    # two medoid candidates\n    m1 = int(feasible[np.argmin(d_dep)])\n    m2 = int(feasible[np.argmax(d_dep)])\n\n    # assign all unvisited nodes to nearest medoid\n    d1 = distance_matrix[cand, m1].astype(float)\n    d2 = distance_matrix[cand, m2].astype(float)\n    assign_cost = np.minimum(d1, d2)\n\n    # use median of assignment cost instead of sum\n    median_cost = float(np.median(assign_cost))\n\n    target = m1 if median_cost <= median_cost else m2  # deterministic placeholder\n\n    # add deterministic noise for tie\u2011breaking\n    noise = 1e-6 * np.arange(len(feasible))\n    d_to_target = distance_matrix[feasible, target].astype(float) + noise\n    # use argpartition to find the closest feasible node\n    idx = int(np.argpartition(d_to_target, 0)[0])\n    return int(feasible[idx])\n\n",
  "kmedoids_proxy_aug_244": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    feasible = cand[demands[cand] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # distances from depot to feasible nodes\n    d_dep = distance_matrix[depot, feasible].astype(float)\n    # inverse distance as weight (avoid division by zero)\n    inv_d = 1.0 / (d_dep + 1e-12)\n\n    # normalize weights to get probabilities\n    probs = inv_d / (np.sum(inv_d) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n\n    # randomly select a feasible node weighted by these probabilities\n    chosen = np.random.choice(feasible, p=probs)\n    return int(chosen)\n\n",
  "capacity_scaled_insertion_aug_245": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Build feasible list with a while loop (syntactic rewrite)\n    feasible = np.empty(0, dtype=int)\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = unvisited_nodes[idx]\n        if demands[node] <= cap + 1e-12:\n            feasible = np.append(feasible, node)\n        idx += 1\n\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = np.square(distance_matrix[current_node, feasible]).astype(float)\n    d_nd = np.square(distance_matrix[feasible, depot]).astype(float)\n\n    ins = d_cn + d_nd - d_cd\n    dem = demands[feasible].astype(float)\n\n    scaled = ins * (1.0 + dem / (cap + 1e-12))\n    scaled = np.clip(scaled, 0, np.inf)  # prevent overflow\n\n    return int(feasible[np.argmin(scaled)])\n\n",
  "capacity_scaled_insertion_aug_246": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap + 1e-12], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    ins = d_cn + d_nd - d_cd\n    dem = demands[feasible].astype(float)\n\n    # Parameter tuning: weighted sum\n    score = 0.6 * ins + 0.4 * dem / (cap + 1e-12)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(feasible.size, dtype=float) * 1e-6\n    score += noise\n\n    # Top\u2011k selection\n    top_k = min(7, feasible.size)\n    idx_top = np.argpartition(score, top_k - 1)[:top_k]\n    top_scores = score[idx_top]\n\n    # Softmin probabilities\n    temp = 0.5\n    probs = np.exp(-top_scores / temp)\n    probs /= probs.sum()\n\n    rng = np.random.default_rng(42)\n    chosen = rng.choice(idx_top, p=probs)\n    return int(feasible[chosen])\n\n",
  "capacity_scaled_insertion_aug_247": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap + 1e-12], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    ins = d_cn + d_nd - d_cd\n    dem = demands[feasible].astype(float)\n\n    scaled = ins * (1.0 + dem / (cap + 1e-12))\n\n    # Use median instead of mean for robustness\n    med = np.median(scaled)\n    scaled -= med\n\n    # Deterministic noise for tie\u2011breaking\n    scaled += np.arange(feasible.size, dtype=float) * 1e-6\n\n    # Random choice among the 5 lowest scaled values\n    top_k = min(5, feasible.size)\n    idx_top = np.argpartition(scaled, top_k - 1)[:top_k]\n\n    rng = np.random.default_rng(123)\n    chosen = rng.choice(idx_top)\n    return int(feasible[chosen])\n\n",
  "capacity_scaled_insertion_aug_248": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap + 1e-12], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    # Proxy distance: Manhattan (absolute) distance\n    d_cd = float(np.abs(distance_matrix[current_node, depot]))\n    d_cn = np.abs(distance_matrix[current_node, feasible]).astype(float)\n    d_nd = np.abs(distance_matrix[feasible, depot]).astype(float)\n\n    ins = d_cn + d_nd - d_cd\n    dem = demands[feasible].astype(float)\n\n    scaled = ins * (1.0 + dem / (cap + 1e-12))\n    scaled = np.clip(scaled, 0, np.inf)\n\n    mean_val = np.mean(scaled)\n\n    # Random tie\u2011breaking among nodes within 1% of the mean\n    threshold = mean_val * 1.01\n    mask = scaled <= threshold\n    candidates = feasible[mask]\n    if candidates.size == 0:\n        candidates = feasible\n\n    rng = np.random.default_rng(7)\n    return int(rng.choice(candidates))\n\n",
  "nearest_neighbor_with_isolation_penalty_aug_249": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    feasible_mask = demands[candidates] <= cap\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = candidates[feasible_mask]\n    dist_mat = distance_matrix\n    dist_fu = dist_mat[np.ix_(feasible, candidates)].astype(float)\n\n    # Replace distance to itself with infinity to avoid self\u2011neighbour\n    for idx, node in enumerate(feasible):\n        same_idx = np.where(candidates == node)[0]\n        if same_idx.size > 0:\n            dist_fu[idx, same_idx[0]] = np.inf\n\n    nn = np.min(dist_fu, axis=1)\n    d_cn = dist_mat[current_node, feasible].astype(float)\n\n    # Small deterministic noise for tie\u2011breaking\n    rng = np.random.default_rng(seed=42)\n    noise = rng.random(feasible.size) * 1e-6\n\n    score = d_cn + 0.5 * nn + noise\n    return int(feasible[np.argmin(score)])\n\n",
  "nearest_neighbor_with_isolation_penalty_aug_250": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    rest_cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    feasible_mask = demands[candidates] <= rest_cap\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = candidates[feasible_mask]\n    dist_mat = distance_matrix\n    dist_fu = dist_mat[np.ix_(feasible, candidates)].astype(float)\n\n    for i, node in enumerate(feasible):\n        same = np.where(candidates == node)[0]\n        if same.size > 0:\n            dist_fu[i, same[0]] = np.inf\n\n    nn = np.min(dist_fu, axis=1)\n    d_cn = dist_mat[current_node, feasible].astype(float)\n\n    score = d_cn + 0.4 * nn\n    # Clip to avoid overflow in exp\n    score_clipped = np.clip(score, None, 700)\n\n    temp = 0.3\n    exp_vals = np.exp(-score_clipped / temp)\n    denom = np.sum(exp_vals) + 1e-12  # epsilon to avoid division by zero\n    probs = exp_vals / denom\n\n    rng = np.random.default_rng()\n    chosen_idx = rng.choice(len(feasible), p=probs)\n    return int(feasible[chosen_idx])\n\n",
  "nearest_neighbor_with_isolation_penalty_aug_251": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = [int(x) for x in unvisited_nodes]\n    feasible = [c for c in candidates if demands[c] <= cap]\n    if not feasible:\n        return depot\n\n    dist_mat = distance_matrix\n    # Isolation via mean distance to all other candidates\n    isolation = []\n    for node in feasible:\n        others = [c for c in candidates if c != node]\n        if others:\n            dists = dist_mat[node, others]\n            isolation.append(np.mean(dists))\n        else:\n            isolation.append(np.inf)\n\n    d_cn = np.array([dist_mat[current_node, node] for node in feasible], dtype=float)\n    score = d_cn + 0.6 * np.array(isolation)\n\n    rng = np.random.default_rng(seed=123)\n    noise = rng.random(len(feasible)) * 1e-7\n    score += noise\n\n    top_k = 5\n    if len(feasible) > top_k:\n        idxs = np.argpartition(score, top_k)[:top_k]\n    else:\n        idxs = np.arange(len(feasible))\n\n    chosen_idx = rng.choice(idxs)\n    return int(feasible[chosen_idx])\n\n",
  "nearest_neighbor_with_isolation_penalty_aug_252": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    feasible = []\n    for node in candidates:\n        if demands[node] <= cap:\n            feasible.append(node)\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n    dist_mat = distance_matrix\n\n    isolation = []\n    for node in feasible:\n        others = candidates[candidates != node]\n        if others.size > 0:\n            dists = dist_mat[node, others]\n            isolation.append(np.max(dists))\n        else:\n            isolation.append(0.0)\n\n    isolation = np.array(isolation, dtype=float)\n    d_cn = dist_mat[current_node, feasible].astype(float)\n\n    # Clip distances to avoid overflow\n    d_cn = np.clip(d_cn, None, 1e6)\n    isolation = np.clip(isolation, None, 1e6)\n\n    score = d_cn + 0.7 * isolation\n    rng = np.random.default_rng(seed=7)\n    noise = rng.random(score.size) * 1e-5\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "lexicographic_demand_then_distance_aug_253": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename variables for clarity\n    candidates = unvisited_nodes\n    capacity = float(rest_capacity)\n\n    # Ensure demands are non\u2011negative and bounded by the vehicle capacity\n    dem = np.clip(demands, 0, capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    # Feasible nodes: demand fits in the remaining capacity\n    feasible = candidates[dem[candidates] <= capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Find the maximum demand among feasible nodes\n    max_demand = np.max(dem[feasible])\n    max_nodes = feasible[dem[feasible] >= max_demand - 1e-12]\n\n    # Distances from the current node to the candidate nodes\n    dist = distance_matrix[current_node, max_nodes]\n\n    # Add tiny deterministic noise to break ties in a reproducible way\n    rng = np.random.default_rng(42)\n    noise = rng.uniform(-1e-6, 1e-6, size=dist.shape)\n    dist_noisy = dist + noise\n\n    # Pick the node with the smallest (noisy) distance\n    idx = int(np.argmin(dist_noisy))\n    return int(max_nodes[idx])\n\n",
  "lexicographic_demand_then_distance_aug_254": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Variable renaming\n    nodes = unvisited_nodes\n    capacity = float(rest_capacity)\n\n    # Clip demands to a valid range\n    dem = np.clip(demands, 0, capacity)\n\n    if nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = nodes[dem[nodes] <= capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Weighted score: prioritize demand, penalize distance\n    alpha = 0.8   # demand weight\n    beta = 0.2    # distance weight\n    dist = distance_matrix[current_node, feasible]\n    score = alpha * dem[feasible] - beta * dist\n\n    # Top\u2011k selection (k = 7)\n    top_k = 7\n    if feasible.size <= top_k:\n        top_idx = np.argsort(-score)  # descending order\n    else:\n        top_idx = np.argpartition(-score, top_k - 1)[:top_k]\n        top_idx = top_idx[np.argsort(-score[top_idx])]\n\n    top_nodes = feasible[top_idx]\n\n    # Among the top nodes, choose the one with the smallest distance\n    top_dist = distance_matrix[current_node, top_nodes]\n    idx = int(np.argmin(top_dist))\n    return int(top_nodes[idx])\n\n",
  "lexicographic_demand_then_distance_aug_255": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Rename for readability\n    nodes = unvisited_nodes\n    capacity = float(rest_capacity)\n\n    # Ensure valid demand values\n    dem = np.clip(demands, 0, capacity)\n\n    if nodes.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = nodes[dem[nodes] <= capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Nodes with the maximum demand\n    max_demand = np.max(dem[feasible])\n    max_nodes = feasible[dem[feasible] >= max_demand - 1e-12]\n\n    # Distances to the current node\n    dist = distance_matrix[current_node, max_nodes]\n\n    # Soft\u2011min with temperature T\n    T = 0.5\n    dist_clipped = np.clip(dist, 0, 1e6)          # avoid overflow\n    exp_vals = np.exp(-dist_clipped / (T + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)  # epsilon on denominator\n\n    # Deterministic weighted choice\n    rng = np.random.default_rng(123)\n    chosen_idx = int(rng.choice(len(max_nodes), p=probs))\n    return int(max_nodes[chosen_idx])\n\n",
  "lexicographic_demand_then_distance_aug_256": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Variable renaming\n    cand = unvisited_nodes\n    capacity = float(rest_capacity)\n\n    # Clip demands\n    dem = np.clip(demands, 0, capacity)\n\n    if cand.size == 0:\n        return depot\n\n    # Feasible nodes\n    feasible = cand[dem[cand] <= capacity]\n    if feasible.size == 0:\n        return depot\n\n    # Nodes with the maximum demand\n    max_demand = np.max(dem[feasible])\n    max_nodes = feasible[dem[feasible] >= max_demand - 1e-12]\n\n    # Use squared distance as a proxy metric\n    sq_dist = np.square(distance_matrix[current_node, max_nodes])\n    sq_dist = np.clip(sq_dist, 0, 1e12)  # bound to avoid overflow\n\n    # Choose the node with the maximum squared distance\n    idx = int(np.argmax(sq_dist))\n\n    # Deterministic noise to break ties\n    rng = np.random.default_rng(7)\n    noise = rng.uniform(-1e-6, 1e-6, size=sq_dist.shape)\n    noisy_sq = sq_dist + noise\n    idx = int(np.argmax(noisy_sq))\n    return int(max_nodes[idx])\n\n",
  "closest_to_depot_when_fullness_high_aug_257": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    # Feasible nodes\n    feasible_mask = demands[candidates] <= cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    # Avoid division by zero\n    mean_dem = np.mean(demands[candidates] + 1e-12)\n    tight = cap < 1.2 * mean_dem\n\n    # Distances (clip to avoid negative values)\n    d_cur = np.clip(dist_mat[current_node, feasible], 0, np.inf)\n    d_dep = np.clip(dist_mat[depot, feasible], 0, np.inf)\n\n    # Weighted score\n    score = (0.25 * d_cur + 0.75 * d_dep) if tight else (0.85 * d_cur + 0.15 * d_dep)\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(len(score)) * 1e-6\n    score += noise\n\n    # Soft\u2011min selection\n    temp = 1.0\n    exp_vals = np.exp(-score / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    idx = np.argmax(probs)\n\n    return int(feasible[idx])\n\n",
  "closest_to_depot_when_fullness_high_aug_258": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    feasible_mask = demands[candidates] <= cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    median_dem = np.median(demands[candidates] + 1e-12)\n    tight = cap < 1.5 * median_dem\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n\n    score = (0.6 * d_cur + 0.4 * d_dep) if tight else (0.7 * d_cur + 0.3 * d_dep)\n\n    top_k = 7\n    if len(score) <= top_k:\n        chosen = np.random.choice(len(score))\n    else:\n        top_indices = np.argpartition(score, -top_k)[-top_k:]\n        chosen = np.random.choice(top_indices)\n\n    return int(feasible[chosen])\n\n",
  "closest_to_depot_when_fullness_high_aug_259": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    feasible_mask = demands[candidates] <= cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    max_dem = np.max(demands[candidates] + 1e-12)\n    tight = cap < 1.1 * max_dem\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n\n    score = 0.8 * np.maximum(d_cur, 1e-12) + 0.2 * np.maximum(d_dep, 1e-12)\n\n    noise = np.arange(len(score)) * 1e-7\n    score += noise\n\n    top_k = 3\n    if len(score) <= top_k:\n        chosen = np.random.choice(len(score))\n    else:\n        top_indices = np.argpartition(score, -top_k)[-top_k:]\n        chosen = np.random.choice(top_indices)\n\n    return int(feasible[chosen])\n\n",
  "closest_to_depot_when_fullness_high_aug_260": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    feasible_mask = demands[candidates] <= cap\n    if not np.any(feasible_mask):\n        return depot\n    feasible = candidates[feasible_mask]\n\n    mean_dem = np.mean(demands[candidates] + 1e-12)\n    tight = cap < 1.4 * mean_dem\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n\n    score = d_cur + d_dep  # simple sum of distances\n\n    # Deterministic noise for tie\u2011breaking\n    score += np.arange(len(score)) * 1e-7\n\n    top_k = 5\n    if len(score) <= top_k:\n        chosen = np.random.choice(len(score))\n    else:\n        top_indices = np.argpartition(score, -top_k)[-top_k:]\n        chosen = np.random.choice(top_indices)\n\n    return int(feasible[chosen])\n\n",
  "capacity_splitter_low_high_aug_261": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    rem_cap = float(rest_capacity)\n    reqs = demands\n\n    # feasible set\n    feasible_mask = reqs[candidates] <= rem_cap\n    feasible = candidates[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    # split by median demand\n    dem_vals = reqs[feasible].astype(float)\n    med_val = float(np.median(dem_vals))\n    low = feasible[dem_vals <= med_val]\n    high = feasible[dem_vals > med_val]\n\n    # preference rule\n    prefer_high = (current_node % 2 == 0)\n    if prefer_high and high.size > 0:\n        cand = high\n    elif low.size > 0:\n        cand = low\n    else:\n        cand = feasible\n\n    # distances to candidates\n    dists = dist_mat[current_node, cand].astype(float)\n\n    # find the minimal distance using a while loop\n    min_idx = 0\n    min_val = dists[0]\n    i = 1\n    while i < dists.size:\n        if dists[i] < min_val:\n            min_val = dists[i]\n            min_idx = i\n        i += 1\n\n    return int(cand[min_idx])\n\n",
  "capacity_splitter_low_high_aug_262": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    rem_cap = float(rest_capacity)\n    reqs = demands\n\n    # feasible nodes\n    feasible_mask = reqs[candidates] <= rem_cap\n    feasible = candidates[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    dem_vals = reqs[feasible].astype(float)\n    med_val = float(np.median(dem_vals))\n    low = feasible[dem_vals <= med_val]\n    high = feasible[dem_vals > med_val]\n\n    prefer_high = (current_node % 2 == 0)\n    if prefer_high and high.size > 0:\n        cand = high\n    elif low.size > 0:\n        cand = low\n    else:\n        cand = feasible\n\n    # distances\n    dists = dist_mat[current_node, cand].astype(float)\n    dists = np.clip(dists, 0, None)\n\n    # weighted score: distance + demand ratio\n    weight_dist = 0.7\n    weight_dem = 0.3\n    dem_ratio = reqs[cand].astype(float) / (rem_cap + 1e-12)\n    score = weight_dist * dists + weight_dem * dem_ratio\n\n    # top\u2011k filtering\n    top_k = 7\n    if score.size > top_k:\n        idx_top = np.argpartition(score, top_k)[:top_k]\n        cand = cand[idx_top]\n        dists = dists[idx_top]\n        score = score[idx_top]\n\n    # choose minimal score\n    idx = int(np.argmin(score))\n    return int(cand[idx])\n\n",
  "capacity_splitter_low_high_aug_263": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    rem_cap = float(rest_capacity)\n    reqs = demands\n\n    feasible_mask = reqs[candidates] <= rem_cap\n    feasible = candidates[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    dem_vals = reqs[feasible].astype(float)\n    med_val = float(np.median(dem_vals))\n    low = feasible[dem_vals <= med_val]\n    high = feasible[dem_vals > med_val]\n\n    prefer_high = (current_node % 2 == 0)\n    if prefer_high and high.size > 0:\n        cand = high\n    elif low.size > 0:\n        cand = low\n    else:\n        cand = feasible\n\n    # distances with deterministic noise for tie\u2011breaking\n    dists = dist_mat[current_node, cand].astype(float)\n    noise = np.arange(dists.size) * 1e-9\n    dists_noisy = dists + noise\n\n    # softmin probabilities\n    tau = 1.0\n    exp_vals = np.exp(-(dists_noisy) / (tau + 1e-12))\n    probs = exp_vals / np.clip(np.sum(exp_vals), 1e-12, None)\n\n    # select among the nearest top\u2011k\n    top_k = 5\n    idx_top = np.argsort(dists_noisy)[:top_k]\n    probs_top = probs[idx_top]\n    probs_top = probs_top / np.clip(np.sum(probs_top), 1e-12, None)\n\n    rng = np.random.default_rng(seed=42)\n    chosen = rng.choice(idx_top, p=probs_top)\n    return int(cand[chosen])\n\n",
  "capacity_splitter_low_high_aug_264": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    rem_cap = float(rest_capacity)\n    reqs = demands\n\n    feasible_mask = reqs[candidates] <= rem_cap\n    feasible = candidates[feasible_mask]\n    if feasible.size == 0:\n        return depot\n\n    dem_vals = reqs[feasible].astype(float)\n    med_val = float(np.median(dem_vals))\n    low = feasible[dem_vals <= med_val]\n    high = feasible[dem_vals > med_val]\n\n    prefer_high = (current_node % 2 == 0)\n    if prefer_high and high.size > 0:\n        cand = high\n    elif low.size > 0:\n        cand = low\n    else:\n        cand = feasible\n\n    # squared distances for numerical stability\n    dists_sq = np.square(dist_mat[current_node, cand]).astype(float)\n    dists_sq = np.clip(dists_sq, 0, None)\n\n    # demand ratio\n    dem_vals_cand = reqs[cand].astype(float)\n    dem_ratio = dem_vals_cand / (rem_cap + 1e-12)\n\n    # combined score\n    score = dists_sq * 0.6 + dem_ratio * 0.4\n\n    # softmax probabilities\n    tau = 0.5\n    exp_vals = np.exp(-score / (tau + 1e-12))\n    probs = exp_vals / np.clip(np.sum(exp_vals), 1e-12, None)\n\n    # top\u2011k selection\n    top_k = 3\n    idx_top = np.argsort(score)[:top_k]\n    probs_top = probs[idx_top]\n    probs_top = probs_top / np.clip(np.sum(probs_top), 1e-12, None)\n\n    rng = np.random.default_rng(seed=7)\n    chosen = rng.choice(idx_top, p=probs_top)\n    return int(cand[chosen])\n\n",
  "min_cross_distance_to_route_aug_265": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n\n    # use squared distances in the scoring\n    score = np.maximum(np.square(d_cur), np.square(d_dep)) + 0.1 * (d_cur + d_dep)\n    idx = np.argmin(score)\n    return int(feasible[idx])\n\n",
  "min_cross_distance_to_route_aug_266": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n\n    # choose the 7 nodes closest to the depot\n    top_k = 7\n    if feasible.size > top_k:\n        idx_top = np.argsort(d_dep)[:top_k]\n        feasible = feasible[idx_top]\n        d_cur = d_cur[idx_top]\n        d_dep = d_dep[idx_top]\n\n    # updated weighting\n    score = np.maximum(d_cur, d_dep) + 0.25 * (d_cur + d_dep)\n    idx = np.argmin(score)\n    return int(feasible[idx])\n\n",
  "min_cross_distance_to_route_aug_267": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n\n    # base score with small deterministic noise\n    score = np.maximum(d_cur, d_dep) + 0.1 * (d_cur + d_dep)\n    noise = np.random.uniform(-1e-6, 1e-6, size=score.shape)\n    score_noisy = score + noise\n\n    # soft\u2011min probabilities\n    T = 0.5\n    exp_vals = np.exp(-score_noisy / (T + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n\n    # random choice among top\u2011k weighted by probabilities\n    top_k = 5\n    if feasible.size > top_k:\n        idx_top = np.argsort(score_noisy)[:top_k]\n        feasible_top = feasible[idx_top]\n        probs_top = probs[idx_top]\n        probs_top = probs_top / (np.sum(probs_top) + 1e-12)\n        chosen = np.random.choice(len(feasible_top), p=probs_top)\n        return int(feasible_top[chosen])\n    else:\n        chosen = np.random.choice(len(feasible), p=probs)\n        return int(feasible[chosen])\n\n",
  "min_cross_distance_to_route_aug_268": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cur = dist_mat[current_node, feasible]\n    d_dep = dist_mat[depot, feasible]\n\n    # clip to avoid extreme values\n    d_cur = np.clip(d_cur, 0, 1e6)\n    d_dep = np.clip(d_dep, 0, 1e6)\n\n    # median of summed distances and max of individual distances\n    sum_med = np.median(d_cur + d_dep)\n    max_val = np.max(np.maximum(d_cur, d_dep))\n    score = 0.15 * (d_cur + d_dep - sum_med) + 0.85 * max_val\n\n    # weighting by inverse depot distance\n    inv_dep = 1.0 / (d_dep + 1e-12)\n    weights = inv_dep / (np.sum(inv_dep) + 1e-12)\n    weights = np.clip(weights, 0, 1)\n\n    top_k = 6\n    if feasible.size > top_k:\n        idx_top = np.argsort(score)[:top_k]\n        feasible_top = feasible[idx_top]\n        weights_top = weights[idx_top]\n        weights_top = weights_top / (np.sum(weights_top) + 1e-12)\n        chosen = np.random.choice(len(feasible_top), p=weights_top)\n        return int(feasible_top[chosen])\n    else:\n        chosen = np.random.choice(len(feasible), p=weights)\n        return int(feasible[chosen])\n\n",
  "ranked_borda_count_aug_269": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Short\u2011circuit when nothing is left to visit\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    # Feasible candidates that respect the remaining capacity\n    remaining_cap = float(rest_capacity)\n    feasible = np.array([c for c in unvisited_nodes if demands[c] <= remaining_cap], dtype=int)\n\n    # If no candidate fits, return to depot\n    if len(feasible) == 0:\n        return depot\n\n    # Distances and demands for the feasible nodes\n    d_cur  = distance_matrix[current_node, feasible].astype(float)\n    d_dep  = distance_matrix[depot,   feasible].astype(float)\n    dem    = demands[feasible].astype(float)\n\n    n = len(feasible)\n\n    # Ranking (lower distance \u2192 higher rank)\n    r1 = np.argsort(np.argsort(d_cur))\n    r2 = np.argsort(np.argsort(d_dep))\n    r3 = np.argsort(np.argsort(-dem))\n\n    # Borda points + deterministic noise for tie\u2011breaking\n    points = (n - 1 - r1) + (n - 1 - r2) + (n - 1 - r3)\n    points = points + 1e-6 * np.arange(n)          # deterministic noise\n\n    # Pick the candidate with the highest points\n    return int(feasible[int(np.argmax(points))])\n\n",
  "ranked_borda_count_aug_270": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    remaining_cap = float(rest_capacity)\n    feasible = np.array([c for c in unvisited_nodes if demands[c] <= remaining_cap], dtype=int)\n\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    d_dep = distance_matrix[depot,   feasible].astype(float)\n    dem   = demands[feasible].astype(float)\n\n    # Normalise distances and demands\n    eps = 1e-12\n    norm_d_cur = (d_cur - d_cur.min()) / (d_cur.ptp() + eps)\n    norm_d_dep = (d_dep - d_dep.min()) / (d_dep.ptp() + eps)\n    norm_dem   = (dem - dem.min())   / (dem.ptp()   + eps)\n\n    # Weighted score (lower is better)\n    w_cur, w_dep, w_dem = 0.4, 0.4, 0.2\n    score = w_cur * norm_d_cur + w_dep * norm_d_dep - w_dem * norm_dem\n\n    # Deterministic noise for tie\u2011breaking\n    score += 1e-6 * np.arange(len(feasible))\n\n    # Select the top\u2011k candidates and choose the best one\n    top_k = 7\n    top_idx = np.argpartition(score, top_k - 1)[:top_k]\n    best_idx = top_idx[np.argmin(score[top_idx])]\n\n    return int(feasible[best_idx])\n\n",
  "ranked_borda_count_aug_271": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    remaining_cap = float(rest_capacity)\n    feasible = np.array([c for c in unvisited_nodes if demands[c] <= remaining_cap], dtype=int)\n\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    d_dep = distance_matrix[depot,   feasible].astype(float)\n    dem   = demands[feasible].astype(float)\n\n    # Median of the two distance sets\n    combined_dist = np.median(np.vstack([d_cur, d_dep]), axis=0)\n\n    # Score: distance minus a fraction of demand\n    score = combined_dist - 0.5 * dem\n\n    # Softmax (lower score \u2192 higher probability)\n    temp = 0.5\n    eps = 1e-12\n    exp_vals = np.exp(-score / temp)\n    probs = exp_vals / (exp_vals.sum() + eps)\n\n    # Deterministic noise added to probabilities\n    probs += 1e-6 * np.arange(len(probs)) / len(probs)\n    probs = np.clip(probs, 0, 1)  # safety bound\n\n    # Choose the node with the highest probability\n    chosen_idx = int(np.argmax(probs))\n    return int(feasible[chosen_idx])\n\n",
  "ranked_borda_count_aug_272": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    remaining_cap = float(rest_capacity)\n    feasible = np.array([c for c in unvisited_nodes if demands[c] <= remaining_cap], dtype=int)\n\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    d_dep = distance_matrix[depot,   feasible].astype(float)\n    dem   = demands[feasible].astype(float)\n\n    # Squared distances as proxy\n    d_cur_sq = np.square(d_cur)\n    d_dep_sq = np.square(d_dep)\n\n    # Mean of the squared distances\n    mean_sq = (d_cur_sq + d_dep_sq) / 2.0\n    n = len(feasible)\n\n    # Ranking based on mean distance and demand\n    r_mean = np.argsort(np.argsort(mean_sq))\n    r_dem  = np.argsort(np.argsort(-dem))\n\n    # Borda points with clipping to avoid overflow\n    points = (n - 1 - r_mean) + (n - 1 - r_dem)\n    points = np.clip(points, 0, 2 * (n - 1))\n\n    # Deterministic noise for tie\u2011breaking\n    points += 1e-6 * np.arange(n)\n\n    return int(feasible[int(np.argmax(points))])\n\n",
  "max_margin_to_capacity_aug_273": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = np.clip(float(rest_capacity), 0, np.inf)\n    candidates = unvisited_nodes.copy()\n    feasible = np.empty(0, dtype=int)\n    idx = 0\n    while idx < candidates.size:\n        node = candidates[idx]\n        if demands[node] <= cap:\n            feasible = np.append(feasible, node)\n        idx += 1\n\n    if feasible.size == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    median_demand = np.median(demands[candidates])\n    tight = cap < float(median_demand)\n\n    # Inverted logic: when tight, emphasize distance more\n    weight_dist = 0.6 if tight else 0.4\n    weight_dem = 1.0 - weight_dist\n\n    score = (weight_dist * (d_cn / (np.mean(d_cn) + 1e-12)) +\n             weight_dem * (dem / (np.mean(dem) + 1e-12)))\n\n    # Deterministic noise for tie-breaking\n    noise = np.arange(feasible.size) * 1e-9\n    score += noise\n\n    chosen_idx = int(np.argmin(score))\n    return int(feasible[chosen_idx])\n\n",
  "max_margin_to_capacity_aug_274": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = np.clip(float(rest_capacity), 0, np.inf)\n    mask = demands[unvisited_nodes] <= cap\n    if not np.any(mask):\n        return depot\n\n    feasible = unvisited_nodes[mask]\n    dem = demands[feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    tight = cap < float(np.median(demands[unvisited_nodes]))\n\n    if tight:\n        score = (0.4 * (dem / (np.mean(dem) + 1e-12)) +\n                 0.6 * (d_cn / (np.mean(d_cn) + 1e-12)))\n    else:\n        score = (0.7 * (d_cn / (np.mean(d_cn) + 1e-12)) +\n                 0.3 * (dem / (np.mean(dem) + 1e-12)))\n\n    # Softmin probabilities\n    temp = 0.5\n    exp_neg = np.exp(-score / (temp + 1e-12))\n    probs = exp_neg / np.clip(np.sum(exp_neg), 1e-12, None)\n\n    # Top\u2011k candidates\n    top_k = 7\n    if feasible.size > top_k:\n        top_idx = np.argpartition(score, top_k)[:top_k]\n        probs = probs[top_idx]\n        top_candidates = feasible[top_idx]\n    else:\n        top_candidates = feasible\n\n    probs = probs / np.clip(np.sum(probs), 1e-12, None)\n    chosen = np.random.choice(top_candidates, p=probs)\n    return int(chosen)\n\n",
  "max_margin_to_capacity_aug_275": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([node for node in unvisited_nodes if demands[node] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    tight = cap < float(np.median(demands[unvisited_nodes]))\n\n    # Invert logic: emphasize distance when tight\n    if tight:\n        denom_cn = np.clip(np.max(d_cn), 1e-12, None)\n        denom_dem = np.clip(np.max(dem), 1e-12, None)\n        score = (0.5 * (d_cn / denom_cn) +\n                 0.5 * (dem / denom_dem))\n    else:\n        score = d_cn  # nearest\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.linspace(0, 1e-9, score.size)\n    score += noise\n\n    chosen_idx = int(np.argmin(score))\n    return int(feasible[chosen_idx])\n\n",
  "max_margin_to_capacity_aug_276": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    mask = demands[unvisited_nodes] <= cap\n    if not np.any(mask):\n        return depot\n\n    feasible = unvisited_nodes[mask]\n    dem = demands[feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # Proxy scaling using sums\n    dem_scale = np.sum(dem) + 1e-12\n    dist_scale = np.sum(d_cn) + 1e-12\n\n    tight = cap < float(np.median(demands[unvisited_nodes]))\n\n    if tight:\n        score = (0.4 * (dem / dem_scale) +\n                 0.6 * (d_cn / dist_scale))\n    else:\n        score = (0.7 * (d_cn / dist_scale) +\n                 0.3 * (dem / dem_scale))\n\n    # Softmin probabilities\n    temp = 1.0\n    exp_neg = np.exp(-score / (temp + 1e-12))\n    probs = exp_neg / np.clip(np.sum(exp_neg), 1e-12, None)\n\n    # Deterministic noise before selecting the best\n    noise = np.arange(feasible.size) * 1e-9\n    adjusted = -np.log(probs + 1e-12) + noise\n    chosen_idx = int(np.argmin(adjusted))\n    return int(feasible[chosen_idx])\n\n",
  "short_edge_preferential_attachment_aug_277": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap_left = float(rest_capacity)\n    dmd = demands\n    dist_mat = distance_matrix\n    eps = 1e-12\n\n    # Build feasible indices with a while loop\n    feasible = np.empty(0, dtype=int)\n    idx = 0\n    while idx < len(unvisited_nodes):\n        node = unvisited_nodes[idx]\n        if dmd[node] <= cap_left:\n            feasible = np.append(feasible, node)\n        idx += 1\n\n    if len(feasible) == 0:\n        return depot\n\n    # Compute weights as inverse squared distance with tiny deterministic noise\n    rng = np.random.default_rng((int(current_node) * 97531 +\n                                 int(len(unvisited_nodes)) * 864197523) & 0xFFFFFFFF)\n    d = dist_mat[current_node, feasible].astype(float)\n    w = 1.0 / (np.square(d) + eps)\n    noise = rng.normal(scale=1e-6, size=w.shape)\n    w = np.clip(w + noise, 1e-12, None)\n\n    # Normalise to a probability distribution\n    p = w / (np.sum(w) + eps)\n    return int(rng.choice(feasible, p=p))\n\n",
  "short_edge_preferential_attachment_aug_278": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap_left = float(rest_capacity)\n    dmd = demands\n    dist_mat = distance_matrix\n    eps = 1e-12\n    top_k = 7\n\n    # Feasible mask and distances\n    mask = dmd[unvisited_nodes] <= cap_left\n    feasible_nodes = unvisited_nodes[mask]\n    if len(feasible_nodes) == 0:\n        return depot\n\n    dists = dist_mat[current_node, feasible_nodes].astype(float)\n\n    # Pick the top_k smallest distances\n    if len(feasible_nodes) > top_k:\n        idx_top = np.argpartition(dists, top_k)[:top_k]\n        feasible_nodes = feasible_nodes[idx_top]\n        dists = dists[idx_top]\n\n    # Compute inverse\u2011squared weights\n    w = 1.0 / (np.square(dists) + eps)\n    w = np.clip(w, 1e-12, None)\n\n    # Normalise to probabilities\n    p = w / (np.sum(w) + eps)\n\n    # Deterministic random choice\n    rng = np.random.default_rng((int(current_node) * 97531 +\n                                 int(len(unvisited_nodes)) * 864197523) & 0xFFFFFFFF)\n    return int(rng.choice(feasible_nodes, p=p))\n\n",
  "short_edge_preferential_attachment_aug_279": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap_left = float(rest_capacity)\n    dmd = demands\n    dist_mat = distance_matrix\n    eps = 1e-12\n    tie_eps = 1e-8\n\n    # Feasible nodes\n    feasible = unvisited_nodes[dmd[unvisited_nodes] <= cap_left]\n    if len(feasible) == 0:\n        return depot\n\n    # Distances\n    d = dist_mat[current_node, feasible].astype(float)\n\n    # Find minimal distance\n    min_dist = np.min(d)\n    # Identify all nodes within a tiny epsilon of the minimum\n    close_mask = np.abs(d - min_dist) <= tie_eps\n    close_nodes = feasible[close_mask]\n    close_dists = d[close_mask]\n\n    if len(close_nodes) == 1:\n        return int(close_nodes[0])\n\n    # Break ties with a tiny random perturbation\n    rng = np.random.default_rng((int(current_node) * 97531 +\n                                 int(len(unvisited_nodes)) * 864197523) & 0xFFFFFFFF)\n    perturbed = close_dists + rng.uniform(-1e-9, 1e-9, size=close_dists.shape)\n    chosen = close_nodes[np.argmin(perturbed)]\n    return int(chosen)\n\n",
  "short_edge_preferential_attachment_aug_280": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap_left = float(rest_capacity)\n    dmd = demands\n    dist_mat = distance_matrix\n    eps = 1e-12\n    temp = 0.5  # temperature for softmin\n\n    # Feasible nodes\n    feasible = unvisited_nodes[dmd[unvisited_nodes] <= cap_left]\n    if len(feasible) == 0:\n        return depot\n\n    # Distances and costs\n    d = dist_mat[current_node, feasible].astype(float)\n    cost = d * dmd[feasible].astype(float)\n\n    # Weighted score: 0.6*distance + 0.4*cost\n    score = 0.6 * d + 0.4 * cost\n    # Softmin probabilities\n    exp_score = np.exp(-score / (temp + eps))\n    exp_score = np.clip(exp_score, 1e-12, None)\n    p = exp_score / (np.sum(exp_score) + eps)\n\n    # Add tiny deterministic noise to break ties\n    rng = np.random.default_rng((int(current_node) * 97531 +\n                                 int(len(unvisited_nodes)) * 864197523) & 0xFFFFFFFF)\n    noise = rng.normal(scale=1e-7, size=p.shape)\n    p = np.clip(p + noise, 1e-12, None)\n    p = p / (np.sum(p) + eps)\n\n    return int(rng.choice(feasible, p=p))\n\n",
  "late_route_closure_bias_aug_281": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap_remain = float(rest_capacity)\n    # vectorised feasible selection\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap_remain]\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    eps = 1e-12\n    # t is bounded between 0 and 1\n    t = np.clip(1.0 / (len(feasible) + 1.0 + eps), 0.0, 1.0)\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(len(feasible)) * 1e-8\n    score = (1.0 - t) * d_cn + t * d_nd + noise\n    return int(feasible[int(np.argmin(score))])\n\n",
  "late_route_closure_bias_aug_282": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # feasible nodes via list comprehension\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    eps = 1e-12\n    # fixed weight for return distance\n    w_return = 0.35\n    score = (1.0 - w_return) * d_cn + w_return * d_nd\n\n    # softmin probabilities\n    min_score = np.min(score)\n    exp_vals = np.exp(-(score - min_score) / (0.1 + eps))\n    probs = exp_vals / np.clip(np.sum(exp_vals), eps, None)\n\n    # sample from top\u2011k\n    top_k = 7\n    top_indices = np.argsort(score)[:top_k]\n    top_probs = probs[top_indices]\n    top_probs /= np.clip(np.sum(top_probs), eps, None)\n\n    chosen_idx = np.random.choice(top_indices, p=top_probs)\n    return int(feasible[chosen_idx])\n\n",
  "late_route_closure_bias_aug_283": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # build feasible list with a while loop\n    idx = 0\n    feasible_list = []\n    while idx < len(unvisited_nodes):\n        node = unvisited_nodes[idx]\n        if demands[node] <= cap:\n            feasible_list.append(node)\n        idx += 1\n    feasible = np.array(feasible_list, dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    eps = 1e-12\n    # median of current\u2011to\u2011node distances influences the bias\n    median_d = np.median(d_cn)\n    t = np.clip(1.0 / (median_d + 1.0 + eps), 0.0, 1.0)\n\n    # deterministic noise\n    noise = np.linspace(0, 1e-7, len(feasible))\n    score = (1.0 - t) * d_cn + t * d_nd + noise\n    return int(feasible[int(np.argmin(score))])\n\n",
  "late_route_closure_bias_aug_284": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # feasible nodes via list comprehension\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    eps = 1e-12\n    # proxy: approximate return distance by a scaling factor\n    d_nd_proxy = 1.2 * d_nd\n    # aggregate using np.max\n    agg = np.clip(np.maximum(d_cn, d_nd_proxy), 0, None)\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(len(feasible)) * 1e-9\n    score = agg + noise\n    return int(feasible[int(np.argmin(score))])\n\n",
  "pseudo_sweep_by_distance_order_aug_285": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # Quick exit if nothing left\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap_rem = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    # Feasible nodes that fit into remaining capacity\n    feas_nodes = np.array([n for n in candidates if demands[n] <= cap_rem], dtype=int)\n    if len(feas_nodes) == 0:\n        return depot\n\n    # Order by depot distance (vectorised)\n    dist_to_depot = distance_matrix[depot, candidates].astype(float)\n    ord_idx = np.argsort(dist_to_depot)\n    ord_nodes = candidates[ord_idx]\n\n    cur_r = float(distance_matrix[depot, current_node])\n\n    # Position of the current node in the sorted list\n    pos = int(np.searchsorted(np.sort(dist_to_depot) + 1e-12, cur_r + 1e-12))\n\n    # Scan forward in circular fashion for the first feasible node\n    n = len(ord_nodes)\n    step = 0\n    idx = pos\n    while step < n:\n        cand = int(ord_nodes[idx % n])\n        if cand in feas_nodes:\n            return cand\n        idx += 1\n        step += 1\n\n    # Fallback: choose the nearest feasible node from the current node\n    # Add deterministic noise to break ties\n    noise = 1e-6 * (feas_nodes % 1000)\n    dist_from_cur = distance_matrix[current_node, feas_nodes] + noise\n    min_idx = np.argmin(dist_from_cur)\n    return int(feas_nodes[min_idx])\n\n",
  "pseudo_sweep_by_distance_order_aug_286": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap_rem = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    feas_nodes = candidates[demands[candidates] <= cap_rem]\n    if len(feas_nodes) == 0:\n        return depot\n\n    # Scoring: distance to depot + inverse slack (to favour larger remaining capacity)\n    dist_to_depot = distance_matrix[depot, feas_nodes]\n    slack = cap_rem - demands[feas_nodes]\n    slack = np.clip(slack, 1e-12, None)          # avoid division by zero\n    scores = 0.6 * dist_to_depot + 0.4 * (1.0 / (slack + 1e-12))\n\n    # Top\u2011k selection\n    top_k = 7\n    if len(scores) <= top_k:\n        top_idx = np.argsort(scores)\n    else:\n        top_idx = np.argpartition(scores, top_k)[:top_k]\n        top_idx = top_idx[np.argsort(scores[top_idx])]\n    top_nodes = feas_nodes[top_idx]\n\n    # Deterministic random choice among top\u2011k\n    rng = np.random.RandomState(current_node + depot)\n    chosen = rng.choice(top_nodes)\n    return int(chosen)\n\n",
  "pseudo_sweep_by_distance_order_aug_287": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap_rem = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    feas_nodes = candidates[demands[candidates] <= cap_rem]\n    if len(feas_nodes) == 0:\n        return depot\n\n    # Distances from the current node with deterministic noise\n    noise = 1e-6 * (feas_nodes % 1000)\n    dist_cur = distance_matrix[current_node, feas_nodes] + noise\n\n    # Softmin probabilities\n    lambda_val = 5.0\n    probs = np.exp(-lambda_val * dist_cur)\n    probs = probs / (np.sum(probs) + 1e-12)\n\n    chosen_idx = np.argmax(probs)\n    return int(feas_nodes[chosen_idx])\n\n",
  "pseudo_sweep_by_distance_order_aug_288": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap_rem = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    feas_nodes = candidates[demands[candidates] <= cap_rem]\n    if len(feas_nodes) == 0:\n        return depot\n\n    # Use squared distances to avoid expensive sqrt operations\n    dist_sq = distance_matrix[depot, feas_nodes] ** 2\n    ord_idx = np.argsort(dist_sq)\n    ord_nodes = feas_nodes[ord_idx]\n\n    cur_r_sq = distance_matrix[depot, current_node] ** 2\n    pos = int(np.searchsorted(np.sort(dist_sq) + 1e-12, cur_r_sq + 1e-12))\n\n    # Circular forward scan for a feasible node\n    n = len(ord_nodes)\n    step = 0\n    idx = pos\n    while step < n:\n        cand = int(ord_nodes[idx % n])\n        if cand in feas_nodes:\n            return cand\n        idx += 1\n        step += 1\n\n    # Fallback: choose the node with the largest squared distance (proxy)\n    max_idx = np.argmax(dist_sq)\n    return int(feas_nodes[max_idx])\n\n",
  "knn_barycenter_pull_aug_289": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = candidates[demands[candidates] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    k = min(7, len(candidates))\n\n    # Distances from every feasible node to all candidates\n    dist_to_cand = distance_matrix[feasible[:, None], candidates]\n    # Clip to avoid extreme values\n    dist_to_cand = np.clip(dist_to_cand, 0, np.max(distance_matrix) + 1)\n\n    # k\u2011nearest distances and median as barycenter\n    kth = np.partition(dist_to_cand, k - 1, axis=1)[:, :k]\n    bary = np.median(kth, axis=1)\n\n    d_cur = distance_matrix[current_node, feasible]\n    # Score: weighted sum of current distance and barycenter\n    scores = 0.7 * d_cur + 0.3 * bary\n\n    # Deterministic tie\u2011breaker: tiny increasing noise\n    noise = 1e-9 * np.arange(feasible.size)\n    scores += noise\n\n    # Choose node with minimal score\n    return int(feasible[np.argmin(scores)])\n\n",
  "knn_barycenter_pull_aug_290": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = candidates[demands[candidates] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    k = min(7, len(candidates))\n    top_k = min(5, feasible.size)\n\n    # Distances and barycenter (mean of k nearest)\n    dist_to_cand = distance_matrix[feasible[:, None], candidates]\n    kth = np.partition(dist_to_cand, k - 1, axis=1)[:, :k]\n    bary = np.sum(kth, axis=1) / (k + 1e-12)\n\n    d_cur = distance_matrix[current_node, feasible]\n    scores = 0.6 * d_cur + 0.4 * bary\n\n    # Add deterministic noise before ranking\n    scores += 1e-9 * np.arange(feasible.size)\n\n    # Select top\u2011k indices\n    top_indices = np.argpartition(scores, top_k - 1)[:top_k]\n    top_scores = scores[top_indices]\n\n    # Soft\u2011min probabilities\n    T = 1.0\n    weights = np.exp(-top_scores / (T + 1e-12))\n    probs = weights / (np.sum(weights) + 1e-12)\n\n    # Random choice weighted by soft\u2011min\n    chosen = np.random.choice(top_indices, p=probs)\n    return int(feasible[chosen])\n\n",
  "knn_barycenter_pull_aug_291": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = candidates[demands[candidates] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    k = min(7, len(candidates))\n\n    # Compute score for each feasible node\n    scores = []\n    for idx, n in enumerate(feasible):\n        d_cur = float(distance_matrix[current_node, n])\n        # Clip to keep values bounded\n        d_cur = np.clip(d_cur, 0, np.max(distance_matrix) + 1)\n        # k\u2011nearest distances to all candidates\n        nearest = np.partition(distance_matrix[n, candidates], k - 1)[:k]\n        # Use maximum of the k nearest as proxy\n        bary = float(np.max(nearest))\n        score = 0.5 * d_cur + 0.5 * bary + 1e-9 * idx\n        scores.append(score)\n\n    return int(feasible[np.argmin(scores)])\n\n",
  "knn_barycenter_pull_aug_292": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    if candidates.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = candidates[demands[candidates] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    # Sum of distances from each feasible node to all candidates\n    sum_dist = np.sum(distance_matrix[feasible[:, None], candidates], axis=1)\n    bary = sum_dist / (len(candidates) + 1e-12)\n\n    d_cur = distance_matrix[current_node, feasible]\n    # Weighted score: more emphasis on barycenter\n    scores = 0.4 * d_cur + 0.6 * bary\n\n    # Clip scores to avoid extreme values\n    scores = np.clip(scores, 0, np.max(scores) + 1)\n\n    # Add small deterministic noise for tie\u2011breaking\n    scores += 1e-9 * np.arange(feasible.size)\n\n    return int(feasible[np.argmin(scores)])\n\n",
  "local_two_cluster_switch_aug_293": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur = int(current_node)\n    dep = int(depot)\n    rem = float(rest_capacity)\n    dem = demands\n    dist_mat = distance_matrix\n    cand = unvisited_nodes\n\n    if cand.size == 0:\n        return dep\n\n    # --- feasibility filtering (vectorised) ---\n    feasible_mask = dem[cand] <= rem\n    feasible = cand[feasible_mask]\n    if feasible.size == 0:\n        return dep\n\n    # --- mean\u2011based clustering instead of median ---\n    depot_dist = dist_mat[dep, feasible].astype(float)\n    mean_dist = np.mean(depot_dist, dtype=float) + 1e-12\n    near = feasible[depot_dist <= mean_dist]\n    far  = feasible[depot_dist >  mean_dist]\n\n    # --- flip logic (unchanged) ---\n    flip = ((cur * 31 + feasible.size * 17) & 1) == 0\n    pool = far if (flip and far.size > 0) else (near if near.size > 0 else feasible)\n\n    # --- softmin selection with tiny deterministic noise for tie breaking ---\n    dist_from_cur = dist_mat[cur, pool].astype(float)\n    # clip distances to avoid overflow in the exponential\n    clipped = np.clip(dist_from_cur, -1e5, 1e5)\n    eps = 1e-12\n    weights = np.exp(-clipped / (eps + 1e-12))\n    # deterministic noise proportional to the index\n    noise = np.arange(weights.size) * 1e-9\n    weighted = weights + noise\n    idx = int(np.argmax(weighted))\n    return int(pool[idx])\n\n",
  "local_two_cluster_switch_aug_294": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur   = int(current_node)\n    dep   = int(depot)\n    rem   = float(rest_capacity)\n    dem   = demands\n    dist  = distance_matrix\n    cand  = unvisited_nodes\n\n    if cand.size == 0:\n        return dep\n\n    # --- feasibility filtering ---\n    feas_mask = dem[cand] <= rem\n    feas      = cand[feas_mask]\n    if feas.size == 0:\n        return dep\n\n    # --- distances from current node, with clipping to keep values sane ---\n    dist_cur = dist[cur, feas].astype(float)\n    dist_cur = np.clip(dist_cur, 0, 1e6)\n\n    # --- add tiny noise for deterministic tie breaking ---\n    noise = np.random.rand(feas.size) * 1e-6\n    dist_noisy = dist_cur + noise\n\n    # --- top\u2011k nearest selection (hyperparameter tuned to 7) ---\n    top_k = 7\n    top_k = min(top_k, feas.size)\n    # use argpartition for efficient partial sort\n    top_idx = np.argpartition(dist_noisy, top_k - 1)[:top_k]\n    # random choice among the top_k candidates\n    chosen = int(np.random.choice(top_idx))\n    return int(feas[chosen])\n\n",
  "local_two_cluster_switch_aug_295": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur   = int(current_node)\n    dep   = int(depot)\n    rem   = float(rest_capacity)\n    dem   = demands\n    dist  = distance_matrix\n    cand  = unvisited_nodes\n\n    if cand.size == 0:\n        return dep\n\n    # --- feasibility filtering ---\n    feas_mask = dem[cand] <= rem\n    feas      = cand[feas_mask]\n    if feas.size == 0:\n        return dep\n\n    # --- hybrid scoring: distance + weighted demand ----------\n    eps = 1e-12\n    alpha = 0.5                      # tuned hyper\u2011parameter\n    # demand normalised by remaining capacity\n    norm_demand = dem[feas] / (rem + eps)\n    score = dist[cur, feas].astype(float) + alpha * norm_demand\n    # clip score to avoid extreme values\n    score = np.clip(score, 0, 1e9)\n\n    # --- greedy selection of minimal score ---\n    idx = int(np.argmin(score))\n    return int(feas[idx])\n\n",
  "local_two_cluster_switch_aug_296": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur   = int(current_node)\n    dep   = int(depot)\n    rem   = float(rest_capacity)\n    dem   = demands\n    dist  = distance_matrix\n    cand  = unvisited_nodes\n\n    if cand.size == 0:\n        return dep\n\n    # --- feasibility filtering ---\n    feas_mask = dem[cand] <= rem\n    feas      = cand[feas_mask]\n    if feas.size == 0:\n        return dep\n\n    # --- deterministic hash\u2011based pseudo\u2011random selection ---\n    hash_val = ((cur * 31) + (feas.size * 17) + int(rem * 1000)) & 0xFFFFFFFF\n    idx = hash_val % feas.size\n    return int(feas[idx])\n\n",
  "demand_similarity_chain_aug_297": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap_rem = float(rest_capacity)\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap_rem]\n    if feasible.size == 0:\n        return depot\n\n    target = float(demands[current_node]) if current_node != depot else float(np.median(demands[feasible]))\n    dem = demands[feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    denom = np.mean(d_cur) + 1e-12\n    ratio = np.clip(d_cur / denom, 0, 10)\n    score = 0.6 * np.abs(dem - target) + 0.4 * ratio\n    score += 1e-6 * np.arange(score.size)  # deterministic tie\u2011breaking\n\n    return int(feasible[np.argmin(score)])\n\n",
  "demand_similarity_chain_aug_298": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    target = float(demands[current_node]) if current_node != depot else float(np.median(demands[feasible]))\n    dem = demands[feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    denom = np.max(d_cur) + 1e-12\n    ratio = np.clip(d_cur / denom, 0, 10)\n    score = 0.5 * np.abs(dem - target) + 0.5 * ratio\n    score += 1e-6 * np.arange(score.size)  # deterministic noise\n\n    top_k = min(5, score.size)\n    idxs = np.argpartition(score, top_k - 1)[:top_k]          # smallest scores\n    chosen = np.random.choice(idxs)                           # random among top\u2011k\n    return int(feasible[chosen])\n\n",
  "demand_similarity_chain_aug_299": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cap = float(rest_capacity)\n    feasible = []\n    i = 0\n    while i < unvisited_nodes.size:\n        node = int(unvisited_nodes[i])\n        if demands[node] <= cap:\n            feasible.append(node)\n        i += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n    target = float(demands[current_node]) if current_node != depot else float(np.median(demands[feasible]))\n    dem = demands[feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    denom = np.mean(d_cur) + 1e-12\n    ratio = np.clip(d_cur / denom, 0, 10)\n    score = 0.8 * ratio + 0.2 * np.abs(dem - target)\n\n    return int(feasible[np.argmin(score)])\n\n",
  "min_radial_detour_aug_300": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    # feasible nodes that fit in remaining capacity\n    feasible = np.array([node for node in unvisited_nodes\n                         if demands[node] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n   = distance_matrix[depot, feasible].astype(float)\n    d_cn  = distance_matrix[current_node, feasible].astype(float)\n\n    denom = np.mean(d_cn) + 1e-12\n    score = 0.6 * np.abs(r_n - r_cur) + 0.4 * (d_cn / denom)\n\n    # deterministic noise to break ties\n    noise = np.arange(feasible.size, dtype=float) * 1e-12\n    score += noise\n\n    idx = int(np.argmin(score))\n    return int(feasible[idx])\n\n",
  "min_radial_detour_aug_301": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    rng = np.random.default_rng()\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = rest_capacity\n    feasible = np.array([node for node in unvisited_nodes\n                         if demands[node] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n   = distance_matrix[depot, feasible].astype(float)\n    d_cn  = distance_matrix[current_node, feasible].astype(float)\n\n    denom = np.mean(d_cn) + 1e-12\n    score = 0.7 * np.abs(r_n - r_cur) + 0.3 * (d_cn / denom)\n\n    # soft\u2011min probabilities\n    probs = np.exp(-score)\n    probs = probs / probs.sum()\n\n    # pick uniformly from the five best candidates\n    top_k = min(5, feasible.size)\n    top_indices = np.argpartition(probs, -top_k)[-top_k:]\n    chosen_idx = rng.choice(top_indices,\n                            p=probs[top_indices] / probs[top_indices].sum())\n\n    return int(feasible[chosen_idx])\n\n",
  "min_radial_detour_aug_302": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = rest_capacity\n    feasible = np.array([node for node in unvisited_nodes\n                         if demands[node] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n   = distance_matrix[depot, feasible].astype(float)\n    d_cn  = distance_matrix[current_node, feasible].astype(float)\n\n    denom = np.max(d_cn) + 1e-12\n    score = 0.5 * np.abs(r_n - r_cur) + 0.5 * (d_cn / denom)\n\n    # find index of smallest score with a while loop\n    min_idx = 0\n    min_val = score[0]\n    i = 1\n    while i < score.size:\n        if score[i] < min_val:\n            min_val = score[i]\n            min_idx = i\n        i += 1\n\n    return int(feasible[min_idx])\n\n",
  "min_radial_detour_aug_303": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    rng = np.random.default_rng()\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = rest_capacity\n    feasible = np.array([node for node in unvisited_nodes\n                         if demands[node] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n   = np.square(distance_matrix[depot, feasible]).astype(float)\n    d_cn  = np.square(distance_matrix[current_node, feasible]).astype(float)\n\n    denom = np.sum(d_cn) + 1e-12\n    score = 0.8 * np.abs(r_n - r_cur) + 0.2 * (d_cn / denom)\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(feasible.size, dtype=float) * 1e-12\n    score += noise\n\n    top_k = min(7, feasible.size)\n    top_indices = np.argpartition(score, top_k - 1)[:top_k]\n    chosen_idx = rng.choice(top_indices)\n\n    return int(feasible[chosen_idx])\n\n",
  "max_depot_progress_aug_304": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    # renamed variables\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if len(candidates) == 0:\n        return depot\n\n    # feasible nodes based on capacity\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # distances to depot\n    r_cur = float(dist_mat[current_node, depot])\n    r_n = dist_mat[feasible, depot].astype(float)\n    # step distances from current node\n    step = dist_mat[current_node, feasible].astype(float)\n\n    # improvement and ratio\n    improvement = np.maximum(0.0, r_cur - r_n)\n    ratio = np.clip(improvement / (step + 1e-12), 0.0, 1e6)\n\n    # fallback: if not far, choose nearest\n    if r_cur < float(np.median(dist_mat[depot, feasible])):\n        nearest_idx = np.argmin(step)\n        return int(feasible[nearest_idx])\n\n    # otherwise choose node with maximal ratio\n    best_idx = np.argmax(ratio)\n    return int(feasible[best_idx])\n\n",
  "max_depot_progress_aug_305": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    rng = np.random.default_rng(42)          # deterministic RNG\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if len(candidates) == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    r_cur = float(dist_mat[current_node, depot])\n    r_n = dist_mat[feasible, depot].astype(float)\n    step = dist_mat[current_node, feasible].astype(float)\n\n    improvement = np.maximum(0.0, r_cur - r_n)\n    # weighted score: 0.6 improvement + 0.4 / step\n    score = 0.6 * improvement + 0.4 * (1.0 / (step + 1e-12))\n\n    # deterministic noise for tie\u2011breaking\n    noise = rng.uniform(-1e-8, 1e-8, size=score.shape)\n    score += noise\n\n    # if far, choose randomly among top\u2011k scores\n    if r_cur >= float(np.median(dist_mat[depot, feasible])):\n        top_k = 5\n        if feasible.size <= top_k:\n            chosen = rng.choice(feasible, size=feasible.size, replace=False)\n        else:\n            top_idx = np.argsort(score)[-top_k:]\n            chosen = rng.choice(feasible[top_idx], size=1, replace=False)\n        return int(chosen[0])\n\n    # otherwise nearest\n    nearest_idx = np.argmin(step)\n    return int(feasible[nearest_idx])\n\n",
  "min_travel_plus_spread_aug_306": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = candidates[demands[candidates] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    d_cur = dist_mat[current_node, feasible].astype(float)\n\n    # Manual mean with epsilon to avoid division by zero\n    if candidates.size > 0:\n        mat = dist_mat[np.ix_(feasible, candidates)].astype(float)\n        sum_dist = mat.sum(axis=1)\n        mean_to_cand = sum_dist / (candidates.size + 1e-12)\n    else:\n        mean_to_cand = np.zeros_like(d_cur)\n\n    mean_to_cand = np.clip(mean_to_cand, 0, None)\n\n    # Tuned weights\n    score = 0.7 * d_cur + 0.3 * mean_to_cand\n\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-8 * np.arange(score.size)\n    score += noise\n\n    idx = int(np.argmin(score))\n    return int(feasible[idx])\n\n",
  "min_travel_plus_spread_aug_307": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dmat = distance_matrix\n    cand = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if cand.size == 0:\n        return depot\n\n    # Feasible nodes via list comprehension\n    feasible = np.array([c for c in cand if demands[c] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # Distances using a for loop\n    d_cur = np.empty(feasible.size, dtype=float)\n    for i, node in enumerate(feasible):\n        d_cur[i] = float(dmat[current_node, node])\n\n    # Max distance to remaining nodes\n    max_to_cand = np.empty(feasible.size, dtype=float)\n    for i, node in enumerate(feasible):\n        max_to_cand[i] = float(np.max(dmat[node, cand]))\n\n    max_to_cand = np.clip(max_to_cand, 0, None)\n\n    # Different weight tuning\n    score = 0.6 * d_cur + 0.4 * max_to_cand\n\n    # Deterministic noise for tie\u2011breaking\n    score += 1e-7 * np.arange(score.size)\n\n    # Top\u2011k selection\n    top_k = 7\n    if score.size <= top_k:\n        top_idx = np.argsort(score)\n    else:\n        top_idx = np.argpartition(score, top_k)[:top_k]\n        top_idx = top_idx[np.argsort(score[top_idx])]\n\n    chosen = int(feasible[top_idx[0]])\n    return chosen\n\n",
  "min_travel_plus_spread_aug_308": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    d_matrix = distance_matrix\n    nodes = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if nodes.size == 0:\n        return depot\n\n    # Feasible nodes with a while loop\n    feasible = np.empty(0, dtype=int)\n    i = 0\n    while i < nodes.size:\n        node = int(nodes[i])\n        if demands[node] <= cap:\n            feasible = np.append(feasible, node)\n        i += 1\n\n    if feasible.size == 0:\n        return depot\n\n    d_cur = d_matrix[current_node, feasible].astype(float)\n\n    # Median distance to remaining nodes\n    if nodes.size > 0:\n        mat = d_matrix[np.ix_(feasible, nodes)].astype(float)\n        median_to_nodes = np.median(mat, axis=1)\n    else:\n        median_to_nodes = np.zeros_like(d_cur)\n\n    median_to_nodes = np.clip(median_to_nodes, 0, None)\n\n    # Softmin with temperature\n    score = 0.5 * d_cur + 0.5 * median_to_nodes\n    temp = 1.0\n    exp_neg = np.exp(-(score) / (temp + 1e-12))\n    probs = exp_neg / (exp_neg.sum() + 1e-12)\n\n    chosen_idx = int(np.argmax(probs))\n    return int(feasible[chosen_idx])\n\n",
  "min_travel_plus_spread_aug_309": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    matrix = distance_matrix\n    nodes = unvisited_nodes\n    cap = float(rest_capacity)\n\n    if nodes.size == 0:\n        return depot\n\n    # Feasible nodes via list comprehension\n    feasible = np.array([c for c in nodes if demands[c] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # Distances\n    d_cur = np.array([float(matrix[current_node, n]) for n in feasible], dtype=float)\n\n    # Sum distance to remaining nodes\n    sum_to_nodes = np.array([float(matrix[n, nodes].sum()) for n in feasible], dtype=float)\n    sum_to_nodes = np.clip(sum_to_nodes, 0, None)\n\n    # Different weight tuning\n    score = 0.4 * d_cur + 0.6 * sum_to_nodes\n\n    # Deterministic noise\n    score += 1e-9 * np.arange(score.size)\n\n    # Clip to avoid overflow\n    score = np.clip(score, 0, 1e9)\n\n    idx = int(np.argmin(score))\n    return int(feasible[idx])\n\n",
  "min_return_edge_max_aug_310": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap = rest_capacity\n    demands_arr = demands\n\n    if candidates.size == 0:\n        return depot\n\n    # Feasible nodes that satisfy capacity\n    feasible = np.array([n for n in candidates if demands_arr[n] <= rest_cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(dist_mat[current_node, depot]) + 1e-12\n    d_cn = dist_mat[current_node, feasible].astype(float)\n    d_nd = dist_mat[feasible, depot].astype(float)\n\n    # Score: largest edge in the triplet (current->node, node->depot, current->depot)\n    score = np.maximum.reduce([d_cn, d_nd, np.full_like(d_cn, d_cd)]) + 1e-12\n    score = np.clip(score, 0, np.inf)\n\n    # Deterministic tiny noise to break ties\n    rng = np.random.default_rng(12345)\n    noise = rng.normal(0, 1e-6, size=feasible.size)\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "min_return_edge_max_aug_311": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap = rest_capacity\n    demands_arr = demands\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands_arr[n] <= rest_cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(dist_mat[current_node, depot]) + 1e-12\n    d_cn = dist_mat[current_node, feasible].astype(float)\n    d_nd = dist_mat[feasible, depot].astype(float)\n\n    # Weighted sum of outgoing and return distances\n    score = 0.7 * d_cn + 0.3 * d_nd\n    # Penalise long trips by normalising with depot distance\n    score = score / (d_cd + 1e-12)\n    score = np.clip(score, 0, np.inf)\n\n    top_k = 7\n    if feasible.size <= top_k:\n        chosen_idx = int(np.argmin(score))\n    else:\n        rng = np.random.default_rng(9876)\n        top_indices = np.argpartition(score, top_k)[:top_k]\n        chosen_idx = int(rng.choice(top_indices))\n\n    return int(feasible[chosen_idx])\n\n",
  "min_return_edge_max_aug_312": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap = rest_capacity\n    demands_arr = demands\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands_arr[n] <= rest_cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(dist_mat[current_node, depot]) + 1e-12\n    d_cn = dist_mat[current_node, feasible].astype(float)\n    d_nd = dist_mat[feasible, depot].astype(float)\n\n    # Mean of the three edge lengths\n    score = np.mean([d_cn, d_nd, np.full_like(d_cn, d_cd)], axis=0)\n\n    # Soft\u2011min with temperature \u03c4 = 1.0\n    tau = 1.0\n    exp_vals = np.exp(-score / tau)\n    exp_vals = np.clip(exp_vals, 0, np.inf)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    rng = np.random.default_rng(5555)\n    chosen_idx = int(rng.choice(feasible.size, p=probs))\n    return int(feasible[chosen_idx])\n\n",
  "min_return_edge_max_aug_313": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rest_cap = rest_capacity\n    demands_arr = demands\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = np.array([n for n in candidates if demands_arr[n] <= rest_cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(dist_mat[current_node, depot]) + 1e-12\n    d_cn = np.square(dist_mat[current_node, feasible]).astype(float)\n    d_nd = np.square(dist_mat[feasible, depot]).astype(float)\n\n    # Weighted sum of squared distances\n    score = 0.5 * d_cn + 0.3 * d_nd + 0.2 * np.square(d_cd)\n    score = np.clip(score, 0, 1e6)\n\n    # Tiny deterministic noise for tie\u2011breaking\n    rng = np.random.default_rng(7777)\n    noise = rng.uniform(-1e-6, 1e-6, size=feasible.size)\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "max_min_distance_separation_aug_314": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    # feasible nodes that fit in remaining capacity\n    feasible = np.array([c for c in candidates if demands[c] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # local neighbourhood of the current node\n    m = min(10, len(candidates))\n    d_cur_all = distance_matrix[current_node, candidates].astype(float)\n    neigh = candidates[np.argsort(d_cur_all)[:m]]\n\n    # distances from feasible nodes to the neighbourhood\n    dist_to_neigh = distance_matrix[np.ix_(feasible, neigh)].astype(float)\n    min_to_neigh = np.min(dist_to_neigh, axis=1)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # scoring: diversify (min distance) minus proximity penalty\n    score = min_to_neigh - 0.4 * d_cn\n\n    # deterministic tie\u2011breaking noise\n    noise = 1e-6 * np.arange(len(feasible))\n    final_score = score + noise\n\n    return int(feasible[np.argmax(final_score)])\n\n",
  "max_min_distance_separation_aug_315": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    # build feasible list with a while loop\n    feasible = []\n    idx = 0\n    while idx < len(candidates):\n        node = candidates[idx]\n        if demands[node] <= cap:\n            feasible.append(node)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n\n    # neighbourhood of the current node\n    m = min(8, len(candidates))\n    sorted_idx = np.argsort(distance_matrix[current_node, candidates])[:m]\n    neigh = candidates[sorted_idx]\n\n    # distances to neighbourhood\n    dist_to_neigh = distance_matrix[np.ix_(feasible, neigh)].astype(float)\n    median_to_neigh = np.median(dist_to_neigh, axis=1)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # score based on median distance minus proximity\n    score = median_to_neigh - 0.3 * d_cn\n\n    # soft\u2011min selection with random tie\u2011breaking\n    soft = np.exp(-score)\n    soft /= soft.sum() + 1e-12  # avoid division by zero\n    choice = np.random.choice(feasible, p=soft)\n\n    return int(choice)\n\n",
  "max_min_distance_separation_aug_316": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    # feasible nodes\n    feasible = np.array([c for c in candidates if demands[c] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # neighbourhood size depends on remaining capacity\n    max_demand = np.max(demands[candidates]) if len(candidates) > 0 else 1.0\n    m = int(min(8, max(1, np.floor(cap / max_demand))))\n\n    d_cur_all = distance_matrix[current_node, candidates].astype(float)\n    neigh = candidates[np.argsort(d_cur_all)[:m]]\n\n    dist_to_neigh = distance_matrix[np.ix_(feasible, neigh)].astype(float)\n    max_to_neigh = np.max(dist_to_neigh, axis=1)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # add tiny random noise for deterministic tie\u2011breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=len(feasible))\n    score = max_to_neigh - 0.2 * d_cn + noise\n    score = np.clip(score, -1e6, 1e6)  # bound the score\n\n    return int(feasible[np.argmax(score)])\n\n",
  "max_min_distance_separation_aug_317": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n\n    # feasible nodes\n    feasible = np.array([c for c in candidates if demands[c] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    m = min(8, len(candidates))\n\n    d_cur_all = distance_matrix[current_node, candidates].astype(float)\n    neigh = candidates[np.argsort(d_cur_all)[:m]]\n\n    dist_to_neigh = distance_matrix[np.ix_(feasible, neigh)].astype(float)\n\n    # use squared distances for diversification\n    min_to_neigh_sq = np.min(np.square(dist_to_neigh + 1e-12), axis=1)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_cn_sq = np.square(d_cn + 1e-12)\n\n    score = min_to_neigh_sq - 0.5 * d_cn_sq\n    score = np.clip(score, -1e6, 1e6)  # ensure valid range\n\n    return int(feasible[np.argmax(score)])\n\n",
  "capacity_fraction_targeting_dynamic_aug_318": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur = current_node\n    dep = depot\n    cand = unvisited_nodes\n    rem_cap = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n\n    if cand.size == 0:\n        return dep\n\n    # Build the list of feasible nodes with a while loop\n    feasible = np.empty(0, dtype=int)\n    idx = 0\n    while idx < cand.size:\n        node = cand[idx]\n        if dem[node] <= rem_cap:\n            feasible = np.append(feasible, node)\n        idx += 1\n\n    if feasible.size == 0:\n        return dep\n\n    # Dynamic target fraction\n    frac_target = 0.85 - 0.4 * (1.0 / (cand.size + 1.0))\n    frac_target = np.clip(frac_target, 0.0, 1.0)\n\n    dem_frac = dem[feasible].astype(float) / (rem_cap + 1e-12)\n    miss = np.abs(dem_frac - frac_target)\n\n    d_cn = dist_mat[cur, feasible].astype(float)\n    mean_dist = np.mean(d_cn) if d_cn.size > 0 else 1e-12\n    norm_dist = d_cn / (mean_dist + 1e-12)\n\n    score = 0.75 * miss + 0.25 * norm_dist\n    return int(feasible[np.argmin(score)])\n\n",
  "capacity_fraction_targeting_dynamic_aug_319": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = rest_capacity\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    # Tuned target fraction\n    frac_target = 0.8 - 0.3 * (1.0 / (unvisited_nodes.size + 1.0))\n    frac_target = np.clip(frac_target, 0.0, 1.0)\n\n    dem_frac = demands[feasible].astype(float) / (cap + 1e-12)\n    miss = np.abs(dem_frac - frac_target)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    mean_dist = np.mean(d_cn) if d_cn.size > 0 else 1e-12\n    norm_dist = d_cn / (mean_dist + 1e-12)\n\n    # Adjusted scoring weights\n    score = 0.6 * miss + 0.4 * norm_dist\n\n    # Select among the top\u2011k lowest scores\n    top_k = 7\n    if score.size > top_k:\n        idx_top = np.argpartition(score, top_k)[:top_k]\n    else:\n        idx_top = np.arange(score.size)\n    min_idx = np.argmin(score[idx_top])\n    return int(feasible[idx_top[min_idx]])\n\n",
  "capacity_fraction_targeting_dynamic_aug_320": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = rest_capacity\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    frac_target = 0.85 - 0.4 * (1.0 / (unvisited_nodes.size + 1.0))\n    frac_target = np.clip(frac_target, 0.0, 1.0)\n\n    dem_frac = demands[feasible].astype(float) / (cap + 1e-12)\n    miss = np.abs(dem_frac - frac_target)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    median_dist = np.median(d_cn) if d_cn.size > 0 else 1e-12\n    norm_dist = d_cn / (median_dist + 1e-12)\n\n    score = 0.75 * miss + 0.25 * norm_dist\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(score.size, dtype=float) * 1e-8\n    score += noise\n\n    # Soft\u2011min probabilities\n    exp_vals = np.exp(-score)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # Sample according to the probabilities\n    rnd = np.random.rand()\n    cum = np.cumsum(probs)\n    idx = np.searchsorted(cum, rnd)\n    return int(feasible[idx])\n\n",
  "capacity_fraction_targeting_dynamic_aug_321": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cur = current_node\n    dep = depot\n    cand = unvisited_nodes\n    rem_cap = rest_capacity\n    dem = demands\n    dist_mat = distance_matrix\n\n    if cand.size == 0:\n        return dep\n\n    # Build feasible list with a while loop\n    feasible = np.empty(0, dtype=int)\n    i = 0\n    while i < cand.size:\n        n = cand[i]\n        if dem[n] <= rem_cap:\n            feasible = np.append(feasible, n)\n        i += 1\n\n    if feasible.size == 0:\n        return dep\n\n    # Different target fraction\n    frac_target = 0.9 - 0.5 * (1.0 / (cand.size + 1.0))\n    frac_target = np.clip(frac_target, 0.0, 1.0)\n\n    dem_frac = dem[feasible].astype(float) / (rem_cap + 1e-12)\n    miss = np.abs(dem_frac - frac_target)\n\n    d_cn = dist_mat[cur, feasible].astype(float)\n    max_dist = np.max(d_cn) if d_cn.size > 0 else 1e-12\n    norm_dist = d_cn / (max_dist + 1e-12)\n\n    # Balanced scoring\n    score = 0.5 * miss + 0.5 * norm_dist\n\n    # Random choice among the top\u2011k lowest scores\n    top_k = 5\n    if score.size > top_k:\n        idx_top = np.argpartition(score, top_k)[:top_k]\n    else:\n        idx_top = np.arange(score.size)\n    chosen_idx = np.random.choice(idx_top)\n    return int(feasible[chosen_idx])\n\n",
  "edge_triangle_slack_max_aug_322": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    eps = 1e-12\n\n    # rename for clarity\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n\n    # feasibility filtering\n    cap = float(rest_capacity)\n    feasible = np.array([c for c in candidates if demands[c] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    # distances\n    d_cd = float(dist_mat[current_node, depot])\n    d_cn = dist_mat[current_node, feasible].astype(float)\n    d_nd = dist_mat[feasible, depot].astype(float)\n\n    # detour metric\n    detour = d_cn + d_nd - d_cd\n\n    # deterministic tie\u2011breaking noise\n    noise = np.random.rand(detour.size) * 1e-9\n    scores = detour + noise\n\n    # soft\u2011min with temperature\n    temp = 0.05\n    exp_scores = np.exp(-scores / (temp + eps))\n    probs = exp_scores / (np.sum(exp_scores) + eps)\n\n    chosen = feasible[int(np.argmax(probs))]\n    return int(chosen)\n\n",
  "edge_triangle_slack_max_aug_323": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    eps = 1e-12\n    cap = float(rest_capacity)\n\n    # build feasible list with a while loop\n    feasible = []\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = unvisited_nodes[idx]\n        if demands[node] <= cap:\n            feasible.append(node)\n        idx += 1\n    if not feasible:\n        return depot\n    feasible = np.array(feasible, dtype=int)\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    # detour and weighted mean adjustment\n    detour = d_cn + d_nd - d_cd\n    mean_det = (d_cn + d_nd + d_cd) / (3.0 + eps)\n    score = 0.6 * detour + 0.4 * mean_det\n    score = np.clip(score, 0, None)\n\n    # top\u2011k selection\n    top_k = 7\n    if top_k > len(feasible):\n        top_k = len(feasible)\n    top_indices = np.argpartition(score, top_k - 1)[:top_k]\n\n    # random choice among top\u2011k\n    chosen_idx = np.random.choice(top_indices)\n    return int(feasible[chosen_idx])\n\n",
  "edge_triangle_slack_max_aug_324": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    eps = 1e-12\n    cap = float(rest_capacity)\n\n    feasible = np.array([node for node in unvisited_nodes if demands[node] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    detour = d_cn + d_nd - d_cd\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(detour.size) * 1e-9\n    detour_noisy = detour + noise\n\n    # median aggregation\n    median_val = np.median([d_cn, d_nd, np.full_like(d_cn, d_cd)], axis=0)\n\n    # normalize with safe denominator\n    detour_norm = detour_noisy / (np.max(detour_noisy) + eps)\n    score = detour_norm + 0.5 * (median_val - d_cd)\n    score = np.clip(score, 0, None)\n\n    chosen = feasible[int(np.argmin(score))]\n    return int(chosen)\n\n",
  "edge_triangle_slack_max_aug_325": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    eps = 1e-12\n    cap = float(rest_capacity)\n\n    # feasibility list via while loop\n    feasible = []\n    i = 0\n    while i < unvisited_nodes.size:\n        node = unvisited_nodes[i]\n        if demands[node] <= cap:\n            feasible.append(node)\n        i += 1\n    if not feasible:\n        return depot\n    feasible = np.array(feasible, dtype=int)\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    # proxy: squared distances\n    d_cn_sq = np.square(d_cn)\n    d_nd_sq = np.square(d_nd)\n    d_cd_sq = d_cd ** 2\n\n    detour_sq = d_cn_sq + d_nd_sq - d_cd_sq\n    detour_sq = np.clip(detour_sq, 0, None)\n\n    # normalize safely\n    detour_norm = detour_sq / (np.max(detour_sq) + eps)\n\n    # order by normalized detour\n    order = np.argsort(detour_norm)\n    for idx in order:\n        return int(feasible[idx])\n    return depot\n\n",
  "max_compact_cluster_gain_aug_326": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    feasible = candidates[demands[candidates] <= cap0]\n    if len(feasible) == 0:\n        return depot\n\n    # Base compactness using median of pairwise distances\n    if len(feasible) > 1:\n        base_comp = float(np.median(distance_matrix[np.ix_(feasible, feasible)]))\n    else:\n        base_comp = 0.0\n\n    best_obj = float('inf')\n    best_n = depot\n\n    # Random noise for tie breaking\n    noise = np.random.rand(len(feasible)) * 1e-6\n\n    for idx, n in enumerate(feasible):\n        rem = feasible[feasible != n]\n        if len(rem) <= 1:\n            comp = 0.0\n        else:\n            comp = float(np.median(distance_matrix[np.ix_(rem, rem)]))\n        step = float(distance_matrix[current_node, n])\n        step = np.clip(step, 0, np.max(distance_matrix))\n        obj = comp + 0.2 * step + 0.1 * base_comp + noise[idx]\n        if obj < best_obj:\n            best_obj = obj\n            best_n = int(n)\n\n    return best_n\n\n",
  "max_compact_cluster_gain_aug_327": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    feasible = candidates[demands[candidates] <= cap0]\n    if len(feasible) == 0:\n        return depot\n\n    # Base compactness using max of pairwise distances\n    if len(feasible) > 1:\n        base_comp = float(np.max(distance_matrix[np.ix_(feasible, feasible)]))\n    else:\n        base_comp = 0.0\n\n    best_objs = []\n    for n in feasible:\n        rem = feasible[feasible != n]\n        if len(rem) <= 1:\n            comp = 0.0\n        else:\n            comp = float(np.max(distance_matrix[np.ix_(rem, rem)]))\n        step = float(distance_matrix[current_node, n])\n        step = np.clip(step, 0, np.max(distance_matrix))\n        obj = 0.3 * step + 0.4 * comp + 0.3 * base_comp\n        best_objs.append(obj)\n\n    best_objs = np.array(best_objs)\n    min_obj = np.min(best_objs)\n    tol = 1e-9\n    candidates_idx = np.where(best_objs <= min_obj + tol)[0]\n    if len(candidates_idx) > 1:\n        chosen_idx = np.random.choice(candidates_idx)\n    else:\n        chosen_idx = candidates_idx[0]\n    return int(feasible[chosen_idx])\n\n",
  "nearest_with_demand_floor_aug_328": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    dem = demands\n\n    if len(candidates) == 0:\n        return depot\n\n    # feasible nodes by capacity\n    feasible = [c for c in candidates if dem[c] <= rem_cap]\n    if len(feasible) == 0:\n        return depot\n\n    # demand floor at 20th percentile\n    dem_all = np.array([dem[i] for i in feasible], dtype=float)\n    floor = np.quantile(dem_all, 0.2) if len(dem_all) > 1 else dem_all[0]\n\n    # filter by floor\n    filtered = [i for i in feasible if dem[i] >= floor]\n    cand = filtered if filtered else feasible\n\n    # distances with deterministic tie\u2011breaking noise\n    d = np.clip(dist_mat[current_node, cand].astype(float), 0, None)\n    d += 1e-12 * np.arange(len(d))  # small increasing noise\n\n    return int(cand[int(np.argmin(d))])\n\n",
  "nearest_with_demand_floor_aug_329": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    dem = demands\n\n    if len(candidates) == 0:\n        return depot\n\n    feasible = [c for c in candidates if dem[c] <= rem_cap]\n    if len(feasible) == 0:\n        return depot\n\n    dem_all = np.array([dem[i] for i in feasible], dtype=float)\n    floor = np.quantile(dem_all, 0.3) if len(dem_all) > 1 else dem_all[0]  # 30th percentile\n\n    filtered = [i for i in feasible if dem[i] >= floor]\n    cand = filtered if filtered else feasible\n\n    d = np.clip(dist_mat[current_node, cand].astype(float), 0, 1e6)\n\n    # select top_k closest nodes\n    top_k = min(7, len(d))\n    top_indices = np.argpartition(d, top_k - 1)[:top_k]\n    d_top = d[top_indices]\n\n    # softmin weighting\n    temperature = 0.5\n    weights = np.exp(-d_top / (temperature + 1e-12))\n    chosen = top_indices[np.argmax(weights)]\n\n    return int(cand[chosen])\n\n",
  "nearest_with_demand_floor_aug_330": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    dem = demands\n\n    if len(candidates) == 0:\n        return depot\n\n    feasible = [c for c in candidates if dem[c] <= rem_cap]\n    if len(feasible) == 0:\n        return depot\n\n    dem_all = np.array([dem[i] for i in feasible], dtype=float)\n    floor = np.median(dem_all) if len(dem_all) > 1 else dem_all[0]  # median threshold\n\n    filtered = [i for i in feasible if dem[i] >= floor]\n    cand = filtered if filtered else feasible\n\n    # use squared distances as proxy\n    d = np.square(dist_mat[current_node, cand].astype(float))\n    d = np.clip(d, 0, None)\n\n    top_k = min(5, len(d))\n    top_indices = np.argpartition(d, top_k - 1)[:top_k]\n    chosen = np.random.choice(top_indices)\n\n    return int(cand[chosen])\n\n",
  "nearest_with_demand_floor_aug_331": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    rem_cap = rest_capacity\n    dem = demands\n\n    if len(candidates) == 0:\n        return depot\n\n    feasible = []\n    for c in candidates:\n        if dem[c] <= rem_cap:\n            feasible.append(c)\n    if len(feasible) == 0:\n        return depot\n\n    dem_all = np.array([dem[i] for i in feasible], dtype=float)\n    floor = np.quantile(dem_all, 0.15) if len(dem_all) > 1 else dem_all[0]  # 15th percentile\n\n    filtered = []\n    for i in feasible:\n        if dem[i] >= floor:\n            filtered.append(i)\n    cand = filtered if filtered else feasible\n\n    d = np.clip(dist_mat[current_node, cand].astype(float), 0, None)\n    d += 1e-8 * np.arange(len(d))  # deterministic noise\n\n    idx = np.argmin(d)\n    return int(cand[idx])\n\n",
  "randomized_topk_insertion_aug_332": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    eps = 1e-12\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Build a list of feasible nodes with a while loop\n    feasible = []\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = int(unvisited_nodes[idx])\n        if demands[node] <= cap:\n            feasible.append(node)\n        idx += 1\n\n    if not feasible:\n        return depot\n\n    feasible = np.array(feasible, dtype=int)\n    d_cd = float(distance_matrix[current_node, depot])\n\n    # Insertion cost\n    ins = (distance_matrix[current_node, feasible] +\n           distance_matrix[feasible, depot] - d_cd).astype(float)\n\n    # Choose the best 7 candidates (or fewer if not enough)\n    top_k = min(7, len(feasible))\n    idx_top = np.argsort(ins)[:top_k]\n    cand = feasible[idx_top]\n\n    # Soft\u2011min probability distribution\n    inv_cost = 1.0 / (ins[idx_top] + eps)\n    probs = inv_cost / (np.sum(inv_cost) + eps)\n    probs = np.clip(probs, 0, 1)\n\n    rng = np.random.default_rng(seed=int(current_node) ^ int(cap * 1000))\n    return int(rng.choice(cand, p=probs))\n\n",
  "randomized_topk_insertion_aug_333": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    eps = 1e-12\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Feasible nodes via list comprehension\n    feasible = np.array([n for n in unvisited_nodes\n                         if demands[int(n)] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n\n    # Insertion cost\n    ins = (distance_matrix[current_node, feasible] +\n           distance_matrix[feasible, depot] - d_cd).astype(float)\n\n    # Deterministic noise for tie breaking\n    noise = np.arange(1, ins.size + 1) * 1e-9\n    ins_noisy = ins + noise\n\n    # Top\u20115 candidates\n    top_k = min(5, ins_noisy.size)\n    idx_top = np.argpartition(ins_noisy, top_k)[:top_k]\n    cand = feasible[idx_top]\n\n    # Soft\u2011max probabilities (negative cost)\n    exp_vals = np.exp(-ins_noisy[idx_top] /\n                      (np.mean(ins_noisy[idx_top]) + eps))\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n    probs = np.clip(probs, 0, 1)\n\n    seed = (current_node * 1234567) ^ (len(unvisited_nodes) * 7654321) ^ (int(cap * 1000))\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(cand, p=probs))\n\n",
  "randomized_topk_insertion_aug_334": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    eps = 1e-12\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Vectorised feasibility check\n    feasible_mask = demands[unvisited_nodes] <= cap\n    feasible = unvisited_nodes[feasible_mask].astype(int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n\n    # Insertion cost\n    ins = (distance_matrix[current_node, feasible] +\n           distance_matrix[feasible, depot] - d_cd).astype(float)\n\n    # Top\u20116 candidates using argpartition\n    top_k = min(6, ins.size)\n    idx_top = np.argpartition(ins, top_k)[:top_k]\n    cand = feasible[idx_top]\n\n    # Scale by median cost for a more robust soft\u2011min\n    median_cost = np.median(ins[idx_top]) + eps\n    scale = median_cost / (ins[idx_top] + eps)\n    probs = scale / (np.sum(scale) + eps)\n    probs = np.clip(probs, 0, 1)\n\n    seed = (current_node * 9876543) + (int(cap * 1000)) ^ len(unvisited_nodes)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(cand, p=probs))\n\n",
  "randomized_topk_insertion_aug_335": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    eps = 1e-12\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # Feasible nodes via comprehension\n    feasible = np.array([n for n in unvisited_nodes\n                         if demands[int(n)] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n\n    # Insertion cost\n    ins = (distance_matrix[current_node, feasible] +\n           distance_matrix[feasible, depot] - d_cd).astype(float)\n\n    # Add tiny random noise for deterministic tie\u2011breaking\n    rng_noise = np.random.default_rng(seed=int(current_node) * 19260817 +\n                                      int(cap * 1000))\n    noise = rng_noise.uniform(-1e-8, 1e-8, size=ins.shape)\n    ins_noisy = ins + noise\n\n    # Top\u20115 candidates\n    top_k = min(5, ins_noisy.size)\n    idx_top = np.argpartition(ins_noisy, top_k)[:top_k]\n    cand = feasible[idx_top]\n\n    # Soft\u2011max with temperature based on mean cost\n    temp = np.mean(ins_noisy[idx_top]) + eps\n    exp_vals = np.exp(-ins_noisy[idx_top] / (temp + eps))\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n    probs = np.clip(probs, 0, 1)\n\n    rng_choice = np.random.default_rng(seed=int(current_node) * 19260817 +\n                                       int(cap * 1000))\n    return int(rng_choice.choice(cand, p=probs))\n\n",
  "boltzmann_utility_demand_minus_cost_aug_336": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible_mask = demands[unvisited_nodes] <= cap\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = unvisited_nodes[feasible_mask]\n    dem = demands[feasible].astype(float)\n    dist = distance_matrix[current_node, feasible].astype(float)\n\n    alpha = 0.75\n    util = dem - alpha * dist\n    util = np.clip(util, -1e6, 1e6)\n\n    # Softmax with temperature\n    max_util = np.max(util)\n    exp_util = np.exp((util - max_util) / (np.std(util) + 1e-9))\n    probs = exp_util / (np.sum(exp_util) + 1e-12)\n\n    seed = (current_node * 1234567) ^ (len(unvisited_nodes) * 7654321)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=probs))\n\n",
  "boltzmann_utility_demand_minus_cost_aug_337": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    dist = distance_matrix[current_node, feasible].astype(float)\n\n    beta = 0.4\n    alpha = 0.6\n    util = beta * dem - alpha * dist\n    util = np.clip(util, -1e6, 1e6)\n\n    # small deterministic noise for tie\u2011breaking\n    rng_noise = np.random.default_rng((current_node * 9876543) ^ (len(unvisited_nodes) * 3456789))\n    noise = rng_noise.uniform(-1e-6, 1e-6, size=feasible.size)\n    util_noisy = util + noise\n\n    # top\u2011k selection\n    top_k = 7\n    if feasible.size > top_k:\n        idx_top = np.argpartition(-util_noisy, top_k-1)[:top_k]\n        feasible_top = feasible[idx_top]\n        util_top = util_noisy[idx_top]\n    else:\n        feasible_top = feasible\n        util_top = util_noisy\n\n    max_util = np.max(util_top)\n    exp_util = np.exp((util_top - max_util) / (np.std(util_top) + 1e-9))\n    probs = exp_util / (np.sum(exp_util) + 1e-12)\n\n    seed = (current_node * 19260817) ^ (len(unvisited_nodes) * 91827364)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible_top, p=probs))\n\n",
  "boltzmann_utility_demand_minus_cost_aug_338": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    dist = distance_matrix[current_node, feasible].astype(float)\n\n    alpha = 0.7\n    util = dem - alpha * dist\n    util = np.clip(util, -1e6, 1e6)\n\n    # softmin using median for temperature\n    med_util = np.median(util)\n    T = np.std(util) + 1e-9\n    exp_util = np.exp(-(util - med_util) / T)\n\n    probs = exp_util / (np.sum(exp_util) + 1e-12)\n\n    # select top\u2011k = 5 for randomness\n    top_k = 5\n    if feasible.size > top_k:\n        idx_top = np.argpartition(-probs, top_k-1)[:top_k]\n        feasible_top = feasible[idx_top]\n        probs_top = probs[idx_top]\n        probs_top = probs_top / (np.sum(probs_top) + 1e-12)\n    else:\n        feasible_top = feasible\n        probs_top = probs\n\n    seed = (current_node * 31415926) ^ (len(unvisited_nodes) * 27182818)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible_top, p=probs_top))\n\n",
  "boltzmann_utility_demand_minus_cost_aug_339": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible_mask = demands[unvisited_nodes] <= cap\n    if not np.any(feasible_mask):\n        return depot\n\n    feasible = unvisited_nodes[feasible_mask]\n    dem = demands[feasible].astype(float)\n    dist = distance_matrix[current_node, feasible].astype(float)\n\n    alpha = 0.5\n    util = dem - alpha * dist\n    util = np.clip(util, -1e6, 1e6)\n\n    max_util = np.max(util)\n    eps = 1e-9\n    tie_mask = np.abs(util - max_util) <= eps\n    tied_nodes = feasible[tie_mask]\n\n    if tied_nodes.size > 1:\n        seed = (current_node * 27182818) ^ (len(unvisited_nodes) * 31415926)\n        rng = np.random.default_rng(seed % (2**32))\n        return int(rng.choice(tied_nodes))\n    else:\n        return int(tied_nodes[0])\n\n",
  "gated_isolation_then_nearest_aug_340": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    dist_mat   = distance_matrix\n    cap        = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = candidates[demands[candidates] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    # pairwise distances from feasible nodes to all candidates\n    dist_fu = dist_mat[np.ix_(feasible, candidates)].astype(float)\n    for i, node in enumerate(feasible):\n        same = np.where(candidates == node)[0]\n        if same.size > 0:\n            dist_fu[i, same[0]] = np.inf\n\n    nearest = np.min(dist_fu, axis=1)\n    nearest = np.clip(nearest, 1e-12, None)          # avoid zero distances\n\n    thr = float(np.quantile(nearest, 0.75))\n    iso = feasible[nearest >= thr]\n\n    if iso.size > 0:\n        d_iso = np.clip(dist_mat[current_node, iso].astype(float), 1e-12, None)\n        noise = np.random.randint(1, 10) / 1e6\n        return int(iso[int(np.argmin(d_iso + noise))])\n\n    d = np.clip(dist_mat[current_node, feasible].astype(float), 1e-12, None)\n    noise = np.random.randint(1, 10) / 1e6\n    return int(feasible[int(np.argmin(d + noise))])\n\n",
  "gated_isolation_then_nearest_aug_341": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    dist_mat   = distance_matrix\n    cap        = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = candidates[demands[candidates] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    # distance from current node\n    d = np.clip(dist_mat[current_node, feasible].astype(float), 1e-12, None)\n\n    # cost proxy: use demand as a \u201cpenalty\u201d\n    cost = demands[feasible].astype(float)\n\n    # weighted score\n    score = 0.6 * d + 0.4 * cost\n\n    # keep only top\u2011k nodes with lowest score\n    top_k = 7\n    if feasible.size > top_k:\n        idx_top = np.argpartition(score, top_k)[:top_k]\n        feasible = feasible[idx_top]\n        score    = score[idx_top]\n\n    # soft\u2011min probability distribution\n    beta = 1.0\n    exp_val = np.exp(-beta * score)\n    prob = exp_val / (np.sum(exp_val) + 1e-12)          # epsilon to avoid div\u2011by\u2011zero\n\n    chosen = np.random.choice(feasible, p=prob)\n    return int(chosen)\n\n",
  "gated_isolation_then_nearest_aug_342": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    dist_mat   = distance_matrix\n    cap        = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = candidates[demands[candidates] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    # compute squared Euclidean distances as proxy (avoids sqrt)\n    d_sq = np.clip(dist_mat[current_node, feasible].astype(float)**2, 1e-12, None)\n\n    # nearest distances (sqrt of d_sq)\n    nearest = np.sqrt(d_sq)\n\n    thr = float(np.mean(nearest))                      # use mean instead of percentile\n    iso = feasible[nearest >= thr]\n\n    if iso.size > 0:\n        d_iso = np.clip(dist_mat[current_node, iso].astype(float), 1e-12, None)\n        noise = np.random.randint(1, 10) / 1e6\n        return int(iso[int(np.argmin(d_iso + noise))])\n\n    noise = np.random.randint(1, 10) / 1e6\n    return int(feasible[int(np.argmin(d_sq + noise))])\n\n",
  "gated_isolation_then_nearest_aug_343": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = np.asarray(unvisited_nodes, dtype=int)\n    dist_mat   = distance_matrix\n    cap        = float(rest_capacity)\n\n    if candidates.size == 0:\n        return depot\n\n    # build feasible list with a while loop\n    feasible = []\n    i = 0\n    while i < candidates.size:\n        node = candidates[i]\n        if demands[node] <= cap:\n            feasible.append(node)\n        i += 1\n    feasible = np.array(feasible, dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    # distances from current node\n    d = np.clip(dist_mat[current_node, feasible].astype(float), 1e-12, None)\n\n    # mean\u2011based threshold\n    thr = float(np.mean(d))\n    iso = feasible[d >= thr]\n\n    if iso.size > 0:\n        d_iso = np.clip(dist_mat[current_node, iso].astype(float), 1e-12, None)\n        noise = np.random.randint(1, 10) / 1e6\n        return int(iso[int(np.argmin(d_iso + noise))])\n\n    noise = np.random.randint(1, 10) / 1e6\n    return int(feasible[int(np.argmin(d + noise))])\n\n",
  "min_weighted_harmonic_distances_aug_344": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cap = float(rest_capacity)\n    rng = np.random.default_rng(0)\n    # Build feasible list using a while loop\n    feasible = []\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = int(unvisited_nodes[idx])\n        if demands[node] <= cap:\n            feasible.append(node)\n        idx += 1\n    if not feasible:\n        return depot\n    feasible = np.array(feasible, dtype=int)\n\n    d_curr = distance_matrix[current_node, feasible]\n    d_dep  = distance_matrix[depot, feasible]\n    eps = 1e-12\n    denom = 1.0 / (d_curr + eps) + 1.0 / (d_dep + eps)\n    harm = 2.0 / np.clip(denom, a_min=eps, a_max=None)\n\n    # deterministic noise for tie\u2011breaking\n    noise = rng.random(len(feasible)) * 1e-6\n    harm += noise\n    return int(feasible[np.argmin(harm)])\n\n",
  "min_weighted_harmonic_distances_aug_345": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cap = float(rest_capacity)\n    # feasible nodes via list comprehension\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_curr = distance_matrix[current_node, feasible]\n    d_dep  = distance_matrix[depot, feasible]\n    # weighted sum scoring with tuned weights\n    weight_curr, weight_dep = 0.6, 0.4\n    score = weight_curr * np.clip(d_curr, a_min=1e-12, a_max=None) + \\\n            weight_dep * np.clip(d_dep, a_min=1e-12, a_max=None)\n\n    # top\u2011k selection\n    top_k = 7\n    if feasible.size > top_k:\n        idx = np.argpartition(score, top_k)[:top_k]\n        candidates = feasible[idx]\n    else:\n        candidates = feasible\n\n    # random choice among top\u2011k\n    rng = np.random.default_rng(42)\n    return int(rng.choice(candidates))\n\n",
  "min_weighted_harmonic_distances_aug_346": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cap = float(rest_capacity)\n    # feasible nodes\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d_curr = distance_matrix[current_node, feasible]\n    d_dep  = distance_matrix[depot, feasible]\n    # proxy: median of the two distances\n    med = np.median(np.stack([d_curr, d_dep], axis=0), axis=0)\n\n    # deterministic noise for tie\u2011breaking\n    rng = np.random.default_rng(123)\n    noise = rng.random(feasible.size) * 1e-6\n    scores = med + noise\n\n    # softmin sampling\n    tau = 0.5\n    scores = np.clip(scores, a_min=1e-12, a_max=None)\n    probs = np.exp(-scores / tau)\n    probs /= probs.sum()\n\n    return int(rng.choice(feasible, p=probs))\n\n",
  "min_weighted_harmonic_distances_aug_347": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    cap = float(rest_capacity)\n    # Build feasible list with a while loop\n    feasible = []\n    i = 0\n    while i < unvisited_nodes.size:\n        node = int(unvisited_nodes[i])\n        if demands[node] <= cap:\n            feasible.append(node)\n        i += 1\n    if not feasible:\n        return depot\n    feasible = np.array(feasible, dtype=int)\n\n    d_curr = distance_matrix[current_node, feasible]\n    d_dep  = distance_matrix[depot, feasible]\n    eps = 1e-12\n    denom = 1.0 / (d_curr + eps) + 1.0 / (d_dep + eps)\n    harm = 2.0 / np.clip(denom, a_min=eps, a_max=None)\n\n    # tie\u2011breaking: prefer smaller node id\n    harm -= 1e-9 * feasible\n    idx = np.argmin(harm)\n    return int(feasible[idx])\n\n",
  "soft_regret_on_two_criteria_aug_348": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    # feasible nodes using list comprehension\n    feasible = np.array([c for c in candidates if demands[c] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    beta = 0.6\n    # cost with deterministic noise to break ties\n    base_cost = dist_mat[current_node, feasible].astype(float) + beta * dist_mat[depot, feasible].astype(float)\n    noise = np.arange(feasible.size) * 1e-6\n    cost = base_cost + noise\n\n    if feasible.size == 1:\n        return int(feasible[0])\n\n    # sort costs\n    sorted_idx = np.argsort(cost)\n    best_cost = float(cost[sorted_idx[0]])\n    kth_cost = float(cost[sorted_idx[min(2, sorted_idx.size - 1)]])\n    regret = kth_cost - best_cost\n\n    # use median if regret small else best\n    if regret > (np.std(cost) + 1e-12):\n        return int(feasible[sorted_idx[0]])\n    else:\n        return int(feasible[sorted_idx[sorted_idx.size // 2]])\n\n",
  "soft_regret_on_two_criteria_aug_349": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    # build feasible list with a while loop\n    feasible = np.empty(0, dtype=int)\n    i = 0\n    while i < candidates.size:\n        node = int(candidates[i])\n        if demands[node] <= cap:\n            feasible = np.append(feasible, node)\n        i += 1\n\n    if feasible.size == 0:\n        return depot\n\n    beta = 0.5\n    raw_cost = dist_mat[current_node, feasible].astype(float) + beta * dist_mat[depot, feasible].astype(float)\n    clipped_cost = np.clip(raw_cost, 0, 1e6)\n\n    # softmin with temperature\n    temp = 1.0\n    exp_neg = np.exp(-clipped_cost / temp)\n    denom = np.sum(exp_neg) + 1e-12\n    probs = exp_neg / denom\n\n    # select randomly among top_k high\u2011probability nodes\n    top_k = 3\n    top_indices = np.argsort(probs)[-top_k:]\n    chosen = np.random.choice(top_indices)\n    return int(feasible[chosen])\n\n",
  "soft_regret_on_two_criteria_aug_350": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    # vectorized feasibility check\n    mask = demands[candidates] <= cap\n    feasible = candidates[mask].astype(int)\n\n    if feasible.size == 0:\n        return depot\n\n    beta = 0.55\n    base_cost = dist_mat[current_node, feasible].astype(float) + beta * dist_mat[depot, feasible].astype(float)\n    noise = (np.arange(feasible.size) % 3) * 1e-7  # small deterministic noise\n    cost = base_cost + noise\n\n    if feasible.size == 1:\n        return int(feasible[0])\n\n    sorted_idx = np.argsort(cost)\n    best = cost[sorted_idx[0]]\n    kth = cost[sorted_idx[min(4, sorted_idx.size - 1)]]\n    regret = kth - best\n\n    # use mean difference as threshold\n    if regret > (np.mean(cost) + 1e-12):\n        return int(feasible[sorted_idx[0]])\n    else:\n        top_k = 5\n        top_indices = sorted_idx[:top_k]\n        chosen = top_indices[np.random.randint(0, top_k)]\n        return int(feasible[chosen])\n\n",
  "soft_regret_on_two_criteria_aug_351": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    dist_mat = distance_matrix\n    candidates = unvisited_nodes\n    cap = float(rest_capacity)\n\n    # build feasible list with a for loop\n    feasible = []\n    for node in candidates:\n        if demands[node] <= cap:\n            feasible.append(int(node))\n    feasible = np.array(feasible, dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    beta = 0.4\n    # compute cost with a simple linear combination\n    cost = dist_mat[current_node, feasible].astype(float) + beta * dist_mat[depot, feasible].astype(float)\n    cost = np.clip(cost, 0, 1e6)\n\n    if feasible.size == 1:\n        return int(feasible[0])\n\n    sorted_idx = np.argsort(cost)\n    best = cost[sorted_idx[0]]\n    kth = cost[sorted_idx[min(2, sorted_idx.size - 1)]]\n    regret = kth - best\n\n    # threshold using standard deviation\n    if regret > (np.std(cost) + 1e-12):\n        return int(feasible[sorted_idx[0]])\n    else:\n        # deterministic noise for tie\u2011breaking\n        noise = np.linspace(0, 1e-5, feasible.size)\n        cost += noise\n        sorted_idx = np.argsort(cost)\n        return int(feasible[sorted_idx[sorted_idx.size // 2]])\n\n",
  "min_cost_per_remaining_capacity_aug_352": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    remaining = rest_capacity\n\n    if candidates.size == 0:\n        return depot\n\n    # Feasible nodes that can be served without exceeding capacity\n    feasible = candidates[demands[candidates] <= remaining - 1e-12]\n    if feasible.size == 0:\n        # If no feasible node exists, try nodes that exactly fit the capacity\n        exact_fit = candidates[demands[candidates] <= remaining]\n        if exact_fit.size == 0:\n            return depot\n        dists = distance_matrix[current_node, exact_fit]\n        return int(exact_fit[np.argmin(dists)])\n\n    dem = demands[feasible]\n    dists = distance_matrix[current_node, feasible]\n    rem = remaining - dem + 1e-12\n    # Cost per remaining capacity (add epsilon to avoid division by zero)\n    score = dists / np.clip(rem, a_min=1e-12, a_max=None)\n    return int(feasible[np.argmin(score)])\n\n",
  "min_cost_per_remaining_capacity_aug_353": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    candidates = unvisited_nodes\n    remaining = rest_capacity\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = candidates[demands[candidates] <= remaining - 1e-12]\n    if feasible.size == 0:\n        exact_fit = candidates[demands[candidates] <= remaining]\n        if exact_fit.size == 0:\n            return depot\n        dists = distance_matrix[current_node, exact_fit]\n        return int(exact_fit[np.argmin(dists)])\n\n    dem = demands[feasible]\n    dists = distance_matrix[current_node, feasible]\n    rem = remaining - dem + 1e-12\n\n    # Weighted scoring: 60% distance, 40% remaining capacity\n    score = 0.6 * dists + 0.4 * rem\n    # Add deterministic noise to break ties\n    noise = np.arange(len(score)) * 1e-6\n    score += noise\n\n    return int(feasible[np.argmin(score)])\n\n",
  "min_cost_per_remaining_capacity_aug_354": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    rng = np.random.default_rng(0)          # deterministic seed\n    candidates = unvisited_nodes\n    remaining = rest_capacity\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = candidates[demands[candidates] <= remaining - 1e-12]\n    if feasible.size == 0:\n        exact_fit = candidates[demands[candidates] <= remaining]\n        if exact_fit.size == 0:\n            return depot\n        dists = distance_matrix[current_node, exact_fit]\n        return int(exact_fit[np.argmin(dists)])\n\n    dem = demands[feasible]\n    dists = distance_matrix[current_node, feasible]\n    rem = remaining - dem + 1e-12\n\n    score = dists / np.clip(rem, a_min=1e-12, a_max=None)\n    # Soft\u2011min with temperature 0.5\n    logits = -score / 0.5\n    probs = np.exp(logits - np.max(logits))\n    probs /= probs.sum()\n    chosen = rng.choice(len(probs), p=probs)\n    return int(feasible[chosen])\n\n",
  "min_cost_per_remaining_capacity_aug_355": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    rng = np.random.default_rng(0)          # deterministic seed\n    candidates = unvisited_nodes\n    remaining = rest_capacity\n\n    if candidates.size == 0:\n        return depot\n\n    feasible = candidates[demands[candidates] <= remaining - 1e-12]\n    if feasible.size == 0:\n        exact_fit = candidates[demands[candidates] <= remaining]\n        if exact_fit.size == 0:\n            return depot\n        dists = distance_matrix[current_node, exact_fit]\n        return int(exact_fit[np.argmin(dists)])\n\n    dem = demands[feasible]\n    dists = distance_matrix[current_node, feasible]\n    rem = remaining - dem + 1e-12\n\n    score = dists / np.clip(rem, a_min=1e-12, a_max=None)\n    # Select top\u2011k (k=7 or fewer if not enough nodes)\n    k = min(7, len(score))\n    topk_idx = np.argpartition(score, k - 1)[:k]\n    chosen = topk_idx[rng.integers(0, k)]\n    return int(feasible[chosen])\n\n",
  "max_neighborhood_demand_density_aug_356": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    # Filter feasible nodes\n    feasible = cand[demands[cand] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    k = min(6, cand.size)\n    best_node, best_score = None, -np.inf\n\n    # Iterate with a while loop\n    i = 0\n    while i < feasible.size:\n        n = feasible[i]\n        # distances from n to all candidates\n        dists = distance_matrix[n, cand].astype(float)\n        # indices of k nearest candidates\n        nearest_idx = np.argsort(dists)[:k]\n        nearest = cand[nearest_idx]\n        # compute score\n        dem_sum = float(np.sum(demands[nearest]))\n        avg_d = float(np.median(dists[nearest_idx]))  # use median\n        # add epsilon to denominator\n        denom = avg_d + 1e-12\n        val = dem_sum / denom - 0.1 * float(distance_matrix[current_node, n])\n        if val > best_score:\n            best_score, best_node = val, int(n)\n        i += 1\n\n    return int(best_node) if best_node is not None else depot\n\n",
  "max_neighborhood_demand_density_aug_357": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    feasible = cand[demands[cand] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    top_k = 7\n    best_node, best_score = None, -np.inf\n\n    # deterministic noise based on node index\n    noise = 1e-6 * np.arange(feasible.size, dtype=float)\n\n    for idx, n in enumerate(feasible):\n        dists = distance_matrix[n, cand].astype(float)\n        nearest_idx = np.argsort(dists)[:top_k]\n        nearest = cand[nearest_idx]\n        dem_sum = float(np.sum(demands[nearest]))\n        avg_d = float(np.mean(dists[nearest_idx]))\n        denom = avg_d + 1e-12\n        # weight adjustment: more emphasis on distance penalty\n        val = dem_sum / denom - 0.2 * float(distance_matrix[current_node, n])\n        val += noise[idx]  # tie-breaking noise\n        if val > best_score:\n            best_score, best_node = val, int(n)\n\n    return int(best_node) if best_node is not None else depot\n\n",
  "max_neighborhood_demand_density_aug_358": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    cand = np.asarray(unvisited_nodes, dtype=int)\n\n    feasible = cand[demands[cand] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    k = min(6, cand.size)\n    best_node, best_score = None, -np.inf\n\n    for n in feasible:\n        dists = distance_matrix[n, cand].astype(float)\n        nearest_idx = np.argsort(dists)[:k]\n        nearest = cand[nearest_idx]\n        # proxy: use max demand among neighbors\n        max_dem = float(np.max(demands[nearest]))\n        avg_d = float(np.median(dists[nearest_idx]))\n        denom = avg_d + 1e-12\n        val = max_dem / denom - 0.1 * float(distance_matrix[current_node, n])\n        # clip score to avoid extreme values\n        val = np.clip(val, -1e6, 1e6)\n        if val > best_score:\n            best_score, best_node = val, int(n)\n\n    return int(best_node) if best_node is not None else depot\n\n",
  "anti_depot_bias_when_far_aug_359": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n\n    # gather feasible nodes using a while loop\n    feasible = np.empty(0, dtype=int)\n    idx = 0\n    while idx < unvisited_nodes.size:\n        node = unvisited_nodes[idx]\n        if demands[node] <= cap:\n            feasible = np.append(feasible, node)\n        idx += 1\n\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_nd = distance_matrix[depot, feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # avoid division by zero in median computation\n    median_nd = np.median(d_nd) + 1e-12\n    far = d_cd > median_nd\n\n    # small deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=feasible.shape)\n\n    if far:\n        score = 0.6 * (-d_nd) + 0.4 * (-d_cn) + noise  # stay out\n        idx = int(np.argmax(score))\n    else:\n        score = 0.6 * d_nd + 0.4 * d_cn + noise          # stay near\n        idx = int(np.argmin(score))\n\n    return int(feasible[idx])\n\n",
  "anti_depot_bias_when_far_aug_360": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_nd = distance_matrix[depot, feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # use mean instead of median for threshold\n    mean_nd = np.mean(d_nd) + 1e-12\n    far = d_cd > mean_nd\n\n    # weighting scheme\n    w1, w2 = 0.8, 0.2\n\n    if far:\n        raw_score = w1 * (-d_nd) + w2 * (-d_cn)\n    else:\n        raw_score = w1 * d_nd + w2 * d_cn\n\n    # softmin via exponentials\n    beta = 5.0\n    exp_scores = np.exp(-beta * raw_score)\n    probs = exp_scores / np.clip(exp_scores.sum(), 1e-12, None)\n\n    # pick one of the top_k candidates\n    top_k = 7\n    top_indices = np.argsort(probs)[-top_k:]\n    chosen = np.random.choice(\n        top_indices,\n        p=probs[top_indices] / np.clip(probs[top_indices].sum(), 1e-12, None)\n    )\n    return int(feasible[chosen])\n\n",
  "anti_depot_bias_when_far_aug_361": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_nd = distance_matrix[depot, feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # clip distances to avoid negative values\n    d_nd = np.clip(d_nd, 0, None)\n    d_cn = np.clip(d_cn, 0, None)\n\n    # median\u2011based far flag\n    median_nd = np.median(d_nd) + 1e-12\n    far = d_cd > median_nd\n\n    # equal weighting\n    w1, w2 = 0.5, 0.5\n    if far:\n        raw = w1 * d_nd + w2 * d_cn\n    else:\n        raw = w1 * (-d_nd) + w2 * (-d_cn)\n\n    # softmax probabilities\n    exp_raw = np.exp(raw - np.max(raw))\n    probs = exp_raw / np.clip(exp_raw.sum(), 1e-12, None)\n\n    # weighted random choice among top_k\n    top_k = 5\n    top_indices = np.argsort(probs)[-top_k:]\n    chosen = np.random.choice(\n        top_indices,\n        p=probs[top_indices] / np.clip(probs[top_indices].sum(), 1e-12, None)\n    )\n    return int(feasible[chosen])\n\n",
  "anti_depot_bias_when_far_aug_362": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.empty(0, dtype=int)\n    for node in unvisited_nodes:\n        if demands[node] <= cap:\n            feasible = np.append(feasible, node)\n\n    if feasible.size == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_nd = distance_matrix[depot, feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # mean\u2011based threshold with epsilon\n    mean_nd = np.mean(d_nd) + 1e-12\n    far = d_cd > mean_nd\n\n    # inverted scoring\n    w1, w2 = 0.7, 0.3\n    if far:\n        score = w1 * d_nd + w2 * d_cn          # choose nearer to depot\n    else:\n        score = w1 * (-d_nd) + w2 * (-d_cn)    # choose farther\n\n    # noise for deterministic tie\u2011breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=feasible.shape)\n    score += noise\n\n    idx = int(np.argmin(score))\n    return int(feasible[idx])\n\n",
  "stochastic_threshold_acceptance_aug_363": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = max(rest_capacity, 0.0)\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    d = distance_matrix[current_node, feasible].astype(float)\n    best = float(np.min(d))\n\n    eps = 0.15\n    seed = (current_node * 2166136261) ^ (len(unvisited_nodes) * 16777619) ^ (int(cap * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n\n    perm = rng.permutation(feasible.size)\n    for idx in perm:\n        if float(d[idx]) <= best * (1.0 + eps):\n            return int(feasible[idx])\n\n    # Soft\u2011minimum over the top\u20113 closest nodes\n    top_k = min(3, feasible.size)\n    top_idx = np.argpartition(d, top_k - 1)[:top_k]\n    weights = np.exp(-d[top_idx] / (best + 1e-12))\n    weights /= np.sum(weights + 1e-12)\n    choice = rng.choice(top_idx, p=weights)\n    return int(feasible[choice])\n\n",
  "stochastic_threshold_acceptance_aug_364": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = np.clip(rest_capacity, 0.0, np.inf)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if feasible.size == 0:\n        return depot\n\n    d = distance_matrix[current_node, feasible]\n    best = float(np.min(d))\n\n    eps = 0.1\n    seed = (current_node * 123456789) ^ (len(unvisited_nodes) * 987654321) ^ (int(cap * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n\n    top_k = min(5, feasible.size)\n    top_idx = np.argpartition(d, top_k - 1)[:top_k]\n    noise = rng.uniform(-1e-8, 1e-8, size=top_idx.size)\n    scores = d[top_idx] + noise\n    best_idx = np.argmin(scores)\n    return int(feasible[top_idx[best_idx]])\n\n",
  "stochastic_threshold_acceptance_aug_365": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    if unvisited_nodes.size == 0:\n        return depot\n\n    cap = np.clip(rest_capacity, 0.0, np.inf)\n    feasible = unvisited_nodes[demands[unvisited_nodes] <= cap]\n    if feasible.size == 0:\n        return depot\n\n    d = distance_matrix[current_node, feasible]\n    d = np.clip(d, 1e-12, np.inf)  # ensure non\u2011negative distances\n    median_dist = np.median(d)\n\n    eps = 0.05\n    seed = (current_node * 19260817) ^ (len(unvisited_nodes) * 918273645) ^ (int(cap * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n\n    mask = d <= median_dist + eps\n    candidates = feasible[mask]\n    if candidates.size == 0:\n        candidates = feasible\n\n    # Add tiny deterministic noise before choosing\n    noise = rng.uniform(-1e-9, 1e-9, size=candidates.size)\n    idx = np.argmin(noise)\n    return int(candidates[idx])\n\n"
}
