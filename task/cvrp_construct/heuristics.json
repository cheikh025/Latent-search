{
  "nearest_neighbor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Classic nearest neighbor: select closest feasible node.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    return int(feasible[np.argmin(distances)])\n",
  "farthest_insertion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Select farthest feasible node from depot (sweep outliers first).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[depot, feasible]\n    return int(feasible[np.argmax(distances)])\n",
  "demand_to_distance_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Maximize demand/distance ratio (pack efficiently).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible] + 1e-9\n    demand_vals = demands[feasible]\n    ratios = demand_vals / distances\n    return int(feasible[np.argmax(ratios)])\n",
  "capacity_utilization_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Select node with highest demand that fits (maximize capacity usage).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    demand_vals = demands[feasible]\n    return int(feasible[np.argmax(demand_vals)])\n",
  "savings_heuristic": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Clarke-Wright savings: maximize (d_depot_i + d_depot_j - d_ij).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    return int(feasible[np.argmax(savings)])\n",
  "minimal_detour": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize detour: current->node + node->depot vs current->depot.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    d_nodes_depot = distance_matrix[feasible, depot]\n    \n    detours = d_current_nodes + d_nodes_depot - d_current_depot\n    return int(feasible[np.argmin(detours)])\n",
  "weighted_distance_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Weighted: 60% distance + 40% demand efficiency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    demand_norm = demand_vals / (np.mean(demand_vals) + 1e-9)\n    \n    scores = 0.6 * dist_norm - 0.4 * demand_norm  # Lower is better\n    return int(feasible[np.argmin(scores)])\n",
  "depot_proximity_bias": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prefer nodes closer to depot when capacity is low.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    capacity_ratio = rest_capacity / (np.max(demands) + 1e-9)\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_depot = distance_matrix[depot, feasible]\n    \n    if capacity_ratio < 0.3:  # Low capacity: prefer near depot\n        scores = 0.3 * d_current + 0.7 * d_depot\n    else:\n        scores = 0.8 * d_current + 0.2 * d_depot\n    \n    return int(feasible[np.argmin(scores)])\n",
  "cluster_centroid": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Select node closest to centroid of remaining feasible nodes.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Mean distance to all feasible nodes\n    mean_distances = distance_matrix[np.ix_(feasible, feasible)].mean(axis=1)\n    \n    d_current = distance_matrix[current_node, feasible]\n    scores = d_current + 0.5 * mean_distances\n    \n    return int(feasible[np.argmin(scores)])\n",
  "alternating_nearest_farthest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Alternate between nearest and farthest based on step count.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    step = len(distance_matrix) - len(unvisited_nodes)\n    distances = distance_matrix[current_node, feasible]\n    \n    if step % 2 == 0:\n        return int(feasible[np.argmin(distances)])\n    else:\n        return int(feasible[np.argmax(distances)])\n",
  "regret_insertion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Select node with highest regret (difference between best and second-best).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    if len(feasible) == 1:\n        return int(feasible[0])\n    \n    # For each feasible node, find two closest positions\n    distances = distance_matrix[current_node, feasible]\n    sorted_idx = np.argsort(distances)\n    \n    if len(sorted_idx) > 1:\n        regret = distances[sorted_idx[1]] - distances[sorted_idx[0]]\n        return int(feasible[sorted_idx[np.argmax([regret])]])\n    \n    return int(feasible[sorted_idx[0]])\n",
  "sweep_algorithm": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Angular sweep: prefer nodes in similar direction from depot.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Use distance relationships as proxy for angle\n    d_depot_current = distance_matrix[depot, current_node]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    # Cosine law approximation for angular proximity\n    scores = d_current_nodes / (d_depot_current + d_depot_nodes + 1e-9)\n    return int(feasible[np.argmin(scores)])\n",
  "balanced_route_length": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Balance between extending route and returning to depot.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    capacity_remaining_ratio = rest_capacity / (np.sum(demands[unvisited_nodes]) + 1e-9)\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_to_depot = distance_matrix[feasible, depot]\n    \n    # If low remaining demand, prefer finishing route\n    if capacity_remaining_ratio > 0.5:\n        scores = d_current + 0.3 * d_to_depot\n    else:\n        scores = d_current + 0.8 * d_to_depot\n    \n    return int(feasible[np.argmin(scores)])\n",
  "demand_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prioritize high-demand nodes early in the route.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    total_unvisited_demand = np.sum(demands[unvisited_nodes])\n    progress = 1.0 - (total_unvisited_demand / (np.sum(demands) + 1e-9))\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    \n    # Early: prefer high demand; Late: prefer close\n    weight = 1.0 - progress\n    scores = distances - weight * demand_vals\n    \n    return int(feasible[np.argmin(scores)])\n",
  "random_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Random selection among feasible nodes (deterministic seed).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    seed = int(current_node * 73856093) ^ int(len(unvisited_nodes) * 19349663)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible))\n",
  "min_max_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize maximum distance to remaining nodes (keep route compact).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    max_distances = distance_matrix[np.ix_(feasible, unvisited_nodes)].max(axis=1)\n    return int(feasible[np.argmin(max_distances)])\n",
  "insertion_cost": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize insertion cost: d(current,node) + d(node,depot) - d(current,depot).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_cd = distance_matrix[current_node, depot]\n    d_cn = distance_matrix[current_node, feasible]\n    d_nd = distance_matrix[feasible, depot]\n    \n    insertion_costs = d_cn + d_nd - d_cd\n    return int(feasible[np.argmin(insertion_costs)])\n",
  "diversity_maximizer": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Select node most different from recent selections (avoid clustering).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Use depot distance as diversity proxy\n    d_depot = distance_matrix[depot, feasible]\n    d_current = distance_matrix[current_node, feasible]\n    \n    diversity = np.abs(d_depot - d_current)\n    scores = d_current - 0.5 * diversity\n    \n    return int(feasible[np.argmin(scores)])\n",
  "capacity_aware_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Nearest neighbor with capacity threshold adjustment.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    \n    # Penalize high-demand nodes when capacity is low\n    capacity_factor = rest_capacity / (np.max(demands) + 1e-9)\n    penalty = (1.0 - capacity_factor) * demand_vals\n    \n    scores = distances + penalty\n    return int(feasible[np.argmin(scores)])\n",
  "stochastic_savings": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Probabilistic selection based on savings values.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    savings = savings - savings.min() + 1e-9  # Ensure positive\n    \n    probs = savings / np.sum(savings)\n    \n    seed = int(current_node * 2654435761) ^ int(len(unvisited_nodes) * 2246822519)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "composite_five_factor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Composite: distance + demand + depot + capacity + cluster centrality.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_depot = distance_matrix[depot, feasible]\n    demand_vals = demands[feasible]\n    capacity_util = demand_vals / (rest_capacity + 1e-9)\n    \n    mean_dist = distance_matrix[np.ix_(feasible, unvisited_nodes)].mean(axis=1)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    score = (0.3 * norm(d_current) + \n             0.2 * norm(d_depot) - \n             0.2 * norm(demand_vals) + \n             0.15 * norm(capacity_util) + \n             0.15 * norm(mean_dist))\n    \n    return int(feasible[np.argmin(score)])\n",
  "route_compactness": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize route spread: prefer nodes that keep route geographically tight.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Variance of distances as compactness measure\n    distances_to_all = distance_matrix[feasible, :]\n    variance = np.var(distances_to_all, axis=1)\n    \n    d_current = distance_matrix[current_node, feasible]\n    scores = d_current + 0.5 * variance\n    \n    return int(feasible[np.argmin(scores)])\n",
  "adaptive_threshold": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Adaptive distance threshold based on remaining capacity.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    median_dist = np.median(distances)\n    \n    capacity_ratio = rest_capacity / (np.sum(demands[unvisited_nodes]) + 1e-9)\n    \n    # High capacity: explore (accept far nodes); Low capacity: exploit (nearby)\n    threshold = median_dist * (0.5 + capacity_ratio)\n    \n    close_nodes = [i for i, d in enumerate(distances) if d <= threshold]\n    if close_nodes:\n        return int(feasible[close_nodes[np.argmin(demands[feasible][close_nodes])]])\n    \n    return int(feasible[np.argmin(distances)])\n",
  "minmax_normalized": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Min-max normalize all factors and combine equally.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_depot = distance_matrix[depot, feasible]\n    demand_vals = demands[feasible]\n    \n    def minmax(x):\n        mn, mx = x.min(), x.max()\n        if mx - mn < 1e-9:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn)\n    \n    score = minmax(d_current) + minmax(d_depot) - minmax(demand_vals)\n    return int(feasible[np.argmin(score)])\n",
  "exponential_distance_decay": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Exponentially decay probability with distance.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    mean_dist = np.mean(distances)\n    \n    weights = np.exp(-distances / (mean_dist + 1e-9))\n    probs = weights / np.sum(weights)\n    \n    seed = int(current_node * 1597334677) ^ int(depot * 3812015801)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "remaining_demand_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Consider ratio of node demand to total remaining demand.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    total_remaining = np.sum(demands[unvisited_nodes]) + 1e-9\n    demand_ratios = demands[feasible] / total_remaining\n    \n    distances = distance_matrix[current_node, feasible]\n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    \n    scores = dist_norm - 0.4 * demand_ratios\n    return int(feasible[np.argmin(scores)])\n",
  "bottleneck_avoid": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Avoid nodes that are bottlenecks (far from all others).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Minimum distance to any other unvisited node\n    dist_matrix = distance_matrix[np.ix_(feasible, unvisited_nodes)]\n    min_dist_to_others = np.min(dist_matrix, axis=1)\n    \n    d_current = distance_matrix[current_node, feasible]\n    scores = d_current + 0.6 * min_dist_to_others\n    \n    return int(feasible[np.argmin(scores)])\n",
  "petal_algorithm": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Petal-like routing: follow similar depot-distance arcs.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_depot_current = distance_matrix[depot, current_node]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    # Prefer nodes at similar distance from depot\n    depot_dist_diff = np.abs(d_depot_nodes - d_depot_current)\n    scores = d_current_nodes + 0.7 * depot_dist_diff\n    \n    return int(feasible[np.argmin(scores)])\n",
  "hybrid_nearest_savings": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Hybrid: 50% nearest neighbor + 50% savings heuristic.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current\n    \n    dist_norm = d_current / (np.mean(d_current) + 1e-9)\n    savings_norm = savings / (np.mean(np.abs(savings)) + 1e-9)\n    \n    scores = 0.5 * dist_norm - 0.5 * savings_norm\n    return int(feasible[np.argmin(scores)])\n"
}
