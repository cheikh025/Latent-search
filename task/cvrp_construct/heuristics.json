{
  "nearest_neighbor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Classic nearest neighbor: select closest feasible node.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    return int(feasible[np.argmin(distances)])\n",
  "farthest_insertion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Select farthest feasible node from depot (sweep outliers first).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[depot, feasible]\n    return int(feasible[np.argmax(distances)])\n",
  "demand_to_distance_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Maximize demand/distance ratio (pack efficiently).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible] + 1e-9\n    demand_vals = demands[feasible]\n    ratios = demand_vals / distances\n    return int(feasible[np.argmax(ratios)])\n",
  "capacity_utilization_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Select node with highest demand that fits (maximize capacity usage).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    demand_vals = demands[feasible]\n    return int(feasible[np.argmax(demand_vals)])\n",
  "savings_heuristic": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Clarke-Wright savings: maximize (d_depot_i + d_depot_j - d_ij).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    return int(feasible[np.argmax(savings)])\n",
  "minimal_detour": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize detour: current->node + node->depot vs current->depot.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    d_nodes_depot = distance_matrix[feasible, depot]\n    \n    detours = d_current_nodes + d_nodes_depot - d_current_depot\n    return int(feasible[np.argmin(detours)])\n",
  "weighted_distance_demand": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Weighted: 60% distance + 40% demand efficiency.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    \n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    demand_norm = demand_vals / (np.mean(demand_vals) + 1e-9)\n    \n    scores = 0.6 * dist_norm - 0.4 * demand_norm  # Lower is better\n    return int(feasible[np.argmin(scores)])\n",
  "depot_proximity_bias": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prefer nodes closer to depot when capacity is low.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    capacity_ratio = rest_capacity / (np.max(demands) + 1e-9)\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_depot = distance_matrix[depot, feasible]\n    \n    if capacity_ratio < 0.3:  # Low capacity: prefer near depot\n        scores = 0.3 * d_current + 0.7 * d_depot\n    else:\n        scores = 0.8 * d_current + 0.2 * d_depot\n    \n    return int(feasible[np.argmin(scores)])\n",
  "cluster_centroid": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Select node closest to centroid of remaining feasible nodes.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Mean distance to all feasible nodes\n    mean_distances = distance_matrix[np.ix_(feasible, feasible)].mean(axis=1)\n    \n    d_current = distance_matrix[current_node, feasible]\n    scores = d_current + 0.5 * mean_distances\n    \n    return int(feasible[np.argmin(scores)])\n",
  "alternating_nearest_farthest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Alternate between nearest and farthest based on step count.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    step = len(distance_matrix) - len(unvisited_nodes)\n    distances = distance_matrix[current_node, feasible]\n    \n    if step % 2 == 0:\n        return int(feasible[np.argmin(distances)])\n    else:\n        return int(feasible[np.argmax(distances)])\n",
  "regret_insertion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Select node with highest regret (difference between best and second-best).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    if len(feasible) == 1:\n        return int(feasible[0])\n    \n    # For each feasible node, find two closest positions\n    distances = distance_matrix[current_node, feasible]\n    sorted_idx = np.argsort(distances)\n    \n    if len(sorted_idx) > 1:\n        regret = distances[sorted_idx[1]] - distances[sorted_idx[0]]\n        return int(feasible[sorted_idx[np.argmax([regret])]])\n    \n    return int(feasible[sorted_idx[0]])\n",
  "sweep_algorithm": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Angular sweep: prefer nodes in similar direction from depot.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Use distance relationships as proxy for angle\n    d_depot_current = distance_matrix[depot, current_node]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    # Cosine law approximation for angular proximity\n    scores = d_current_nodes / (d_depot_current + d_depot_nodes + 1e-9)\n    return int(feasible[np.argmin(scores)])\n",
  "balanced_route_length": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Balance between extending route and returning to depot.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    capacity_remaining_ratio = rest_capacity / (np.sum(demands[unvisited_nodes]) + 1e-9)\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_to_depot = distance_matrix[feasible, depot]\n    \n    # If low remaining demand, prefer finishing route\n    if capacity_remaining_ratio > 0.5:\n        scores = d_current + 0.3 * d_to_depot\n    else:\n        scores = d_current + 0.8 * d_to_depot\n    \n    return int(feasible[np.argmin(scores)])\n",
  "demand_urgency": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prioritize high-demand nodes early in the route.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    total_unvisited_demand = np.sum(demands[unvisited_nodes])\n    progress = 1.0 - (total_unvisited_demand / (np.sum(demands) + 1e-9))\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    \n    # Early: prefer high demand; Late: prefer close\n    weight = 1.0 - progress\n    scores = distances - weight * demand_vals\n    \n    return int(feasible[np.argmin(scores)])\n",
  "random_feasible": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Random selection among feasible nodes (deterministic seed).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    seed = int(current_node * 73856093) ^ int(len(unvisited_nodes) * 19349663)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible))\n",
  "min_max_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize maximum distance to remaining nodes (keep route compact).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    max_distances = distance_matrix[np.ix_(feasible, unvisited_nodes)].max(axis=1)\n    return int(feasible[np.argmin(max_distances)])\n",
  "insertion_cost": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize insertion cost: d(current,node) + d(node,depot) - d(current,depot).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_cd = distance_matrix[current_node, depot]\n    d_cn = distance_matrix[current_node, feasible]\n    d_nd = distance_matrix[feasible, depot]\n    \n    insertion_costs = d_cn + d_nd - d_cd\n    return int(feasible[np.argmin(insertion_costs)])\n",
  "diversity_maximizer": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Select node most different from recent selections (avoid clustering).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Use depot distance as diversity proxy\n    d_depot = distance_matrix[depot, feasible]\n    d_current = distance_matrix[current_node, feasible]\n    \n    diversity = np.abs(d_depot - d_current)\n    scores = d_current - 0.5 * diversity\n    \n    return int(feasible[np.argmin(scores)])\n",
  "capacity_aware_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Nearest neighbor with capacity threshold adjustment.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    demand_vals = demands[feasible]\n    \n    # Penalize high-demand nodes when capacity is low\n    capacity_factor = rest_capacity / (np.max(demands) + 1e-9)\n    penalty = (1.0 - capacity_factor) * demand_vals\n    \n    scores = distances + penalty\n    return int(feasible[np.argmin(scores)])\n",
  "stochastic_savings": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Probabilistic selection based on savings values.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current_nodes\n    savings = savings - savings.min() + 1e-9  # Ensure positive\n    \n    probs = savings / np.sum(savings)\n    \n    seed = int(current_node * 2654435761) ^ int(len(unvisited_nodes) * 2246822519)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "composite_five_factor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Composite: distance + demand + depot + capacity + cluster centrality.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_depot = distance_matrix[depot, feasible]\n    demand_vals = demands[feasible]\n    capacity_util = demand_vals / (rest_capacity + 1e-9)\n    \n    mean_dist = distance_matrix[np.ix_(feasible, unvisited_nodes)].mean(axis=1)\n    \n    def norm(x):\n        return (x - x.min()) / (x.max() - x.min() + 1e-9)\n    \n    score = (0.3 * norm(d_current) + \n             0.2 * norm(d_depot) - \n             0.2 * norm(demand_vals) + \n             0.15 * norm(capacity_util) + \n             0.15 * norm(mean_dist))\n    \n    return int(feasible[np.argmin(score)])\n",
  "route_compactness": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize route spread: prefer nodes that keep route geographically tight.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Variance of distances as compactness measure\n    distances_to_all = distance_matrix[feasible, :]\n    variance = np.var(distances_to_all, axis=1)\n    \n    d_current = distance_matrix[current_node, feasible]\n    scores = d_current + 0.5 * variance\n    \n    return int(feasible[np.argmin(scores)])\n",
  "adaptive_threshold": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Adaptive distance threshold based on remaining capacity.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    median_dist = np.median(distances)\n    \n    capacity_ratio = rest_capacity / (np.sum(demands[unvisited_nodes]) + 1e-9)\n    \n    # High capacity: explore (accept far nodes); Low capacity: exploit (nearby)\n    threshold = median_dist * (0.5 + capacity_ratio)\n    \n    close_nodes = [i for i, d in enumerate(distances) if d <= threshold]\n    if close_nodes:\n        return int(feasible[close_nodes[np.argmin(demands[feasible][close_nodes])]])\n    \n    return int(feasible[np.argmin(distances)])\n",
  "minmax_normalized": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Min-max normalize all factors and combine equally.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_depot = distance_matrix[depot, feasible]\n    demand_vals = demands[feasible]\n    \n    def minmax(x):\n        mn, mx = x.min(), x.max()\n        if mx - mn < 1e-9:\n            return np.zeros_like(x)\n        return (x - mn) / (mx - mn)\n    \n    score = minmax(d_current) + minmax(d_depot) - minmax(demand_vals)\n    return int(feasible[np.argmin(score)])\n",
  "exponential_distance_decay": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Exponentially decay probability with distance.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    distances = distance_matrix[current_node, feasible]\n    mean_dist = np.mean(distances)\n    \n    weights = np.exp(-distances / (mean_dist + 1e-9))\n    probs = weights / np.sum(weights)\n    \n    seed = int(current_node * 1597334677) ^ int(depot * 3812015801)\n    rng = np.random.default_rng(seed % (2**32))\n    \n    return int(rng.choice(feasible, p=probs))\n",
  "remaining_demand_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Consider ratio of node demand to total remaining demand.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    total_remaining = np.sum(demands[unvisited_nodes]) + 1e-9\n    demand_ratios = demands[feasible] / total_remaining\n    \n    distances = distance_matrix[current_node, feasible]\n    dist_norm = distances / (np.mean(distances) + 1e-9)\n    \n    scores = dist_norm - 0.4 * demand_ratios\n    return int(feasible[np.argmin(scores)])\n",
  "bottleneck_avoid": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Avoid nodes that are bottlenecks (far from all others).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    # Minimum distance to any other unvisited node\n    dist_matrix = distance_matrix[np.ix_(feasible, unvisited_nodes)]\n    min_dist_to_others = np.min(dist_matrix, axis=1)\n    \n    d_current = distance_matrix[current_node, feasible]\n    scores = d_current + 0.6 * min_dist_to_others\n    \n    return int(feasible[np.argmin(scores)])\n",
  "petal_algorithm": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Petal-like routing: follow similar depot-distance arcs.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_depot_current = distance_matrix[depot, current_node]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    d_current_nodes = distance_matrix[current_node, feasible]\n    \n    # Prefer nodes at similar distance from depot\n    depot_dist_diff = np.abs(d_depot_nodes - d_depot_current)\n    scores = d_current_nodes + 0.7 * depot_dist_diff\n    \n    return int(feasible[np.argmin(scores)])\n",
  "hybrid_nearest_savings": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Hybrid: 50% nearest neighbor + 50% savings heuristic.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    \n    feasible = [node for node in unvisited_nodes if demands[node] <= rest_capacity]\n    if not feasible:\n        return depot\n    \n    d_current = distance_matrix[current_node, feasible]\n    d_current_depot = distance_matrix[current_node, depot]\n    d_depot_nodes = distance_matrix[depot, feasible]\n    \n    savings = d_current_depot + d_depot_nodes - d_current\n    \n    dist_norm = d_current / (np.mean(d_current) + 1e-9)\n    savings_norm = savings / (np.mean(np.abs(savings)) + 1e-9)\n    \n    scores = 0.5 * dist_norm - 0.5 * savings_norm\n    return int(feasible[np.argmin(scores)])\n",
  "efficiency_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Maximize demand served per unit travel from current node (demand / distance).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = [n for n in unvisited_nodes if demands[n] <= cap]\n    if not feasible:\n        return depot\n\n    d = distance_matrix[current_node, feasible]\n    dem = demands[feasible]\n\n    # Prefer high demand with short travel; protect against zero distance\n    score = dem / (d + 1e-9)\n\n    # Tie-break deterministically toward closer\n    best = np.argmax(score)\n    return int(feasible[int(best)])\n",
  "farthest_from_depot_push": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Push outward early: pick node that is far from depot but still reachable from current (weighted).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = [n for n in unvisited_nodes if demands[n] <= cap]\n    if not feasible:\n        return depot\n\n    d_depot = distance_matrix[depot, feasible]\n    d_cur = distance_matrix[current_node, feasible]\n\n    # Prefer far-from-depot while not too far from current\n    score = 0.7 * d_depot - 0.3 * d_cur\n    return int(feasible[int(np.argmax(score))])\n",
  "capacity_slack_preserver": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Preserve future feasibility: prefer nodes that leave a large remaining slack, with a mild distance term.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = [n for n in unvisited_nodes if demands[n] <= cap]\n    if not feasible:\n        return depot\n\n    dem = demands[feasible]\n    slack = cap - dem\n    d_cur = distance_matrix[current_node, feasible]\n\n    # Larger slack is better; shorter distance is better\n    score = 1.0 * slack - 0.2 * d_cur\n    return int(feasible[int(np.argmax(score))])\n",
  "two_step_lookahead_min_completion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"2-step lookahead: choose i that minimizes (cur->i) + min_{k feasible after i}(i->k) + return-to-depot surrogate.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    feasible_i = [n for n in unvisited_nodes if demands[n] <= cap0]\n    if not feasible_i:\n        return depot\n\n    best_i = None\n    best_cost = float('inf')\n\n    unv = np.asarray(unvisited_nodes, dtype=int)\n\n    for i in feasible_i:\n        cap1 = cap0 - float(demands[i])\n        remaining = unv[unv != i]\n        feasible_k = remaining[demands[remaining] <= cap1]\n\n        base = float(distance_matrix[current_node, i])\n        # Encourage choices that also keep depot return reasonable\n        depot_term = 0.3 * float(distance_matrix[i, depot])\n\n        if len(feasible_k) == 0:\n            cost = base + depot_term\n        else:\n            next_leg = float(np.min(distance_matrix[i, feasible_k]))\n            cost = base + 0.6 * next_leg + depot_term\n\n        if cost < best_cost:\n            best_cost = cost\n            best_i = i\n\n    return int(best_i) if best_i is not None else depot\n",
  "local_density_attractor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prefer nodes in dense areas: minimize distance-to-current plus average distance to a few nearest unvisited neighbors.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = [n for n in unv if demands[n] <= cap]\n    if not feasible:\n        return depot\n\n    k = min(5, len(unv))\n    scores = []\n\n    for n in feasible:\n        d_cur = float(distance_matrix[current_node, n])\n        # Density proxy: mean distance from n to its k nearest unvisited (including feasible/non-feasible)\n        d_to_unv = distance_matrix[n, unv]\n        nearest = np.partition(d_to_unv, k - 1)[:k]\n        density = float(np.mean(nearest))\n        scores.append(d_cur + 0.8 * density)\n\n    return int(feasible[int(np.argmin(scores))])\n",
  "softmax_cost_temperature": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Stochastic softmax over a composite cost with adaptive temperature (more greedy when capacity is tight).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem = demands[feasible]\n\n    # Composite cost: travel + mild depot pull - mild demand reward\n    cost = d_cur + 0.25 * d_dep - 0.15 * dem\n\n    # Temperature: smaller when cap is small => greedier\n    cap_scale = max(cap, 1e-9)\n    temp = 0.3 + 1.5 * (cap_scale / (cap_scale + np.mean(dem) + 1e-9))\n\n    # Softmax over negative cost\n    x = -(cost - np.min(cost)) / max(temp, 1e-9)\n    w = np.exp(x - np.max(x))\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (int(current_node) * 1000003) ^ (int(len(unvisited_nodes)) * 9176) ^ (int(cap_scale * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n\n    return int(rng.choice(feasible, p=p))\n",
  "adaptive_weighted_mix": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Adaptive weights: when capacity is high, favor proximity; when low, favor demand-fit and depot pull.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem = demands[feasible]\n\n    # Normalize helpers\n    def z(x):\n        x = np.asarray(x, dtype=float)\n        return (x - np.mean(x)) / (np.std(x) + 1e-9)\n\n    # Capacity tightness in [0,1] (approx)\n    tight = 1.0 / (1.0 + cap)\n    w_dist = 0.7 * (1.0 - tight)\n    w_depot = 0.2 + 0.4 * tight\n    w_dem = 0.3 + 0.5 * tight\n\n    score = w_dist * z(d_cur) + w_depot * z(d_dep) - w_dem * z(dem)\n    return int(feasible[int(np.argmin(score))])\n",
  "triangle_consistency_min": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prefer geometrically consistent steps: minimize |(cur->depot) - (cur->n + n->depot)| (near-shortest detour to depot).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible]\n    d_nd = distance_matrix[feasible, depot]\n\n    # If visiting n keeps the path toward depot nearly shortest, this detour measure is small\n    detour_gap = np.abs(d_cd - (d_cn + d_nd))\n\n    # Secondary: prefer closer to current\n    score = detour_gap + 0.15 * d_cn\n    return int(feasible[int(np.argmin(score))])\n",
  "k_regret_distance_to_depot": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"k-regret variant: pick node whose best-vs-kth best (by combined cur+depot distance) has largest regret.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Cost proxy for committing to n now: cur->n plus n->depot pull\n    cost = distance_matrix[current_node, feasible] + 0.4 * distance_matrix[feasible, depot]\n\n    if len(feasible) == 1:\n        return int(feasible[0])\n\n    k = min(3, len(feasible))\n    order = np.argsort(cost)\n\n    # Regret defined as kth_best - best\n    regret = float(cost[order[k - 1]] - cost[order[0]])\n\n    # Turn scalar regret into selection: choose the node that is best (order[0]) if regret is small,\n    # otherwise choose the node at order[1] to avoid over-committing (a distinct behavior).\n    if regret < (np.std(cost) + 1e-9):\n        return int(feasible[int(order[0])])\n    return int(feasible[int(order[min(1, len(order) - 1)])])\n",
  "return_risk_aware": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Risk-aware return: penalize choices likely to force an expensive return (cur->n + n->depot), with demand-fit bonus.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible]\n    d_nd = distance_matrix[feasible, depot]\n    dem = demands[feasible]\n\n    # Penalize long \"commitment\" legs; reward consuming a good fraction of remaining capacity\n    frac = dem / (cap + 1e-9)\n    score = (d_cn + 0.9 * d_nd) - 0.6 * frac\n\n    return int(feasible[int(np.argmin(score))])\n",
  "expansion_frontier": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Frontier expansion: prefer nodes that increase the current route radius from depot without a huge step.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n = distance_matrix[depot, feasible]\n    step = distance_matrix[current_node, feasible]\n\n    gain = np.maximum(0.0, r_n - r_cur)\n    score = gain / (step + 1e-9)  # outward gain per travel\n\n    return int(feasible[int(np.argmax(score))])\n",
  "perimeter_then_fill": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Two-phase proxy: early choose far nodes (perimeter), later choose near nodes (fill-in) based on remaining capacity.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_dep = distance_matrix[depot, feasible]\n    d_cur = distance_matrix[current_node, feasible]\n    dem = demands[feasible]\n\n    # Remaining-capacity fraction relative to max demand among remaining (scale-free)\n    frac = cap / (float(np.max(demands[unvisited_nodes])) + 1e-9)\n    frac = float(np.clip(frac, 0.0, 1.0))\n\n    # High frac => perimeter; low frac => fill-in\n    score = (0.8 * frac) * d_dep + (0.2 + 0.6 * (1.0 - frac)) * d_cur - 0.15 * dem\n\n    return int(feasible[int(np.argmin(score))])\n",
  "hub_avoidance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Avoid hubs: penalize nodes that are too central (small mean distance to remaining), to reduce backtracking.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = np.array([n for n in unv if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Centrality proxy: mean distance to remaining unvisited\n    mean_to_unv = distance_matrix[np.ix_(feasible, unv)].mean(axis=1)\n    d_cur = distance_matrix[current_node, feasible]\n\n    # Prefer less-central (larger mean_to_unv) but still not far from current\n    score = d_cur - 0.6 * mean_to_unv\n    return int(feasible[int(np.argmin(score))])\n",
  "isolation_rescue": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Rescue isolated customers: prioritize nodes whose nearest neighbor among remaining is far (\"lonely\" nodes).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = np.array([n for n in unv if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # For each feasible node, compute distance to its nearest OTHER unvisited node\n    dist_to_unv = distance_matrix[np.ix_(feasible, unv)]\n    # Mask self if present\n    for i, n in enumerate(feasible):\n        same = np.where(unv == n)[0]\n        if len(same) > 0:\n            dist_to_unv[i, same[0]] = np.inf\n\n    nearest_other = np.min(dist_to_unv, axis=1)\n    d_cur = distance_matrix[current_node, feasible]\n\n    # High nearest_other => isolated; pull them earlier, with mild distance penalty\n    score = -1.0 * nearest_other + 0.25 * d_cur\n    return int(feasible[int(np.argmin(score))])\n",
  "capacity_bucket_prioritizer": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Capacity bucketing: prefer demands that fit a target fill level (e.g., ~80% utilization) while staying close.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible]\n\n    target_fill = 0.8  # target fraction of remaining capacity to consume\n    fill_frac = dem / (cap + 1e-9)\n    fill_miss = np.abs(fill_frac - target_fill)\n\n    score = 0.7 * fill_miss + 0.3 * (d_cur / (np.mean(d_cur) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "probabilistic_rank_blend": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Stochastic rank blending: sample using blended ranks of (cur distance) and (depot distance) and (demand).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible]\n    d_dep = distance_matrix[depot, feasible]\n    dem = demands[feasible].astype(float)\n\n    # Ranks: smaller distance better; larger demand better\n    r_cur = np.argsort(np.argsort(d_cur)).astype(float)\n    r_dep = np.argsort(np.argsort(d_dep)).astype(float)\n    r_dem = np.argsort(np.argsort(-dem)).astype(float)\n\n    blend = 0.45 * r_cur + 0.35 * r_dep + 0.20 * r_dem\n\n    # Convert to probabilities favoring low blended rank\n    x = -(blend - np.min(blend))\n    w = np.exp(x - np.max(x))\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (int(current_node) * 1315423911) ^ (int(len(unvisited_nodes)) * 2654435761)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=p))\n",
  "myopic_2opt_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Myopic 2-opt proxy: prefer nodes that minimize the larger of (cur->n) and (n->depot) to keep edges balanced.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible]\n    d_nd = distance_matrix[feasible, depot]\n\n    # Balanced-edge criterion (minimize the max edge)\n    score = np.maximum(d_cn, d_nd) + 0.1 * np.minimum(d_cn, d_nd)\n    return int(feasible[int(np.argmin(score))])\n",
  "depot_shadow": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Depot shadowing: pick nodes that keep d(depot,n) close to d(depot,current) (stay on an annulus), reducing zig-zag.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n = distance_matrix[depot, feasible]\n    d_cn = distance_matrix[current_node, feasible]\n\n    annulus = np.abs(r_n - r_cur)\n    score = 0.65 * annulus + 0.35 * d_cn\n    return int(feasible[int(np.argmin(score))])\n",
  "demand_smoothing": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Demand smoothing: avoid extreme demand jumps by targeting demands near the median of remaining feasible.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    target = float(np.median(dem))\n    dem_dev = np.abs(dem - target)\n\n    d_cur = distance_matrix[current_node, feasible]\n    score = 0.6 * dem_dev + 0.4 * (d_cur / (np.mean(d_cur) + 1e-9))\n\n    return int(feasible[int(np.argmin(score))])\n",
  "rare_fit_priority": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Rare-fit priority: prefer nodes whose demand is close to remaining capacity (harder to place later) with distance tie-break.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    closeness = np.abs(cap - dem)  # smaller => rarer fit (nearly fills capacity)\n\n    d_cur = distance_matrix[current_node, feasible]\n    score = 0.8 * (closeness / (np.mean(closeness) + 1e-9)) + 0.2 * (d_cur / (np.mean(d_cur) + 1e-9))\n\n    return int(feasible[int(np.argmin(score))])\n",
  "pareto_front_selector": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Pareto selection on (distance from current, negative demand): pick from non-dominated set, then best insertion cost.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    dem = demands[feasible].astype(float)\n\n    # Non-dominated wrt minimize d_cur and maximize dem\n    nd_mask = np.ones(len(feasible), dtype=bool)\n    for i in range(len(feasible)):\n        if not nd_mask[i]:\n            continue\n        for j in range(len(feasible)):\n            if i == j:\n                continue\n            if (d_cur[j] <= d_cur[i] + 1e-12) and (dem[j] >= dem[i] - 1e-12) and ((d_cur[j] < d_cur[i] - 1e-12) or (dem[j] > dem[i] + 1e-12)):\n                nd_mask[i] = False\n                break\n\n    nd = feasible[nd_mask]\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, nd]\n    d_nd = distance_matrix[nd, depot]\n    ins = d_cn + d_nd - d_cd\n    return int(nd[int(np.argmin(ins))])\n",
  "demand_quantile_gate": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Quantile gating: restrict to top-q demand feasible nodes, then choose nearest among them.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    q = 0.65  # keep upper 35% demands\n    thr = float(np.quantile(dem, q)) if len(dem) > 1 else float(dem[0])\n    cand = feasible[dem >= thr]\n    if len(cand) == 0:\n        cand = feasible\n\n    d = distance_matrix[current_node, cand]\n    return int(cand[int(np.argmin(d))])\n",
  "angle_turn_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Turn-minimizing proxy: penalize sharp \"turns\" using cosine-law angle at current (prev assumed depot).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Approximate previous node as depot for a consistent signature\n    a = float(distance_matrix[depot, current_node])\n    b = distance_matrix[current_node, feasible].astype(float)  # current->n\n    c = distance_matrix[depot, feasible].astype(float)         # depot->n\n\n    # cos(theta) at current for triangle (depot-current-n)\n    cos_theta = (a*a + b*b - c*c) / (2.0 * a * b + 1e-9)\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n    turn_pen = 1.0 - cos_theta  # small when straight-ish\n\n    score = 0.75 * b + 0.25 * (turn_pen * (np.mean(b) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "rarity_by_demand_histogram": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Demand rarity: prefer nodes whose demand falls in a rare bin among unvisited (reduces future packing conflicts).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = np.array([n for n in unv if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem_all = demands[unv].astype(float)\n    dem_f = demands[feasible].astype(float)\n\n    bins = min(8, max(2, int(np.sqrt(len(dem_all))) ))\n    mn, mx = float(np.min(dem_all)), float(np.max(dem_all))\n    if mx - mn < 1e-9:\n        # fallback: nearest\n        return int(feasible[int(np.argmin(distance_matrix[current_node, feasible]))])\n\n    edges = np.linspace(mn, mx + 1e-12, bins + 1)\n    idx_all = np.clip(np.digitize(dem_all, edges) - 1, 0, bins - 1)\n    counts = np.bincount(idx_all, minlength=bins).astype(float)\n\n    idx_f = np.clip(np.digitize(dem_f, edges) - 1, 0, bins - 1)\n    rarity = 1.0 / (counts[idx_f] + 1e-9)  # higher => rarer\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    score = -1.0 * rarity + 0.2 * (d_cur / (np.mean(d_cur) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "minimax_edge_guard": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimax guard: minimize the worst of (cur->n) and (n->nearest unvisited) to avoid dead-ends.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = np.array([n for n in unv if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Precompute nearest neighbor distance among unvisited for each feasible node\n    dist_fu = distance_matrix[np.ix_(feasible, unv)].astype(float)\n    for i, n in enumerate(feasible):\n        same = np.where(unv == n)[0]\n        if len(same) > 0:\n            dist_fu[i, same[0]] = np.inf\n    nn = np.min(dist_fu, axis=1)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    score = np.maximum(d_cn, nn) + 0.05 * (d_cn + nn)\n    return int(feasible[int(np.argmin(score))])\n",
  "route_endurance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Endurance heuristic: pick node that maximizes remaining capacity *after* accounting for return distance pressure.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap0], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    cap_after = cap0 - dem\n\n    d_nd = distance_matrix[feasible, depot].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # Higher is better: capacity left minus distance pressure\n    endurance = cap_after - 0.25 * (d_cn + d_nd)\n    return int(feasible[int(np.argmax(endurance))])\n",
  "local_prize_collecting": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Prize-collecting proxy: treat demand as prize and distance as cost; pick max (prize - lambda*cost).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    # lambda adapts: tighter capacity => higher emphasis on prize\n    lam = 0.6 / (cap + 1.0)\n    utility = dem - lam * d_cn\n    return int(feasible[int(np.argmax(utility))])\n",
  "anti_greedy_shake": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Anti-greedy shake: pick the 2nd-best by distance with small probability to diversify, else best.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d = distance_matrix[current_node, feasible].astype(float)\n    order = np.argsort(d)\n    best = int(order[0])\n    if len(order) == 1:\n        return int(feasible[best])\n\n    second = int(order[1])\n\n    seed = (int(current_node) * 374761393) ^ (int(len(unvisited_nodes)) * 668265263) ^ (int(cap * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n\n    # More shaking when far from depot (proxy for being in outer region)\n    p = float(np.clip(distance_matrix[current_node, depot] / (np.mean(distance_matrix[depot, feasible]) + 1e-9), 0.05, 0.35))\n    return int(feasible[second]) if rng.random() < p else int(feasible[best])\n",
  "expected_future_feasibility": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Expected feasibility: choose node maximizing the fraction of remaining nodes that would stay feasible after serving it.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = np.array([n for n in unv if demands[n] <= cap0], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    best_n = None\n    best_score = -1e18\n\n    for n in feasible:\n        cap1 = cap0 - float(demands[n])\n        remaining = unv[unv != n]\n        if len(remaining) == 0:\n            feas_frac = 1.0\n        else:\n            feas_frac = float(np.mean(demands[remaining] <= cap1))\n\n        # Slight distance penalty so it doesn't ignore geometry\n        score = feas_frac - 0.02 * float(distance_matrix[current_node, n])\n        if score > best_score:\n            best_score = score\n            best_n = n\n\n    return int(best_n) if best_n is not None else depot\n",
  "closest_feasible_by_ranked_ring": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Ring-based selection: restrict to nodes whose depot-distance rank is closest to current's depot-distance rank, then nearest.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    r_all = distance_matrix[depot, unv].astype(float)\n    order = np.argsort(r_all)\n    rank = np.empty_like(order)\n    rank[order] = np.arange(len(order))\n\n    # rank of current among unvisited radii (if current is depot, put middle)\n    if current_node == depot:\n        cur_rank = len(unv) // 2\n    else:\n        # approximate by inserting current radius into distribution\n        cur_r = float(distance_matrix[depot, current_node])\n        cur_rank = int(np.searchsorted(np.sort(r_all), cur_r))\n\n    feasible_ranks = rank[np.searchsorted(unv, feasible, sorter=np.argsort(unv))]\n    # above line is tricky; use a safer mapping\n    idx_map = {int(n): i for i, n in enumerate(unv.tolist())}\n    feasible_ranks = np.array([rank[idx_map[int(n)]] for n in feasible], dtype=float)\n\n    ring_gap = np.abs(feasible_ranks - float(cur_rank))\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    score = 0.7 * ring_gap + 0.3 * (d_cur / (np.mean(d_cur) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "min_expected_added_cost_via_nearest_next": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Approximate expected added cost: cur->i + E[min(i->k)] over feasible k after i + i->depot term.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap0 = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible_i = unv[demands[unv] <= cap0]\n    if len(feasible_i) == 0:\n        return depot\n\n    best_i, best = None, float('inf')\n    for i in feasible_i:\n        cap1 = cap0 - float(demands[i])\n        rem = unv[unv != i]\n        feasible_k = rem[demands[rem] <= cap1]\n\n        base = float(distance_matrix[current_node, i])\n        ret = 0.35 * float(distance_matrix[i, depot])\n\n        if len(feasible_k) == 0:\n            exp_next = 0.0\n        else:\n            # expectation proxy: average of the 3 nearest distances\n            di = distance_matrix[i, feasible_k].astype(float)\n            m = min(3, len(di))\n            exp_next = float(np.mean(np.partition(di, m - 1)[:m]))\n\n        cost = base + 0.6 * exp_next + ret\n        if cost < best:\n            best = cost\n            best_i = int(i)\n\n    return int(best_i) if best_i is not None else depot\n",
  "demand_to_depot_ratio": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Maximize demand per depot distance (preference for 'valuable' far customers) with mild current-distance penalty.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_dep = distance_matrix[depot, feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    score = dem / (d_dep + 1e-9) - 0.1 * (d_cur / (np.mean(d_cur) + 1e-9))\n    return int(feasible[int(np.argmax(score))])\n",
  "nearest_with_capacity_guardband": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Nearest neighbor but enforce a guardband: avoid consuming more than a set fraction of remaining capacity unless forced.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    guard = 0.75 * cap\n    small = feasible[demands[feasible] <= guard]\n    cand = small if len(small) > 0 else feasible\n\n    d = distance_matrix[current_node, cand].astype(float)\n    return int(cand[int(np.argmin(d))])\n",
  "median_direction_pull": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Pull toward the median unvisited node (in distance-space): pick node minimizing |d(n,median)-d(current,median)| + d(current,n).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # choose a 'median' node by depot distance\n    r = distance_matrix[depot, unv].astype(float)\n    med = int(unv[int(np.argsort(r)[len(r)//2])])\n\n    d_nm = distance_matrix[feasible, med].astype(float)\n    d_cm = float(distance_matrix[current_node, med])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    score = np.abs(d_nm - d_cm) + 0.5 * d_cn\n    return int(feasible[int(np.argmin(score))])\n",
  "entropy_balanced_sampling": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Entropy-balanced sampling: sample from a near-uniform distribution biased slightly toward good insertion costs.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n    ins = d_cn + d_nd - d_cd\n\n    # Flatten probabilities (high entropy): p ~ exp(-ins / T) with large T\n    T = (np.mean(ins) + 1e-9) * 3.0\n    x = -(ins - np.min(ins)) / (T + 1e-9)\n    w = np.exp(x - np.max(x))\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (int(current_node) * 1103515245 + int(len(unvisited_nodes)) * 12345) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(rng.choice(feasible, p=p))\n",
  "balanced_two_anchor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Two-anchor balance: choose node minimizing |d(n,depot) - d(n,current)| plus a distance term (keeps symmetric progression).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_dep = distance_matrix[feasible, depot].astype(float)\n    d_cur = distance_matrix[feasible, current_node].astype(float)\n\n    sym = np.abs(d_dep - d_cur)\n    step = distance_matrix[current_node, feasible].astype(float)\n\n    score = 0.65 * sym + 0.35 * (step / (np.mean(step) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "min_variance_step": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize step variance: prefer nodes whose distances to remaining unvisited have low variance (stable neighborhood).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dist_fu = distance_matrix[np.ix_(feasible, unv)].astype(float)\n    var = np.var(dist_fu, axis=1)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    score = 0.55 * (d_cn / (np.mean(d_cn) + 1e-9)) + 0.45 * (var / (np.mean(var) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "depot_return_deadline": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Return deadline: if far from depot, bias toward nodes that move closer to depot; otherwise nearest.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    # If current is \"far\", prefer decreasing depot distance\n    far = d_cd > float(np.median(distance_matrix[depot, feasible]))\n    if far:\n        score = d_nd + 0.3 * d_cn\n    else:\n        score = d_cn\n\n    return int(feasible[int(np.argmin(score))])\n",
  "kmedoids_proxy": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"k-medoids proxy (k=2): pick the medoid among feasible that best represents remaining unvisited, then go toward it.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # choose 2 candidate medoids among feasible: closest-to-depot and farthest-from-depot\n    d_dep_f = distance_matrix[depot, feasible].astype(float)\n    m1 = int(feasible[int(np.argmin(d_dep_f))])\n    m2 = int(feasible[int(np.argmax(d_dep_f))])\n\n    # assign unvisited to nearest medoid and compute total cost\n    d1 = distance_matrix[unv, m1].astype(float)\n    d2 = distance_matrix[unv, m2].astype(float)\n    cost1 = float(np.sum(np.minimum(d1, d2)))\n\n    target = m1 if cost1 <= cost1 else m2  # deterministic; placeholder but stable\n    # move toward chosen medoid: select feasible node closest to target\n    d_to_target = distance_matrix[feasible, target].astype(float)\n    return int(feasible[int(np.argmin(d_to_target))])\n",
  "capacity_scaled_insertion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Insertion cost scaled by capacity impact: (ins_cost) * (1 + demand/rest_capacity).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n    ins = d_cn + d_nd - d_cd\n\n    dem = demands[feasible].astype(float)\n    scaled = ins * (1.0 + dem / (cap + 1e-9))\n    return int(feasible[int(np.argmin(scaled))])\n",
  "nearest_neighbor_with_isolation_penalty": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"NN + isolation penalty: avoid stepping into nodes whose nearest unvisited neighbor is far (unless near by).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dist_fu = distance_matrix[np.ix_(feasible, unv)].astype(float)\n    for i, n in enumerate(feasible):\n        same = np.where(unv == n)[0]\n        if len(same) > 0:\n            dist_fu[i, same[0]] = np.inf\n    nn = np.min(dist_fu, axis=1)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    score = d_cn + 0.4 * nn\n    return int(feasible[int(np.argmin(score))])\n",
  "lexicographic_demand_then_distance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Lexicographic: first maximize demand, then minimize distance (stable deterministic).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    max_dem = float(np.max(dem))\n    cand = feasible[dem >= max_dem - 1e-12]\n\n    d = distance_matrix[current_node, cand].astype(float)\n    return int(cand[int(np.argmin(d))])\n",
  "closest_to_depot_when_fullness_high": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Fullness-aware: when remaining capacity is small relative to mean demand, pick depot-close nodes; else current-close.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    mean_dem = float(np.mean(demands[unvisited_nodes])) if len(unvisited_nodes) > 0 else 1.0\n    tight = cap < 1.2 * mean_dem\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[depot, feasible].astype(float)\n\n    score = (0.2 * d_cn + 0.8 * d_nd) if tight else (0.9 * d_cn + 0.1 * d_nd)\n    return int(feasible[int(np.argmin(score))])\n",
  "capacity_splitter_low_high": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Split demands into low/high relative to median; alternate preference based on parity of current node id.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    med = float(np.median(dem))\n    low = feasible[dem <= med]\n    high = feasible[dem > med]\n\n    prefer_high = (int(current_node) % 2 == 0)\n    cand = high if (prefer_high and len(high) > 0) else (low if len(low) > 0 else feasible)\n\n    d = distance_matrix[current_node, cand].astype(float)\n    return int(cand[int(np.argmin(d))])\n",
  "min_cross_distance_to_route": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Cross-distance minimization: pick node that is simultaneously close to current and not too far from depot (min of max).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[depot, feasible].astype(float)\n\n    score = np.maximum(d_cn, d_nd) + 0.1 * (d_cn + d_nd)\n    return int(feasible[int(np.argmin(score))])\n",
  "ranked_borda_count": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Borda count over three criteria: (cur distance asc), (depot distance asc), (demand desc).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n    d_dep = distance_matrix[depot, feasible].astype(float)\n    dem = demands[feasible].astype(float)\n\n    n = len(feasible)\n    r1 = np.argsort(np.argsort(d_cur))\n    r2 = np.argsort(np.argsort(d_dep))\n    r3 = np.argsort(np.argsort(-dem))\n\n    # Borda: higher points for better rank (lower rank index)\n    points = (n - 1 - r1) + (n - 1 - r2) + (n - 1 - r3)\n    return int(feasible[int(np.argmax(points))])\n",
  "max_margin_to_capacity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Max margin: prefer very small demands when capacity is tight (leave flexibility), else nearest.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    tight = cap < float(np.median(demands[unvisited_nodes]))\n    if tight:\n        score = 0.8 * (dem / (np.mean(dem) + 1e-9)) + 0.2 * (d_cn / (np.mean(d_cn) + 1e-9))\n    else:\n        score = d_cn\n\n    return int(feasible[int(np.argmin(score))])\n",
  "short_edge_preferential_attachment": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Preferential attachment on short edges: probability proportional to 1/(distance^2) among feasible.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d = distance_matrix[current_node, feasible].astype(float)\n    w = 1.0 / (d * d + 1e-9)\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (int(current_node) * 97531 + int(len(unvisited_nodes)) * 864197523) & 0xFFFFFFFF\n    rng = np.random.default_rng(seed)\n    return int(rng.choice(feasible, p=p))\n",
  "late_route_closure_bias": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Closure bias: when few feasible remain, bias toward minimizing return distance; else minimize current distance.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    # fewer feasible => close route\n    t = 1.0 / (len(feasible) + 1.0)\n    score = (1.0 - t) * d_cn + t * d_nd\n    return int(feasible[int(np.argmin(score))])\n",
  "pseudo_sweep_by_distance_order": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Pseudo-sweep without coordinates: follow the circular order induced by sorting by depot distance and stepping forward.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # order by depot distance\n    r = distance_matrix[depot, unv].astype(float)\n    ord_nodes = unv[np.argsort(r)]\n\n    # find nearest position for current radius and take next feasible in that direction\n    cur_r = float(distance_matrix[depot, current_node])\n    pos = int(np.searchsorted(np.sort(r), cur_r))\n\n    # scan forward then backward for a feasible node\n    ord_list = ord_nodes.tolist()\n    feas_set = set(map(int, feasible.tolist()))\n\n    for step in range(len(ord_list)):\n        idx = (pos + step) % len(ord_list)\n        cand = int(ord_list[idx])\n        if cand in feas_set:\n            return cand\n\n    return int(feasible[int(np.argmin(distance_matrix[current_node, feasible]))])\n",
  "knn_barycenter_pull": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"kNN barycenter pull (distance-space): prefer nodes close to the 'barycenter' of remaining via mean distance to k nearest unvisited.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    k = min(7, len(unv))\n    scores = []\n    for n in feasible:\n        d_to_unv = distance_matrix[n, unv].astype(float)\n        nn = np.partition(d_to_unv, k - 1)[:k]\n        bary = float(np.mean(nn))\n        d_cur = float(distance_matrix[current_node, n])\n        scores.append(d_cur + 0.9 * bary)\n    return int(feasible[int(np.argmin(scores))])\n",
  "local_two_cluster_switch": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Two-cluster switch: split feasible by depot distance median; alternate choosing nearer/farther cluster using a hash of state.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    r = distance_matrix[depot, feasible].astype(float)\n    med = float(np.median(r))\n    near = feasible[r <= med]\n    far = feasible[r > med]\n\n    flip = ((int(current_node) * 31 + int(len(unvisited_nodes)) * 17) & 1) == 0\n    cand = far if (flip and len(far) > 0) else (near if len(near) > 0 else feasible)\n\n    d = distance_matrix[current_node, cand].astype(float)\n    return int(cand[int(np.argmin(d))])\n",
  "demand_similarity_chain": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Demand-similarity chain: keep demands smooth by targeting demands close to last served (current node's demand), with distance tie-break.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    target = float(demands[current_node]) if current_node != depot else float(np.median(demands[feasible]))\n    dem = demands[feasible].astype(float)\n    d_cur = distance_matrix[current_node, feasible].astype(float)\n\n    score = 0.7 * np.abs(dem - target) + 0.3 * (d_cur / (np.mean(d_cur) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "min_radial_detour": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Radial detour: minimize |(depot->n) - (depot->current)| while also keeping cur->n small (annulus-following).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    r_cur = float(distance_matrix[depot, current_node])\n    r_n = distance_matrix[depot, feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    score = 0.6 * np.abs(r_n - r_cur) + 0.4 * (d_cn / (np.mean(d_cn) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "max_depot_progress": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Max depot progress: prefer nodes that most reduce depot distance (move inward) per unit step when far from depot.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    r_cur = float(distance_matrix[current_node, depot])\n    r_n = distance_matrix[feasible, depot].astype(float)\n    step = distance_matrix[current_node, feasible].astype(float)\n\n    improvement = np.maximum(0.0, r_cur - r_n)\n    score = improvement / (step + 1e-9)\n\n    # If not far, fallback to nearest\n    if r_cur < float(np.median(distance_matrix[depot, feasible])):\n        return int(feasible[int(np.argmin(step))])\n    return int(feasible[int(np.argmax(score))])\n",
  "min_travel_plus_spread": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Travel+spread: minimize cur->n plus mean distance from n to remaining unvisited (avoid spread-out moves).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    mean_to_unv = distance_matrix[np.ix_(feasible, unv)].astype(float).mean(axis=1)\n\n    score = d_cn + 0.5 * mean_to_unv\n    return int(feasible[int(np.argmin(score))])\n",
  "min_return_edge_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize max edge among (cur->n, n->depot, cur->depot) to keep route edges balanced.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    score = np.maximum.reduce([d_cn, d_nd, np.full_like(d_cn, d_cd)])\n    return int(feasible[int(np.argmin(score))])\n",
  "max_min_distance_separation": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Max-min separation: choose a node that is far from already-nearby candidates (diversify), while not too far from current.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    # Define a local neighborhood around current (closest m unvisited)\n    m = min(8, len(unv))\n    d_cur_all = distance_matrix[current_node, unv].astype(float)\n    neigh = unv[np.argsort(d_cur_all)[:m]]\n\n    # For each feasible node, maximize its minimum distance to this neighborhood (spread), with step penalty\n    dist_to_neigh = distance_matrix[np.ix_(feasible, neigh)].astype(float)\n    min_to_neigh = np.min(dist_to_neigh, axis=1)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    score = min_to_neigh - 0.3 * d_cn\n    return int(feasible[int(np.argmax(score))])\n",
  "capacity_fraction_targeting_dynamic": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Dynamic capacity fraction targeting: target demand fraction depends on how many unvisited remain.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    # Early => larger chunks; late => smaller chunks\n    frac_target = 0.85 - 0.4 * (1.0 / (len(unvisited_nodes) + 1.0))\n\n    dem = demands[feasible].astype(float)\n    frac = dem / (cap + 1e-9)\n    miss = np.abs(frac - frac_target)\n\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    score = 0.75 * miss + 0.25 * (d_cn / (np.mean(d_cn) + 1e-9))\n    return int(feasible[int(np.argmin(score))])\n",
  "edge_triangle_slack_max": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Maximize triangle slack: pick node maximizing (cur->n + n->depot - cur->depot) negative slack (i.e., most shortcut-like).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n    d_nd = distance_matrix[feasible, depot].astype(float)\n\n    detour = d_cn + d_nd - d_cd\n    # Prefer smallest detour (most negative slack is impossible in metric, but smallest is best)\n    return int(feasible[int(np.argmin(detour))])\n",
  "max_compact_cluster_gain": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Compact cluster gain: prefer nodes whose selection keeps remaining feasible tightly clustered (minimizes mean pairwise distance after removal).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap0 = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap0]\n    if len(feasible) == 0:\n        return depot\n\n    # Baseline compactness of feasible set\n    base = float(np.mean(distance_matrix[np.ix_(feasible, feasible)])) if len(feasible) > 1 else 0.0\n\n    best_n, best = None, float('inf')\n    for n in feasible:\n        rem = feasible[feasible != n]\n        if len(rem) <= 1:\n            comp = 0.0\n        else:\n            comp = float(np.mean(distance_matrix[np.ix_(rem, rem)]))\n        # objective: keep compactness low + keep step short\n        step = float(distance_matrix[current_node, n])\n        obj = comp + 0.15 * step + 0.05 * base\n        if obj < best:\n            best = obj\n            best_n = int(n)\n\n    return int(best_n) if best_n is not None else depot\n",
  "nearest_with_demand_floor": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Demand floor: ignore tiny demands early (below 20th percentile) to avoid fragmentation; otherwise nearest.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dem_all = demands[feasible].astype(float)\n    floor = float(np.quantile(dem_all, 0.2)) if len(dem_all) > 1 else float(dem_all[0])\n\n    filtered = feasible[demands[feasible] >= floor]\n    cand = filtered if len(filtered) > 0 else feasible\n\n    d = distance_matrix[current_node, cand].astype(float)\n    return int(cand[int(np.argmin(d))])\n",
  "randomized_topk_insertion": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Randomized top-k by insertion cost: sample uniformly from the best k insertion-cost candidates (deterministic seed).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    ins = distance_matrix[current_node, feasible].astype(float) + distance_matrix[feasible, depot].astype(float) - d_cd\n\n    k = min(5, len(feasible))\n    idx = np.argsort(ins)[:k]\n    cand = feasible[idx]\n\n    seed = (int(current_node) * 2654435761) ^ (int(len(unvisited_nodes)) * 2246822519) ^ (int(cap * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(cand))\n",
  "boltzmann_utility_demand_minus_cost": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Boltzmann utility: sample with probability ~ exp((demand - alpha*distance)/T).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    dem = demands[feasible].astype(float)\n    d = distance_matrix[current_node, feasible].astype(float)\n\n    alpha = 0.8\n    util = dem - alpha * d\n\n    T = (np.std(util) + 1e-9) * 1.5 + 1e-9\n    x = (util - np.max(util)) / T\n    w = np.exp(x)\n    p = w / (np.sum(w) + 1e-12)\n\n    seed = (int(current_node) * 73856093) ^ (int(len(unvisited_nodes)) * 19349663)\n    rng = np.random.default_rng(seed % (2**32))\n    return int(rng.choice(feasible, p=p))\n",
  "gated_isolation_then_nearest": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Isolation gate: if there exists a very isolated feasible node (nearest-neighbor distance above 80th percentile), take it; else nearest.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    dist_fu = distance_matrix[np.ix_(feasible, unv)].astype(float)\n    for i, n in enumerate(feasible):\n        same = np.where(unv == n)[0]\n        if len(same) > 0:\n            dist_fu[i, same[0]] = np.inf\n    nn = np.min(dist_fu, axis=1)\n\n    if len(nn) > 1:\n        thr = float(np.quantile(nn, 0.8))\n        iso = feasible[nn >= thr]\n        if len(iso) > 0:\n            d_iso = distance_matrix[current_node, iso].astype(float)\n            return int(iso[int(np.argmin(d_iso))])\n\n    d = distance_matrix[current_node, feasible].astype(float)\n    return int(feasible[int(np.argmin(d))])\n",
  "min_weighted_harmonic_distances": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Harmonic distance blend: minimize harmonic mean of distances to (current, depot) (penalizes being far from either).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d1 = distance_matrix[current_node, feasible].astype(float)\n    d2 = distance_matrix[depot, feasible].astype(float)\n\n    harm = 2.0 / (1.0 / (d1 + 1e-9) + 1.0 / (d2 + 1e-9))\n    return int(feasible[int(np.argmin(harm))])\n",
  "soft_regret_on_two_criteria": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Soft regret: compute regret on combined cost (cur distance + beta*depot distance) among feasible; pick max regret node.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    beta = 0.45\n    cost = distance_matrix[current_node, feasible].astype(float) + beta * distance_matrix[depot, feasible].astype(float)\n    if len(feasible) == 1:\n        return int(feasible[0])\n\n    ord_idx = np.argsort(cost)\n    best = float(cost[ord_idx[0]])\n    kth = float(cost[ord_idx[min(2, len(ord_idx)-1)]])\n    regret = kth - best\n\n    # map scalar regret to choice: if regret large, take the top candidate; else take the median candidate (diversify)\n    if regret > (np.std(cost) + 1e-9):\n        return int(feasible[int(ord_idx[0])])\n    return int(feasible[int(ord_idx[len(ord_idx)//2])])\n",
  "min_cost_per_remaining_capacity": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Minimize travel cost per remaining capacity after service: (cur->n) / (cap - demand).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap - 1e-12], dtype=int)\n    if len(feasible) == 0:\n        # if only exact-fill nodes exist, choose nearest exact-fill\n        feasible2 = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n        if len(feasible2) == 0:\n            return depot\n        d = distance_matrix[current_node, feasible2].astype(float)\n        return int(feasible2[int(np.argmin(d))])\n\n    dem = demands[feasible].astype(float)\n    d = distance_matrix[current_node, feasible].astype(float)\n    rem = (cap - dem) + 1e-9\n\n    score = d / rem\n    return int(feasible[int(np.argmin(score))])\n",
  "max_neighborhood_demand_density": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Neighborhood demand density: maximize sum(demands of k nearest unvisited to n)/avg distance (dense high-demand pockets).\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    unv = np.asarray(unvisited_nodes, dtype=int)\n    feasible = unv[demands[unv] <= cap]\n    if len(feasible) == 0:\n        return depot\n\n    k = min(6, len(unv))\n    best_n, best = None, -1e18\n    for n in feasible:\n        d_to_unv = distance_matrix[n, unv].astype(float)\n        idx = np.argsort(d_to_unv)[:k]\n        neigh = unv[idx]\n        dem_sum = float(np.sum(demands[neigh]))\n        avg_d = float(np.mean(d_to_unv[idx]))\n        val = dem_sum / (avg_d + 1e-9) - 0.1 * float(distance_matrix[current_node, n])\n        if val > best:\n            best = val\n            best_n = int(n)\n\n    return int(best_n) if best_n is not None else depot\n",
  "anti_depot_bias_when_far": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Anti-depot bias when far: if current is far from depot, avoid picking depot-near nodes (stay out); else pick depot-near.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d_cd = float(distance_matrix[current_node, depot])\n    d_nd = distance_matrix[depot, feasible].astype(float)\n    d_cn = distance_matrix[current_node, feasible].astype(float)\n\n    far = d_cd > float(np.median(d_nd))\n    if far:\n        score = 0.7 * (-d_nd) + 0.3 * (-d_cn)  # maximize both distances (stay out)\n        return int(feasible[int(np.argmax(score))])\n    else:\n        score = 0.7 * d_nd + 0.3 * d_cn\n        return int(feasible[int(np.argmin(score))])\n",
  "stochastic_threshold_acceptance": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n    \"\"\"Threshold acceptance: pick the first feasible in a random scan whose distance is within (1+eps) of the best distance.\"\"\"\n    if len(unvisited_nodes) == 0:\n        return depot\n\n    cap = float(rest_capacity)\n    feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n    if len(feasible) == 0:\n        return depot\n\n    d = distance_matrix[current_node, feasible].astype(float)\n    best = float(np.min(d))\n\n    eps = 0.15  # acceptance band\n    seed = (int(current_node) * 2166136261) ^ (int(len(unvisited_nodes)) * 16777619) ^ (int(cap * 1000) & 0xFFFFFFFF)\n    rng = np.random.default_rng(seed % (2**32))\n\n    perm = rng.permutation(len(feasible))\n    for idx in perm:\n        if float(d[idx]) <= best * (1.0 + eps):\n            return int(feasible[int(idx)])\n\n    return int(feasible[int(np.argmin(d))])\n"
}





