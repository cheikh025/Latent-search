{
  "min_incremental_cost_global": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose the (facility, location) pair with minimum incremental cost vs already-assigned facilities.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            d = delta(int(f), int(l))\n            if d < best:\n                best, best_f, best_l = d, int(f), int(l)\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "max_flow_to_assigned_best_location": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility with largest interaction to already-placed facilities; place it in its best free location.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    if ass.size:\n        w = (flow_matrix[np.ix_(un, ass)].sum(axis=1) + flow_matrix[np.ix_(ass, un)].sum(axis=0)).astype(float)\n    else:\n        w = (flow_matrix[un].sum(axis=1) + flow_matrix[:, un].sum(axis=0)).astype(float)\n\n    f = int(un[int(np.argmax(w))])\n\n    def delta(l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_l = int(free[int(np.argmin([delta(int(l)) for l in free]))])\n    out = list(current_assignment)\n    out[f] = best_l\n    return out\n",
  "max_total_flow_best_location": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick the globally highest-flow facility remaining; place in the best free location (incremental).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    f = int(un[int(np.argmax(tot[un]))])\n\n    if ass.size == 0:\n        l = int(free[int(np.argmin(distance_matrix[free].sum(axis=1)))])\n    else:\n        inc = []\n        for loc in free:\n            d = np.sum(flow_matrix[f, ass] * distance_matrix[loc, locs] +\n                       flow_matrix[ass, f] * distance_matrix[locs, loc])\n            inc.append(float(d))\n        l = int(free[int(np.argmin(inc))])\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n",
  "central_location_best_facility": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose a 'central' free location first, then choose the facility that best fits there (incremental).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    # centrality by sum-distance to all locations (smaller is more central)\n    loc_c = distance_matrix[free].sum(axis=1).astype(float)\n    l = int(free[int(np.argmin(loc_c))])\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def delta(f):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_f = int(un[int(np.argmin([delta(int(f)) for f in un]))])\n    out = list(current_assignment)\n    out[best_f] = l\n    return out\n",
  "max_regret_2_insertion": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Regret-2: for each facility compute (2nd best - best) over free locations; assign max-regret facility to its best.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_f, best_l, best_reg = int(un[0]), int(free[0]), -1.0\n    for f in un:\n        costs = np.array([delta(int(f), int(l)) for l in free], dtype=float)\n        if costs.size == 1:\n            reg, lbest = float(\"inf\"), int(free[0])\n        else:\n            idx = np.argsort(costs)\n            reg, lbest = float(costs[idx[1]] - costs[idx[0]]), int(free[int(idx[0])])\n        if reg > best_reg:\n            best_reg, best_f, best_l = reg, int(f), lbest\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "flow_weighted_regret": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Regret-2 weighted by interaction strength (flow to assigned / total flow).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_f, best_l, best_score = int(un[0]), int(free[0]), -1.0\n    for f in un:\n        costs = np.array([delta(int(f), int(l)) for l in free], dtype=float)\n        idx = np.argsort(costs)\n        best = float(costs[idx[0]])\n        second = float(costs[idx[1]]) if costs.size > 1 else best + 1.0\n        regret = second - best\n        strength = float(tot[int(f)]) if tot[int(f)] > 0 else 1.0\n        score = regret * strength\n        if score > best_score:\n            best_score, best_f, best_l = score, int(f), int(free[int(idx[0])])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "minimax_interaction": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Minimax: pick assignment that minimizes the worst single interaction cost to any already-assigned facility.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def worst(f, l):\n        if ass.size == 0:\n            return 0.0\n        c1 = flow_matrix[f, ass] * distance_matrix[l, locs]\n        c2 = flow_matrix[ass, f] * distance_matrix[locs, l]\n        return float(np.max(c1 + c2))\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            w = worst(int(f), int(l))\n            if w < best:\n                best, best_f, best_l = w, int(f), int(l)\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "annealed_softmax_pair_sampling": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Sample a good (facility, location) pair with a temperature that cools as the assignment fills.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    T = max(1e-6, 2.0 * (1.0 - progress) + 0.05)\n\n    pairs = []\n    costs = []\n    for f in un:\n        for l in free:\n            if ass.size == 0:\n                d = 0.0\n            else:\n                d = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                 flow_matrix[ass, f] * distance_matrix[locs, l]))\n            pairs.append((int(f), int(l)))\n            costs.append(d)\n\n    c = np.array(costs, dtype=float)\n    c = c - c.min()  # stabilize\n    p = np.exp(-c / T)\n    p = p / (p.sum() + 1e-12)\n    idx = int(np.random.choice(len(pairs), p=p))\n    f, l = pairs[idx]\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n",
  "randomized_greedy_topk_pairs": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Compute all incremental costs; pick randomly among the top-k best pairs (GRASP-style constructive step).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = []\n    costs = []\n    for f in un:\n        for l in free:\n            if ass.size == 0:\n                d = 0.0\n            else:\n                d = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                 flow_matrix[ass, f] * distance_matrix[locs, l]))\n            pairs.append((int(f), int(l)))\n            costs.append(d)\n\n    c = np.array(costs, dtype=float)\n    k = max(1, int(np.ceil(0.10 * len(pairs))))\n    idxs = np.argsort(c)[:k]\n    pick = int(np.random.choice(idxs))\n    f, l = pairs[pick]\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n",
  "one_step_lookahead_mean_future": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Greedy incremental + cheap future estimate using remaining-flow * mean distance of remaining locations.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    # Precompute remaining facility \"mass\"\n    sym_flow = flow_matrix + flow_matrix.T\n    rem_flow_mass = sym_flow[np.ix_(un, un)].sum(axis=1).astype(float)\n\n    # Meanf: mean distance among remaining free locations\n    if free.size > 1:\n        Dff = distance_matrix[np.ix_(free, free)].astype(float)\n        mean_d = float(Dff.mean())\n    else:\n        mean_d = 0.0\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for idx_f, f in enumerate(un):\n        for l in free:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                   flow_matrix[ass, f] * distance_matrix[locs, l]))\n            future = rem_flow_mass[idx_f] * mean_d\n            score = inc + 0.15 * future\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "linearized_potential_matching": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Match high-flow facilities to low-distance-sum locations using a linearized scalar potential.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    # potentials\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    ql = distance_matrix.sum(axis=1).astype(float)\n    # normalize to comparable scale\n    pf_n = (pf - pf.mean()) / (pf.std() + 1e-12)\n    ql_n = (ql - ql.mean()) / (ql.std() + 1e-12)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc + 0.40 * (pf_n[int(f)] * ql_n[int(l)])\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "spectral_rank_quantile_match": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Rank facilities by leading eigenvector of symmetrized flow; rank locations by closeness; match quantiles.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    # leading eigenvector (symmetric => eigh)\n    vals, vecs = np.linalg.eigh(F)\n    vf = np.abs(vecs[:, int(np.argmax(vals))])\n    vf = (vf - vf.min()) / (vf.max() - vf.min() + 1e-12)\n\n    # location rank: smaller sum-distance => higher rank\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n\n    # pick facility with highest rank among unassigned\n    f = int(un[int(np.argmax(vf[un]))])\n    target = float(vf[f])\n\n    # pick free location with closest centrality rank (quantile match)\n    idx = int(np.argmin(np.abs(cl[free] - target)))\n    l = int(free[idx])\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n",
  "strong_neighbor_attraction": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose facility that most strongly connects to an already-placed facility; place near that facility's location.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    if ass.size == 0:\n        # fall back: high-flow facility to central free location\n        tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(tot[un]))])\n        l = int(free[int(np.argmin(distance_matrix[free].sum(axis=1)))])\n        out = list(current_assignment); out[f] = l\n        return out\n\n    locs = a[ass].astype(int)\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # facility selection by max connection to any assigned facility\n    conn = sym_flow[np.ix_(un, ass)].max(axis=1)\n    f = int(un[int(np.argmax(conn))])\n\n    # choose anchor assigned facility with strongest link\n    j = int(ass[int(np.argmax(sym_flow[f, ass]))])\n    anchor_loc = int(a[j])\n\n    # place in free location closest to anchor_loc\n    l = int(free[int(np.argmin(distance_matrix[free, anchor_loc]))])\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n",
  "vogel_penalty_allocation": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Vogel-style penalties on the incremental cost matrix to choose a high-penalty row/col then allocate its min.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    # Build cost matrix C (rows=unassigned facilities, cols=free locations)\n    C = np.zeros((un.size, free.size), dtype=float)\n    if ass.size:\n        for i, f in enumerate(un):\n            for j, l in enumerate(free):\n                C[i, j] = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                       flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # Row/column penalties = (2nd best - best)\n    row_pen = np.full(un.size, float(\"inf\"))\n    for i in range(un.size):\n        r = np.sort(C[i])\n        row_pen[i] = float(r[1] - r[0]) if r.size > 1 else float(\"inf\")\n\n    col_pen = np.full(free.size, float(\"inf\"))\n    for j in range(free.size):\n        c = np.sort(C[:, j])\n        col_pen[j] = float(c[1] - c[0]) if c.size > 1 else float(\"inf\")\n\n    if float(row_pen.max()) >= float(col_pen.max()):\n        i = int(np.argmax(row_pen))\n        j = int(np.argmin(C[i]))\n    else:\n        j = int(np.argmax(col_pen))\n        i = int(np.argmin(C[:, j]))\n\n    f = int(un[i]); l = int(free[j])\n    out = list(current_assignment); out[f] = l\n    return out\n",
  "adaptive_candidate_sampling": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Speed/quality tradeoff: sample candidates by facility flow and location centrality, then pick best incremental.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    # sample sizes adapt with progress\n    kf = max(2, int(np.ceil((0.25 + 0.50 * (1.0 - progress)) * un.size)))\n    kl = max(2, int(np.ceil((0.25 + 0.50 * (1.0 - progress)) * free.size)))\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    top_f = un[np.argsort(-pf[un])[:min(kf, un.size)]]\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    top_l = free[np.argsort(-cl[free])[:min(kl, free.size)]]\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l, best = int(top_f[0]), int(top_l[0]), float(\"inf\")\n    for f in top_f:\n        for l in top_l:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best, best_f, best_l = inc, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "entropy_uncertainty_then_best": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick the facility with highest placement-entropy over free locations, then place it at its best location.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def deltas_for_f(f):\n        if ass.size == 0:\n            return np.zeros(free.size, dtype=float)\n        return np.array([np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                flow_matrix[ass, f] * distance_matrix[locs, l]) for l in free], dtype=float)\n\n    best_f, best_l, best_H = int(un[0]), int(free[0]), -1.0\n    for f in un:\n        c = deltas_for_f(int(f))\n        c = c - c.min()\n        p = np.exp(-c / (c.std() + 1e-6))\n        p = p / (p.sum() + 1e-12)\n        H = float(-np.sum(p * np.log(p + 1e-12)))\n        if H > best_H:\n            best_H, best_f = H, int(f)\n            best_l = int(free[int(np.argmin(c))])\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "zscore_blended_scoring": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Compute all incremental costs, z-score them, then blend with facility-flow and location-centrality z-scores.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf_z = (pf - pf.mean()) / (pf.std() + 1e-12)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl_z = (cl - cl.mean()) / (cl.std() + 1e-12)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = []\n    incs = []\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            pairs.append((int(f), int(l)))\n            incs.append(inc)\n\n    incs = np.array(incs, dtype=float)\n    inc_z = (incs - incs.mean()) / (incs.std() + 1e-12)\n\n    # Want: low incremental (small inc_z), high flow (large pf_z), central location (large cl_z)\n    score = inc_z - 0.25 * pf_z[[p[0] for p in pairs]] - 0.25 * cl_z[[p[1] for p in pairs]]\n\n    idx = int(np.argmin(score))\n    f, l = pairs[idx]\n\n    out = list(current_assignment); out[f] = l\n    return out\n",
  "potential_balance_gap": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Minimize incremental cost + penalty for mismatch between facility flow-potential and location centrality.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n    lam = 0.35\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc + lam * abs(pf[int(f)] - cl[int(l)]) * (abs(inc) + 1.0)\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "deterministic_hash_tiebreak_min_inc": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Greedy min incremental; break close ties deterministically using a hash of the partial assignment.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    # simple stable hash\n    h = int(np.sum((np.arange(n) + 1) * (a + 2)))\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            # small deterministic noise in [0,1)\n            noise = ((h ^ (int(f) * 1315423911) ^ (int(l) * 2654435761)) & 0xffffffff) / 2**32\n            score = inc + 1e-6 * noise\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "two_swap_improvement_if_complete": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''If incomplete: greedy min incremental. If complete: perform best improving 2-swap (local search step).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n\n    def total_cost(arr):\n        idx = np.arange(n)\n        L = arr.astype(int)\n        return float(np.sum(flow_matrix[np.ix_(idx, idx)] * distance_matrix[np.ix_(L, L)]))\n\n    if un.size == 0:\n        best = total_cost(a)\n        best_arr = a.copy()\n        for i in range(n):\n            for j in range(i + 1, n):\n                b = a.copy()\n                b[i], b[j] = b[j], b[i]\n                c = total_cost(b)\n                if c < best:\n                    best, best_arr = c, b\n        return best_arr.astype(int).tolist()\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best, best_f, best_l = inc, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "sampled_three_cycle_if_complete": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''If complete: try sampled 3-cycle improvements. If incomplete: max-regret insertion.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n\n    def total_cost(arr):\n        idx = np.arange(n)\n        L = arr.astype(int)\n        return float(np.sum(flow_matrix[np.ix_(idx, idx)] * distance_matrix[np.ix_(L, L)]))\n\n    if un.size == 0:\n        base = total_cost(a)\n        best = base\n        best_arr = a.copy()\n        # sample up to 200 random triples\n        m = min(200, n * (n - 1) * (n - 2) // 6)\n        for _ in range(m):\n            i, j, k = np.random.choice(n, size=3, replace=False)\n            b = a.copy()\n            b[i], b[j], b[k] = a[k], a[i], a[j]  # 3-cycle\n            c = total_cost(b)\n            if c < best:\n                best, best_arr = c, b\n        return best_arr.astype(int).tolist()\n\n    # Otherwise: regret-2 insertion\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_f, best_l, best_reg = int(un[0]), int(free[0]), -1.0\n    for f in un:\n        costs = np.array([delta(int(f), int(l)) for l in free], dtype=float)\n        idx = np.argsort(costs)\n        reg = float(costs[idx[1]] - costs[idx[0]]) if costs.size > 1 else float(\"inf\")\n        if reg > best_reg:\n            best_reg, best_f, best_l = reg, int(f), int(free[int(idx[0])])\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "future_pairwise_top_neighbor_flow": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Incremental cost + future estimate based on strongest unassigned neighbor flows (top-k).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # mean distance among free locations for future approximation\n    mean_d = float(distance_matrix[np.ix_(free, free)].mean()) if free.size > 1 else 0.0\n\n    k = min(5, un.size)  # neighbors\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        # strongest remaining interactions for f\n        nbrs = un[np.argsort(-sym_flow[f, un])[:k]]\n        future_mass = float(sym_flow[f, nbrs].sum())\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc + 0.10 * future_mass * mean_d\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "robust_median_centrality_assignment": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Use robust (median-based) location centrality and facility flow to pick the next placement.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    f = int(un[int(np.argmax(pf[un]))])\n\n    # robust centrality: median distance to all locations (smaller => more central)\n    med = np.median(distance_matrix[free], axis=1).astype(float)\n    l0 = int(free[int(np.argmin(med))])\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    if ass.size == 0:\n        l = l0\n    else:\n        # choose between a few most-central free locations by true incremental cost\n        cand = free[np.argsort(med)[:min(6, free.size)]]\n        best, l = float(\"inf\"), int(cand[0])\n        for loc in cand:\n            inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[loc, locs] +\n                               flow_matrix[ass, f] * distance_matrix[locs, loc]))\n            if inc < best:\n                best, l = inc, int(loc)\n\n    out = list(current_assignment); out[f] = l\n    return out\n",
  "facility_diversity_then_greedy": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Early diversify facility types: pick facility farthest (in flow space) from already assigned; then greedy place.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    progress = 1.0 - (un.size / max(1, n))\n\n    # \"flow feature\" = row+col vector\n    F = (flow_matrix + flow_matrix.T).astype(float)\n\n    if ass.size and progress < 0.6:\n        # choose unassigned facility with largest distance to mean assigned flow-profile\n        mu = F[ass].mean(axis=0)\n        d = np.linalg.norm(F[un] - mu[None, :], axis=1)\n        f = int(un[int(np.argmax(d))])\n    else:\n        tot = F.sum(axis=1)\n        f = int(un[int(np.argmax(tot[un]))])\n\n    locs = a[ass].astype(int)\n\n    best, l = float(\"inf\"), int(free[0])\n    for loc in free:\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[loc, locs] +\n                                                    flow_matrix[ass, f] * distance_matrix[locs, loc]))\n        if inc < best:\n            best, l = inc, int(loc)\n\n    out = list(current_assignment); out[f] = l\n    return out\n",
  "flow_distance_cosine_alignment": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Align facility interaction profile with location distance profile using cosine similarity, then greedily place.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    # facility profile: sym flow row\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    # location profile: inverse distances (closer = larger)\n    G = 1.0 / (distance_matrix.astype(float) + 1e-6)\n\n    # normalize profiles\n    Fz = F / (np.linalg.norm(F, axis=1, keepdims=True) + 1e-12)\n    Gz = G / (np.linalg.norm(G, axis=1, keepdims=True) + 1e-12)\n\n    # pick facility and location pair maximizing alignment minus incremental cost proxy\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l, best = int(un[0]), int(free[0]), -float(\"inf\")\n    for f in un:\n        for l in free:\n            align = float(np.dot(Fz[int(f)], Gz[int(l)]))\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = align - 0.001 * inc\n            if score > best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "min_incremental_cost_pair_cached": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Min incremental cost over all (facility, location) pairs (straight, cache-friendly loops).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l = int(un[0]), int(free[0])\n    best = float('inf')\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                   flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best = inc\n                best_f, best_l = f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "min_incremental_cost_lexicographic": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Min incremental; tie-break by (facility total flow desc, location centrality desc).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l = int(un[0]), int(free[0])\n    best = float('inf')\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best - 1e-12:\n                best = inc\n                best_f, best_l = f, l\n            elif abs(inc - best) <= 1e-12:\n                if (pf[f], cl[l]) > (pf[best_f], cl[best_l]):\n                    best_f, best_l = f, l\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "min_weighted_inc_by_free_dispersion": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Incremental cost weighted by how dispersed the remaining locations are (penalize early mistakes).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used)\n\n    # dispersion among free locations\n    if free.size > 1:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        disp = float(D.std())\n    else:\n        disp = 0.0\n\n    w = 1.0 + 0.35 * (disp / (float(distance_matrix.std()) + 1e-12))\n\n    ass = np.flatnonzero(a != -1)\n    locs = a[ass].astype(int)\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = w * inc\n            if score < best:\n                best = score\n                best_f, best_l = int(f), int(l)\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "max_flow_to_free_then_place": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility with largest total flow to still-unassigned facilities; then place by min incremental to assigned.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n    mass = sym[np.ix_(un, un)].sum(axis=1)\n    f = int(un[int(np.argmax(mass))])\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best_l = int(free[0])\n    best = float('inf')\n    for l in free:\n        l = int(l)\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc\n            best_l = l\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "min_incremental_plus_quadratic_penalty": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Minimize incremental + quadratic penalty for placing high-flow facility far from currently used locations.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if ass.size == 0:\n                far = float(distance_matrix[l].mean())\n            else:\n                far = float(distance_matrix[l, locs].mean())\n            score = inc + 0.20 * pf[f] * (far ** 2)\n            if score < best:\n                best = score\n                best_f, best_l = f, l\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "max_regret_3_insertion": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Regret-3 insertion: (3rd best - best) chooses the facility; assign it to its best location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_score = -1.0\n    best_f = int(un[0])\n    best_l = int(free[0])\n\n    for f in un:\n        costs = np.array([delta(int(f), int(l)) for l in free], dtype=float)\n        idx = np.argsort(costs)\n        best = float(costs[idx[0]])\n        third = float(costs[idx[2]]) if costs.size >= 3 else float(costs[idx[-1]])\n        score = third - best\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[int(idx[0])])\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "max_regret_ratio_insertion": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Regret ratio: (2nd-best / (best+eps)) picks facility; assign to best location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    eps = 1e-9\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_score = -1.0\n    best_f = int(un[0])\n    best_l = int(free[0])\n\n    for f in un:\n        costs = np.array([delta(int(f), int(l)) for l in free], dtype=float)\n        idx = np.argsort(costs)\n        b = float(costs[idx[0]])\n        s = float(costs[idx[1]]) if costs.size > 1 else (b + 1.0)\n        score = s / (b + eps)\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[int(idx[0])])\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "facility_pair_seed_then_place_one": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''If nothing assigned: seed by max-flow facility pair to closest location pair; else add min-incremental pair.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    if ass.size == 0 and un.size >= 2 and free.size >= 2:\n        # pick facility pair with max sym flow\n        sym = (flow_matrix + flow_matrix.T).astype(float)\n        sub = sym[np.ix_(un, un)]\n        iu, ju = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        f1 = int(un[iu]); f2 = int(un[ju])\n        # pick location pair with min distance\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        il, jl = np.unravel_index(int(np.argmin(D + np.eye(D.shape[0]) * 1e12)), D.shape)\n        l1 = int(free[il]); l2 = int(free[jl])\n        # assign one of them now (the heuristic is single-step)\n        out = a.copy(); out[f1] = l1\n        return out.tolist()\n\n    # fallback: min incremental pair\n    locs = a[ass].astype(int)\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best = inc\n                best_f, best_l = f, l\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "location_pair_seed_then_best_facility": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''If nothing assigned: pick closest location pair; place highest-flow facility on one of them.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    if ass.size == 0 and free.size >= 2:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        i, j = np.unravel_index(int(np.argmin(D + np.eye(D.shape[0]) * 1e12)), D.shape)\n        l = int(free[int(i)])\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(pf[un]))])\n        out = a.copy(); out[f] = l\n        return out.tolist()\n\n    # otherwise: greedy min incremental pair\n    locs = a[ass].astype(int)\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                                         flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n            if inc < best:\n                best = inc; best_f = int(f); best_l = int(l)\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "anti_greedy_outlier_location_first": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Early: assign to most isolated free location to reduce later corner-cases; late: min incremental.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used)\n\n    progress = 1.0 - (un.size / max(1, n))\n\n    ass = np.flatnonzero(a != -1)\n    locs = a[ass].astype(int)\n\n    if progress < 0.5:\n        # pick most isolated free location by mean distance to other free locations\n        if free.size > 1:\n            D = distance_matrix[np.ix_(free, free)].astype(float)\n            iso = D.mean(axis=1)\n            l = int(free[int(np.argmax(iso))])\n        else:\n            l = int(free[0])\n        # place facility that best fits there\n        best = float('inf'); best_f = int(un[0])\n        for f in un.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best = inc; best_f = f\n        out = a.copy(); out[best_f] = l\n        return out.tolist()\n\n    # late: min incremental pair\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best = inc; best_f = f; best_l = l\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "late_stage_minimax_blend": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Blend min incremental early with minimax interaction late (progress-adaptive).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    lam = max(0.0, min(1.0, (progress - 0.55) / 0.45))  # 0 until ~55%, then ramps to 1\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            if ass.size == 0:\n                inc = 0.0\n                worst = 0.0\n            else:\n                c1 = flow_matrix[f, ass] * distance_matrix[l, locs]\n                c2 = flow_matrix[ass, f] * distance_matrix[locs, l]\n                worst = float(np.max(c1 + c2))\n                inc = float(np.sum(c1 + c2))\n            score = (1.0 - lam) * inc + lam * worst\n            if score < best:\n                best = score\n                best_f, best_l = f, l\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "balanced_bipartite_greedy_step": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Constructive step that targets balance: choose facility and location ranks (high-flow vs central) then refine by cost.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n\n    # pick percentile index based on progress\n    progress = 1.0 - (un.size / max(1, n))\n    q = 0.15 + 0.70 * progress\n\n    uf_sorted = un[np.argsort(-pf[un])]\n    lf_sorted = free[np.argsort(-cl[free])]\n\n    f = int(uf_sorted[min(len(uf_sorted)-1, int(q * (len(uf_sorted)-1) + 0.5))])\n    l0 = int(lf_sorted[min(len(lf_sorted)-1, int(q * (len(lf_sorted)-1) + 0.5))])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # refine: among a small location neighborhood around l0, pick best for f\n    if free.size > 1:\n        k = min(8, free.size)\n        near = free[np.argsort(distance_matrix[free, l0])[:k]]\n    else:\n        near = np.array([l0], dtype=int)\n\n    best = float('inf'); best_l = int(near[0])\n    for l in near.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "stochastic_rcl_facility_then_location": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Two-stage GRASP: pick facility from restricted candidate list (flow); then pick location from RCL (incremental).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # facility RCL (top 20%)\n    kf = max(1, int(np.ceil(0.20 * un.size)))\n    f_cand = un[np.argsort(-pf[un])[:kf]]\n    f = int(np.random.choice(f_cand))\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # location RCL by incremental cost\n    costs = []\n    for l in free.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        costs.append(inc)\n    costs = np.asarray(costs, dtype=float)\n    kl = max(1, int(np.ceil(0.20 * free.size)))\n    idx = np.argsort(costs)[:kl]\n    l = int(free[int(np.random.choice(idx))])\n\n    out = a.copy(); out[f] = l\n    return out.tolist()\n",
  "adaptive_rcl_by_progress": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''RCL size shrinks as progress increases; choose among best pairs with probability proportional to exp(-cost/T).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    frac = 0.25 * (1.0 - progress) + 0.05  # from 30% early down to ~5% late\n\n    pairs = []\n    costs = []\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            pairs.append((f, l))\n            costs.append(inc)\n\n    costs = np.asarray(costs, dtype=float)\n    k = max(1, int(np.ceil(frac * costs.size)))\n    idx = np.argsort(costs)[:k]\n\n    c = costs[idx]\n    c = c - c.min()\n    T = max(1e-6, 1.5 * (1.0 - progress) + 0.05)\n    p = np.exp(-c / T)\n    p = p / (p.sum() + 1e-12)\n\n    pick = int(np.random.choice(idx, p=p))\n    f, l = pairs[pick]\n\n    out = a.copy(); out[int(f)] = int(l)\n    return out.tolist()\n",
  "heavy_edge_match_then_place": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick unassigned facility pair with max sym flow; place one facility near the other's best-fit anchor among assigned.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    if un.size >= 2:\n        sub = sym[np.ix_(un, un)].copy()\n        np.fill_diagonal(sub, -np.inf)\n        i, j = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        f = int(un[i])\n    else:\n        f = int(un[0])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # choose location minimizing incremental; if assigned exists, add bias to be near the \"strongest\" assigned neighbor\n    best = float('inf'); best_l = int(free[0])\n    if ass.size:\n        anchor_fac = int(ass[int(np.argmax(sym[f, ass]))])\n        anchor_loc = int(a[anchor_fac])\n    else:\n        anchor_loc = None\n\n    for l in free.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        bias = 0.0 if anchor_loc is None else 0.10 * float(distance_matrix[l, anchor_loc])\n        score = inc + bias\n        if score < best:\n            best = score; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "min_inc_with_location_crowding": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Incremental cost + crowding penalty if chosen location is far from the centroid of already-used locations.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    locs = a[ass].astype(int)\n\n    if ass.size:\n        # centroid in distance space via medoid: location minimizing sum to used locations\n        medoid_idx = int(np.argmin(distance_matrix[locs][:, locs].sum(axis=1)))\n        center_loc = int(locs[medoid_idx])\n    else:\n        center_loc = None\n\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            crowd = 0.0 if center_loc is None else 0.08 * float(distance_matrix[l, center_loc])\n            score = inc + crowd\n            if score < best:\n                best = score; best_f = int(f); best_l = int(l)\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "min_inc_with_flow_centrality_facility": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Select facility by eigenvector centrality of flow graph (approx via power iteration), then best location by incremental.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    # power iteration (few steps)\n    v = np.ones(n, dtype=float) / n\n    for _ in range(12):\n        v = F @ v\n        v = v / (np.linalg.norm(v) + 1e-12)\n    v = np.abs(v)\n\n    f = int(un[int(np.argmax(v[un]))])\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf'); best_l = int(free[0])\n    for l in free.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "min_inc_with_location_pagerank": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Bias toward high PageRank locations on the inverse-distance graph; choose best pair under biased score.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # build stochastic matrix from inverse distances\n    W = 1.0 / (distance_matrix.astype(float) + 1e-6)\n    np.fill_diagonal(W, 0.0)\n    P = W / (W.sum(axis=1, keepdims=True) + 1e-12)\n\n    d = 0.85\n    pr = np.ones(n, dtype=float) / n\n    for _ in range(20):\n        pr = d * (P.T @ pr) + (1.0 - d) / n\n    pr = (pr - pr.min()) / (pr.max() - pr.min() + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc - 0.25 * pr[l]  # prefer higher-pr locations\n            if score < best:\n                best = score; best_f = f; best_l = l\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "directional_flow_asymmetry_priority": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Prioritize facilities with high flow asymmetry to already assigned; place to minimize asymmetric incremental.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    locs = a[ass].astype(int)\n\n    if ass.size:\n        asym = np.abs(flow_matrix[np.ix_(un, ass)].sum(axis=1) - flow_matrix[np.ix_(ass, un)].sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(asym))])\n    else:\n        # if no assigned, just pick high total flow\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(pf[un]))])\n\n    best = float('inf'); best_l = int(free[0])\n    for l in free.astype(int):\n        if ass.size == 0:\n            inc = 0.0\n        else:\n            out_cost = np.sum(flow_matrix[f, ass] * distance_matrix[l, locs])\n            in_cost = np.sum(flow_matrix[ass, f] * distance_matrix[locs, l])\n            inc = float(out_cost + in_cost)\n        if inc < best:\n            best = inc; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "min_inc_with_rank_sum": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Score = rank(inc) + rank(-facility_flow) + rank(-location_centrality), pick min.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = []\n    incs = []\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            pairs.append((f, l))\n            incs.append(inc)\n\n    incs = np.asarray(incs, dtype=float)\n    inc_rank = np.argsort(np.argsort(incs))\n\n    f_vals = np.array([pf[f] for f, _ in pairs], dtype=float)\n    l_vals = np.array([cl[l] for _, l in pairs], dtype=float)\n\n    f_rank = np.argsort(np.argsort(-f_vals))\n    l_rank = np.argsort(np.argsort(-l_vals))\n\n    score = inc_rank + 0.35 * f_rank + 0.35 * l_rank\n    idx = int(np.argmin(score))\n    f, l = pairs[idx]\n\n    out = a.copy(); out[int(f)] = int(l)\n    return out.tolist()\n",
  "min_inc_with_small_k_medoids_locations": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Cluster free locations into k medoids (k small), pick a medoid location, then choose best facility for it.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # pick k medoids as the k most central free locations\n    k = min(5, max(1, free.size // 5))\n    cent = distance_matrix[free].sum(axis=1).astype(float)\n    medoids = free[np.argsort(cent)[:k]].astype(int)\n\n    # choose one medoid to fill now: the one farthest from already-used locations (covers space)\n    ass = np.flatnonzero(a != -1).astype(int)\n    if ass.size:\n        locs = a[ass].astype(int)\n        spread = np.array([distance_matrix[m, locs].mean() for m in medoids], dtype=float)\n        l = int(medoids[int(np.argmax(spread))])\n    else:\n        l = int(medoids[0])\n\n    locs = a[ass].astype(int)\n\n    best = float('inf'); best_f = int(un[0])\n    for f in un.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_f = int(f)\n\n    out = a.copy(); out[best_f] = l\n    return out.tolist()\n",
  "min_inc_with_facility_hubs_first": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Early: place hub facilities (top flow) onto central locations; later: pure min incremental.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    if progress < 0.45:\n        # choose among top hub facilities\n        kf = max(1, int(np.ceil(0.20 * un.size)))\n        hubs = un[np.argsort(-pf[un])[:kf]]\n        f = int(hubs[0])\n        # choose among top central locations\n        kl = max(1, int(np.ceil(0.20 * free.size)))\n        cents = free[np.argsort(-cl[free])[:kl]]\n        # pick best hub-central pair by incremental\n        best = float('inf'); best_f = int(f); best_l = int(cents[0])\n        for f2 in hubs.astype(int):\n            for l2 in cents.astype(int):\n                inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f2, ass] * distance_matrix[l2, locs] +\n                                                            flow_matrix[ass, f2] * distance_matrix[locs, l2]))\n                if inc < best:\n                    best = inc; best_f = int(f2); best_l = int(l2)\n        out = a.copy(); out[best_f] = best_l\n        return out.tolist()\n\n    # later: pure min incremental pair\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best = inc; best_f = int(f); best_l = int(l)\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "least_constrained_location_first": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick the location with most similar distances to other free locations (least constrained), then best facility for it.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    if free.size > 1:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        # \"least constrained\" = minimal variance of its distances to other free locations\n        v = D.var(axis=1)\n        l = int(free[int(np.argmin(v))])\n    else:\n        l = int(free[0])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf'); best_f = int(un[0])\n    for f in un.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_f = int(f)\n\n    out = a.copy(); out[best_f] = l\n    return out.tolist()\n",
  "most_constrained_location_first": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick the most extreme free location (highest distance-sum), then best facility for it (avoid dead-ends).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    s = distance_matrix[free].sum(axis=1).astype(float)\n    l = int(free[int(np.argmax(s))])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf'); best_f = int(un[0])\n    for f in un.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_f = int(f)\n\n    out = a.copy(); out[best_f] = l\n    return out.tolist()\n",
  "facility_similarity_bundle": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility that is most similar (cosine) to already-assigned flow profile; place near centroid of used locations.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    Fn = F / (np.linalg.norm(F, axis=1, keepdims=True) + 1e-12)\n\n    if ass.size:\n        mu = Fn[ass].mean(axis=0)\n        mu = mu / (np.linalg.norm(mu) + 1e-12)\n        sims = Fn[un] @ mu\n        f = int(un[int(np.argmax(sims))])\n    else:\n        pf = F.sum(axis=1)\n        f = int(un[int(np.argmax(pf[un]))])\n\n    if ass.size:\n        locs = a[ass].astype(int)\n        # choose free location closest to used-set medoid\n        medoid_idx = int(np.argmin(distance_matrix[locs][:, locs].sum(axis=1)))\n        center = int(locs[medoid_idx])\n        l0 = int(free[int(np.argmin(distance_matrix[free, center]))])\n    else:\n        l0 = int(free[int(np.argmin(distance_matrix[free].sum(axis=1)))])\n\n    # local refinement by incremental among nearest few\n    k = min(8, free.size)\n    cand = free[np.argsort(distance_matrix[free, l0])[:k]].astype(int)\n\n    locs = a[ass].astype(int)\n    best = float('inf'); best_l = int(cand[0])\n    for l in cand:\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "opportunity_cost_facility_choice": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose facility with highest opportunity cost: avg(inc) - min(inc); assign to its min(inc) location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    def inc_costs(f):\n        if ass.size == 0:\n            return np.zeros(free.size, dtype=float)\n        return np.array([np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                flow_matrix[ass, f] * distance_matrix[locs, l]) for l in free], dtype=float)\n\n    best_score = -1.0\n    best_f = int(un[0])\n    best_l = int(free[0])\n\n    for f in un.astype(int):\n        c = inc_costs(int(f))\n        score = float(c.mean() - c.min())\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[int(np.argmin(c))])\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "mean_plus_std_risk_averse": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Risk-averse: score(l)=mean interaction cost + k*std interaction cost vs assigned; choose min across pairs.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    k = 0.25 + 0.75 * progress  # more risk-averse late\n\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                score = 0.0\n            else:\n                c = flow_matrix[f, ass] * distance_matrix[l, locs] + flow_matrix[ass, f] * distance_matrix[locs, l]\n                score = float(c.mean() + k * c.std())\n            if score < best:\n                best = score; best_f = int(f); best_l = int(l)\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "min_inc_with_soft_conflicts": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Penalize placing a facility at a location whose distance profile poorly matches already-assigned interactions.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    locs = a[ass].astype(int)\n\n    # interaction mass between candidate f and assigned facilities\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        w = sym[f, ass].astype(float) if ass.size else None\n        wsum = float(w.sum()) if ass.size else 1.0\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if ass.size == 0:\n                penalty = 0.0\n            else:\n                # compare location distances to assigned locs against inverse of interaction weights (soft match)\n                d = distance_matrix[l, locs].astype(float)\n                d = (d - d.mean()) / (d.std() + 1e-12)\n                ww = (w - w.mean()) / (w.std() + 1e-12)\n                penalty = float(np.sum((d - (-ww))**2) / (ass.size + 1e-12))\n            score = inc + 0.05 * penalty * (abs(inc) + 1.0)\n            if score < best:\n                best = score; best_f = f; best_l = l\n\n    out = a.copy(); out[int(best_f)] = int(best_l)\n    return out.tolist()\n",
  "short_horizon_rollout_sample": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Sample a few candidate pairs; for each, simulate a short greedy rollout (h steps) and pick best simulated outcome.''' \n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n\n    un0 = np.flatnonzero(a0 == -1).astype(int)\n    if un0.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a0 != -1):\n        used[a0[a0 != -1]] = True\n    free0 = np.flatnonzero(~used).astype(int)\n\n    ass0 = np.flatnonzero(a0 != -1).astype(int)\n    locs0 = a0[ass0].astype(int)\n\n    # build all pairs costs (incremental)\n    pairs = []\n    costs = []\n    for f in un0.astype(int):\n        for l in free0.astype(int):\n            inc = 0.0 if ass0.size == 0 else float(np.sum(flow_matrix[f, ass0] * distance_matrix[l, locs0] +\n                                                         flow_matrix[ass0, f] * distance_matrix[locs0, l]))\n            pairs.append((f, l))\n            costs.append(inc)\n\n    costs = np.asarray(costs, dtype=float)\n    k = min(20, max(3, int(0.08 * len(pairs))))\n    cand_idx = np.argsort(costs)[:k]\n\n    def total_cost(arr):\n        idx = np.arange(n)\n        L = arr.astype(int)\n        return float(np.sum(flow_matrix[np.ix_(idx, idx)] * distance_matrix[np.ix_(L, L)]))\n\n    h = min(3, un0.size)  # rollout depth\n    best_total = float('inf')\n    best_pair = pairs[int(cand_idx[0])]\n\n    for idxp in cand_idx:\n        f, l = pairs[int(idxp)]\n        a = a0.copy()\n        a[int(f)] = int(l)\n        # greedy fill h-1 steps using min incremental\n        for _ in range(h - 1):\n            un = np.flatnonzero(a == -1).astype(int)\n            if un.size == 0:\n                break\n            used = np.zeros(n, dtype=bool)\n            used[a[a != -1]] = True\n            free = np.flatnonzero(~used).astype(int)\n            ass = np.flatnonzero(a != -1).astype(int)\n            locs = a[ass].astype(int)\n            bf, bl, b = int(un[0]), int(free[0]), float('inf')\n            for f2 in un.astype(int):\n                for l2 in free.astype(int):\n                    inc = float(np.sum(flow_matrix[f2, ass] * distance_matrix[l2, locs] +\n                                       flow_matrix[ass, f2] * distance_matrix[locs, l2]))\n                    if inc < b:\n                        b = inc; bf = int(f2); bl = int(l2)\n            a[bf] = bl\n        # if still incomplete, just evaluate partial by incremental proxy\n        if np.any(a == -1):\n            # proxy: sum current incremental contributions only\n            ass = np.flatnonzero(a != -1).astype(int)\n            locs = a[ass].astype(int)\n            proxy = 0.0\n            for i in range(ass.size):\n                for j in range(ass.size):\n                    proxy += float(flow_matrix[ass[i], ass[j]] * distance_matrix[locs[i], locs[j]])\n            tot = proxy\n        else:\n            tot = total_cost(a)\n        if tot < best_total:\n            best_total = tot\n            best_pair = (int(f), int(l))\n\n    out = a0.copy(); out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n",
  "beam_search_width3_one_step": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''One-step beam: expand best few partial assignments by one move, keep top-B, return the first move of best branch.''' \n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n\n    un0 = np.flatnonzero(a0 == -1).astype(int)\n    if un0.size == 0:\n        return a0.tolist()\n\n    def inc_pair(a, f, l):\n        ass = np.flatnonzero(a != -1).astype(int)\n        if ass.size == 0:\n            return 0.0\n        locs = a[ass].astype(int)\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # enumerate candidate moves and seed beam by best K\n    used0 = np.zeros(n, dtype=bool)\n    if np.any(a0 != -1):\n        used0[a0[a0 != -1]] = True\n    free0 = np.flatnonzero(~used0).astype(int)\n\n    moves = []\n    costs = []\n    for f in un0.astype(int):\n        for l in free0.astype(int):\n            moves.append((f, l))\n            costs.append(inc_pair(a0, int(f), int(l)))\n\n    costs = np.asarray(costs, dtype=float)\n    K = min(12, len(moves))\n    seed = np.argsort(costs)[:K]\n\n    B = 3\n    beam = []\n    for idx in seed:\n        f, l = moves[int(idx)]\n        a = a0.copy(); a[int(f)] = int(l)\n        beam.append((float(costs[int(idx)]), a, (int(f), int(l))))\n    beam.sort(key=lambda x: x[0])\n    beam = beam[:B]\n\n    # one additional expansion layer\n    new_beam = []\n    for base_cost, a, first_move in beam:\n        un = np.flatnonzero(a == -1).astype(int)\n        if un.size == 0:\n            new_beam.append((base_cost, a, first_move))\n            continue\n        used = np.zeros(n, dtype=bool)\n        used[a[a != -1]] = True\n        free = np.flatnonzero(~used).astype(int)\n        for f2 in un.astype(int):\n            for l2 in free.astype(int):\n                c = inc_pair(a, int(f2), int(l2))\n                b = a.copy(); b[int(f2)] = int(l2)\n                new_beam.append((base_cost + c, b, first_move))\n\n    new_beam.sort(key=lambda x: x[0])\n    best_first = new_beam[0][2]\n\n    out = a0.copy(); out[best_first[0]] = best_first[1]\n    return out.tolist()\n",
  "cross_entropy_pair_selection": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Cross-entropy style: sample pairs from a distribution, keep elites, update logits once, then pick MAP pair.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = [(int(f), int(l)) for f in un for l in free]\n    m = len(pairs)\n\n    # initial logits from negative incremental cost\n    base = np.zeros(m, dtype=float)\n    for i, (f, l) in enumerate(pairs):\n        if ass.size == 0:\n            base[i] = 0.0\n        else:\n            base[i] = -float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # normalize\n    logits = (base - base.mean()) / (base.std() + 1e-6)\n\n    # sample\n    S = min(200, max(40, 3 * m))\n    p = np.exp(logits - logits.max())\n    p = p / (p.sum() + 1e-12)\n    samp = np.random.choice(m, size=S, replace=True, p=p)\n\n    # evaluate sampled costs\n    costs = np.zeros(S, dtype=float)\n    for k, idx in enumerate(samp):\n        f, l = pairs[int(idx)]\n        if ass.size == 0:\n            costs[k] = 0.0\n        else:\n            costs[k] = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # elite set\n    elite_frac = 0.15\n    E = max(5, int(elite_frac * S))\n    elite_idx = samp[np.argsort(costs)[:E]]\n\n    # update logits toward elites\n    alpha = 0.6\n    counts = np.bincount(elite_idx, minlength=m).astype(float)\n    counts = counts / (counts.sum() + 1e-12)\n    logits = (1 - alpha) * logits + alpha * (np.log(counts + 1e-12) - np.log(1.0 / m))\n\n    # pick MAP\n    pick = int(np.argmax(logits))\n    f, l = pairs[pick]\n\n    out = a.copy(); out[f] = l\n    return out.tolist()\n",
  "incremental_cost_with_symmetry_breaking": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Min incremental but add tiny symmetry-breaking bias favoring smaller location indices early (stabilizes runs).''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    eps = 1e-6 * (1.0 - progress)\n\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc + eps * (l / max(1, n - 1))\n            if score < best:\n                best = score; best_f = f; best_l = l\n\n    out = a.copy(); out[int(best_f)] = int(best_l)\n    return out.tolist()\n",
  "dual_greedy_facility_and_location": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Compute best location for each facility and best facility for each location; pick the most mutually consistent pair.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    def inc(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # best location per facility\n    f_best_l = {}\n    f_best_c = {}\n    for f in un.astype(int):\n        cs = np.array([inc(int(f), int(l)) for l in free], dtype=float)\n        j = int(np.argmin(cs))\n        f_best_l[int(f)] = int(free[j])\n        f_best_c[int(f)] = float(cs[j])\n\n    # best facility per location\n    l_best_f = {}\n    l_best_c = {}\n    for l in free.astype(int):\n        cs = np.array([inc(int(f), int(l)) for f in un], dtype=float)\n        i = int(np.argmin(cs))\n        l_best_f[int(l)] = int(un[i])\n        l_best_c[int(l)] = float(cs[i])\n\n    # pick pair with maximum mutuality score\n    best_score = -float('inf'); best_pair = (int(un[0]), int(free[0]))\n    for f in un.astype(int):\n        l = f_best_l[int(f)]\n        mutual = 1 if l_best_f[int(l)] == int(f) else 0\n        score = 2.0 * mutual - f_best_c[int(f)] - l_best_c[int(l)]\n        if score > best_score:\n            best_score = score\n            best_pair = (int(f), int(l))\n\n    out = a.copy(); out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n",
  "partial_cost_gradient_descent_step": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Treat each facility's location as variable; approximate a gradient via swapping benefit and commit one assignment.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    locs = a[ass].astype(int)\n\n    # pick a facility with largest partial \"force\" from assigned facilities\n    if ass.size:\n        force = (flow_matrix[np.ix_(un, ass)].sum(axis=1) + flow_matrix[np.ix_(ass, un)].sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(force))])\n    else:\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(pf[un]))])\n\n    # choose location that minimizes a quadratic form distance^2 weighted by interaction\n    best = float('inf'); best_l = int(free[0])\n    for l in free.astype(int):\n        if ass.size == 0:\n            score = float((distance_matrix[l].astype(float) ** 2).mean())\n        else:\n            w_out = flow_matrix[f, ass].astype(float)\n            w_in = flow_matrix[ass, f].astype(float)\n            w = w_out + w_in\n            wsum = float(w.sum()) + 1e-12\n            d = distance_matrix[l, locs].astype(float)\n            score = float(np.sum(w * (d ** 2)) / wsum)\n        if score < best:\n            best = score; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "two_step_lookahead_best_pair": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Evaluate each (facility,location) by incremental cost plus a one-step greedy lookahead on the remainder.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    def inc_cost(f: int, l: int, ass_idx: np.ndarray, ass_locs: np.ndarray) -> float:\n        if ass_idx.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass_idx] * distance_matrix[l, ass_locs] +\n                            flow_matrix[ass_idx, f] * distance_matrix[ass_locs, l]))\n\n    best_score = float(\"inf\")\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n\n            # immediate incremental\n            inc = inc_cost(f, l, ass, locs)\n\n            # lookahead: after placing (f,l), greedily place the best next facility/location pair\n            un2 = un[un != f]\n            free2 = free[free != l]\n\n            if un2.size == 0 or free2.size == 0:\n                la = 0.0\n            else:\n                ass2 = np.concatenate([ass, np.array([f], dtype=int)])\n                locs2 = np.concatenate([locs, np.array([l], dtype=int)])\n\n                la_best = float(\"inf\")\n                for f2 in un2:\n                    f2 = int(f2)\n                    for l2 in free2:\n                        l2 = int(l2)\n                        c = inc_cost(f2, l2, ass2, locs2)\n                        if c < la_best:\n                            la_best = c\n                la = la_best\n\n            score = inc + 0.35 * la\n            if score < best_score:\n                best_score = score\n                best_f, best_l = f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "min_incremental_location_neighborhood": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Restrict location candidates to be near already used locations (k-nearest), then pick best incremental pair.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # If nothing assigned, fall back to globally best pair by incremental (=0), using centrality to break ties.\n    if ass.size == 0:\n        central = distance_matrix[free].sum(axis=1).astype(float)\n        l = int(free[int(np.argmin(central))])\n        f = int(un[0])\n        out = a.copy()\n        out[f] = l\n        return out.tolist()\n\n    # Candidate locations: union of k-nearest free locations to each assigned location\n    k = max(2, int(np.ceil(0.25 * free.size)))\n    cand_mask = np.zeros(n, dtype=bool)\n    for al in locs:\n        al = int(al)\n        d = distance_matrix[free, al].astype(float)\n        idx = np.argsort(d)[:min(k, free.size)]\n        cand_mask[free[idx]] = True\n    cand_locs = free[cand_mask[free]]\n\n    best = float(\"inf\")\n    best_f, best_l = int(un[0]), int(cand_locs[0])\n\n    for f in un.astype(int):\n        for l in cand_locs.astype(int):\n            inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                               flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best, best_f, best_l = inc, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "surrogate_linear_assignment_pick": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Build a surrogate linear cost for remaining facilities/locations, solve a greedy assignment, take its first pair.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # Facility weight: interaction strength to already assigned (or total if none assigned)\n    if ass.size:\n        w_f = (flow_matrix[np.ix_(un, ass)].sum(axis=1) + flow_matrix[np.ix_(ass, un)].sum(axis=0)).astype(float)\n    else:\n        w_f = (flow_matrix[un].sum(axis=1) + flow_matrix[:, un].sum(axis=0)).astype(float)\n\n    # Location weight: distance to already used locations (smaller preferred), or centrality if none assigned\n    if ass.size:\n        w_l = distance_matrix[np.ix_(free, locs)].sum(axis=1).astype(float)\n    else:\n        w_l = distance_matrix[free].sum(axis=1).astype(float)\n\n    # Surrogate linear costs: outer product\n    C = np.outer(w_f, w_l)\n\n    # Greedy linear assignment: repeatedly take cheapest remaining row/col\n    rows = list(range(C.shape[0]))\n    cols = list(range(C.shape[1]))\n    chosen = []\n    Cwork = C.copy()\n\n    while rows and cols:\n        i, j = divmod(int(np.argmin(Cwork[np.ix_(rows, cols)])), len(cols))\n        r = rows[i]\n        c = cols[j]\n        chosen.append((r, c))\n        rows.pop(i)\n        cols.pop(j)\n        if not rows or not cols:\n            break\n\n    # Choose the pair that also has best true incremental cost to current assignment\n    best = float(\"inf\")\n    best_f, best_l = int(un[0]), int(free[0])\n    for r, c in chosen[:min(4, len(chosen))]:\n        f = int(un[r])\n        l = int(free[c])\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best, best_f, best_l = inc, f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "flow_community_then_central_match": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick a facility from the densest remaining flow community; place it on the most central free location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    # Densest community proxy: pick facility with max average flow to its top neighbors among unassigned\n    k = min(6, max(1, un.size - 1))\n    scores = np.zeros(un.size, dtype=float)\n    for i, f in enumerate(un):\n        f = int(f)\n        neigh = sym[f, un]\n        # exclude self by setting to -inf then selecting top-k\n        neigh = neigh.copy()\n        neigh[i] = -np.inf\n        topk = np.sort(neigh)[-k:] if k > 0 else np.array([0.0])\n        scores[i] = float(np.mean(topk)) if topk.size else 0.0\n\n    f = int(un[int(np.argmax(scores))])\n\n    # Choose central free location by sum distance to all locations\n    centrality = distance_matrix[free].sum(axis=1).astype(float)\n    l = int(free[int(np.argmin(centrality))])\n\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n",
  "min_incremental_with_cost_variance_regularizer": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick pair minimizing incremental cost plus a penalty on the variance of its interaction costs to assigned facilities.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    lam = 0.25\n\n    best = float(\"inf\")\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                score = 0.0\n            else:\n                vec = (flow_matrix[f, ass] * distance_matrix[l, locs] +\n                       flow_matrix[ass, f] * distance_matrix[locs, l]).astype(float)\n                inc = float(vec.sum())\n                var = float(vec.var()) if vec.size > 1 else 0.0\n                score = inc + lam * var\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "max_bottleneck_flow_pair_then_best_location": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose a facility that participates in the highest remaining flow edge; place it at location minimizing incremental.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    # Find endpoint of max edge among unassigned\n    if un.size >= 2:\n        sub = sym[np.ix_(un, un)].copy()\n        np.fill_diagonal(sub, -np.inf)\n        i, j = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        f = int(un[i])  # pick one endpoint deterministically\n    else:\n        f = int(un[0])\n\n    # Place to best free location by incremental cost\n    best_l = int(free[0])\n    best = float(\"inf\")\n    for l in free.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best, best_l = inc, int(l)\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n",
  "centrality_regret_blend": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''For each facility compute regret-2 over locations, weighted by location centrality; pick max-weighted-regret.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # centrality score in [0,1], higher means more central\n    c = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    c = (c - c.min()) / (c.max() - c.min() + 1e-12)\n\n    def delta(f: int, l: int) -> float:\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_score = -1.0\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        costs = np.array([delta(f, int(l)) for l in free], dtype=float)\n        idx = np.argsort(costs)\n        l1 = int(free[int(idx[0])])\n        regret = float(costs[idx[1]] - costs[idx[0]]) if costs.size > 1 else float(\"inf\")\n        score = regret * (0.6 + 0.4 * c[l1])  # encourage committing central locations when regret is high\n        if score > best_score:\n            best_score, best_f, best_l = score, f, l1\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "farthest_location_then_max_flow_facility": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick the currently farthest free location from used ones; assign the facility with highest total flow to assigned.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    if ass.size == 0:\n        # pick most peripheral location by sum distances\n        per = distance_matrix[free].sum(axis=1).astype(float)\n        l = int(free[int(np.argmax(per))])\n        # pick most connected facility\n        tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(tot[un]))])\n        out = a.copy(); out[f] = l\n        return out.tolist()\n\n    locs = a[ass].astype(int)\n\n    # choose farthest free location from the set of used locations (max min-distance)\n    dmin = np.min(distance_matrix[np.ix_(free, locs)], axis=1).astype(float)\n    l = int(free[int(np.argmax(dmin))])\n\n    # choose facility with max interaction to assigned\n    w = (flow_matrix[np.ix_(un, ass)].sum(axis=1) + flow_matrix[np.ix_(ass, un)].sum(axis=0)).astype(float)\n    f = int(un[int(np.argmax(w))])\n\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n",
  "balanced_quadrant_location_assignment": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Approximate spatial spread by picking a location that balances centroid distance, then assign best-fitting facility.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    if ass.size == 0:\n        # start from a moderately central (median) location\n        sd = distance_matrix[free].sum(axis=1).astype(float)\n        l = int(free[int(np.argsort(sd)[len(sd)//2])])\n        f = int(un[0])\n        out = a.copy(); out[f] = l\n        return out.tolist()\n\n    locs = a[ass].astype(int)\n\n    # choose free location whose distance to assigned-locations centroid (in distance space) is closest to median\n    D = distance_matrix[np.ix_(free, locs)].astype(float)\n    dmean = D.mean(axis=1)\n    target = float(np.median(dmean))\n    l = int(free[int(np.argmin(np.abs(dmean - target)))])\n\n    # assign the facility that minimizes incremental cost at this chosen l\n    best_f = int(un[0]); best = float(\"inf\")\n    for f in un.astype(int):\n        inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                           flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best, best_f = inc, int(f)\n\n    out = a.copy()\n    out[best_f] = l\n    return out.tolist()\n",
  "degree_corrected_flow_then_place": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility with highest (flow to assigned)/(1+flow to unassigned) to prioritize bridging; then best location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    if ass.size == 0:\n        # pick by total sym flow\n        mass = sym[un].sum(axis=1).astype(float)\n        f = int(un[int(np.argmax(mass))])\n    else:\n        to_ass = sym[np.ix_(un, ass)].sum(axis=1).astype(float)\n        to_un  = sym[np.ix_(un, un)].sum(axis=1).astype(float)\n        score = to_ass / (1.0 + to_un)\n        f = int(un[int(np.argmax(score))])\n\n    best_l = int(free[0])\n    best = float(\"inf\")\n    for l in free.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best, best_l = inc, int(l)\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n",
  "triadic_closure_anchor": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose facility that forms strongest triadic closure with two already-assigned facilities; place near their locations.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    if ass.size < 2:\n        # fall back to best incremental pair\n        locs = a[ass].astype(int)\n        best = float(\"inf\"); best_f = int(un[0]); best_l = int(free[0])\n        for f in un.astype(int):\n            for l in free.astype(int):\n                inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n                if inc < best:\n                    best, best_f, best_l = inc, int(f), int(l)\n        out = a.copy(); out[best_f] = best_l\n        return out.tolist()\n\n    locs = a[ass].astype(int)\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    # triadic score: sum of top-2 connections to assigned (encourages closing triangles)\n    scores = np.zeros(un.size, dtype=float)\n    top2_idx = np.zeros((un.size, 2), dtype=int)\n    for i, f in enumerate(un):\n        vals = sym[int(f), ass].astype(float)\n        idx = np.argsort(-vals)[:2]\n        scores[i] = float(vals[idx].sum())\n        top2_idx[i, :] = idx\n\n    i = int(np.argmax(scores))\n    f = int(un[i])\n    a1 = int(ass[top2_idx[i, 0]])\n    a2 = int(ass[top2_idx[i, 1]])\n    l1 = int(a[a1]); l2 = int(a[a2])\n\n    # place close to both anchors: minimize sum of distances\n    dsum = (distance_matrix[free, l1] + distance_matrix[free, l2]).astype(float)\n    l = int(free[int(np.argmin(dsum))])\n\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n",
  "eigen_embedding_match_remaining": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Embed remaining facilities/locations into 1D via eigenvectors; match closest embedded values, then commit one pair.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # Facility embedding: 2nd eigenvector of Laplacian of sym flow (Fiedler vector)\n    W = (flow_matrix + flow_matrix.T).astype(float)\n    d = W.sum(axis=1)\n    L = np.diag(d) - W\n    # numerical stability: use eigh on symmetric L\n    vals, vecs = np.linalg.eigh(L)\n    if vals.size >= 2:\n        vf = vecs[:, 1]\n    else:\n        vf = vecs[:, 0]\n    vf = (vf - vf.min()) / (vf.max() - vf.min() + 1e-12)\n\n    # Location embedding: 2nd eigenvector of Laplacian of similarity (inverse distance)\n    S = 1.0 / (distance_matrix.astype(float) + 1e-6)\n    ds = S.sum(axis=1)\n    Ls = np.diag(ds) - S\n    vls, vecs2 = np.linalg.eigh(Ls)\n    if vls.size >= 2:\n        vl = vecs2[:, 1]\n    else:\n        vl = vecs2[:, 0]\n    vl = (vl - vl.min()) / (vl.max() - vl.min() + 1e-12)\n\n    # Choose unassigned facility with most extreme embedding (to anchor ends), match closest free location embedding\n    f = int(un[int(np.argmax(np.abs(vf[un] - 0.5)))])\n    target = float(vf[f])\n    l = int(free[int(np.argmin(np.abs(vl[free] - target)))])\n\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n",
  "robust_trimmed_mean_incremental": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Use trimmed-mean interaction cost to be robust to outliers when choosing the next pair.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    trim = 0.20\n\n    best = float(\"inf\")\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                score = 0.0\n            else:\n                v = (flow_matrix[f, ass] * distance_matrix[l, locs] +\n                     flow_matrix[ass, f] * distance_matrix[locs, l]).astype(float)\n                v_sorted = np.sort(v)\n                k = int(np.floor(trim * v_sorted.size))\n                if v_sorted.size - 2*k <= 0:\n                    tmean = float(v_sorted.mean())\n                else:\n                    tmean = float(v_sorted[k:-k].mean())\n                score = tmean * float(v.sum() / (tmean * v.size + 1e-12))  # mild scale correction\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "greedy_with_location_sparsity_penalty": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Greedy incremental cost + penalty for using a location too close to already used ones (encourage spatial spread).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    lam = 0.30\n\n    best = float(\"inf\")\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if ass.size == 0:\n                prox = float(distance_matrix[l].mean())\n            else:\n                # proximity = inverse of min distance to used locations\n                dmin = float(np.min(distance_matrix[l, locs]))\n                prox = 1.0 / (dmin + 1e-6)\n            score = inc + lam * prox * (abs(inc) + 1.0)\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "progressive_beam_top_pairs": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Keep a small beam of best partial assignments for one step and commit the move that appears in the best beam state.'''\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n    un0 = np.flatnonzero(a0 == -1).astype(int)\n    if un0.size == 0:\n        return a0.tolist()\n\n    used0 = np.zeros(n, dtype=bool)\n    if np.any(a0 != -1):\n        used0[a0[a0 != -1]] = True\n    free0 = np.flatnonzero(~used0).astype(int)\n\n    ass0 = np.flatnonzero(a0 != -1).astype(int)\n    locs0 = a0[ass0].astype(int)\n\n    def inc(a: np.ndarray, f: int, l: int) -> float:\n        ass = np.flatnonzero(a != -1).astype(int)\n        if ass.size == 0:\n            return 0.0\n        locs = a[ass].astype(int)\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    progress = 1.0 - (un0.size / max(1, n))\n    beam_width = int(max(3, min(12, 3 + round(12 * (1.0 - progress)))))\n\n    # Build candidate pairs by incremental cost (top-m)\n    pairs = []\n    costs = []\n    for f in un0:\n        for l in free0:\n            c = 0.0 if ass0.size == 0 else float(np.sum(flow_matrix[int(f), ass0] * distance_matrix[int(l), locs0] +\n                                                       flow_matrix[ass0, int(f)] * distance_matrix[locs0, int(l)]))\n            pairs.append((int(f), int(l)))\n            costs.append(float(c))\n\n    idxs = np.argsort(np.array(costs, dtype=float))[:min(len(pairs), beam_width * 4)]\n    cand = [pairs[int(i)] for i in idxs]\n\n    # Expand one step with beam: for each candidate, compute (inc + best next inc)\n    best_score = float(\"inf\")\n    best_pair = cand[0]\n\n    for f, l in cand:\n        a1 = a0.copy()\n        a1[f] = l\n        un1 = np.flatnonzero(a1 == -1).astype(int)\n        used1 = np.zeros(n, dtype=bool); used1[a1[a1 != -1]] = True\n        free1 = np.flatnonzero(~used1).astype(int)\n\n        inc1 = inc(a0, f, l)\n        if un1.size == 0 or free1.size == 0:\n            score = inc1\n        else:\n            la = float(\"inf\")\n            for f2 in un1:\n                for l2 in free1:\n                    c2 = inc(a1, int(f2), int(l2))\n                    if c2 < la:\n                        la = c2\n            score = inc1 + 0.25 * la\n\n        if score < best_score:\n            best_score = score\n            best_pair = (f, l)\n\n    out = a0.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n",
  "min_incremental_using_flow_normalization": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Minimize incremental cost where flows are normalized by facility degrees to reduce dominance of hubs.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # degree normalization\n    deg_out = flow_matrix.sum(axis=1).astype(float) + 1e-12\n    deg_in  = flow_matrix.sum(axis=0).astype(float) + 1e-12\n\n    best = float(\"inf\")\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum((flow_matrix[f, ass] / deg_out[f]) * distance_matrix[l, locs] +\n                                   (flow_matrix[ass, f] / deg_in[f]) * distance_matrix[locs, l]))\n            if inc < best:\n                best, best_f, best_l = inc, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "max_flow_gradient_magnitude": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility with largest estimated objective-gradient magnitude; place it to minimize that gradient contribution.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    if ass.size == 0:\n        # gradient proxy reduces to total flow\n        g = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(g[un]))])\n        # choose most central location\n        cen = distance_matrix[free].sum(axis=1).astype(float)\n        l = int(free[int(np.argmin(cen))])\n        out = a.copy(); out[f] = l\n        return out.tolist()\n\n    # gradient magnitude proxy: sum_j |F(f,j)+F(j,f)| * avg distance to assigned locs\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n    avg_d = distance_matrix[:, locs].mean(axis=1).astype(float)  # for each location\n    grad = np.zeros(un.size, dtype=float)\n    for i, f in enumerate(un):\n        grad[i] = float(np.sum(sym[int(f), ass]) * np.mean(avg_d[free]))\n    f = int(un[int(np.argmax(grad))])\n\n    # place f at location minimizing its incremental contribution\n    best = float(\"inf\"); best_l = int(free[0])\n    for l in free.astype(int):\n        inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                           flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best, best_l = inc, int(l)\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n",
  "location_kmedoids_seed_then_best_facility": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose a medoid-like free location (min sum distance to other free); assign the best facility for it.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # medoid among free locations\n    if free.size > 1:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        l = int(free[int(np.argmin(D.sum(axis=1)))])\n    else:\n        l = int(free[0])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # choose facility that fits l best (incremental); break ties by total flow\n    tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    best = float(\"inf\")\n    best_f = int(un[0])\n    for f in un.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        score = inc - 1e-9 * tot[f]\n        if score < best:\n            best, best_f = score, int(f)\n\n    out = a.copy()\n    out[best_f] = l\n    return out.tolist()\n",
  "flow_aware_location_pairing": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Select two high-flow unassigned facilities, map one of them to the best of the two closest free locations (single-step).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    # pick facility pair with max sym flow\n    if un.size >= 2:\n        sub = sym[np.ix_(un, un)].copy()\n        np.fill_diagonal(sub, -np.inf)\n        i, j = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        f1 = int(un[i]); f2 = int(un[j])\n    else:\n        f1 = int(un[0]); f2 = int(un[0])\n\n    # pick two closest free locations\n    if free.size >= 2:\n        D = distance_matrix[np.ix_(free, free)].astype(float).copy()\n        np.fill_diagonal(D, np.inf)\n        i, j = np.unravel_index(int(np.argmin(D)), D.shape)\n        l1 = int(free[i]); l2 = int(free[j])\n    else:\n        l1 = int(free[0]); l2 = int(free[0])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    def inc(f: int, l: int) -> float:\n        return 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # choose which endpoint to assign now, and to which of the close locations\n    options = [(f1, l1), (f1, l2), (f2, l1), (f2, l2)]\n    best = float(\"inf\"); best_pair = options[0]\n    for f, l in options:\n        c = inc(int(f), int(l))\n        if c < best:\n            best, best_pair = c, (int(f), int(l))\n\n    out = a.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n",
  "min_incremental_with_flow_skewness_penalty": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Incremental cost + penalty if the facility's remaining-flow distribution is highly skewed (harder to place later).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n    lam = 0.15\n\n    def skewness(x: np.ndarray) -> float:\n        x = x.astype(float)\n        m = float(x.mean())\n        s = float(x.std()) + 1e-12\n        z = (x - m) / s\n        return float(np.mean(z**3))\n\n    best = float(\"inf\")\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        # skewness of remaining interactions (to unassigned)\n        rem = sym[f, un].copy().astype(float)\n        # remove self if present\n        rem[un == f] = 0.0\n        sk = abs(skewness(rem)) if rem.size >= 3 else 0.0\n\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc + lam * sk * (abs(inc) + 1.0)\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "max_regret3_facility_then_best_location": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility with largest regret between best and 3rd-best locations (by incremental cost); then assign to best location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    def inc(f: int, l: int) -> float:\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_regret = -1.0\n    best_f = int(un[0])\n    best_l = int(free[0])\n\n    for f in un.astype(int):\n        costs = np.array([inc(f, int(l)) for l in free], dtype=float)\n        if costs.size == 1:\n            regret = float('inf')\n            l_pick = int(free[0])\n        else:\n            idx = np.argsort(costs)\n            l_pick = int(free[int(idx[0])])\n            k = min(2, costs.size - 1)  # 3rd best if possible, else 2nd best\n            regret = float(costs[idx[k]] - costs[idx[0]])\n        if regret > best_regret:\n            best_regret = regret\n            best_f = int(f)\n            best_l = int(l_pick)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "stochastic_unassigned_sampling_min_inc": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Sample a subset of unassigned facilities and free locations; choose min incremental among sampled pairs.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    rng = np.random.default_rng()\n    fu = min(un.size, max(3, int(np.ceil(0.35 * un.size))))\n    fl = min(free.size, max(3, int(np.ceil(0.35 * free.size))))\n    su = rng.choice(un, size=fu, replace=False).astype(int)\n    sl = rng.choice(free, size=fl, replace=False).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf')\n    best_f, best_l = int(su[0]), int(sl[0])\n\n    for f in su:\n        for l in sl:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                   flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n            if inc < best:\n                best, best_f, best_l = inc, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "simulated_annealing_pair_choice": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Compute incremental cost for all pairs; sample next move via Boltzmann distribution with temperature based on progress.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = [(int(f), int(l)) for f in un for l in free]\n    m = len(pairs)\n\n    costs = np.zeros(m, dtype=float)\n    if ass.size == 0:\n        costs[:] = 0.0\n    else:\n        for i, (f, l) in enumerate(pairs):\n            costs[i] = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    progress = 1.0 - (un.size / max(1, n))\n    T = max(1e-6, 2.0 * (1.0 - progress) + 0.05)\n\n    c = costs - costs.min()\n    w = np.exp(-c / T)\n    w = w / (w.sum() + 1e-12)\n\n    idx = int(np.random.choice(m, p=w))\n    f, l = pairs[idx]\n\n    out = a.copy()\n    out[int(f)] = int(l)\n    return out.tolist()\n",
  "pseudo_tabu_by_hash_exclusion": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Greedy min incremental but exclude a small hash-determined subset of facilities/locations (pseudo-tabu, state-free).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    # deterministic hash from partial assignment\n    h = int(np.sum((np.arange(n, dtype=int) + 1) * (a + 2))) & 0xffffffff\n\n    # exclude ~10% of candidates (but never all)\n    fu = max(0, int(np.floor(0.10 * un.size)))\n    fl = max(0, int(np.floor(0.10 * free.size)))\n\n    if fu > 0:\n        order_u = np.argsort(((un * 2654435761) ^ h) & 0xffffffff)\n        ban_u = set(int(x) for x in un[order_u[:fu]])\n    else:\n        ban_u = set()\n\n    if fl > 0:\n        order_l = np.argsort(((free * 2246822519) ^ (h >> 1)) & 0xffffffff)\n        ban_l = set(int(x) for x in free[order_l[:fl]])\n    else:\n        ban_l = set()\n\n    cand_u = np.array([int(x) for x in un if int(x) not in ban_u], dtype=int)\n    cand_l = np.array([int(x) for x in free if int(x) not in ban_l], dtype=int)\n\n    if cand_u.size == 0:\n        cand_u = un.astype(int)\n    if cand_l.size == 0:\n        cand_l = free.astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf')\n    best_f, best_l = int(cand_u[0]), int(cand_l[0])\n\n    for f in cand_u:\n        for l in cand_l:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                   flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n            if inc < best:\n                best, best_f, best_l = inc, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "upper_bound_completion_greedy_score": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Score each candidate by (incremental now + greedy completion upper bound for one more step); pick minimum.'''\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n\n    un0 = np.flatnonzero(a0 == -1).astype(int)\n    if un0.size == 0:\n        return a0.tolist()\n\n    used0 = np.zeros(n, dtype=bool)\n    if np.any(a0 != -1):\n        used0[a0[a0 != -1]] = True\n    free0 = np.flatnonzero(~used0).astype(int)\n\n    ass0 = np.flatnonzero(a0 != -1).astype(int)\n    locs0 = a0[ass0].astype(int)\n\n    def inc(a: np.ndarray, f: int, l: int) -> float:\n        ass = np.flatnonzero(a != -1).astype(int)\n        if ass.size == 0:\n            return 0.0\n        locs = a[ass].astype(int)\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # precompute immediate incrementals\n    pairs = [(int(f), int(l)) for f in un0 for l in free0]\n\n    best_score = float('inf')\n    best_pair = pairs[0]\n\n    for f, l in pairs:\n        a1 = a0.copy(); a1[int(f)] = int(l)\n        score = inc(a0, int(f), int(l))\n\n        # greedy completion UB for one more placement\n        un1 = np.flatnonzero(a1 == -1).astype(int)\n        used1 = np.zeros(n, dtype=bool); used1[a1[a1 != -1]] = True\n        free1 = np.flatnonzero(~used1).astype(int)\n\n        if un1.size and free1.size:\n            best_next = float('inf')\n            for f2 in un1:\n                for l2 in free1:\n                    c2 = inc(a1, int(f2), int(l2))\n                    if c2 < best_next:\n                        best_next = c2\n            score = score + 0.35 * best_next\n\n        if score < best_score:\n            best_score = score\n            best_pair = (int(f), int(l))\n\n    out = a0.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n",
  "dual_potential_gap_minimization": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose pair that best matches facility 'potential' with location 'potential' (dual-inspired), then tie-break by incremental.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            gap = abs(float(pf[int(f)] - cl[int(l)]))\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                   flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n            score = gap + 1e-6 * inc\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "median_interaction_cost_pair": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick pair minimizing the median of interaction costs to already-assigned facilities (robust alternative to sum).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                score = 0.0\n            else:\n                v = (flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                     flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]).astype(float)\n                score = float(np.median(v))\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "minimax_incremental_worst_edge": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose pair that minimizes the worst (maximum) interaction cost to already-assigned facilities (minimax).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                score = 0.0\n            else:\n                v = (flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                     flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]).astype(float)\n                score = float(np.max(v))\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "maximin_alignment_score": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Maximize a conservative alignment: min( normalized facility potential, normalized location centrality ) among pairs.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n\n    best = -float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            score = float(min(pf[int(f)], cl[int(l)]))\n            if score > best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "farthest_point_flow_clustering_representative": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick a 'cluster representative' facility using farthest-point traversal in flow-space; place at best location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    # build 2-3 centers among unassigned via farthest-point on a distance derived from sym flow\n    k = min(3, max(1, un.size))\n    centers = [int(un[0])]\n\n    # distance: 1/(flow+eps) using connection strength to centers (larger is farther)\n    eps = 1e-6\n    for _ in range(1, k):\n        best_f = int(un[0])\n        best_d = -1.0\n        for f in un.astype(int):\n            d = 0.0\n            for c in centers:\n                d += 1.0 / (sym[int(f), int(c)] + eps)\n            if d > best_d:\n                best_d = d\n                best_f = int(f)\n        centers.append(best_f)\n\n    # representative: center with largest total sym flow to other unassigned (densest center)\n    center_scores = [float(np.sum(sym[int(c), un])) for c in centers]\n    f = int(centers[int(np.argmax(center_scores))])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best_l = int(free[0])\n    best = float('inf')\n    for l in free.astype(int):\n        if ass.size == 0:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                               flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n        if inc < best:\n            best, best_l = inc, int(l)\n\n    out = a.copy()\n    out[int(f)] = int(best_l)\n    return out.tolist()\n",
  "free_location_degree_centrality_then_best_facility": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick free location with highest similarity-degree (1/d); assign the facility that best fits it by incremental cost.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    # similarity graph on locations\n    S = 1.0 / (distance_matrix.astype(float) + 1e-6)\n    deg = S[free].sum(axis=1).astype(float)\n    l = int(free[int(np.argmax(deg))])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best_f = int(un[0])\n    best = float('inf')\n    for f in un.astype(int):\n        if ass.size == 0:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                               flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n        if inc < best:\n            best, best_f = inc, int(f)\n\n    out = a.copy()\n    out[int(best_f)] = int(l)\n    return out.tolist()\n",
  "maximize_entropy_of_location_costs": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility whose incremental costs over locations have highest entropy (most 'uncertain'), then choose its best location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    def costs_for_f(f: int) -> np.ndarray:\n        if ass.size == 0:\n            return np.zeros(free.size, dtype=float)\n        c = np.zeros(free.size, dtype=float)\n        for i, l in enumerate(free.astype(int)):\n            c[i] = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n        return c\n\n    best_ent = -float('inf')\n    best_f = int(un[0])\n    best_l = int(free[0])\n\n    for f in un.astype(int):\n        c = costs_for_f(int(f))\n        # convert to a probability distribution via softmax of -cost\n        x = -(c - c.min())\n        p = np.exp(x - x.max())\n        p = p / (p.sum() + 1e-12)\n        ent = float(-np.sum(p * np.log(p + 1e-12)))\n        l_pick = int(free[int(np.argmin(c))])\n        if ent > best_ent:\n            best_ent = ent\n            best_f = int(f)\n            best_l = l_pick\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "diversify_by_flow_distance_from_assigned": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick among top-k low-incremental pairs the one whose facility is most dissimilar (in flow-space) to assigned facilities.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = []\n    incs = []\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                   flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n            pairs.append((int(f), int(l)))\n            incs.append(float(inc))\n\n    incs = np.asarray(incs, dtype=float)\n    k = max(1, int(np.ceil(0.08 * incs.size)))\n    top = np.argsort(incs)[:k]\n\n    # flow dissimilarity: L2 distance between facility flow row and mean assigned flow row\n    if ass.size:\n        mu = flow_matrix[ass].mean(axis=0).astype(float)\n    else:\n        mu = flow_matrix.mean(axis=0).astype(float)\n\n    best = -float('inf')\n    best_pair = pairs[int(top[0])]\n\n    for idx in top:\n        f, l = pairs[int(idx)]\n        d = float(np.linalg.norm(flow_matrix[int(f)].astype(float) - mu))\n        score = d - 1e-6 * float(incs[int(idx)])\n        if score > best:\n            best = score\n            best_pair = (int(f), int(l))\n\n    out = a.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n",
  "bilinear_flow_distance_tradeoff": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose pair minimizing: alpha*incremental + (1-alpha)*[facility_potential * location_centrality_penalty].'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    cent = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cent = (cent - cent.min()) / (cent.max() - cent.min() + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    alpha = 0.25 + 0.70 * progress  # rely more on true incremental later\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                   flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n            penalty = float(pf[int(f)] * (1.0 - cent[int(l)]))\n            score = alpha * inc + (1.0 - alpha) * penalty * (abs(inc) + 1.0)\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "randomized_rounding_softmax_pairs": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Compute incremental costs, build softmax over -cost, and sample a move (randomized rounding).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = [(int(f), int(l)) for f in un for l in free]\n    m = len(pairs)\n\n    costs = np.zeros(m, dtype=float)\n    if ass.size == 0:\n        costs[:] = 0.0\n    else:\n        for i, (f, l) in enumerate(pairs):\n            costs[i] = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    x = -(costs - costs.min())\n    # temperature based on dispersion\n    T = float(max(1e-6, np.std(costs) + 1e-6))\n    p = np.exp((x - x.max()) / T)\n    p = p / (p.sum() + 1e-12)\n\n    idx = int(np.random.choice(m, p=p))\n    f, l = pairs[idx]\n\n    out = a.copy()\n    out[int(f)] = int(l)\n    return out.tolist()\n",
  "pairwise_conflict_penalty_flow_similarity": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Incremental cost + penalty if facility is flow-similar to an assigned facility whose location is near candidate location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # precompute normalized facility flow rows for cosine similarity\n    F = flow_matrix.astype(float)\n    norms = np.linalg.norm(F, axis=1) + 1e-12\n    Fn = (F.T / norms).T\n\n    lam = 0.20\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                inc = 0.0\n                pen = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                   flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n                # conflict: sum over assigned facilities of (cos_sim * exp(-dist))\n                cos = (Fn[int(f)] @ Fn[ass].T).astype(float)\n                near = np.exp(-distance_matrix[int(l), locs].astype(float))\n                pen = float(np.sum(cos * near))\n            score = inc + lam * pen * (abs(inc) + 1.0)\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "facility_max_stddev_then_best_location": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility with highest stddev of incremental costs across free locations (most sensitive), then pick its best location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best_f = int(un[0])\n    best_std = -1.0\n    best_l = int(free[0])\n\n    for f in un.astype(int):\n        if ass.size == 0:\n            costs = np.zeros(free.size, dtype=float)\n        else:\n            costs = np.zeros(free.size, dtype=float)\n            for i, l in enumerate(free.astype(int)):\n                costs[i] = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                        flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n        s = float(costs.std())\n        if s > best_std:\n            best_std = s\n            best_f = int(f)\n            best_l = int(free[int(np.argmin(costs))])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "location_max_stddev_then_best_facility": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick location with highest stddev of incremental costs across unassigned facilities, then pick best facility for it.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best_l = int(free[0])\n    best_std = -1.0\n    best_f = int(un[0])\n\n    for l in free.astype(int):\n        if ass.size == 0:\n            costs = np.zeros(un.size, dtype=float)\n        else:\n            costs = np.zeros(un.size, dtype=float)\n            for i, f in enumerate(un.astype(int)):\n                costs[i] = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                        flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n        s = float(costs.std())\n        if s > best_std:\n            best_std = s\n            best_l = int(l)\n            best_f = int(un[int(np.argmin(costs))])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "hotspot_hubs_penalize_consuming_central_locations": "import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Greedy incremental but penalize using highly-central locations early if many high-flow hubs remain unassigned.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    # hubness among remaining facilities\n    hub = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    hub_u = hub[un]\n    # fraction of hubs among remaining: top-25% mass\n    thr = np.quantile(hub_u, 0.75) if hub_u.size else 0.0\n    hub_frac = float(np.mean(hub_u >= thr)) if hub_u.size else 0.0\n\n    # location centrality\n    cent = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cent = (cent - cent.min()) / (cent.max() - cent.min() + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    lam = (1.0 - progress) * hub_frac * 0.75\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                   flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n            # penalize consuming central locations early if many hubs remain\n            score = inc + lam * float(cent[int(l)]) * (abs(inc) + 1.0)\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "min_incremental_cost_global_aug_0": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    # Pre\u2011compute reusable components\n    flow_f_ass = flow_matrix[un[:, None], ass]          # shape (len(un), len(ass))\n    flow_ass_f = flow_matrix[ass[:, None], un].T        # shape (len(un), len(ass))\n    dist_l_locs = distance_matrix[free[:, None], locs]  # shape (len(free), len(ass))\n    dist_locs_l = distance_matrix[locs[:, None], free]  # shape (len(ass), len(free))\n\n    best_f, best_l = None, None\n    best_val = np.inf\n\n    # Small deterministic noise to break ties\n    noise_factor = 1e-6\n\n    for i_f, f in enumerate(un):\n        # Vectorised delta for all free locations\n        delta_l = np.dot(flow_f_ass[i_f], dist_l_locs.T) + np.dot(flow_ass_f[i_f], dist_locs_l)\n        # Add noise proportional to indices\n        delta_l += noise_factor * (i_f * free + np.arange(free.size))\n        # Clip to avoid extreme values\n        delta_l = np.clip(delta_l, -1e12, 1e12)\n        min_idx = np.argmin(delta_l)\n        if delta_l[min_idx] < best_val:\n            best_val = delta_l[min_idx]\n            best_f = f\n            best_l = free[min_idx]\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "min_incremental_cost_global_aug_1": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    best_f, best_l = None, None\n    best_val = np.inf\n\n    temp = 0.5                     # temperature for softmin\n    epsilon = 1e-12                # to avoid division by zero\n    noise = 1e-7                   # deterministic tie\u2011breaker\n\n    f_idx = 0\n    while f_idx < un.size:\n        f = un[f_idx]\n        # Compute delta for this facility over all free locations\n        delta_l = np.zeros(free.size)\n        for l_idx, l in enumerate(free):\n            delta_l[l_idx] = np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                    flow_matrix[ass, f] * distance_matrix[locs, l])\n        # Add deterministic noise\n        delta_l += noise * (f_idx * free + np.arange(free.size))\n        # Softmin probabilities\n        min_val = np.min(delta_l)\n        exp_vals = np.exp(-(delta_l - min_val) / (temp + epsilon))\n        probs = exp_vals / (np.sum(exp_vals) + epsilon)\n        probs = np.clip(probs, 0, 1)\n        l_idx = np.argmax(probs)\n        if delta_l[l_idx] < best_val:\n            best_val = delta_l[l_idx]\n            best_f = f\n            best_l = free[l_idx]\n        f_idx += 1\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "min_incremental_cost_global_aug_2": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    top_k = 5\n    rng = np.random.default_rng(seed=42)\n\n    best_f, best_l = None, None\n    best_val = np.inf\n\n    for f in un:\n        # Vectorised delta for all free locations\n        flow_f_ass = flow_matrix[f, ass]\n        delta_l = np.dot(flow_f_ass, distance_matrix[free[:, None], locs].T) + \\\n                  np.dot(flow_matrix[ass, f], distance_matrix[locs[:, None], free])\n        delta_l = np.clip(delta_l, -1e12, 1e12)\n        # Get indices of the smallest top_k values\n        if delta_l.size > top_k:\n            kth = np.partition(delta_l, top_k - 1)[top_k - 1]\n            candidate_mask = delta_l <= kth\n            candidate_indices = np.where(candidate_mask)[0]\n        else:\n            candidate_indices = np.arange(delta_l.size)\n        # Deterministic noise for tie\u2011breaking\n        noise = 1e-8 * (f * free + np.arange(free.size))\n        delta_l += noise\n        # Randomly pick one of the top_k candidates\n        chosen_idx = rng.choice(candidate_indices)\n        if delta_l[chosen_idx] < best_val:\n            best_val = delta_l[chosen_idx]\n            best_f = f\n            best_l = free[chosen_idx]\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "max_flow_to_assigned_best_location_aug_3": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    candidates = np.where(assign == -1)[0]\n    if candidates.size == 0:\n        return list(assign)\n\n    occupied = np.zeros(n, dtype=bool)\n    occupied[assign[assign != -1]] = True\n    free_locs = np.where(~occupied)[0]\n\n    placed = np.where(assign != -1)[0]\n    placed_locs = assign[placed]\n\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    if placed.size:\n        w = (flow_mat[np.ix_(candidates, placed)].sum(axis=1) +\n             flow_mat[np.ix_(placed, candidates)].sum(axis=0)).astype(float)\n    else:\n        w = (flow_mat[candidates].sum(axis=1) +\n             flow_mat[:, candidates].sum(axis=0)).astype(float)\n\n    f_idx = int(candidates[np.argmax(w)])\n\n    def delta(l):\n        if placed.size == 0:\n            return 0.0\n        val = np.sum(flow_mat[f_idx, placed] * dist_mat[l, placed_locs] +\n                     flow_mat[placed, f_idx] * dist_mat[placed_locs, l])\n        avg = val / (placed.size + 1e-12)\n        return float(np.clip(avg, 0, np.inf))\n\n    deltas = np.array([delta(int(l)) for l in free_locs], dtype=float)\n    best_l = int(free_locs[np.argmin(deltas)])\n    out = list(assign)\n    out[f_idx] = best_l\n    return out\n\n",
  "max_flow_to_assigned_best_location_aug_4": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    candidates = np.where(assign == -1)[0]\n    if candidates.size == 0:\n        return list(assign)\n\n    occupied = np.zeros(n, dtype=bool)\n    occupied[assign[assign != -1]] = True\n    free_locs = np.where(~occupied)[0]\n\n    placed = np.where(assign != -1)[0]\n    placed_locs = assign[placed]\n\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    weight1, weight2 = 0.6, 0.4\n    if placed.size:\n        w1 = flow_mat[np.ix_(candidates, placed)].sum(axis=1)\n        w2 = flow_mat[np.ix_(placed, candidates)].sum(axis=0)\n        w = weight1 * w1 + weight2 * w2\n    else:\n        w1 = flow_mat[candidates].sum(axis=1)\n        w2 = flow_mat[:, candidates].sum(axis=0)\n        w = weight1 * w1 + weight2 * w2\n\n    top_k = 7\n    if top_k < w.size:\n        top_idx = np.argpartition(-w, top_k-1)[:top_k]\n    else:\n        top_idx = np.arange(w.size)\n    f_idx = int(candidates[top_idx[np.argmax(w[top_idx])]])\n\n    def delta(l):\n        if placed.size == 0:\n            return 0.0\n        val = np.sum(flow_mat[f_idx, placed] * dist_mat[l, placed_locs] +\n                     flow_mat[placed, f_idx] * dist_mat[placed_locs, l])\n        avg = val / (placed.size + 1e-12)\n        return float(np.clip(0.9 * avg, 0, np.inf))\n\n    deltas = np.array([delta(int(l)) for l in free_locs], dtype=float)\n    best_l = int(free_locs[np.argmin(deltas)])\n    out = list(assign)\n    out[f_idx] = best_l\n    return out\n\n",
  "max_flow_to_assigned_best_location_aug_5": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    rng = np.random.default_rng(seed=42)\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    candidates = np.where(assign == -1)[0]\n    if candidates.size == 0:\n        return list(assign)\n\n    occupied = np.zeros(n, dtype=bool)\n    occupied[assign[assign != -1]] = True\n    free_locs = np.where(~occupied)[0]\n\n    placed = np.where(assign != -1)[0]\n    placed_locs = assign[placed]\n\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    if placed.size:\n        w1 = flow_mat[np.ix_(candidates, placed)].sum(axis=1)\n        w2 = flow_mat[np.ix_(placed, candidates)].sum(axis=0)\n        w = (w1 + w2) / 2.0\n    else:\n        w1 = flow_mat[candidates].sum(axis=1)\n        w2 = flow_mat[:, candidates].sum(axis=0)\n        w = (w1 + w2) / 2.0\n\n    w += np.arange(w.size) * 1e-6\n    f_idx = int(candidates[np.argmax(w)])\n\n    def delta(l):\n        if placed.size == 0:\n            return 0.0\n        val = np.sum(flow_mat[f_idx, placed] * dist_mat[l, placed_locs] +\n                     flow_mat[placed, f_idx] * dist_mat[placed_locs, l])\n        avg = val / (placed.size + 1e-12)\n        return float(np.clip(avg, 0, np.inf))\n\n    deltas = np.array([delta(int(l)) for l in free_locs], dtype=float)\n    alpha = 1.0\n    probs = np.exp(-alpha * deltas)\n    probs = probs / (probs.sum() + 1e-12)\n    idx = rng.choice(len(free_locs), p=probs)\n    best_l = int(free_locs[idx])\n\n    out = list(assign)\n    out[f_idx] = best_l\n    return out\n\n",
  "max_flow_to_assigned_best_location_aug_6": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    candidates = np.where(assign == -1)[0]\n    if candidates.size == 0:\n        return list(assign)\n\n    occupied = np.zeros(n, dtype=bool)\n    occupied[assign[assign != -1]] = True\n    free_locs = np.where(~occupied)[0]\n\n    placed = np.where(assign != -1)[0]\n    placed_locs = assign[placed]\n\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    w1_factor, w2_factor = 0.5, 0.5\n    if placed.size:\n        w1 = flow_mat[np.ix_(candidates, placed)].sum(axis=1)\n        w2 = flow_mat[np.ix_(placed, candidates)].sum(axis=0)\n        w = w1_factor * w1 + w2_factor * w2\n    else:\n        w1 = flow_mat[candidates].sum(axis=1)\n        w2 = flow_mat[:, candidates].sum(axis=0)\n        w = w1_factor * w1 + w2_factor * w2\n\n    w += np.arange(w.size) * 1e-7\n\n    top_k = 5\n    if top_k < w.size:\n        top_idx = np.argpartition(-w, top_k-1)[:top_k]\n    else:\n        top_idx = np.arange(w.size)\n\n    f_idx = int(candidates[top_idx[np.argmax(w[top_idx])]])\n\n    def compute_delta(loc):\n        if placed.size == 0:\n            return 0.0\n        val = np.sum(flow_mat[f_idx, placed] * dist_mat[loc, placed_locs] +\n                     flow_mat[placed, f_idx] * dist_mat[placed_locs, loc])\n        avg = val / (placed.size + 1e-12)\n        return float(np.clip(avg, 0, np.inf))\n\n    deltas = np.array([compute_delta(int(l)) for l in free_locs], dtype=float)\n    best_l = int(free_locs[np.argmin(deltas)])\n\n    out = list(assign)\n    out[f_idx] = best_l\n    return out\n\n",
  "max_total_flow_best_location_aug_7": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Soft\u2011minimum selection with deterministic noise and clipping.\"\"\"\n    # rename for clarity\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    # convert to numpy array\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # facilities not yet placed\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    # locations that are still free\n    used_locs = a[a != -1]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    # facilities already placed\n    placed_facs = np.where(a != -1)[0]\n    placed_locs = a[placed_facs]\n\n    # total flow per facility (used for selecting next facility)\n    tot_flow = (flow_mat.sum(axis=1) + flow_mat.sum(axis=0)).astype(float)\n    f = int(unassigned[np.argmax(tot_flow[unassigned])])\n\n    if placed_facs.size == 0:\n        # first assignment: pick the location with smallest total distance\n        loc = int(free_locs[np.argmin(dist_mat[free_locs].sum(axis=1))])\n    else:\n        # incremental cost for each free location\n        inc = []\n        for loc in free_locs:\n            cost = (\n                flow_mat[f, placed_facs] * dist_mat[loc, placed_locs] +\n                flow_mat[placed_facs, f] * dist_mat[placed_locs, loc]\n            )\n            inc.append(float(cost.sum()))\n        inc = np.array(inc)\n\n        # add tiny deterministic noise to break ties\n        inc += np.arange(len(inc)) * 1e-9\n\n        # soft\u2011min probabilities\n        temp = 1.0\n        exp_vals = np.exp(-inc / (temp + 1e-12))\n        probs = exp_vals / (exp_vals.sum() + 1e-12)\n        probs = np.clip(probs, 1e-12, 1.0)  # avoid zeros\n        loc = int(free_locs[np.argmax(probs)])\n\n    out = list(current_assignment)\n    out[f] = loc\n    return out\n\n",
  "max_total_flow_best_location_aug_8": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Random top\u2011k choice with mean aggregation and noise.\"\"\"\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used_locs = a[a != -1]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    placed_facs = np.where(a != -1)[0]\n    placed_locs = a[placed_facs]\n\n    tot_flow = (flow_mat.sum(axis=1) + flow_mat.sum(axis=0)).astype(float)\n    f = int(unassigned[np.argmax(tot_flow[unassigned])])\n\n    if placed_facs.size == 0:\n        loc = int(free_locs[np.argmin(dist_mat[free_locs].mean(axis=1))])\n    else:\n        # mean weighted cost for each free location\n        inc_mean = []\n        for loc in free_locs:\n            cost = (\n                flow_mat[f, placed_facs] * dist_mat[loc, placed_locs] +\n                flow_mat[placed_facs, f] * dist_mat[placed_locs, loc]\n            )\n            inc_mean.append(float(cost.mean()))\n        inc_mean = np.array(inc_mean)\n\n        # add tiny noise\n        inc_mean += np.random.uniform(0, 1e-6, size=inc_mean.shape)\n\n        top_k = 7\n        k = min(top_k, len(free_locs))\n        top_indices = np.argsort(inc_mean)[:k]\n        chosen = np.random.choice(top_indices)\n        loc = int(free_locs[chosen])\n\n    out = list(current_assignment)\n    out[f] = loc\n    return out\n\n",
  "max_total_flow_best_location_aug_9": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Weighted median aggregation with scaling and clipping.\"\"\"\n    fm = flow_matrix\n    dm = distance_matrix\n\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used_locs = a[a != -1]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    placed_facs = np.where(a != -1)[0]\n    placed_locs = a[placed_facs]\n\n    tot_flow = (fm.sum(axis=1) + fm.sum(axis=0)).astype(float)\n    f = int(unassigned[np.argmax(tot_flow[unassigned])])\n\n    if placed_facs.size == 0:\n        loc = int(free_locs[np.argmin(dm[free_locs].sum(axis=1))])\n    else:\n        # compute weighted cost for each free location\n        inc = np.array([\n            (fm[f, placed_facs] * dm[loc, placed_locs] +\n             fm[placed_facs, f] * dm[placed_locs, loc]).sum()\n            for loc in free_locs\n        ])\n\n        # scaling with median\n        median_val = np.median(inc)\n        inc_scaled = 0.6 * inc + 0.4 * median_val\n\n        # add deterministic noise\n        inc_scaled += np.arange(len(inc_scaled)) * 1e-7\n\n        loc = int(free_locs[np.argmin(inc_scaled)])\n\n    out = list(current_assignment)\n    out[f] = loc\n    return out\n\n",
  "max_total_flow_best_location_aug_10": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Maximum aggregation with squared distances and deterministic tie\u2011breaking.\"\"\"\n    fm = flow_matrix\n    dm = distance_matrix**2  # proxy approximation\n\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used_locs = a[a != -1]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    placed_facs = np.where(a != -1)[0]\n    placed_locs = a[placed_facs]\n\n    tot_flow = (fm.sum(axis=1) + fm.sum(axis=0)).astype(float)\n    f = int(unassigned[np.argmax(tot_flow[unassigned])])\n\n    if placed_facs.size == 0:\n        loc = int(free_locs[np.argmax(dm[free_locs].sum(axis=1))])\n    else:\n        inc = np.array([\n            (fm[f, placed_facs] * dm[loc, placed_locs] +\n             fm[placed_facs, f] * dm[placed_locs, loc]).max()\n            for loc in free_locs\n        ])\n\n        # deterministic incremental noise to break ties\n        inc += np.arange(len(inc)) * 1e-8\n\n        loc = int(free_locs[np.argmax(inc)])\n\n    out = list(current_assignment)\n    out[f] = loc\n    return out\n\n",
  "max_total_flow_best_location_aug_11": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Functional style with np.take, clipping, and mean weighting.\"\"\"\n    fm = flow_matrix\n    dm = distance_matrix\n\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used_locs = a[a != -1]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    placed_facs = np.where(a != -1)[0]\n    placed_locs = a[placed_facs]\n\n    tot_flow = (fm.sum(axis=1) + fm.sum(axis=0)).astype(float)\n    f = int(unassigned[np.argmax(tot_flow[unassigned])])\n\n    if placed_facs.size == 0:\n        # pick location with smallest clipped mean distance\n        mean_dist = np.mean(dm[free_locs], axis=1)\n        mean_dist = np.clip(mean_dist, 1e-12, np.inf)\n        loc = int(free_locs[np.argmin(mean_dist)])\n    else:\n        # vectorised weighted mean cost\n        cost_matrix = (\n            fm[f, placed_facs][:, None] * dm[free_locs][:, None, :] +\n            fm[placed_facs, f][None, :] * dm[free_locs][:, :, None]\n        )\n        # sum over facilities then mean over locations\n        inc = cost_matrix.sum(axis=1).mean(axis=1)\n        inc = np.clip(inc, 1e-12, np.inf)\n\n        # deterministic tie\u2011breaking with small noise\n        inc += np.arange(len(inc)) * 1e-9\n\n        loc = int(free_locs[np.argmin(inc)])\n\n    out = list(current_assignment)\n    out[f] = loc\n    return out\n\n",
  "central_location_best_facility_aug_12": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 1 \u2013 syntactic rewrite, deterministic tie\u2011break, epsilon added to deltas.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # indices of unassigned facilities\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0]\n\n    # centrality: sum of distances to all locations (smaller is better)\n    dist_mat = distance_matrix\n    centrality = dist_mat[free_locs].sum(axis=1)\n    # add epsilon to avoid exact ties\n    centrality += 1e-12\n    target_loc = int(free_locs[np.argmin(centrality)])\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    flow_mat = flow_matrix\n\n    def delta(f):\n        if assigned.size == 0:\n            return 0.0\n        return float(np.sum(flow_mat[f, assigned] * dist_mat[target_loc, locs] +\n                            flow_mat[assigned, f] * dist_mat[locs, target_loc]))\n\n    # compute deltas with small deterministic noise for tie\u2011breaking\n    deltas = np.array([delta(int(f)) + 1e-9 * f for f in unassigned])\n    best_f = int(unassigned[np.argmin(deltas)])\n\n    out = list(current_assignment)\n    out[best_f] = target_loc\n    return out\n\n",
  "central_location_best_facility_aug_13": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 2 \u2013 weighted centrality, softmin selection, random top\u2011k choice.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # unassigned facilities\n    candidates = np.where(a == -1)[0]\n    if candidates.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0]\n\n    # weighted centrality: 60% sum + 40% max distance\n    dist_mat = distance_matrix\n    sum_dist = dist_mat[free_locs].sum(axis=1)\n    max_dist = dist_mat[free_locs].max(axis=1)\n    weighted_centrality = 0.6 * sum_dist + 0.4 * max_dist\n    # add epsilon to avoid division by zero in softmin\n    weighted_centrality += 1e-12\n    target_loc = int(free_locs[np.argmin(weighted_centrality)])\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n    flow_mat = flow_matrix\n\n    def delta(f):\n        if assigned.size == 0:\n            return 0.0\n        return float(np.sum(flow_mat[f, assigned] * dist_mat[target_loc, locs] +\n                            flow_mat[assigned, f] * dist_mat[locs, target_loc]))\n\n    deltas = np.array([delta(int(f)) for f in candidates])\n    # softmin probabilities\n    tau = 1.0\n    exp_vals = np.exp(-deltas / (tau + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # select top_k indices\n    top_k = 7\n    top_indices = np.argpartition(deltas, top_k)[:top_k]\n    top_candidates = candidates[top_indices]\n    top_probs = probs[top_indices]\n    # normalize probabilities\n    top_probs = top_probs / (np.sum(top_probs) + 1e-12)\n\n    # random choice weighted by softmin among top_k\n    chosen_idx = np.random.choice(top_candidates, p=top_probs)\n    best_f = int(chosen_idx)\n\n    out = list(current_assignment)\n    out[best_f] = target_loc\n    return out\n\n",
  "central_location_best_facility_aug_14": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 3 \u2013 vectorised delta, median aggregation, random top\u2011k selection.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0]\n\n    # centrality via median of distances\n    dist_mat = distance_matrix\n    med_centrality = np.median(dist_mat[free_locs], axis=1)\n    target_loc = int(free_locs[np.argmin(med_centrality)])\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n    flow_mat = flow_matrix\n\n    if assigned.size == 0:\n        deltas = np.zeros(unassigned.shape[0], dtype=float)\n    else:\n        # broadcast to compute delta for all unassigned at once\n        f_arr = unassigned[:, None]\n        ass_arr = assigned[None, :]\n        flow_terms = flow_mat[f_arr, ass_arr] * dist_mat[target_loc, locs]\n        flow_terms += flow_mat[ass_arr, f_arr] * dist_mat[locs, target_loc]\n        deltas = np.sum(flow_terms, axis=1).astype(float)\n\n    # clip deltas to avoid negative values\n    deltas = np.clip(deltas, 0, None)\n\n    # random choice among top 5 minimal deltas\n    top_k = 5\n    top_indices = np.argpartition(deltas, top_k)[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n    best_f = int(unassigned[chosen_idx])\n\n    out = list(current_assignment)\n    out[best_f] = target_loc\n    return out\n\n",
  "central_location_best_facility_aug_15": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 4 \u2013 squared distance proxy, max\u2011based centrality, deterministic tie\u2011break.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0]\n\n    # proxy centrality: inverse of squared distance sum, clipped to [0,1]\n    dist_mat = distance_matrix\n    sq_sum = np.sum(dist_mat[free_locs] ** 2, axis=1)\n    inv_centrality = 1.0 / (sq_sum + 1e-12)\n    inv_centrality = np.clip(inv_centrality, 0.0, 1.0)\n    target_loc = int(free_locs[np.argmax(inv_centrality)])\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n    flow_mat = flow_matrix\n\n    if assigned.size == 0:\n        deltas = np.zeros(unassigned.shape[0], dtype=float)\n    else:\n        f_arr = unassigned[:, None]\n        ass_arr = assigned[None, :]\n        flow_terms = flow_mat[f_arr, ass_arr] * dist_mat[target_loc, locs]\n        flow_terms += flow_mat[ass_arr, f_arr] * dist_mat[locs, target_loc]\n        deltas = np.sum(flow_terms, axis=1).astype(float)\n\n    # deterministic tie\u2011break by adding small epsilon times index\n    deltas += 1e-9 * unassigned\n    best_idx = int(np.argmin(deltas))\n    best_f = int(unassigned[best_idx])\n\n    out = list(current_assignment)\n    out[best_f] = target_loc\n    return out\n\n",
  "central_location_best_facility_aug_16": "from typing import List\nimport numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 5 \u2013 softmax selection, mean centrality, clipping, random weighted choice.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0]\n\n    # mean centrality with softmax\n    dist_mat = distance_matrix\n    mean_centrality = dist_mat[free_locs].mean(axis=1)\n    # softmax with temperature\n    tau = 0.5\n    exp_vals = np.exp(-mean_centrality / (tau + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    target_loc = int(free_locs[np.random.choice(len(free_locs), p=probs)])\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n    flow_mat = flow_matrix\n\n    if assigned.size == 0:\n        deltas = np.zeros(unassigned.shape[0], dtype=float)\n    else:\n        f_arr = unassigned[:, None]\n        ass_arr = assigned[None, :]\n        flow_terms = flow_mat[f_arr, ass_arr] * dist_mat[target_loc, locs]\n        flow_terms += flow_mat[ass_arr, f_arr] * dist_mat[locs, target_loc]\n        deltas = np.sum(flow_terms, axis=1).astype(float)\n\n    # clip deltas to avoid negative or overflow\n    deltas = np.clip(deltas, 0, None)\n\n    # softmax over negative deltas to prefer smaller cost\n    exp_vals = np.exp(-deltas / (1.0 + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    best_f = int(unassigned[np.random.choice(len(unassigned), p=probs)])\n\n    out = list(current_assignment)\n    out[best_f] = target_loc\n    return out\n\n",
  "max_regret_2_insertion_aug_17": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Regret\u20112 selection using a vectorized delta computation and a deterministic\n    tie\u2011breaking noise.  The function keeps the original API but rewrites the\n    inner logic to be more numpy\u2011centric.\n    \"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # Facilities that have not yet been assigned\n    candidates = np.where(a == -1)[0]\n    if candidates.size == 0:\n        return list(current_assignment)\n\n    # Locations that are still free\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    # Already assigned facilities and their locations\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    # Helper that returns the incremental cost of putting facility `f`\n    # into location `l` given the current partial assignment.\n    def delta(f: int, l: int) -> float:\n        if assigned.size == 0:\n            return 0.0\n        return float(\n            np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                   flow_matrix[assigned, f] * distance_matrix[locs, l])\n        )\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(candidates.size, dtype=float) * 1e-6\n\n    best_f, best_l = int(candidates[0]), int(free[0])\n    best_reg = -1e12\n\n    idx = 0\n    while idx < candidates.size:\n        f = int(candidates[idx])\n        costs = np.array([delta(f, int(l)) for l in free], dtype=float)\n\n        if costs.size == 1:\n            reg, lbest = np.inf, int(free[0])\n        else:\n            order = np.argsort(costs)\n            reg = costs[order[1]] - costs[order[0]]\n            lbest = int(free[order[0]])\n\n        # Add deterministic noise and clip the regret\n        reg += noise[idx]\n        reg = np.clip(reg, -1e6, 1e6)\n\n        if reg > best_reg:\n            best_reg, best_f, best_l = reg, f, lbest\n        idx += 1\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "max_regret_2_insertion_aug_18": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Soft\u2011min based selection with a scaling factor and a top\u2011k filtering\n    step.  The function uses a probability distribution derived from the\n    negative costs to choose the facility that is expected to be cheapest.\n    \"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # Unassigned facilities and free locations\n    candidates = np.where(a == -1)[0]\n    if candidates.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    def delta(f: int, l: int) -> float:\n        if assigned.size == 0:\n            return 0.0\n        return float(\n            np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                   flow_matrix[assigned, f] * distance_matrix[locs, l])\n        )\n\n    # Parameters\n    scale = 0.5          # softness of the exponential\n    top_k = 7            # how many facilities to keep after ranking\n\n    # Compute a soft\u2011min score for each facility\n    scores = []\n    for f in candidates:\n        costs = np.array([delta(f, int(l)) for l in free], dtype=float)\n        probs = np.exp(-scale * costs) + 1e-12\n        probs /= np.sum(probs) + 1e-12\n        softmin = np.sum(costs * probs)\n        scores.append((softmin, f))\n\n    # Keep the top\u2011k facilities with the smallest soft\u2011min\n    scores.sort(key=lambda x: x[0])\n    top_candidates = scores[:min(top_k, len(scores))]\n\n    # Pick the best facility among the top\u2011k\n    best_f = int(top_candidates[0][1])\n    costs_best = np.array([delta(best_f, int(l)) for l in free], dtype=float)\n    best_l = int(free[np.argmin(costs_best)])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "max_regret_2_insertion_aug_19": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Median\u2011based regret selection.  Among the top\u20113 best locations for the\n    chosen facility a deterministic random choice is made.  A small\n    deterministic noise is added to break ties.\n    \"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    candidates = np.where(a == -1)[0]\n    if candidates.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    def delta(f: int, l: int) -> float:\n        if assigned.size == 0:\n            return 0.0\n        return float(\n            np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                   flow_matrix[assigned, f] * distance_matrix[locs, l])\n        )\n\n    rng = np.random.default_rng(seed=42)\n    noise = np.arange(candidates.size, dtype=float) * 1e-6\n\n    best_f, best_l = int(candidates[0]), int(free[0])\n    best_median = np.inf\n\n    for idx, f in enumerate(candidates):\n        costs = np.array([delta(f, int(l)) for l in free], dtype=float)\n        median_cost = np.median(costs)\n        median_cost += noise[idx]\n        if median_cost < best_median:\n            best_median, best_f = median_cost, int(f)\n\n    # Pick one of the top\u20113 best locations for the chosen facility\n    costs_best = np.array([delta(best_f, int(l)) for l in free], dtype=float)\n    top_indices = np.argsort(costs_best)[:3]\n    chosen_idx = rng.choice(top_indices)\n    best_l = int(free[chosen_idx])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "max_regret_2_insertion_aug_20": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Uses the arithmetic mean (computed manually with an epsilon to avoid\n    division by zero) to evaluate each facility.  The facility with the\n    smallest mean incremental cost is chosen, and its best location\n    is assigned.\n    \"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    candidates = np.where(a == -1)[0]\n    if candidates.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    def delta(f: int, l: int) -> float:\n        if assigned.size == 0:\n            return 0.0\n        return float(\n            np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                   flow_matrix[assigned, f] * distance_matrix[locs, l])\n        )\n\n    best_f, best_l = int(candidates[0]), int(free[0])\n    best_mean = np.inf\n\n    for f in candidates:\n        costs = np.array([delta(f, int(l)) for l in free], dtype=float)\n        mean_cost = np.sum(costs) / (len(costs) + 1e-12)   # epsilon added\n        mean_cost = np.clip(mean_cost, -1e6, 1e6)\n        if mean_cost < best_mean:\n            best_mean, best_f = mean_cost, int(f)\n\n    # Assign the best location for the chosen facility\n    costs_best = np.array([delta(best_f, int(l)) for l in free], dtype=float)\n    best_l = int(free[np.argmin(costs_best)])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "max_regret_2_insertion_aug_21": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Uses a proxy approximation: pre\u2011computes the product of the flow and\n    distance matrices to estimate incremental costs.  A softmax over the\n    negative proxy costs selects the facility, and the facility\u2019s best\n    location is chosen.  An epsilon is added to denominators to avoid\n    division by zero.\n    \"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    candidates = np.where(a == -1)[0]\n    if candidates.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    # Proxy matrix: flow * distance (full product)\n    proxy = flow_matrix @ distance_matrix\n\n    def proxy_delta(f: int, l: int) -> float:\n        if assigned.size == 0:\n            return 0.0\n        # Sum of proxy values for all interactions with already assigned facilities\n        return float(\n            np.sum(proxy[f, assigned] * distance_matrix[l, locs] +\n                   proxy[assigned, f] * distance_matrix[locs, l])\n        )\n\n    # Softmax parameters\n    beta = 0.7\n    eps = 1e-12\n\n    scores = []\n    for f in candidates:\n        costs = np.array([proxy_delta(f, int(l)) for l in free], dtype=float)\n        # Convert to a probability distribution\n        logits = -beta * costs\n        logits -= np.max(logits)  # numerical stability\n        probs = np.exp(logits) + eps\n        probs /= np.sum(probs) + eps\n        # Expected cost under the distribution\n        exp_cost = np.sum(costs * probs)\n        scores.append((exp_cost, f))\n\n    # Choose the facility with the lowest expected proxy cost\n    best_f = int(min(scores, key=lambda x: x[0])[1])\n\n    # Assign the facility to its best location\n    best_l = int(free[np.argmin(np.array([proxy_delta(best_f, int(l)) for l in free], dtype=float))])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "flow_weighted_regret_aug_22": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Regret\u20112 weighted by flow strength.\n    Vectorised delta computation and deterministic noise for tie\u2011breaking.\"\"\"\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    n = len(current_assignment)\n    a = np.array(current_assignment, dtype=int)\n\n    # Unassigned facilities and free locations\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return current_assignment\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    # Total flow per facility (row + column sums)\n    tot = (flow_mat.sum(axis=1) + flow_mat.sum(axis=0)).astype(float)\n\n    # Helper to compute delta for a given facility f and all free locations\n    def delta_vector(f):\n        # Contributions from f \u2192 assigned\n        flow_f_ass = flow_mat[f, ass]          # shape (k,)\n        # Contributions from assigned \u2192 f\n        flow_ass_f = flow_mat[ass, f]          # shape (k,)\n\n        # dist[l, locs] for all free l: shape (free, k)\n        dist_l_locs = dist_mat[free[:, None], locs]\n        # dist[locs, l] for all free l: shape (k, free)\n        dist_locs_l = dist_mat[locs[:, None], free]\n\n        # Sum over assigned facilities\n        cost_l = (flow_f_ass @ dist_l_locs.T).sum(axis=1) + \\\n                 (flow_ass_f @ dist_locs_l).sum(axis=0)\n        return cost_l\n\n    best_f = int(un[0])\n    best_l = int(free[0])\n    best_score = -1.0\n\n    # Deterministic noise to break ties\n    noise = 1e-9 * np.arange(un.size)\n\n    for idx_f, f in enumerate(un):\n        costs = delta_vector(f)\n        # Sort costs, pick best and second best\n        sorted_idx = np.argsort(costs)\n        best_cost = costs[sorted_idx[0]]\n        second_cost = costs[sorted_idx[1]] if costs.size > 1 else best_cost + 1.0\n\n        regret = second_cost - best_cost\n        strength = tot[f] / (tot[f] + 1e-12)          # epsilon guard\n        score = (regret * strength) + noise[idx_f]   # tie\u2011breaking noise\n\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[sorted_idx[0]])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "flow_weighted_regret_aug_23": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Uses while loops, np.mean for delta and a 0.7 weight on regret.\"\"\"\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    n = len(current_assignment)\n    a = np.array(current_assignment, dtype=int)\n\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return current_assignment\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    tot = (flow_mat.sum(axis=1) + flow_mat.sum(axis=0)).astype(float)\n\n    best_f = int(un[0])\n    best_l = int(free[0])\n    best_score = -1.0\n\n    idx = 0\n    while idx < un.size:\n        f = un[idx]\n        # Compute delta using np.mean instead of sum\n        flow_f_ass = flow_mat[f, ass]\n        flow_ass_f = flow_mat[ass, f]\n\n        dist_l_locs = dist_mat[free[:, None], locs]\n        dist_locs_l = dist_mat[locs[:, None], free]\n\n        cost_l = (flow_f_ass @ dist_l_locs.T).mean(axis=1) + \\\n                 (flow_ass_f @ dist_locs_l).mean(axis=0)\n\n        sorted_idx = np.argsort(cost_l)\n        best_cost = cost_l[sorted_idx[0]]\n        second_cost = cost_l[sorted_idx[1]] if cost_l.size > 1 else best_cost + 1.0\n\n        regret = 0.7 * (second_cost - best_cost)          # 0.7 weight\n        strength = np.clip(tot[f] / (tot[f] + 1e-12), 0.0, 1.0)\n        score = regret * strength\n\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[sorted_idx[0]])\n\n        idx += 1\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "flow_weighted_regret_aug_24": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Softmin selection among top\u20113 candidates with random choice.\"\"\"\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    n = len(current_assignment)\n    a = np.array(current_assignment, dtype=int)\n\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return current_assignment\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    tot = (flow_mat.sum(axis=1) + flow_mat.sum(axis=0)).astype(float)\n\n    best_f = int(un[0])\n    best_l = int(free[0])\n    best_score = -1.0\n\n    for f in un:\n        # Vectorised delta\n        flow_f_ass = flow_mat[f, ass]\n        flow_ass_f = flow_mat[ass, f]\n        dist_l_locs = dist_mat[free[:, None], locs]\n        dist_locs_l = dist_mat[locs[:, None], free]\n        cost_l = (flow_f_ass @ dist_l_locs.T).sum(axis=1) + \\\n                 (flow_ass_f @ dist_locs_l).sum(axis=0)\n\n        # Softmin probabilities\n        temp = 0.5\n        probs = np.exp(-cost_l / temp)\n        probs /= probs.sum()\n\n        # Choose among top\u20113 with weighted random selection\n        top_k = min(3, len(cost_l))\n        top_idx = np.argpartition(cost_l, top_k - 1)[:top_k]\n        top_probs = probs[top_idx]\n        top_probs /= top_probs.sum()\n        chosen = np.random.choice(top_idx, p=top_probs)\n\n        regret = cost_l[chosen] - cost_l[np.argmin(cost_l)]\n        strength = tot[f] / (tot[f] + 1e-12)\n        score = regret * strength\n\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[chosen])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "flow_weighted_regret_aug_25": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Uses np.max for delta aggregation and a 0.4 weight on regret.\"\"\"\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    n = len(current_assignment)\n    a = np.array(current_assignment, dtype=int)\n\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return current_assignment\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    tot = (flow_mat.sum(axis=1) + flow_mat.sum(axis=0)).astype(float)\n\n    best_f = int(un[0])\n    best_l = int(free[0])\n    best_score = -1.0\n\n    for f in un:\n        flow_f_ass = flow_mat[f, ass]\n        flow_ass_f = flow_mat[ass, f]\n        dist_l_locs = dist_mat[free[:, None], locs]\n        dist_locs_l = dist_mat[locs[:, None], free]\n\n        cost_l = (flow_f_ass @ dist_l_locs.T).max(axis=1) + \\\n                 (flow_ass_f @ dist_locs_l).max(axis=0)\n\n        sorted_idx = np.argsort(cost_l)\n        best_cost = cost_l[sorted_idx[0]]\n        second_cost = cost_l[sorted_idx[1]] if cost_l.size > 1 else best_cost + 1.0\n\n        regret = 0.4 * (second_cost - best_cost)          # 0.4 weight\n        strength = tot[f] / (tot[f] + 1e-12)\n        score = regret * strength\n\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[sorted_idx[0]])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "flow_weighted_regret_aug_26": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Proxy approximation: delta approximated by matrix multiplication.\"\"\"\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    n = len(current_assignment)\n    a = np.array(current_assignment, dtype=int)\n\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return current_assignment\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    tot = (flow_mat.sum(axis=1) + flow_mat.sum(axis=0)).astype(float)\n\n    best_f = int(un[0])\n    best_l = int(free[0])\n    best_score = -1.0\n\n    # Pre\u2011compute flow rows and columns for all facilities\n    flow_rows = flow_mat\n    flow_cols = flow_mat.T\n\n    for f in un:\n        # Approximate delta: dot product of flow row with distance column\n        # and dot product of flow column with distance row\n        approx_cost = (flow_rows[f, :] @ dist_mat[:, free]) + \\\n                      (flow_cols[f, :] @ dist_mat[free, :])\n\n        sorted_idx = np.argsort(approx_cost)\n        best_cost = approx_cost[sorted_idx[0]]\n        second_cost = approx_cost[sorted_idx[1]] if approx_cost.size > 1 else best_cost + 1.0\n\n        regret = second_cost - best_cost\n        strength = tot[f] / (tot[f] + 1e-12)\n        score = regret * strength\n\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[sorted_idx[0]])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "minimax_interaction_aug_27": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorized minimax with deterministic noise and clipping.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned_facilities = np.where(a != -1)[0]\n    assigned_locs = a[assigned_facilities]\n\n    # Sub\u2011matrices for vectorised calculations\n    flow_sub = flow_matrix[np.ix_(unassigned, assigned_facilities)]\n    dist_sub = distance_matrix[np.ix_(free_locs, assigned_locs)]\n\n    # Broadcast to obtain all pairwise interaction costs\n    cost1 = flow_sub[:, :, None] * dist_sub[None, :, :]\n    cost2 = flow_sub.T[:, :, None] * dist_sub[None, :, :]\n    worst_cost = np.max(cost1 + cost2, axis=(0, 1))\n\n    # Clip to avoid overflow and add epsilon to denominator (no division here, but keep style)\n    worst_cost = np.clip(worst_cost, 0, 1e12)\n    worst_cost = worst_cost / (1.0 + 1e-12)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(unassigned.size * free_locs.size, dtype=float).reshape(unassigned.size, free_locs.size) * 1e-8\n    scores = worst_cost + noise\n\n    # Choose the pair with minimal score\n    idx = np.unravel_index(np.argmin(scores, axis=None), scores.shape)\n    best_f = unassigned[idx[0]]\n    best_l = free_locs[idx[1]]\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "minimax_interaction_aug_28": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy minimax with while loops and random top\u2011k selection.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned_facilities = np.where(a != -1)[0]\n    assigned_locs = a[assigned_facilities]\n\n    best_f = int(unassigned[0])\n    best_l = int(free_locs[0])\n    best_score = float(\"inf\")\n\n    # Random top\u2011k selection\n    rng = np.random.default_rng(1234)\n    top_k = 5\n    for f in unassigned:\n        for l in free_locs:\n            if assigned_facilities.size == 0:\n                w = 0.0\n            else:\n                c1 = flow_matrix[f, assigned_facilities] * distance_matrix[l, assigned_locs]\n                c2 = flow_matrix[assigned_facilities, f] * distance_matrix[assigned_locs, l]\n                w = float(np.max(c1 + c2))\n            # Clip and add epsilon to denominator\n            w = np.clip(w, 0, 1e12) / (1.0 + 1e-12)\n            if w < best_score:\n                best_score = w\n                best_f, best_l = f, l\n\n    # Gather all candidate pairs with their scores\n    scores = []\n    for f in unassigned:\n        for l in free_locs:\n            if assigned_facilities.size == 0:\n                w = 0.0\n            else:\n                c1 = flow_matrix[f, assigned_facilities] * distance_matrix[l, assigned_locs]\n                c2 = flow_matrix[assigned_facilities, f] * distance_matrix[assigned_locs, l]\n                w = float(np.max(c1 + c2))\n            w = np.clip(w, 0, 1e12) / (1.0 + 1e-12)\n            scores.append((w, f, l))\n\n    scores.sort(key=lambda x: x[0])\n    top_candidates = scores[:top_k]\n    _, chosen_f, chosen_l = rng.choice(top_candidates, replace=False)\n    out = list(current_assignment)\n    out[chosen_f] = chosen_l\n    return out\n\n",
  "minimax_interaction_aug_29": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Softmin\u2011based assignment using exponential weighting.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned_facilities = np.where(a != -1)[0]\n    assigned_locs = a[assigned_facilities]\n\n    # Compute worst cost for each pair\n    worst_cost = np.empty((unassigned.size, free_locs.size), dtype=float)\n    for i, f in enumerate(unassigned):\n        for j, l in enumerate(free_locs):\n            if assigned_facilities.size == 0:\n                w = 0.0\n            else:\n                c1 = flow_matrix[f, assigned_facilities] * distance_matrix[l, assigned_locs]\n                c2 = flow_matrix[assigned_facilities, f] * distance_matrix[assigned_locs, l]\n                w = float(np.max(c1 + c2))\n            w = np.clip(w, 0, 1e12) / (1.0 + 1e-12)\n            worst_cost[i, j] = w\n\n    # Softmin weighting\n    beta = 1.0\n    exp_weights = np.exp(-beta * worst_cost)\n    exp_weights = np.clip(exp_weights, 1e-300, None)  # prevent underflow\n    probs = exp_weights / (np.sum(exp_weights) + 1e-12)\n    flat_idx = np.random.default_rng(42).choice(probs.size, p=probs.ravel())\n    fi, li = divmod(flat_idx, free_locs.size)\n    chosen_f = unassigned[fi]\n    chosen_l = free_locs[li]\n\n    out = list(current_assignment)\n    out[chosen_f] = chosen_l\n    return out\n\n",
  "minimax_interaction_aug_30": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Approximate minimax using summed interaction cost instead of max.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned_facilities = np.where(a != -1)[0]\n    assigned_locs = a[assigned_facilities]\n\n    best_f, best_l = int(unassigned[0]), int(free_locs[0])\n    best_score = float(\"inf\")\n\n    for f in unassigned:\n        for l in free_locs:\n            if assigned_facilities.size == 0:\n                w = 0.0\n            else:\n                c1 = flow_matrix[f, assigned_facilities] * distance_matrix[l, assigned_locs]\n                c2 = flow_matrix[assigned_facilities, f] * distance_matrix[assigned_locs, l]\n                w = float(np.sum(c1 + c2))\n            w = np.clip(w, 0, 1e12) / (1.0 + 1e-12)\n            if w < best_score:\n                best_score = w\n                best_f, best_l = f, l\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "minimax_interaction_aug_31": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Inverted control flow: iterate over free locations first with while loops.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned_facilities = np.where(a != -1)[0]\n    assigned_locs = a[assigned_facilities]\n\n    best_f, best_l = int(unassigned[0]), int(free_locs[0])\n    best_score = float(\"inf\")\n\n    i = 0\n    while i < free_locs.size:\n        l = free_locs[i]\n        j = 0\n        while j < unassigned.size:\n            f = unassigned[j]\n            if assigned_facilities.size == 0:\n                w = 0.0\n            else:\n                c1 = flow_matrix[f, assigned_facilities] * distance_matrix[l, assigned_locs]\n                c2 = flow_matrix[assigned_facilities, f] * distance_matrix[assigned_locs, l]\n                w = float(np.max(c1 + c2))\n            w = np.clip(w, 0, 1e12) / (1.0 + 1e-12)\n            if w < best_score:\n                best_score = w\n                best_f, best_l = f, l\n            j += 1\n        i += 1\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "annealed_softmax_pair_sampling_aug_32": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(a)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs_of_assigned = a[assigned]\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    T = np.clip(2.0 * (1.0 - progress) + 0.05, 1e-6, None)\n\n    # Vectorized cost computation\n    costs = np.empty((unassigned.size, free_locs.size), dtype=float)\n    for i, f in enumerate(unassigned):\n        flow_to_ass = flow_matrix[f, assigned]          # shape (k,)\n        flow_from_ass = flow_matrix[assigned, f]        # shape (k,)\n        dist_f_to_locs = distance_matrix[free_locs[:, None], locs_of_assigned]\n        dist_locs_to_f = distance_matrix[locs_of_assigned[:, None], free_locs]\n        costs[i] = (flow_to_ass @ dist_f_to_locs) + (flow_from_ass @ dist_locs_to_f)\n\n    flat_costs = costs.ravel() + np.random.rand(costs.size) * 1e-8\n    probs = np.exp(-flat_costs / T)\n    probs /= (probs.sum() + 1e-12)\n\n    idx = int(np.random.choice(len(probs), p=probs))\n    f_idx, l_idx = np.unravel_index(idx, costs.shape)\n    f = int(unassigned[f_idx])\n    l = int(free_locs[l_idx])\n\n    out = list(a)\n    out[f] = l\n    return out\n\n",
  "annealed_softmax_pair_sampling_aug_33": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(a)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs_of_assigned = a[assigned]\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    T = max(1e-6, 1.5 * (1.0 - progress) + 0.1)\n\n    pairs = []\n    costs = []\n\n    i = 0\n    while i < unassigned.size:\n        f = int(unassigned[i])\n        j = 0\n        while j < free_locs.size:\n            l = int(free_locs[j])\n            if assigned.size == 0:\n                d = 0.0\n            else:\n                prod1 = flow_matrix[f, assigned] * distance_matrix[l, locs_of_assigned]\n                prod2 = flow_matrix[assigned, f] * distance_matrix[locs_of_assigned, l]\n                d = float(np.median(np.concatenate([prod1, prod2])))\n            pairs.append((f, l))\n            costs.append(d + np.random.rand() * 1e-8)\n            j += 1\n        i += 1\n\n    costs_arr = np.array(costs, dtype=float)\n    probs = np.exp(-costs_arr / T)\n    probs /= (probs.sum() + 1e-12)\n\n    idx = int(np.random.choice(len(pairs), p=probs))\n    f, l = pairs[idx]\n\n    out = list(a)\n    out[f] = l\n    return out\n\n",
  "annealed_softmax_pair_sampling_aug_34": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(a)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs_of_assigned = a[assigned]\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    T = np.clip(3.0 * (1.0 - progress) + 0.2, 1e-6, None)\n\n    costs = np.empty((unassigned.size, free_locs.size), dtype=float)\n    for i, f in enumerate(unassigned):\n        flow_to_ass = flow_matrix[f, assigned]\n        flow_from_ass = flow_matrix[assigned, f]\n        dist_f_to_locs = distance_matrix[free_locs[:, None], locs_of_assigned]\n        dist_locs_to_f = distance_matrix[locs_of_assigned[:, None], free_locs]\n        costs[i] = 0.6 * (flow_to_ass @ dist_f_to_locs) + 0.4 * (flow_from_ass @ dist_locs_to_f)\n\n    flat_costs = costs.ravel() + np.random.rand(costs.size) * 1e-8\n    top_k = 7\n    idxs = np.argpartition(flat_costs, top_k)[:top_k]\n    probs = np.exp(-flat_costs[idxs] / T)\n    probs /= (probs.sum() + 1e-12)\n\n    chosen = int(np.random.choice(idxs, p=probs))\n    f_idx, l_idx = np.unravel_index(chosen, costs.shape)\n    f = int(unassigned[f_idx])\n    l = int(free_locs[l_idx])\n\n    out = list(a)\n    out[f] = l\n    return out\n\n",
  "annealed_softmax_pair_sampling_aug_35": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(a)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs_of_assigned = a[assigned]\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    T = max(1e-6, (1.0 - progress) * 4.0 + 0.15)\n\n    pairs = []\n    costs = []\n\n    i = 0\n    while i < unassigned.size:\n        f = int(unassigned[i])\n        j = 0\n        while j < free_locs.size:\n            l = int(free_locs[j])\n            if assigned.size == 0:\n                d = 0.0\n            else:\n                prod1 = flow_matrix[f, assigned] * distance_matrix[l, locs_of_assigned]\n                prod2 = flow_matrix[assigned, f] * distance_matrix[locs_of_assigned, l]\n                d = float(np.max(np.concatenate([prod1, prod2])))\n            pairs.append((f, l))\n            costs.append(d + np.random.rand() * 1e-9)\n            j += 1\n        i += 1\n\n    costs_arr = np.array(costs, dtype=float)\n    probs = np.exp(-costs_arr / T)\n    probs /= (probs.sum() + 1e-12)\n\n    idx = int(np.random.choice(len(pairs), p=probs))\n    f, l = pairs[idx]\n\n    out = list(a)\n    out[f] = l\n    return out\n\n",
  "annealed_softmax_pair_sampling_aug_36": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(a)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs_of_assigned = a[assigned]\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    T = np.clip(2.5 * (1.0 - progress) + 0.1, 1e-6, None)\n\n    # Proxy cost: dot product of the entire flow row with the entire distance row\n    costs = np.empty((unassigned.size, free_locs.size), dtype=float)\n    for i, f in enumerate(unassigned):\n        for j, l in enumerate(free_locs):\n            costs[i, j] = float(np.dot(flow_matrix[f, :], distance_matrix[l, :]))\n\n    flat_costs = costs.ravel() + 1e-10 * np.arange(costs.size)\n    probs = np.exp(-flat_costs / T)\n    probs /= (probs.sum() + 1e-12)\n\n    idx = int(np.random.choice(len(probs), p=probs))\n    f_idx, l_idx = np.unravel_index(idx, costs.shape)\n    f = int(unassigned[f_idx])\n    l = int(free_locs[l_idx])\n\n    out = list(a)\n    out[f] = l\n    return out\n\n",
  "randomized_greedy_topk_pairs_aug_37": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Constructive GRASP step that uses a soft\u2011minimum selection\n    over all possible (facility, location) pairs.\n    \"\"\"\n    n = len(current_assignment)\n    assignment = np.array(current_assignment, dtype=int)\n\n    # Identify unassigned facilities and free locations\n    fac_unassigned = np.where(assignment == -1)[0]\n    if fac_unassigned.size == 0:\n        return list(assignment)\n\n    loc_used = assignment[assignment != -1]\n    loc_free   = np.setdiff1d(np.arange(n), loc_used)\n\n    # Pre\u2011compute indices of already assigned facilities and their locations\n    fac_assigned = np.where(assignment != -1)[0]\n    loc_assigned = assignment[fac_assigned]\n\n    # Build cost matrix for all candidate pairs\n    cost_matrix = np.full((fac_unassigned.size, loc_free.size), np.inf)\n    for i, f in enumerate(fac_unassigned):\n        for j, l in enumerate(loc_free):\n            if fac_assigned.size == 0:\n                inc_cost = 0.0\n            else:\n                inc_cost = float(np.sum(\n                    flow_matrix[f, fac_assigned] * distance_matrix[l, loc_assigned] +\n                    flow_matrix[fac_assigned, f] * distance_matrix[loc_assigned, l]\n                ))\n            cost_matrix[i, j] = inc_cost\n\n    # Soft\u2011minimum weighting: exp(-cost / tau)\n    tau = 1.0\n    weights = np.exp(-cost_matrix / (tau + 1e-12))\n    weights /= np.sum(weights, axis=None) + 1e-12  # avoid division by zero\n\n    # Flatten indices and sample according to softmin probabilities\n    flat_idx = np.random.choice(cost_matrix.size, p=weights.flatten())\n    f_idx, l_idx = np.unravel_index(flat_idx, cost_matrix.shape)\n    chosen_fac = fac_unassigned[f_idx]\n    chosen_loc = loc_free[l_idx]\n\n    assignment[chosen_fac] = chosen_loc\n    return list(assignment)\n\n",
  "randomized_greedy_topk_pairs_aug_38": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Constructive step that iteratively evaluates all pairs,\n    then chooses deterministically among the top\u2011k after adding\n    a small noise for tie\u2011breaking.\n    \"\"\"\n    n = len(current_assignment)\n    assign = np.array(current_assignment, dtype=int)\n\n    # Find unassigned facilities and free locations\n    fac_unassigned = np.where(assign == -1)[0]\n    if fac_unassigned.size == 0:\n        return list(assign)\n\n    loc_used = assign[assign != -1]\n    loc_free = np.setdiff1d(np.arange(n), loc_used)\n\n    # Gather already assigned facilities\n    fac_assigned = np.where(assign != -1)[0]\n    loc_assigned = assign[fac_assigned]\n\n    # Compute incremental costs using a while loop\n    pairs = []\n    costs = []\n    i = 0\n    while i < fac_unassigned.size:\n        f = fac_unassigned[i]\n        j = 0\n        while j < loc_free.size:\n            l = loc_free[j]\n            if fac_assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(\n                    flow_matrix[f, fac_assigned] * distance_matrix[l, loc_assigned] +\n                    flow_matrix[fac_assigned, f] * distance_matrix[loc_assigned, l]\n                ))\n            pairs.append((int(f), int(l)))\n            # deterministic noise for tie\u2011breaking\n            noise = np.random.uniform(-1e-6, 1e-6)\n            costs.append(inc + noise)\n            j += 1\n        i += 1\n\n    costs_arr = np.array(costs, dtype=float)\n    top_k = max(3, int(np.floor(0.15 * len(costs_arr))))\n    idxs = np.argsort(costs_arr)[:top_k]\n    pick = int(np.random.choice(idxs))\n    f, l = pairs[pick]\n\n    assign[f] = l\n    return list(assign)\n\n",
  "randomized_greedy_topk_pairs_aug_39": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Constructive step that samples from the top\u2011k candidates\n    using a weighted probability proportional to exp(-cost).\n    \"\"\"\n    n = len(current_assignment)\n    assign = np.array(current_assignment, dtype=int)\n\n    fac_unassigned = np.where(assign == -1)[0]\n    if fac_unassigned.size == 0:\n        return list(assign)\n\n    loc_used = assign[assign != -1]\n    loc_free = np.setdiff1d(np.arange(n), loc_used)\n\n    fac_assigned = np.where(assign != -1)[0]\n    loc_assigned = assign[fac_assigned]\n\n    # Vectorised cost computation\n    costs = []\n    pairs = []\n    for f in fac_unassigned:\n        for l in loc_free:\n            if fac_assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(\n                    flow_matrix[f, fac_assigned] * distance_matrix[l, loc_assigned] +\n                    flow_matrix[fac_assigned, f] * distance_matrix[loc_assigned, l]\n                ))\n            costs.append(inc)\n            pairs.append((int(f), int(l)))\n\n    costs_arr = np.array(costs, dtype=float)\n    top_k = max(5, int(np.ceil(0.12 * len(costs_arr))))\n    idxs = np.argsort(costs_arr)[:top_k]\n    probs = np.exp(-costs_arr[idxs] / (1.0 + 1e-12))\n    probs /= probs.sum() + 1e-12\n    pick = int(np.random.choice(idxs, p=probs))\n    f, l = pairs[pick]\n\n    assign[f] = l\n    return list(assign)\n\n",
  "randomized_greedy_topk_pairs_aug_40": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Constructive step that uses max\u2011aggregation for the cost\n    and a weighted sum of distance and cost with tuned coefficients.\n    \"\"\"\n    n = len(current_assignment)\n    assign = np.array(current_assignment, dtype=int)\n\n    fac_unassigned = np.where(assign == -1)[0]\n    if fac_unassigned.size == 0:\n        return list(assign)\n\n    loc_used = assign[assign != -1]\n    loc_free = np.setdiff1d(np.arange(n), loc_used)\n\n    fac_assigned = np.where(assign != -1)[0]\n    loc_assigned = assign[fac_assigned]\n\n    # Compute costs using max aggregation\n    costs = []\n    pairs = []\n    for f in fac_unassigned:\n        for l in loc_free:\n            if fac_assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.max(\n                    flow_matrix[f, fac_assigned] * distance_matrix[l, loc_assigned] +\n                    flow_matrix[fac_assigned, f] * distance_matrix[loc_assigned, l]\n                ))\n            costs.append(inc)\n            pairs.append((int(f), int(l)))\n\n    # Weighted sum: 0.6 * distance + 0.4 * cost\n    # Here we approximate distance by the maximum distance in the matrix\n    max_dist = float(np.max(distance_matrix) + 1e-12)\n    weighted = [0.6 * max_dist + 0.4 * c for c in costs]\n    idxs = np.argsort(weighted)\n    pick = int(idxs[0])  # deterministic best\n    f, l = pairs[pick]\n\n    assign[f] = l\n    return list(assign)\n\n",
  "randomized_greedy_topk_pairs_aug_41": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Constructive step that aggregates costs using the median,\n    selects the best pair with a softmax probability,\n    and applies np.clip to keep values bounded.\n    \"\"\"\n    n = len(current_assignment)\n    assign = np.array(current_assignment, dtype=int)\n\n    fac_unassigned = np.where(assign == -1)[0]\n    if fac_unassigned.size == 0:\n        return list(assign)\n\n    loc_used = assign[assign != -1]\n    loc_free = np.setdiff1d(np.arange(n), loc_used)\n\n    fac_assigned = np.where(assign != -1)[0]\n    loc_assigned = assign[fac_assigned]\n\n    # Compute incremental costs\n    costs = []\n    pairs = []\n    for f in fac_unassigned:\n        for l in loc_free:\n            if fac_assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.median(\n                    flow_matrix[f, fac_assigned] * distance_matrix[l, loc_assigned] +\n                    flow_matrix[fac_assigned, f] * distance_matrix[loc_assigned, l]\n                ))\n            costs.append(inc)\n            pairs.append((int(f), int(l)))\n\n    costs_arr = np.array(costs, dtype=float)\n    # Softmax selection with clipping to avoid extreme values\n    logits = -costs_arr\n    logits = np.clip(logits, -20, 20)  # prevent overflow\n    exp_logits = np.exp(logits - np.max(logits))\n    probs = exp_logits / (exp_logits.sum() + 1e-12)\n    pick = int(np.random.choice(len(costs_arr), p=probs))\n    f, l = pairs[pick]\n\n    assign[f] = l\n    return list(assign)\n\n",
  "one_step_lookahead_mean_future_aug_42": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorised incremental choice using a while loop and weighted future.\"\"\"\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    cand_fac = np.where(assign == -1)[0]\n    if cand_fac.size == 0:\n        return list(assign)\n\n    used_fac = np.zeros(n, dtype=bool)\n    used_fac[assign[assign != -1]] = True\n    cand_locs = np.where(~used_fac)[0]\n\n    ass_idx = np.where(assign != -1)[0]\n    assigned_locs = assign[ass_idx]\n\n    # Remaining flow mass for each candidate facility\n    sym_flow = flow_matrix + flow_matrix.T\n    rem_flow_mass = np.sum(sym_flow[np.ix_(cand_fac, cand_fac)], axis=1)\n\n    # Mean distance among remaining free locations\n    if cand_locs.size > 1:\n        Dff = distance_matrix[np.ix_(cand_locs, cand_locs)].astype(float)\n        mean_d = Dff.mean().clip(min=1e-12)\n    else:\n        mean_d = 0.0\n\n    best_score = float(\"inf\")\n    best_f = best_l = -1\n\n    i = 0\n    while i < cand_fac.size:\n        f = cand_fac[i]\n        if ass_idx.size == 0:\n            inc_vec = np.zeros(cand_locs.size, dtype=float)\n        else:\n            part1 = flow_matrix[f, ass_idx] @ distance_matrix[:, assigned_locs]\n            part2 = flow_matrix[ass_idx, f] @ distance_matrix[assigned_locs, :].T\n            inc_vec = part1 + part2\n        future = rem_flow_mass[i] * mean_d\n        scores = inc_vec + 0.8 * future  # heavier weight on future\n        j = np.argmin(scores)\n        if scores[j] < best_score:\n            best_score = scores[j]\n            best_f = f\n            best_l = cand_locs[j]\n        i += 1\n\n    out = list(assign)\n    out[best_f] = best_l\n    return out\n\n",
  "one_step_lookahead_mean_future_aug_43": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Random choice among top\u20113 candidates with max\u2011based future estimate.\"\"\"\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    cand_fac = np.where(assign == -1)[0]\n    if cand_fac.size == 0:\n        return list(assign)\n\n    used_fac = np.zeros(n, dtype=bool)\n    used_fac[assign[assign != -1]] = True\n    cand_locs = np.where(~used_fac)[0]\n\n    ass_idx = np.where(assign != -1)[0]\n    assigned_locs = assign[ass_idx]\n\n    sym_flow = flow_matrix + flow_matrix.T\n    rem_flow_mass = np.sum(sym_flow[np.ix_(cand_fac, cand_fac)], axis=1)\n\n    # Max distance among remaining free locations\n    if cand_locs.size > 1:\n        Dff = distance_matrix[np.ix_(cand_locs, cand_locs)].astype(float)\n        mean_d = Dff.max().clip(min=1e-12)\n    else:\n        mean_d = 0.0\n\n    scores = np.empty((cand_fac.size, cand_locs.size), dtype=float)\n    for i, f in enumerate(cand_fac):\n        for j, l in enumerate(cand_locs):\n            if ass_idx.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass_idx] * distance_matrix[l, assigned_locs] +\n                                   flow_matrix[ass_idx, f] * distance_matrix[assigned_locs, l]))\n            future = rem_flow_mass[i] * mean_d\n            scores[i, j] = inc + 0.4 * future\n\n    # Deterministic noise for stable tie\u2011breaking\n    noise = 1e-6 * np.arange(scores.size).reshape(scores.shape)\n    scores += noise\n\n    # Flatten and find indices of top\u20113 lowest scores\n    flat_idx = np.argsort(scores.ravel())[:3]\n    best_flat = np.random.choice(flat_idx)\n    best_f = cand_fac[best_flat // cand_locs.size]\n    best_l = cand_locs[best_flat % cand_locs.size]\n\n    out = list(assign)\n    out[best_f] = best_l\n    return out\n\n",
  "one_step_lookahead_mean_future_aug_44": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Fully vectorised scoring with median distance and deterministic tie\u2011break.\"\"\"\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    cand_fac = np.where(assign == -1)[0]\n    if cand_fac.size == 0:\n        return list(assign)\n\n    used_fac = np.zeros(n, dtype=bool)\n    used_fac[assign[assign != -1]] = True\n    cand_locs = np.where(~used_fac)[0]\n\n    ass_idx = np.where(assign != -1)[0]\n    assigned_locs = assign[ass_idx]\n\n    sym_flow = flow_matrix + flow_matrix.T\n    rem_flow_mass = np.sum(sym_flow[np.ix_(cand_fac, cand_fac)], axis=1)\n\n    if cand_locs.size > 1:\n        Dff = distance_matrix[np.ix_(cand_locs, cand_locs)].astype(float)\n        mean_d = np.median(Dff).clip(min=1e-12)\n    else:\n        mean_d = 0.0\n\n    # Vectorise inc computation for all pairs\n    if ass_idx.size == 0:\n        inc_matrix = np.zeros((cand_fac.size, cand_locs.size), dtype=float)\n    else:\n        flow_to_ass = flow_matrix[:, ass_idx]          # shape (n, |ass|)\n        flow_from_ass = flow_matrix[ass_idx, :]        # shape (|ass|, n)\n        dist_to_ass = distance_matrix[:, assigned_locs]  # shape (n, |ass|)\n        dist_from_ass = distance_matrix[assigned_locs, :]  # shape (|ass|, n)\n\n        inc_matrix = (flow_to_ass @ dist_to_ass) + (flow_from_ass.T @ dist_from_ass.T)\n\n        # Keep only rows/cols corresponding to candidate facilities\n        inc_matrix = inc_matrix[np.ix_(cand_fac, cand_locs)]\n\n    # Future estimate\n    future = rem_flow_mass[:, None] * mean_d\n    scores = inc_matrix + 0.3 * future\n\n    # Deterministic noise\n    noise = 1e-6 * np.arange(scores.size).reshape(scores.shape)\n    scores += noise\n\n    flat_idx = np.argmin(scores)\n    best_f = cand_fac[flat_idx // cand_locs.size]\n    best_l = cand_locs[flat_idx % cand_locs.size]\n\n    out = list(assign)\n    out[best_f] = best_l\n    return out\n\n",
  "linearized_potential_matching_aug_45": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Match high\u2011flow facilities to low\u2011distance\u2011sum locations using a linearized scalar potential.\"\"\"\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n\n    # Facilities that are still unassigned\n    unassigned_fac = np.where(assign == -1)[0]\n    if unassigned_fac.size == 0:\n        return list(current_assignment)\n\n    # Locations already taken\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[assign[assign != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    # Potential of each facility and the \u201cload\u201d of each location\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    ql = distance_matrix.sum(axis=1).astype(float)\n\n    # Normalise to comparable scale and clip to avoid extreme values\n    pf_norm = np.clip((pf - pf.mean()) / (pf.std() + 1e-12), -1.0, 1.0)\n    ql_norm = np.clip((ql - ql.mean()) / (ql.std() + 1e-12), -1.0, 1.0)\n\n    assigned_fac = np.where(assign != -1)[0]\n    assigned_loc = assign[assigned_fac]\n\n    best_score = np.inf\n    best_f = unassigned_fac[0]\n    best_l = free_locs[0]\n    # Deterministic tie\u2011breaker\n    noise = 1e-8 * np.arange(unassigned_fac.size * free_locs.size)\n    idx = 0\n\n    for f in unassigned_fac:\n        for l in free_locs:\n            if assigned_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(\n                    flow_matrix[f, assigned_fac] @ distance_matrix[l, assigned_loc] +\n                    flow_matrix[assigned_fac, f] @ distance_matrix[assigned_loc, l]\n                )\n            score = inc + 0.40 * (pf_norm[f] * ql_norm[l]) + noise[idx]\n            idx += 1\n            if score < best_score:\n                best_score = score\n                best_f = f\n                best_l = l\n\n    result = list(assign)\n    result[best_f] = best_l\n    return result\n\n",
  "linearized_potential_matching_aug_46": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy assignment with top\u2011k pruning and tuned weighting.\"\"\"\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n\n    unassigned_fac = np.where(assign == -1)[0]\n    if unassigned_fac.size == 0:\n        return list(current_assignment)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[assign[assign != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    ql = distance_matrix.sum(axis=1).astype(float)\n\n    pf_norm = np.clip((pf - pf.mean()) / (pf.std() + 1e-12), -1.0, 1.0)\n    ql_norm = np.clip((ql - ql.mean()) / (ql.std() + 1e-12), -1.0, 1.0)\n\n    assigned_fac = np.where(assign != -1)[0]\n    assigned_loc = assign[assigned_fac]\n\n    m, k = unassigned_fac.size, free_locs.size\n    scores = np.full((m, k), np.inf, dtype=float)\n\n    for i, f in enumerate(unassigned_fac):\n        for j, l in enumerate(free_locs):\n            if assigned_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(\n                    flow_matrix[f, assigned_fac] @ distance_matrix[l, assigned_loc] +\n                    flow_matrix[assigned_fac, f] @ distance_matrix[assigned_loc, l]\n                )\n            scores[i, j] = inc + 0.60 * (pf_norm[f] * ql_norm[l])\n\n    scores_flat = scores.ravel()\n    top_k = min(7, scores_flat.size)\n    topk_idx = np.argpartition(scores_flat, top_k)[:top_k]\n    best_idx_flat = topk_idx[np.argmin(scores_flat[topk_idx])]\n    best_i, best_j = np.unravel_index(best_idx_flat, scores.shape)\n\n    result = list(assign)\n    result[unassigned_fac[best_i]] = free_locs[best_j]\n    return result\n\n",
  "spectral_rank_quantile_match_aug_47": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Select the next facility\u2011to\u2011location assignment using a soft\u2011min\n    selection on the distance centrality and a noisy eigenvector ranking.\"\"\"\n    # Rename for clarity\n    fm = flow_matrix\n    dm = distance_matrix\n\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # Identify unassigned facilities\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    # Track used locations\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    # Symmetrize flow and compute leading eigenvector\n    sym_flow = fm + fm.T\n    vals, vecs = np.linalg.eig(sym_flow)\n    idx_max = np.argmax(vals.real)\n    vf = np.abs(vecs[:, idx_max].real)\n\n    # Add deterministic noise for tie breaking\n    noise = 1e-9 * np.random.rand(vf.size)\n    vf += noise\n\n    # Normalise with clipping to keep values in [0,1]\n    vf_min, vf_max = vf.min(), vf.max()\n    vf_norm = (vf - vf_min) / (vf_max - vf_min + 1e-12)\n    vf_norm = np.clip(vf_norm, 0.0, 1.0)\n\n    # Centrality of locations: use mean distance per location\n    cl = 1.0 / (np.mean(dm, axis=1) + 1e-12)\n    cl_min, cl_max = cl.min(), cl.max()\n    cl_norm = (cl - cl_min) / (cl_max - cl_min + 1e-12)\n    cl_norm = np.clip(cl_norm, 0.0, 1.0)\n\n    # Pick facility with highest eigenvector score\n    f = int(unassigned[np.argmax(vf_norm[unassigned])])\n    target = float(vf_norm[f])\n\n    # Soft\u2011min selection of location\n    diff = np.abs(cl_norm[free] - target)\n    weights = np.exp(-5.0 * diff)\n    weights /= weights.sum() + 1e-12  # normalise\n    idx = np.random.choice(len(free), p=weights)\n    l = int(free[idx])\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n\n",
  "spectral_rank_quantile_match_aug_48": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Select next assignment with top\u2011k facility ranking and deterministic\n    location tie\u2011breaking.\"\"\"\n    fm = flow_matrix\n    dm = distance_matrix\n\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    # Symmetrize flow and compute eigenvector via eigh\n    sym_flow = fm + fm.T\n    vals, vecs = np.linalg.eigh(sym_flow)\n    idx_max = np.argmax(vals)\n    vf = np.abs(vecs[:, idx_max])\n\n    # Add Gaussian noise for stability\n    vf += 0.01 * np.random.randn(vf.size)\n\n    vf_min, vf_max = vf.min(), vf.max()\n    vf_norm = (vf - vf_min) / (vf_max - vf_min + 1e-12)\n    vf_norm = np.clip(vf_norm, 0.0, 1.0)\n\n    # Location centrality using maximum distance (larger -> less central)\n    cl = 1.0 / (np.max(dm, axis=1) + 1e-12)\n    cl_min, cl_max = cl.min(), cl.max()\n    cl_norm = (cl - cl_min) / (cl_max - cl_min + 1e-12)\n    cl_norm = np.clip(cl_norm, 0.0, 1.0)\n\n    # Pick one of the top\u2011k facilities\n    top_k_fac = int(min(5, unassigned.size))\n    top_indices = np.argpartition(-vf_norm[unassigned], top_k_fac)[:top_k_fac]\n    f = int(unassigned[top_indices[np.random.randint(0, top_k_fac)]])\n\n    target = float(vf_norm[f])\n\n    # Compute distance differences\n    diff = np.abs(cl_norm[free] - target)\n    # Pick one of the top\u2011k closest locations\n    top_k_loc = int(min(3, free.size))\n    top_loc_indices = np.argpartition(diff, top_k_loc)[:top_k_loc]\n    l = int(free[top_loc_indices[0]])  # deterministic: smallest index\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n\n",
  "spectral_rank_quantile_match_aug_49": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Use power\u2011iteration to approximate the leading eigenvector and\n    a softmax\u2011weighted location choice.\"\"\"\n    flow = flow_matrix\n    dist = distance_matrix\n\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    # Power iteration for leading eigenvector\n    v = np.random.rand(n)\n    v /= np.linalg.norm(v) + 1e-12\n    for _ in range(10):\n        v = flow @ v\n        v /= np.linalg.norm(v) + 1e-12\n    vf = np.abs(v)\n\n    vf_min, vf_max = vf.min(), vf.max()\n    vf_norm = (vf - vf_min) / (vf_max - vf_min + 1e-12)\n    vf_norm = np.clip(vf_norm, 0.0, 1.0)\n\n    # Location centrality using median distance\n    cl = 1.0 / (np.median(dist, axis=1) + 1e-12)\n    cl_min, cl_max = cl.min(), cl.max()\n    cl_norm = (cl - cl_min) / (cl_max - cl_min + 1e-12)\n    cl_norm = np.clip(cl_norm, 0.0, 1.0)\n\n    f = int(unassigned[np.argmax(vf_norm[unassigned])])\n    target = float(vf_norm[f])\n\n    diff = np.abs(cl_norm[free] - target)\n    # Softmax weighting for location choice\n    weights = np.exp(-2.0 * diff)\n    weights /= weights.sum() + 1e-12\n    idx = np.random.choice(len(free), p=weights)\n    l = int(free[idx])\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n\n",
  "spectral_rank_quantile_match_aug_50": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Proxy eigenvector via total absolute flow and deterministic\n    location selection with index tie\u2011breaking.\"\"\"\n    F_mat = flow_matrix\n    D_mat = distance_matrix\n\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    # Proxy score: sum of absolute flows per facility\n    vf = np.sum(np.abs(F_mat), axis=1).astype(float)\n    vf += 1e-8  # small noise for stability\n\n    vf_min, vf_max = vf.min(), vf.max()\n    vf_norm = (vf - vf_min) / (vf_max - vf_min + 1e-12)\n    vf_norm = np.clip(vf_norm, 0.0, 1.0)\n\n    # Location centrality via median distance\n    cl = 1.0 / (np.median(D_mat, axis=1) + 1e-12)\n    cl_min, cl_max = cl.min(), cl.max()\n    cl_norm = (cl - cl_min) / (cl_max - cl_min + 1e-12)\n    cl_norm = np.clip(cl_norm, 0.0, 1.0)\n\n    f = int(unassigned[np.argmax(vf_norm[unassigned])])\n    target = float(vf_norm[f])\n\n    diff = np.abs(cl_norm[free] - target)\n    # Deterministic tie\u2011breaking: choose location with smallest index\n    idx = np.argmin(diff)\n    l = int(free[idx])\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n\n",
  "strong_neighbor_attraction_aug_51": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur_assign = np.array(current_assignment, dtype=int)\n    n = cur_assign.size\n\n    # facilities that have not yet been placed\n    unassigned = np.where(cur_assign == -1)[0]\n    if unassigned.size == 0:\n        return list(cur_assign)\n\n    # mask of already used locations\n    used = np.zeros(n, dtype=bool)\n    used[cur_assign[cur_assign != -1]] = True\n    free_spots = np.where(~used)[0]\n\n    # already placed facilities\n    assigned_fac = np.where(cur_assign != -1)[0]\n    if assigned_fac.size == 0:\n        # fallback when nothing is placed yet\n        total_flow = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        noise = np.random.uniform(0, 1e-6, size=total_flow.shape)\n        candidate = int(unassigned[np.argmax(total_flow[unassigned] + noise)])\n        free_dist = distance_matrix[free_spots].sum(axis=1)\n        central = int(free_spots[np.argmin(free_dist + noise)])\n        out = list(cur_assign)\n        out[candidate] = central\n        return out\n\n    sym_flow = flow_matrix + flow_matrix.T\n    # strongest connection of each unassigned facility to any assigned one\n    conn = sym_flow[np.ix_(unassigned, assigned_fac)].max(axis=1)\n    noise = np.random.uniform(0, 1e-6, size=conn.shape)\n    f_idx = int(unassigned[np.argmax(conn + noise)])\n\n    # pick the assigned facility most strongly linked to f\n    anchor_fac = int(assigned_fac[np.argmax(sym_flow[f_idx, assigned_fac])])\n    anchor_loc = int(cur_assign[anchor_fac])\n\n    # find free location nearest to the anchor\n    dists = distance_matrix[free_spots, anchor_loc]\n    l_idx = int(free_spots[np.argmin(dists + noise)])\n\n    out = list(cur_assign)\n    out[f_idx] = l_idx\n    return out\n\n",
  "strong_neighbor_attraction_aug_52": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.array(current_assignment, dtype=int)\n    n = cur.size\n\n    unassigned = np.where(cur == -1)[0]\n    if unassigned.size == 0:\n        return list(cur)\n\n    used = np.zeros(n, dtype=bool)\n    used[cur[cur != -1]] = True\n    free_spots = np.where(~used)[0]\n    assigned_fac = np.where(cur != -1)[0]\n\n    if assigned_fac.size == 0:\n        total_flow = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        w_flow = total_flow[unassigned] / (total_flow[unassigned] + 1e-12)\n        top_k = 5\n        top_idx = np.argpartition(-w_flow, top_k-1)[:top_k]\n        chosen_fac = int(unassigned[top_idx[np.argmax(w_flow[top_idx])]])\n        dist_sum = distance_matrix[free_spots].sum(axis=1)\n        chosen_loc = int(free_spots[np.argmin(dist_sum)])\n        res = list(cur)\n        res[chosen_fac] = chosen_loc\n        return res\n\n    sym_flow = flow_matrix + flow_matrix.T\n    conn = sym_flow[np.ix_(unassigned, assigned_fac)].max(axis=1).astype(float)\n    nearest_dist = np.min(distance_matrix[unassigned[:, None], cur[assigned_fac]], axis=1).astype(float)\n\n    beta = 0.5\n    cost = 0.6 * conn + 0.4 * (1.0 / (nearest_dist + 1e-12))\n    probs = np.exp(-beta * cost)\n    probs /= np.clip(probs.sum() + 1e-12, 1e-12, None)\n\n    f_idx = int(unassigned[np.argmax(probs)])\n\n    anchor_fac = int(assigned_fac[np.argmax(sym_flow[f_idx, assigned_fac])])\n    anchor_loc = int(cur[anchor_fac])\n\n    dists = distance_matrix[free_spots, anchor_loc].astype(float)\n    top_k2 = 7\n    top_idx2 = np.argpartition(dists, top_k2-1)[:top_k2]\n    chosen_loc = int(free_spots[top_idx2[np.argmin(dists[top_idx2])]])\n\n    res = list(cur)\n    res[f_idx] = chosen_loc\n    return res\n\n",
  "strong_neighbor_attraction_aug_53": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.array(current_assignment, dtype=int)\n    n = cur.size\n\n    unassigned = np.where(cur == -1)[0]\n    if unassigned.size == 0:\n        return list(cur)\n\n    used = np.zeros(n, dtype=bool)\n    used[cur[cur != -1]] = True\n    free_spots = np.where(~used)[0]\n    assigned_fac = np.where(cur != -1)[0]\n\n    if assigned_fac.size == 0:\n        total_flow = np.maximum(flow_matrix.sum(axis=1), flow_matrix.sum(axis=0)).astype(float)\n        median_val = np.median(total_flow[unassigned])\n        candidates = unassigned[np.where(total_flow[unassigned] >= median_val)[0]]\n        chosen_fac = int(np.random.choice(candidates))\n        dist_median = np.median(distance_matrix[free_spots], axis=1)\n        chosen_loc = int(free_spots[np.argmin(dist_median)])\n        res = list(cur)\n        res[chosen_fac] = chosen_loc\n        return res\n\n    sym_flow = flow_matrix + flow_matrix.T\n    conn = sym_flow[np.ix_(unassigned, assigned_fac)].max(axis=1).astype(float)\n\n    top_k = 3\n    top_idx = np.argpartition(-conn, top_k-1)[:top_k]\n    chosen_fac = int(unassigned[np.random.choice(top_idx)])\n\n    anchor_fac = int(assigned_fac[np.argmax(sym_flow[chosen_fac, assigned_fac])])\n    anchor_loc = int(cur[anchor_fac])\n\n    dists = distance_matrix[free_spots, anchor_loc]\n    top_k2 = 4\n    top_idx2 = np.argpartition(dists, top_k2-1)[:top_k2]\n    chosen_loc = int(free_spots[np.random.choice(top_idx2)])\n\n    res = list(cur)\n    res[chosen_fac] = chosen_loc\n    return res\n\n",
  "strong_neighbor_attraction_aug_54": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.array(current_assignment, dtype=int)\n    n = cur.size\n\n    unassigned = np.where(cur == -1)[0]\n    if unassigned.size == 0:\n        return list(cur)\n\n    used = np.zeros(n, dtype=bool)\n    used[cur[cur != -1]] = True\n    free_spots = np.where(~used)[0]\n    assigned_fac = np.where(cur != -1)[0]\n\n    if assigned_fac.size == 0:\n        mean_flow = flow_matrix.mean(axis=1)\n        chosen_fac = int(unassigned[np.argmax(mean_flow[unassigned])])\n        dist_sq = np.sum(distance_matrix[free_spots]**2, axis=1)\n        chosen_loc = int(free_spots[np.argmin(dist_sq)])\n        res = list(cur)\n        res[chosen_fac] = chosen_loc\n        return res\n\n    sym_flow = flow_matrix + flow_matrix.T\n    conn = sym_flow[np.ix_(unassigned, assigned_fac)].max(axis=1).astype(float)\n    median_dist = np.median(distance_matrix[unassigned[:, None], cur[assigned_fac]], axis=1).astype(float)\n\n    noise = 1e-6 * np.arange(unassigned.size)\n    score = conn / (median_dist + 1e-12) + noise\n    chosen_fac = int(unassigned[np.argmax(score)])\n\n    anchor_fac = int(assigned_fac[np.argmax(sym_flow[chosen_fac, assigned_fac])])\n    anchor_loc = int(cur[anchor_fac])\n\n    dists = distance_matrix[free_spots, anchor_loc]\n    dists_clipped = np.clip(dists, 1e-12, None)\n    chosen_loc = int(free_spots[np.argmin(dists_clipped)])\n\n    res = list(cur)\n    res[chosen_fac] = chosen_loc\n    return res\n\n",
  "vogel_penalty_allocation_aug_55": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vogel-style penalties on the incremental cost matrix to choose a high-penalty row/col then allocate its min.\"\"\"\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    fac_candidates = np.where(assign == -1)[0]\n    if fac_candidates.size == 0:\n        return list(assign)\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[assign[assign != -1]] = True\n    loc_candidates = np.where(~used_locs)[0]\n\n    assigned_fac = np.where(assign != -1)[0]\n    assigned_locs = assign[assigned_fac]\n\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    # Build cost matrix C (rows=fac_candidates, cols=loc_candidates)\n    if assigned_fac.size > 0:\n        cost_matrix = np.zeros((fac_candidates.size, loc_candidates.size), dtype=float)\n        for idx_f, f in enumerate(fac_candidates):\n            flow_to = flow_mat[f, assigned_fac]\n            flow_from = flow_mat[assigned_fac, f]\n            for idx_l, l in enumerate(loc_candidates):\n                dist_from = dist_mat[l, assigned_locs]\n                dist_to = dist_mat[assigned_locs, l]\n                cost_matrix[idx_f, idx_l] = np.sum(flow_to * dist_from + flow_from * dist_to)\n    else:\n        cost_matrix = np.zeros((fac_candidates.size, loc_candidates.size), dtype=float)\n\n    # Add deterministic noise to break ties\n    noise = 1e-8 * np.arange(cost_matrix.size).reshape(cost_matrix.shape)\n    cost_matrix_noisy = cost_matrix + noise\n\n    # Compute row and column penalties (second best - best)\n    row_pen = np.full(fac_candidates.size, np.inf)\n    for i in range(fac_candidates.size):\n        row_vals = np.partition(cost_matrix_noisy[i], 1)[:2]\n        row_pen[i] = float(row_vals[1] - row_vals[0]) if row_vals.size > 1 else np.inf\n\n    col_pen = np.full(loc_candidates.size, np.inf)\n    for j in range(loc_candidates.size):\n        col_vals = np.partition(cost_matrix_noisy[:, j], 1)[:2]\n        col_pen[j] = float(col_vals[1] - col_vals[0]) if col_vals.size > 1 else np.inf\n\n    # Decide whether to pick a row or a column\n    if np.max(row_pen) >= np.max(col_pen):\n        i = int(np.argmax(row_pen))\n        j = int(np.argmin(cost_matrix_noisy[i]))\n    else:\n        j = int(np.argmax(col_pen))\n        i = int(np.argmin(cost_matrix_noisy[:, j]))\n\n    f = int(fac_candidates[i])\n    l = int(loc_candidates[j])\n    out = list(assign)\n    out[f] = l\n    return out\n\n",
  "adaptive_candidate_sampling_aug_56": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign_arr = np.array(current_assignment, dtype=int)\n    size = assign_arr.size\n\n    # facilities that have not yet been placed\n    candidates = np.where(assign_arr == -1)[0]\n    if candidates.size == 0:\n        return list(assign_arr)\n\n    # which locations are already taken\n    used_mask = np.zeros(size, dtype=bool)\n    used_mask[assign_arr[assign_arr != -1]] = True\n    unassigned = np.where(~used_mask)[0]\n\n    # progress factor: 0 when all facilities are placed\n    progress = 1.0 - (candidates.size / max(1, size))\n\n    # adaptive sample sizes\n    kf = max(2, int(np.ceil((0.25 + 0.5 * (1.0 - progress)) * candidates.size)))\n    kl = max(2, int(np.ceil((0.25 + 0.5 * (1.0 - progress)) * unassigned.size)))\n\n    # facility importance based on total flow\n    flow_score = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    top_f = candidates[np.argsort(-flow_score[candidates])[:min(kf, candidates.size)]]\n\n    # location attractiveness based on centrality\n    loc_score = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    top_l = unassigned[np.argsort(-loc_score[unassigned])[:min(kl, unassigned.size)]]\n\n    # already assigned facilities and their locations\n    assigned_idx = np.where(assign_arr != -1)[0]\n    assigned_locs = assign_arr[assigned_idx]\n\n    # search best pair (facility, location)\n    best_inc = np.inf\n    best_f = None\n    best_l = None\n    for f in top_f:\n        for l in top_l:\n            inc = 0.0 if assigned_idx.size == 0 else float(\n                np.sum(flow_matrix[f, assigned_idx] * distance_matrix[l, assigned_locs] +\n                       flow_matrix[assigned_idx, f] * distance_matrix[assigned_locs, l]))\n            if inc < best_inc:\n                best_inc = inc\n                best_f = f\n                best_l = l\n\n    # produce new assignment\n    out = list(assign_arr)\n    out[best_f] = best_l\n    return out\n\n",
  "adaptive_candidate_sampling_aug_57": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return list(a)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    progress = 1.0 - (un.size / max(1, n))\n    kf = max(3, int(np.ceil((0.35 + 0.55 * (1.0 - progress)) * un.size)))\n    kl = max(3, int(np.ceil((0.35 + 0.55 * (1.0 - progress)) * free.size)))\n\n    # weighted flow score (tuned weight 0.6)\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float) * 0.6\n    top_f = un[np.argsort(-pf[un])[:min(kf, un.size)]]\n\n    # location score with clipping to keep values bounded\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = np.clip(cl, 0, 1e6)\n    top_l = free[np.argsort(-cl[free])[:min(kl, free.size)]]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n    best_f, best_l, best = int(top_f[0]), int(top_l[0]), np.inf\n    for f in top_f:\n        for l in top_l:\n            inc = 0.0 if ass.size == 0 else float(\n                np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                       flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best, best_f, best_l = inc, int(f), int(l)\n\n    out = list(a)\n    out[best_f] = best_l\n    return out\n\n",
  "entropy_uncertainty_then_best_aug_58": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    candidates = np.where(assign == -1)[0].astype(int)\n    if candidates.size == 0:\n        return list(assign)\n\n    used = np.zeros(n, dtype=bool)\n    used[assign[assign != -1]] = True\n    free_locs = np.where(~used)[0].astype(int)\n\n    placed = np.where(assign != -1)[0].astype(int)\n    locs = assign[placed].astype(int)\n\n    def deltas_for_fac(f_idx):\n        if placed.size == 0:\n            return np.zeros(free_locs.size, dtype=float)\n        flow_to = flow_matrix[f_idx, placed]\n        flow_from = flow_matrix[placed, f_idx]\n        dist_to = distance_matrix[free_locs[:, None], locs]\n        dist_from = distance_matrix[locs[:, None], free_locs]\n        return np.sum(flow_to[:, None] * dist_to + flow_from[:, None] * dist_from, axis=0)\n\n    best_fac, best_loc, best_entropy = int(candidates[0]), int(free_locs[0]), -1.0\n    noise = np.arange(candidates.size, dtype=float) * 1e-6\n    idx = 0\n    while idx < candidates.size:\n        f = int(candidates[idx])\n        deltas = deltas_for_fac(f)\n        deltas = deltas - deltas.min()\n        std = deltas.std() + 1e-12\n        probs = np.exp(-deltas / std)\n        probs = probs / (probs.sum() + 1e-12)\n        entropy = -np.sum(probs * np.log(probs + 1e-12))\n        if entropy > best_entropy + noise[idx]:\n            best_entropy = entropy\n            best_fac = f\n            best_loc = int(free_locs[np.argmin(deltas)])\n        idx += 1\n\n    result = list(assign)\n    result[best_fac] = best_loc\n    return result\n\n",
  "entropy_uncertainty_then_best_aug_59": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.where(assign == -1)[0].astype(int)\n    if unassigned.size == 0:\n        return list(assign)\n\n    occupied = np.zeros(n, dtype=bool)\n    occupied[assign[assign != -1]] = True\n    free_locs = np.where(~occupied)[0].astype(int)\n\n    placed = np.where(assign != -1)[0].astype(int)\n    locs = assign[placed].astype(int)\n\n    w_flow, w_dist = 0.4, 0.6\n\n    def delta_for(f_idx):\n        if placed.size == 0:\n            return np.zeros(free_locs.size, dtype=float)\n        flow_to = flow_matrix[f_idx, placed]\n        flow_from = flow_matrix[placed, f_idx]\n        dist_to = distance_matrix[free_locs[:, None], locs]\n        dist_from = distance_matrix[locs[:, None], free_locs]\n        flow_term = np.sum(flow_to[:, None] * dist_to + flow_from[:, None] * dist_from, axis=0)\n        return w_flow * flow_term + w_dist * np.min(dist_to + dist_from, axis=0)\n\n    best_fac, best_loc, best_score = int(unassigned[0]), int(free_locs[0]), np.inf\n    top_k = 7\n    for f in unassigned:\n        deltas = delta_for(int(f))\n        k = min(top_k, deltas.size)\n        idx_top = np.argpartition(deltas, k-1)[:k]\n        deltas_k = deltas[idx_top]\n        probs = np.exp(-deltas_k / (deltas_k.std() + 1e-12))\n        probs = probs / (probs.sum() + 1e-12)\n        chosen = idx_top[np.argmax(probs)]\n        score = deltas[chosen]\n        if score < best_score:\n            best_score = score\n            best_fac = f\n            best_loc = int(free_locs[chosen])\n\n    out = list(assign)\n    out[best_fac] = best_loc\n    return out\n\n",
  "entropy_uncertainty_then_best_aug_60": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.where(assign == -1)[0].astype(int)\n    if unassigned.size == 0:\n        return list(assign)\n\n    used = np.zeros(n, dtype=bool)\n    used[assign[assign != -1]] = True\n    free_locs = np.where(~used)[0].astype(int)\n\n    placed = np.where(assign != -1)[0].astype(int)\n    locs = assign[placed].astype(int)\n\n    def approx_delta(f_idx):\n        if placed.size == 0:\n            return np.zeros(free_locs.size, dtype=float)\n        flow_to = flow_matrix[f_idx, placed]\n        flow_from = flow_matrix[placed, f_idx]\n        dist_to = distance_matrix[free_locs[:, None], locs]\n        dist_from = distance_matrix[locs[:, None], free_locs]\n        return np.max(flow_to[:, None] * dist_to + flow_from[:, None] * dist_from, axis=0)\n\n    best_fac, best_loc, best_entropy = int(unassigned[0]), int(free_locs[0]), -1.0\n    rng = np.random.default_rng()\n    for f in unassigned:\n        deltas = approx_delta(int(f))\n        std = np.median(deltas) + 1e-12\n        probs = np.exp(-deltas / std)\n        probs = np.clip(probs, 0, 1)\n        probs = probs / (probs.sum() + 1e-12)\n        entropy = -np.sum(probs * np.log(probs + 1e-12))\n        if entropy > best_entropy:\n            best_entropy = entropy\n            best_fac = f\n            best_loc = int(free_locs[np.argmin(deltas)])\n        elif np.isclose(entropy, best_entropy, atol=1e-8):\n            if rng.random() < 0.5:\n                best_fac = f\n                best_loc = int(free_locs[np.argmin(deltas)])\n\n    out = list(assign)\n    out[best_fac] = best_loc\n    return out\n\n",
  "entropy_uncertainty_then_best_aug_61": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.where(assign == -1)[0].astype(int)\n    if unassigned.size == 0:\n        return list(assign)\n\n    occupied = np.zeros(n, dtype=bool)\n    occupied[assign[assign != -1]] = True\n    free_locs = np.where(~occupied)[0].astype(int)\n\n    placed = np.where(assign != -1)[0].astype(int)\n    locs = assign[placed].astype(int)\n\n    def compute_delta(f_idx):\n        if placed.size == 0:\n            return np.zeros(free_locs.size, dtype=float)\n        flow_to = flow_matrix[f_idx, placed]\n        flow_from = flow_matrix[placed, f_idx]\n        dist_to = distance_matrix[free_locs[:, None], locs]\n        dist_from = distance_matrix[locs[:, None], free_locs]\n        return np.sum(flow_to[:, None] * dist_to + flow_from[:, None] * dist_from, axis=0)\n\n    best_fac, best_loc, best_entropy = int(unassigned[0]), int(free_locs[0]), -1.0\n    noise = np.random.default_rng().uniform(-1e-6, 1e-6, size=unassigned.size)\n    idx = 0\n    while idx < unassigned.size:\n        f = int(unassigned[idx])\n        deltas = compute_delta(f)\n        std = deltas.std() + 1e-12\n        probs = np.exp(-deltas / std)\n        probs = probs / (probs.sum() + 1e-12)\n        entropy = -np.sum(probs * np.log(probs + 1e-12))\n        entropy += noise[idx]\n        if entropy > best_entropy:\n            best_entropy = entropy\n            best_fac = f\n            best_loc = int(free_locs[np.argmin(deltas)])\n        idx += 1\n\n    result = list(assign)\n    result[best_fac] = best_loc\n    return result\n\n",
  "zscore_blended_scoring_aug_62": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorized incremental\u2011cost calculation with deterministic tie\u2011breaking.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # Facilities that have not yet been assigned\n    candidates = np.where(a == -1)[0]\n    if candidates.size == 0:\n        return list(current_assignment)\n\n    # Locations that are still free\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    # Facility flow and location centrality z\u2011scores\n    pf = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    pf_z = (pf - pf.mean()) / (pf.std() + 1e-12)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl_z = (cl - cl.mean()) / (cl.std() + 1e-12)\n\n    # Assigned facilities and their locations\n    ass_f = np.where(a != -1)[0]\n    locs = a[ass_f]\n\n    # Incremental cost matrix (facilities \u00d7 locations)\n    incs = np.empty((candidates.size, free_locs.size), dtype=float)\n    for i, f in enumerate(candidates):\n        if ass_f.size == 0:\n            incs[i] = 0.0\n        else:\n            # Costs for assigning facility f to each free location\n            incs[i] = (\n                np.sum(flow_matrix[f, ass_f] * distance_matrix[free_locs[:, None], locs], axis=1)\n                + np.sum(flow_matrix[ass_f, f] * distance_matrix[locs[:, None], free_locs], axis=0)\n            )\n\n    incs_flat = incs.ravel()\n    inc_z = (incs_flat - incs_flat.mean()) / (incs_flat.std() + 1e-12)\n\n    # Combine scores: lower incremental, higher flow and centrality\n    scores = inc_z - 0.3 * pf_z[candidates.repeat(free_locs.size)] \\\n                - 0.3 * cl_z[free_locs.repeat(candidates.size)]\n\n    # Deterministic noise for tie\u2011breaking\n    rng = np.random.default_rng(42)\n    noise = rng.uniform(0, 1e-6, size=scores.shape)\n    scores += noise\n\n    idx = int(np.argmin(scores))\n    f_idx = idx // free_locs.size\n    l_idx = idx % free_locs.size\n    chosen_f = candidates[f_idx]\n    chosen_l = free_locs[l_idx]\n\n    out = list(current_assignment)\n    out[chosen_f] = chosen_l\n    return out\n\n",
  "zscore_blended_scoring_aug_63": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Top\u2011k selection with median\u2011based z\u2011scores and max\u2011based incremental cost.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    # Median\u2011based z\u2011scores for facility flow and location centrality\n    pf = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    pf_z = (pf - np.median(pf)) / (np.std(pf) + 1e-12)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl_z = (cl - np.median(cl)) / (np.std(cl) + 1e-12)\n\n    assigned_f = np.where(a != -1)[0]\n    locs = a[assigned_f]\n\n    # Incremental cost using the maximum of the flow\u2011distance products\n    incs = []\n    pairs = []\n    for f in unassigned:\n        for l in free:\n            if assigned_f.size == 0:\n                inc = 0.0\n            else:\n                prod1 = flow_matrix[f, assigned_f] * distance_matrix[l, locs]\n                prod2 = flow_matrix[assigned_f, f] * distance_matrix[locs, l]\n                inc = float(np.max(prod1 + prod2))\n            incs.append(inc)\n            pairs.append((f, l))\n    incs = np.array(incs, dtype=float)\n    inc_z = (incs - np.median(incs)) / (np.std(incs) + 1e-12)\n\n    # Scoring with altered weights\n    scores = inc_z - 0.4 * pf_z[[p[0] for p in pairs]] - 0.2 * cl_z[[p[1] for p in pairs]]\n\n    # Choose among the top\u2011k lowest scores\n    top_k = 7\n    top_idx = np.argpartition(scores, top_k)[:top_k]\n    chosen_local = int(np.argmin(scores[top_idx]))\n    f, l = pairs[top_idx[chosen_local]]\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n\n",
  "zscore_blended_scoring_aug_64": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Soft\u2011minimum selection with random sampling from the lowest scores.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    pf = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    pf_z = (pf - pf.mean()) / (pf.std() + 1e-12)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl_z = (cl - cl.mean()) / (cl.std() + 1e-12)\n\n    assigned_f = np.where(a != -1)[0]\n    locs = a[assigned_f]\n\n    incs = []\n    pairs = []\n    for f in unassigned:\n        for l in free:\n            if assigned_f.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, assigned_f] * distance_matrix[l, locs] +\n                                   flow_matrix[assigned_f, f] * distance_matrix[locs, l]))\n            incs.append(inc)\n            pairs.append((f, l))\n    incs = np.array(incs, dtype=float)\n    inc_z = (incs - incs.mean()) / (incs.std() + 1e-12)\n\n    scores = inc_z - 0.25 * pf_z[[p[0] for p in pairs]] - 0.25 * cl_z[[p[1] for p in pairs]]\n\n    # Soft\u2011min probabilities (\u03b2 controls sharpness)\n    beta = 10.0\n    probs = np.exp(-beta * scores)\n    probs = probs / np.clip(probs.sum(), 1e-12, None)\n\n    rng = np.random.default_rng(7)\n    chosen_idx = int(rng.choice(len(scores), p=probs))\n    f, l = pairs[chosen_idx]\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n\n",
  "zscore_blended_scoring_aug_65": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Approximate incremental cost using weighted averages and deterministic tie\u2011breaking.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    pf = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    pf_z = (pf - pf.mean()) / (pf.std() + 1e-12)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl_z = (cl - cl.mean()) / (cl.std() + 1e-12)\n\n    assigned_f = np.where(a != -1)[0]\n    locs = a[assigned_f]\n\n    # Approximate incremental cost: average flow to assigned facilities times average distance\n    avg_flow = np.mean(flow_matrix[unassigned[:, None], assigned_f], axis=1) if assigned_f.size else np.zeros(unassigned.size)\n    avg_dist = np.mean(distance_matrix[free[:, None], locs], axis=1) if assigned_f.size else np.zeros(free.size)\n\n    incs = np.outer(avg_flow, avg_dist).ravel()\n    inc_z = (incs - incs.mean()) / (incs.std() + 1e-12)\n\n    scores = inc_z - 0.35 * pf_z[np.repeat(unassigned, free.size)] - 0.15 * cl_z[np.tile(free, unassigned.size)]\n\n    # Deterministic tie\u2011breaking with small noise\n    rng = np.random.default_rng(99)\n    noise = rng.uniform(0, 1e-7, size=scores.shape)\n    scores += noise\n\n    idx = int(np.argmin(scores))\n    f_idx = idx // free.size\n    l_idx = idx % free.size\n    chosen_f = unassigned[f_idx]\n    chosen_l = free[l_idx]\n\n    out = list(current_assignment)\n    out[chosen_f] = chosen_l\n    return out\n\n",
  "potential_balance_gap_aug_66": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy selection with normalized facility flow potential and location centrality.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # Indices of unassigned facilities\n    cand_f = np.where(a == -1)[0]\n    if cand_f.size == 0:\n        return list(current_assignment)\n\n    # Indices of free locations\n    used_l = np.zeros(n, dtype=bool)\n    used_l[a[a != -1]] = True\n    free_l = np.where(~used_l)[0]\n\n    # Normalised facility flow potential\n    pf = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n    pf = np.clip(pf, 0.0, 1.0)\n\n    # Normalised location centrality (inverse of distance sum)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)\n\n    # Already assigned facilities and their locations\n    assigned_f = np.where(a != -1)[0]\n    assigned_l = a[assigned_f]\n\n    lam = 0.35\n\n    # Incremental cost matrix for each (facility, location) pair\n    inc_mat = np.zeros((cand_f.size, free_l.size))\n    for i_f, f in enumerate(cand_f):\n        for i_l, l in enumerate(free_l):\n            inc = 0.0\n            for k, lk in zip(assigned_f, assigned_l):\n                inc += flow_matrix[f, k] * distance_matrix[l, lk] + \\\n                       flow_matrix[k, f] * distance_matrix[lk, l]\n            inc_mat[i_f, i_l] = inc\n\n    # Score matrix combining cost and centrality mismatch\n    pf_mat = pf[cand_f][:, None]\n    cl_mat = cl[free_l][None, :]\n    score_mat = inc_mat + lam * np.abs(pf_mat - cl_mat) * (np.abs(inc_mat) + 1.0)\n\n    # Choose the best pair\n    i_f, i_l = np.unravel_index(np.argmin(score_mat), score_mat.shape)\n    best_f = int(cand_f[i_f])\n    best_l = int(free_l[i_l])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "potential_balance_gap_aug_67": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Randomly selects among the top\u2011k lowest scoring (facility, location) pairs.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    cand_f = np.where(a == -1)[0]\n    if cand_f.size == 0:\n        return list(current_assignment)\n\n    used_l = np.zeros(n, dtype=bool)\n    used_l[a[a != -1]] = True\n    free_l = np.where(~used_l)[0]\n\n    pf = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n    pf = np.clip(pf, 0.0, 1.0)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)\n\n    assigned_f = np.where(a != -1)[0]\n    assigned_l = a[assigned_f]\n\n    lam = 0.5\n\n    inc_mat = np.zeros((cand_f.size, free_l.size))\n    for i_f, f in enumerate(cand_f):\n        for i_l, l in enumerate(free_l):\n            inc = 0.0\n            for k, lk in zip(assigned_f, assigned_l):\n                inc += flow_matrix[f, k] * distance_matrix[l, lk] + \\\n                       flow_matrix[k, f] * distance_matrix[lk, l]\n            inc_mat[i_f, i_l] = inc\n\n    pf_mat = pf[cand_f][:, None]\n    cl_mat = cl[free_l][None, :]\n    score_mat = inc_mat + lam * np.abs(pf_mat - cl_mat) * (np.abs(inc_mat) + 1.0)\n\n    # Deterministic noise to break ties\n    noise = 1e-6 * (cand_f[:, None] * 1000 + free_l[None, :])\n    score_mat += noise\n\n    # Pick one of the top\u2011k lowest scores at random\n    top_k = 5\n    flat_idx = np.argpartition(score_mat.ravel(), top_k)[:top_k]\n    rng = np.random.default_rng(0)\n    chosen = rng.choice(flat_idx)\n    i_f, i_l = np.unravel_index(chosen, score_mat.shape)\n\n    best_f = int(cand_f[i_f])\n    best_l = int(free_l[i_l])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "potential_balance_gap_aug_68": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Soft\u2011min selection over all candidate pairs, weighted by a temperature parameter.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    cand_f = np.where(a == -1)[0]\n    if cand_f.size == 0:\n        return list(current_assignment)\n\n    used_l = np.zeros(n, dtype=bool)\n    used_l[a[a != -1]] = True\n    free_l = np.where(~used_l)[0]\n\n    pf = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n    pf = np.clip(pf, 0.0, 1.0)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)\n\n    assigned_f = np.where(a != -1)[0]\n    assigned_l = a[assigned_f]\n\n    lam = 0.3\n\n    inc_mat = np.zeros((cand_f.size, free_l.size))\n    for i_f, f in enumerate(cand_f):\n        for i_l, l in enumerate(free_l):\n            inc = 0.0\n            for k, lk in zip(assigned_f, assigned_l):\n                inc += flow_matrix[f, k] * distance_matrix[l, lk] + \\\n                       flow_matrix[k, f] * distance_matrix[lk, l]\n            inc_mat[i_f, i_l] = inc\n\n    pf_mat = pf[cand_f][:, None]\n    cl_mat = cl[free_l][None, :]\n    score_mat = inc_mat + lam * np.abs(pf_mat - cl_mat) * (np.abs(inc_mat) + 1.0)\n\n    # Soft\u2011min probability distribution\n    tau = 1.0\n    probs = np.exp(-score_mat / tau)\n    probs /= probs.sum()\n\n    rng = np.random.default_rng(0)\n    choice = rng.choice(score_mat.size, p=probs.ravel())\n    i_f, i_l = np.unravel_index(choice, score_mat.shape)\n\n    best_f = int(cand_f[i_f])\n    best_l = int(free_l[i_l])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "deterministic_hash_tiebreak_min_inc_aug_69": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.array(current_assignment, dtype=int)\n    n = cur.size\n\n    # indices still unassigned\n    unassigned = np.where(cur == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    # which locations are already taken\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[cur[cur != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    # indices already assigned and their corresponding locations\n    assigned = np.where(cur != -1)[0]\n    locs = cur[assigned]\n\n    # simple deterministic hash for tie\u2011breaking noise\n    h = int(np.sum((np.arange(n) + 1) * (cur + 2)))\n\n    best_score = np.inf\n    best_f, best_l = int(unassigned[0]), int(free_locs[0])\n\n    # iterate with while loops instead of for loops\n    uf_idx = 0\n    while uf_idx < unassigned.size:\n        f = int(unassigned[uf_idx])\n        fl_idx = 0\n        while fl_idx < free_locs.size:\n            l = int(free_locs[fl_idx])\n\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(\n                    flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                    flow_matrix[assigned, f] * distance_matrix[locs, l]\n                ))\n\n            # deterministic noise in [0,1)\n            noise = ((h ^ (f * 1315423911) ^ (l * 2654435761)) & 0xffffffff) \\\n                    / (2**32 + 1e-12)\n            noise = np.clip(noise, 0.0, 0.9999999999999999)\n\n            score = inc + 1e-6 * noise\n            if score < best_score:\n                best_score, best_f, best_l = score, f, l\n\n            fl_idx += 1\n        uf_idx += 1\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "deterministic_hash_tiebreak_min_inc_aug_70": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.array(current_assignment, dtype=int)\n    n = cur.size\n\n    unassigned = np.where(cur == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[cur[cur != -1]] = True\n    free_locs = np.where(~used)[0]\n\n    assigned = np.where(cur != -1)[0]\n    locs = cur[assigned]\n\n    h = int(np.sum((np.arange(n) + 1) * (cur + 2)))\n\n    # compute incremental costs for all candidate pairs\n    scores = np.full((unassigned.size, free_locs.size), np.inf, dtype=float)\n    for ui, f in enumerate(unassigned):\n        if assigned.size == 0:\n            inc = np.zeros(free_locs.size, dtype=float)\n        else:\n            inc = np.sum(\n                flow_matrix[f, assigned] * distance_matrix[free_locs[:, None], locs],\n                axis=1\n            ) + np.sum(\n                flow_matrix[assigned[:, None], f] * distance_matrix[locs[:, None], free_locs],\n                axis=0\n            )\n        # deterministic noise\n        noise = ((h ^ (f * 1315423911) ^ (free_locs * 2654435761)) & 0xffffffff) \\\n                .astype(np.float64) / (2**32 + 1e-12)\n        noise = np.clip(noise, 0.0, 0.9999999999999999)\n\n        scores[ui, :] = inc + 1e-4 * noise  # heavier weight on noise\n\n    # choose among the best top_k candidates\n    top_k = 7\n    flat = scores.ravel()\n    idxs = np.argpartition(flat, top_k)[:top_k]\n    best_idx = idxs[np.argmin(flat[idxs])]\n    best_f = int(unassigned[best_idx // free_locs.size])\n    best_l = int(free_locs[best_idx % free_locs.size])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "deterministic_hash_tiebreak_min_inc_aug_71": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.array(current_assignment, dtype=int)\n    n = cur.size\n\n    unassigned = np.where(cur == -1)[0]\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[cur[cur != -1]] = True\n    free_locs = np.where(~used)[0]\n\n    assigned = np.where(cur != -1)[0]\n    locs = cur[assigned]\n\n    h = int(np.sum((np.arange(n) + 1) * (cur + 2)))\n\n    # proxy: use maximum of the product instead of sum\n    best_score = np.inf\n    best_f, best_l = int(unassigned[0]), int(free_locs[0])\n\n    for f in unassigned:\n        for l in free_locs:\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                prod1 = flow_matrix[f, assigned] * distance_matrix[l, locs]\n                prod2 = flow_matrix[assigned, f] * distance_matrix[locs, l]\n                inc = float(np.max(prod1 + prod2))\n\n            # bounded deterministic noise\n            noise = ((h ^ (f * 1315423911) ^ (l * 2654435761)) & 0xffffffff) \\\n                    / (2**32 + 1e-12)\n            noise = np.clip(noise, 0.0, 0.9999999999999999)\n\n            score = inc + 1e-5 * noise\n            if score < best_score:\n                best_score, best_f, best_l = score, f, l\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "two_swap_improvement_if_complete_aug_72": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy incremental assignment with a soft\u2011min selection and deterministic noise.\n    All variable names are renamed and vectorized operations are used where possible.\n    \"\"\"\n    flow_mat = np.asarray(flow_matrix, dtype=float)\n    dist_mat  = np.asarray(distance_matrix, dtype=float)\n\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0]\n\n    # Vectorized total cost with a tiny denominator to avoid division by zero\n    def total_cost(arr: np.ndarray) -> float:\n        idx = np.arange(n)\n        L   = arr.astype(int)\n        prod = flow_mat[np.ix_(idx, idx)] * dist_mat[np.ix_(L, L)]\n        return np.sum(prod) / (1.0 + 1e-12)\n\n    # ----------  Complete assignment : 2\u2011swap local search  ----------\n    if un.size == 0:\n        best_cost = total_cost(a)\n        best_arr  = a.copy()\n        i = 0\n        while i < n:\n            j = i + 1\n            while j < n:\n                b = a.copy()\n                b[i], b[j] = b[j], b[i]\n                c = total_cost(b)\n                if c < best_cost:\n                    best_cost, best_arr = c, b\n                j += 1\n            i += 1\n        return best_arr.tolist()\n\n    # ----------  Incomplete assignment : greedy incremental  ----------\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass  = np.where(a != -1)[0]\n    locs = a[ass].astype(int)\n\n    # Build a matrix of incremental costs for all (f,l) pairs\n    inc_mat = np.full((un.size, free.size), np.inf, dtype=float)\n    for fi, f in enumerate(un):\n        for li, l in enumerate(free):\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = np.sum(flow_mat[f, ass] * dist_mat[l, locs] +\n                             flow_mat[ass, f] * dist_mat[locs, l])\n            inc_mat[fi, li] = inc\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(inc_mat.size).reshape(inc_mat.shape)\n    inc_mat += noise\n\n    # Soft\u2011min: choose the pair with the smallest noisy incremental cost\n    idx_min = np.unravel_index(np.argmin(inc_mat), inc_mat.shape)\n    best_f  = int(un[idx_min[0]])\n    best_l  = int(free[idx_min[1]])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "two_swap_improvement_if_complete_aug_73": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Uses while\u2011loops, a top\u2011k selection strategy, and np.max aggregation for\n    incremental cost evaluation. Variable names are changed for clarity.\n    \"\"\"\n    f_mat = np.asarray(flow_matrix, dtype=float)\n    d_mat = np.asarray(distance_matrix, dtype=float)\n\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    pending = np.where(assign == -1)[0]\n\n    # Helper to compute total cost (using np.max for a proxy aggregation)\n    def total_cost(arr: np.ndarray) -> float:\n        idx = np.arange(n)\n        L   = arr.astype(int)\n        prod = f_mat[np.ix_(idx, idx)] * d_mat[np.ix_(L, L)]\n        # Proxy: use the maximum pairwise product as a rough cost estimate\n        return np.max(prod) / (1.0 + 1e-12)\n\n    # ----------  Complete assignment : exhaustive 2\u2011swap ----------\n    if pending.size == 0:\n        best = total_cost(assign)\n        best_arr = assign.copy()\n        i = 0\n        while i < n:\n            j = i + 1\n            while j < n:\n                b = assign.copy()\n                b[i], b[j] = b[j], b[i]\n                c = total_cost(b)\n                if c < best:\n                    best, best_arr = c, b\n                j += 1\n            i += 1\n        return best_arr.tolist()\n\n    # ----------  Incomplete assignment : top\u2011k greedy ----------\n    used = np.zeros(n, dtype=bool)\n    used[assign[assign != -1]] = True\n    free = np.where(~used)[0]\n\n    ass  = np.where(assign != -1)[0]\n    locs = assign[ass].astype(int)\n\n    # Compute incremental costs for all (f,l) pairs\n    inc_list = []\n    for f in pending:\n        for l in free:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = np.sum(f_mat[f, ass] * d_mat[l, locs] +\n                             f_mat[ass, f] * d_mat[locs, l])\n            inc_list.append((inc, f, l))\n\n    # Take the top\u2011k smallest increments (k = 7)\n    k = 7\n    inc_list.sort(key=lambda x: x[0] + 1e-9 * (x[1]*1000 + x[2]))\n    best_f, best_l = inc_list[min(k, len(inc_list)) - 1][1:]  # deterministic tie\u2011break\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "two_swap_improvement_if_complete_aug_74": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Implements a list\u2011comprehension based cost estimate using np.median as a\n    proxy aggregation, and a deterministic random\u2011like tie\u2011breaker.\n    Variable names are further obfuscated.\n    \"\"\"\n    f = np.asarray(flow_matrix, dtype=float)\n    d = np.asarray(distance_matrix, dtype=float)\n\n    a = np.array(current_assignment, dtype=int)\n    N = a.size\n    cand = np.where(a == -1)[0]\n\n    # Proxy total cost: median of pairwise products\n    def total_cost(arr: np.ndarray) -> float:\n        idx = np.arange(N)\n        L   = arr.astype(int)\n        prod = f[np.ix_(idx, idx)] * d[np.ix_(L, L)]\n        return np.median(prod) / (1.0 + 1e-12)\n\n    # ----------  Full assignment: exhaustive swap ----------\n    if cand.size == 0:\n        best_val = total_cost(a)\n        best_arr = a.copy()\n        i = 0\n        while i < N:\n            j = i + 1\n            while j < N:\n                b = a.copy()\n                b[i], b[j] = b[j], b[i]\n                c = total_cost(b)\n                if c < best_val:\n                    best_val, best_arr = c, b\n                j += 1\n            i += 1\n        return best_arr.tolist()\n\n    # ----------  Partial assignment: median\u2011based greedy ----------\n    used = np.zeros(N, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned].astype(int)\n\n    # Build list of (increment, f, l) tuples\n    inc_tuples = [(0.0 if assigned.size == 0 else\n                   sum(f[f, assigned] * d[l, locs] + f[assigned, f] * d[locs, l]),\n                   f, l)\n                  for f in cand for l in free]\n\n    # Add deterministic pseudo\u2011noise for tie\u2011breaking\n    noise_factor = 1e-8\n    inc_tuples = [(inc + noise_factor * (f*1000 + l), f, l) for inc, f, l in inc_tuples]\n\n    # Pick the minimal noisy increment\n    best_inc, best_f, best_l = min(inc_tuples, key=lambda x: x[0])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "two_swap_improvement_if_complete_aug_75": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Recursive local search with squared distances and clipping. Variable\n    names are heavily obfuscated. Uses deterministic noise and epsilon\n    protection for division.\n    \"\"\"\n    f_mat = np.asarray(flow_matrix, dtype=float)\n    d_mat = np.asarray(distance_matrix, dtype=float)\n\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n\n    # Helper: total cost using squared distances and clipping\n    def total_cost(arr: np.ndarray) -> float:\n        idx = np.arange(n)\n        L   = arr.astype(int)\n        prod = f_mat[np.ix_(idx, idx)] * np.square(d_mat[np.ix_(L, L)])\n        # Clip to avoid overflow and divide by a small epsilon\n        prod = np.clip(prod, 0, 1e12)\n        return np.sum(prod) / (1.0 + 1e-12)\n\n    # ----------  Full assignment: recursive 2\u2011swap ----------\n    if unassigned.size == 0:\n        best = total_cost(a)\n        best_arr = a.copy()\n        def recurse(i: int, arr: np.ndarray):\n            nonlocal best, best_arr\n            if i >= n:\n                return\n            j = i + 1\n            while j < n:\n                b = arr.copy()\n                b[i], b[j] = b[j], b[i]\n                c = total_cost(b)\n                if c < best:\n                    best, best_arr = c, b\n                j += 1\n            recurse(i + 1, arr)\n\n        recurse(0, a)\n        return best_arr.tolist()\n\n    # ----------  Partial assignment: deterministic greedy ----------\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass   = np.where(a != -1)[0]\n    locs  = a[ass].astype(int)\n\n    best_inc = float(\"inf\")\n    best_f = None\n    best_l = None\n\n    for f in unassigned:\n        for l in free:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = np.sum(f_mat[f, ass] * d_mat[l, locs] +\n                             f_mat[ass, f] * d_mat[locs, l])\n            # Deterministic pseudo\u2011noise\n            inc += 1e-9 * (f * 1000 + l)\n            if inc < best_inc:\n                best_inc, best_f, best_l = inc, f, l\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "sampled_three_cycle_if_complete_aug_76": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    candidates = np.where(a == -1)[0]\n\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    def total_cost(arr):\n        idx = np.arange(n)\n        L = arr.astype(int)\n        return float(np.sum(flow_mat[np.ix_(idx, idx)] * dist_mat[np.ix_(L, L)]))\n\n    if candidates.size == 0:\n        best_cost = total_cost(a)\n        best_arr = a.copy()\n        max_samples = min(200, n * (n - 1) * (n - 2) // 6)\n        i = 0\n        while i < max_samples:\n            tri = np.random.choice(n, 3, replace=False)\n            b = a.copy()\n            b[tri[0]], b[tri[1]], b[tri[2]] = a[tri[2]], a[tri[0]], a[tri[1]]\n            c = total_cost(b)\n            if c < best_cost:\n                best_cost, best_arr = c, b\n            i += 1\n        return best_arr.astype(int).tolist()\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0]\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    def delta(f, l):\n        if assigned.size == 0:\n            return 0.0\n        return float(np.sum(flow_mat[f, assigned] * dist_mat[l, locs] +\n                            flow_mat[assigned, f] * dist_mat[locs, l]))\n\n    # Build delta matrix and apply a softmin selection\n    delta_mat = np.array([[delta(int(f), int(l)) for l in free_locs] for f in candidates],\n                         dtype=float)\n    eps = 1e-12\n    probs = np.exp(-delta_mat / (np.max(delta_mat) + eps))\n    probs = probs / (np.sum(probs, axis=1, keepdims=True) + eps)\n    probs = np.clip(probs, 0, 1)\n    exp_delta = np.sum(probs * delta_mat, axis=1)\n    best_idx = np.argmin(exp_delta)\n    best_f = int(candidates[best_idx])\n    best_l = int(free_locs[np.argmin(delta_mat[best_idx])])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "sampled_three_cycle_if_complete_aug_77": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix * 0.6   # tuned weight\n\n    def total_cost(arr):\n        idx = np.arange(n)\n        L = arr.astype(int)\n        return float(np.sum(flow_mat[np.ix_(idx, idx)] * dist_mat[np.ix_(L, L)]))\n\n    if unassigned.size == 0:\n        base = total_cost(a)\n        best = base\n        best_arr = a.copy()\n        m = min(200, n * (n - 1) * (n - 2) // 6)\n        for _ in range(m):\n            tri = np.random.choice(n, 3, replace=False)\n            b = a.copy()\n            b[tri[0]], b[tri[1]], b[tri[2]] = a[tri[2]], a[tri[0]], a[tri[1]]\n            c = total_cost(b)\n            if c < best:\n                best, best_arr = c, b\n        return best_arr.astype(int).tolist()\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0]\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    def delta(f, l):\n        if assigned.size == 0:\n            return 0.0\n        return float(np.sum(flow_mat[f, assigned] * dist_mat[l, locs] +\n                            flow_mat[assigned, f] * dist_mat[locs, l]))\n\n    top_k = min(7, len(unassigned))\n    min_costs = []\n    for f in unassigned:\n        costs = np.array([delta(int(f), int(l)) for l in free_locs], dtype=float)\n        noise = np.arange(costs.size) * 1e-8          # deterministic tie\u2011breaker\n        costs_noisy = costs + noise\n        min_costs.append((np.min(costs_noisy), f, costs_noisy))\n    min_costs.sort(key=lambda x: x[0])\n    best_f = int(min_costs[0][1])\n    best_l = int(free_locs[np.argmin(min_costs[0][2])])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "sampled_three_cycle_if_complete_aug_78": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n\n    flow_mat = flow_matrix\n    dist_proxy = distance_matrix ** 2          # proxy approximation\n\n    def total_cost(arr):\n        idx = np.arange(n)\n        L = arr.astype(int)\n        return float(np.sum(flow_mat[np.ix_(idx, idx)] * dist_proxy[np.ix_(L, L)]))\n\n    if unassigned.size == 0:\n        base = total_cost(a)\n        best = base\n        best_arr = a.copy()\n        m = min(200, n * (n - 1) * (n - 2) // 6)\n        for _ in range(m):\n            tri = np.random.choice(n, 3, replace=False)\n            b = a.copy()\n            b[tri[0]], b[tri[1]], b[tri[2]] = a[tri[2]], a[tri[0]], a[tri[1]]\n            c = total_cost(b)\n            if c < best:\n                best, best_arr = c, b\n        return best_arr.astype(int).tolist()\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0]\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    def delta(f, l):\n        if assigned.size == 0:\n            return 0.0\n        return float(np.sum(flow_mat[f, assigned] * dist_proxy[l, locs] +\n                            flow_mat[assigned, f] * dist_proxy[locs, l]))\n\n    top_k = min(5, len(unassigned))\n    medians = []\n    for f in unassigned:\n        costs = np.array([delta(int(f), int(l)) for l in free_locs], dtype=float)\n        medians.append((np.median(costs), f, costs))\n    medians.sort(key=lambda x: x[0])\n    chosen_f = int(medians[0][1])\n\n    costs_chosen = medians[0][2]\n    sorted_idx = np.argsort(costs_chosen)\n    top_locs = free_locs[sorted_idx[:top_k]]\n    best_l = int(np.random.choice(top_locs))\n\n    out = list(current_assignment)\n    out[chosen_f] = best_l\n    return out\n\n",
  "future_pairwise_top_neighbor_flow_aug_79": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy selection with vectorized cost and median\u2011based distance estimate.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    cand_nodes = np.where(a == -1)[0].astype(int)\n    if cand_nodes.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0].astype(int)\n\n    assigned_nodes = np.where(a != -1)[0].astype(int)\n    assigned_locs = a[assigned_nodes].astype(int)\n\n    sym_flow_mat = (flow_matrix + flow_matrix.T).astype(float)\n\n    # median distance among free locations, with epsilon in denominator\n    free_sub = distance_matrix[np.ix_(free_locs, free_locs)]\n    mean_dist = float(np.median(free_sub)) if free_locs.size > 1 else 0.0\n\n    # vectorized computation of incremental cost for all (node, location) pairs\n    scores = np.full((cand_nodes.size, free_locs.size), np.inf, dtype=float)\n    for i, f in enumerate(cand_nodes):\n        # strongest remaining interactions for f\n        k = min(5, cand_nodes.size)\n        nbrs = cand_nodes[np.argsort(-sym_flow_mat[f, cand_nodes])[:k]]\n        future_mass = float(sym_flow_mat[f, nbrs].sum())\n\n        # compute cost for each free location\n        if assigned_nodes.size == 0:\n            inc_cost = np.zeros(free_locs.size, dtype=float)\n        else:\n            inc_cost = np.sum(\n                flow_matrix[f, assigned_nodes][:, None] * distance_matrix[free_locs, :][:, assigned_locs] +\n                flow_matrix[assigned_nodes, f][:, None] * distance_matrix[assigned_locs, :][:, free_locs],\n                axis=0\n            )\n\n        # add small noise for deterministic tie\u2011breaking\n        noise = np.random.uniform(0, 1e-6, size=free_locs.size)\n        scores[i] = inc_cost + 0.10 * future_mass * mean_dist + noise\n\n    # choose the (node, location) pair with the minimal score\n    best_idx = np.unravel_index(np.argmin(scores), scores.shape)\n    best_f = cand_nodes[best_idx[0]]\n    best_l = free_locs[best_idx[1]]\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "future_pairwise_top_neighbor_flow_aug_80": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"While\u2011loop based selection with a higher future\u2011mass weight and clipped distance.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0].astype(int)\n    if unassigned.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0].astype(int)\n\n    assigned = np.where(a != -1)[0].astype(int)\n    locs = a[assigned].astype(int)\n\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # clipped median distance among free locations\n    free_sub = distance_matrix[np.ix_(free_locs, free_locs)]\n    mean_d = float(np.median(free_sub)) if free_locs.size > 1 else 0.0\n    max_d = float(np.max(distance_matrix))\n    mean_d = np.clip(mean_d, 0.0, max_d + 1e-12)\n\n    top_k = min(7, unassigned.size)\n    best_f, best_l, best_score = int(unassigned[0]), int(free_locs[0]), float(\"inf\")\n\n    idx = 0\n    while idx < unassigned.size:\n        f = int(unassigned[idx])\n\n        nbrs = unassigned[np.argsort(-sym_flow[f, unassigned])[:top_k]]\n        future_mass = float(sym_flow[f, nbrs].sum())\n\n        for l in free_locs:\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(\n                    flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                    flow_matrix[assigned, f] * distance_matrix[locs, l]\n                ))\n            score = inc + 0.40 * future_mass * mean_d\n            if score < best_score:\n                best_score, best_f, best_l = score, f, int(l)\n\n        idx += 1\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "future_pairwise_top_neighbor_flow_aug_81": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"List\u2011comprehension based selection with sqrt future mass and clipped score.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    unvisited = np.where(a == -1)[0].astype(int)\n    if unvisited.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_locs = np.where(~used)[0].astype(int)\n\n    assigned = np.where(a != -1)[0].astype(int)\n    assigned_locs = a[assigned].astype(int)\n\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # clipped mean distance with epsilon\n    sub = distance_matrix[np.ix_(free_locs, free_locs)]\n    mean_d = float(np.mean(sub)) if free_locs.size > 1 else 0.0\n    mean_d = np.clip(mean_d, 0.0, np.max(distance_matrix) + 1e-12)\n\n    k = min(5, unvisited.size)\n\n    def compute_score(f, l):\n        nbrs = unvisited[np.argsort(-sym_flow[f, unvisited])[:k]]\n        future_mass = float(np.max(sym_flow[f, nbrs]))\n        if assigned.size == 0:\n            inc = 0.0\n        else:\n            inc = float(np.sum(\n                flow_matrix[f, assigned] * distance_matrix[l, assigned_locs] +\n                flow_matrix[assigned, f] * distance_matrix[assigned_locs, l]\n            ))\n        raw = inc + 0.10 * future_mass * mean_d\n        return np.clip(raw, 0.0, np.inf)\n\n    scores = [compute_score(f, l) for f in unvisited for l in free_locs]\n    best_idx = np.argmin(scores)\n    best_f = int(unvisited[best_idx // free_locs.size])\n    best_l = int(free_locs[best_idx % free_locs.size])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n\n",
  "robust_median_centrality_assignment_aug_82": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Robust median\u2011based centrality with explicit loops and clipped distances.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    # Mark used locations\n    used = np.zeros(n, dtype=bool)\n    for idx in a[a != -1]:\n        used[idx] = True\n    free = np.where(~used)[0].astype(int)\n\n    # Facility with largest combined flow\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    f = int(un[np.argmax(pf[un])])\n\n    # Median distance to free locations\n    med = np.median(distance_matrix[free], axis=1).astype(float)\n    l0 = int(free[np.argmin(med)])\n\n    # Current assigned facilities and their locations\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    # Choose next location\n    if ass.size != 0:\n        cand = free[np.argsort(med)[:min(6, free.size)]]\n        best, l = float(\"inf\"), int(cand[0])\n        for loc in cand:\n            dist1 = np.clip(distance_matrix[loc, locs], 0, 1e9)\n            dist2 = np.clip(distance_matrix[locs, loc], 0, 1e9)\n            inc = float(np.sum(flow_matrix[f, ass] * dist1 +\n                               flow_matrix[ass, f] * dist2))\n            if inc < best:\n                best, l = inc, int(loc)\n    else:\n        l = l0\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n\n",
  "robust_median_centrality_assignment_aug_83": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Weighted flow scoring and mean\u2011based centrality with top\u2011k tuning.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    for idx in a[a != -1]:\n        used[idx] = True\n    free = np.where(~used)[0].astype(int)\n\n    # Weighted combined flow (70% row sum, 30% column sum)\n    pf = (0.7 * flow_matrix.sum(axis=1) + 0.3 * flow_matrix.sum(axis=0)).astype(float)\n    f = int(un[np.argmax(pf[un])])\n\n    # Mean distance to free locations, with tiny noise for deterministic tie\u2011break\n    med = np.mean(distance_matrix[free], axis=1).astype(float)\n    med += np.random.uniform(0, 1e-6, size=med.shape)\n    l0 = int(free[np.argmin(med)])\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    if ass.size != 0:\n        top_k = 8\n        cand = free[np.argsort(med)[:min(top_k, free.size)]]\n        best, l = float(\"inf\"), int(cand[0])\n        for loc in cand:\n            dist1 = np.clip(distance_matrix[loc, locs], 0, 1e9)\n            dist2 = np.clip(distance_matrix[locs, loc], 0, 1e9)\n            inc = float(np.sum(flow_matrix[f, ass] * dist1 +\n                               flow_matrix[ass, f] * dist2))\n            inc = np.clip(inc, 0, 1e12)          # safe upper bound\n            if inc < best:\n                best, l = inc, int(loc)\n    else:\n        l = l0\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n\n",
  "robust_median_centrality_assignment_aug_84": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Soft\u2011min location choice and soft\u2011max facility selection with random top\u2011k tie\u2011break.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    for idx in a[a != -1]:\n        used[idx] = True\n    free = np.where(~used)[0].astype(int)\n\n    # Soft\u2011max facility selection\n    pf_vals = flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)\n    pf_norm = pf_vals[un] / (np.sum(pf_vals[un]) + 1e-12)\n    f = int(un[np.random.choice(un.size, p=pf_norm)])\n\n    # Mean distance with deterministic noise\n    med = np.mean(distance_matrix[free], axis=1).astype(float)\n    med += np.random.uniform(0, 1e-6, size=med.shape)\n\n    # Soft\u2011min location selection among top\u2011k\n    top_k = 6\n    top_idx = np.argsort(med)[:min(top_k, free.size)]\n    probs = np.exp(-10 * med[top_idx])\n    probs /= probs.sum() + 1e-12\n    chosen = np.random.choice(top_idx, p=probs)\n    l = int(free[chosen])\n\n    # Incremental cost calculation with clipped distances\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n    if ass.size != 0:\n        dist1 = np.clip(distance_matrix[l, locs], 0, 1e9)\n        dist2 = np.clip(distance_matrix[locs, l], 0, 1e9)\n        inc = float(np.sum(flow_matrix[f, ass] * dist1 +\n                           flow_matrix[ass, f] * dist2))\n    else:\n        inc = 0.0\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n\n",
  "robust_median_centrality_assignment_aug_85": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Proxy approximation: max\u2011based cost, mean centrality, soft\u2011max selections, top\u2011k = 10.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    for idx in a[a != -1]:\n        used[idx] = True\n    free = np.where(~used)[0].astype(int)\n\n    # Soft\u2011max facility selection with scaling\n    pf_vals = flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)\n    pf_scaled = np.exp(5 * pf_vals[un])\n    pf_norm = pf_scaled / (pf_scaled.sum() + 1e-12)\n    f = int(un[np.random.choice(un.size, p=pf_norm)])\n\n    # Mean distance for centrality, clipped for safety\n    med = np.mean(distance_matrix[free], axis=1).astype(float)\n    med = np.clip(med, 0, 1e6)\n\n    # Soft\u2011min location selection among top\u2011k\n    top_k = 10\n    top_idx = np.argsort(med)[:min(top_k, free.size)]\n    probs = np.exp(-5 * med[top_idx])\n    probs /= probs.sum() + 1e-12\n    chosen = np.random.choice(top_idx, p=probs)\n    l = int(free[chosen])\n\n    # Incremental cost using max instead of sum (proxy)\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n    if ass.size != 0:\n        dist1 = np.clip(distance_matrix[l, locs], 0, 1e6)\n        dist2 = np.clip(distance_matrix[locs, l], 0, 1e6)\n        inc = float(np.max(flow_matrix[f, ass] * dist1 +\n                           flow_matrix[ass, f] * dist2))\n    else:\n        inc = 0.0\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n\n",
  "facility_diversity_then_greedy_aug_86": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Softmin location selection, median flow profile, deterministic noise for ties.\"\"\"\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n\n    # Identify unassigned facilities\n    candidates = [i for i, v in enumerate(assign) if v == -1]\n    if not candidates:\n        return list(assign)\n\n    # Determine free locations\n    used_locs = assign[assign != -1]\n    free_locs = [i for i in range(n) if i not in used_locs]\n\n    # Facilities already placed\n    placed = [i for i, v in enumerate(assign) if v != -1]\n    progress = 1.0 - (len(candidates) / max(1, n))\n\n    # Flow feature: symmetric matrix\n    F = (flow_matrix + flow_matrix.T).astype(float)\n\n    if placed and progress < 0.6:\n        # Median flow profile of placed facilities\n        mu = np.median(F[placed], axis=0)\n        # Euclidean distance to median\n        dists = np.linalg.norm(F[candidates] - mu, axis=1)\n        f = int(candidates[int(np.argmax(dists))])\n    else:\n        tot_flow = F.sum(axis=1)\n        f = int(candidates[int(np.argmax(tot_flow[candidates]))])\n\n    # Locations of already placed facilities\n    locs = assign[placed].astype(int)\n\n    # Compute incremental cost for each free location\n    inc_values = []\n    for loc in free_locs:\n        if not placed:\n            inc = 0.0\n        else:\n            flow_to = flow_matrix[f, placed]\n            flow_from = flow_matrix[placed, f]\n            dist_to = distance_matrix[loc, locs]\n            dist_from = distance_matrix[locs, loc]\n            inc = float(np.sum(flow_to * dist_to + flow_from * dist_from))\n        inc_values.append(inc)\n\n    inc_values = np.array(inc_values, dtype=float)\n\n    # Add deterministic noise for tie-breaking\n    inc_values += np.arange(len(inc_values)) * 1e-9\n\n    # Softmin probabilities\n    beta = 10.0\n    exp_vals = np.exp(-beta * inc_values)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    chosen_idx = int(np.argmax(probs))\n    chosen_loc = free_locs[chosen_idx]\n\n    out = list(assign)\n    out[f] = chosen_loc\n    return out\n\n",
  "facility_diversity_then_greedy_aug_87": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"While-loop, weighted max aggregation, adjusted threshold.\"\"\"\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n\n    # Unassigned facilities\n    candidates = np.where(assign == -1)[0]\n    if candidates.size == 0:\n        return list(assign)\n\n    # Free locations\n    used_locs = assign[assign != -1]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    # Already placed facilities\n    placed = np.where(assign != -1)[0]\n    progress = 1.0 - (candidates.size / (max(1, n) + 1e-12))\n\n    F = (flow_matrix + flow_matrix.T).astype(float)\n\n    if placed.size and progress < 0.7:\n        mu = F[placed].mean(axis=0)\n        dists = np.linalg.norm(F[candidates] - mu, axis=1)\n        f = int(candidates[int(np.argmax(dists))])\n    else:\n        tot_flow = F.sum(axis=1)\n        f = int(candidates[int(np.argmax(tot_flow[candidates]))])\n\n    locs = assign[placed].astype(int)\n\n    best_inc = float(\"inf\")\n    chosen_loc = int(free_locs[0])\n\n    idx = 0\n    while idx < free_locs.size:\n        loc = int(free_locs[idx])\n        if placed.size == 0:\n            inc = 0.0\n        else:\n            flow_to = flow_matrix[f, placed]\n            flow_from = flow_matrix[placed, f]\n            dist_to = distance_matrix[loc, locs]\n            dist_from = distance_matrix[locs, loc]\n            inc = 0.7 * np.max(flow_to * dist_to) + 0.3 * np.max(flow_from * dist_from)\n        inc = float(np.clip(inc, 0, np.inf))\n        if inc < best_inc:\n            best_inc = inc\n            chosen_loc = loc\n        idx += 1\n\n    out = list(assign)\n    out[f] = chosen_loc\n    return out\n\n",
  "facility_diversity_then_greedy_aug_88": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Random top-k location choice, max-based facility selection, distance clipping.\"\"\"\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n\n    # Candidates for unassigned facilities\n    candidates = np.where(assign == -1)[0]\n    if candidates.size == 0:\n        return list(assign)\n\n    # Free locations\n    used_locs = assign[assign != -1]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    # Already placed facilities\n    placed = np.where(assign != -1)[0]\n    progress = 1.0 - (candidates.size / (max(1, n) + 1e-12))\n\n    F = (flow_matrix + flow_matrix.T).astype(float)\n\n    if placed.size and progress < 0.5:\n        # Use max distance to mean flow profile\n        mu = F[placed].mean(axis=0)\n        dists = np.linalg.norm(F[candidates] - mu, axis=1)\n        f = int(candidates[int(np.argmax(dists))])\n    else:\n        # Use max total flow for selection\n        tot_flow = F.sum(axis=1)\n        f = int(candidates[int(np.argmax(tot_flow[candidates]))])\n\n    locs = assign[placed].astype(int)\n\n    # Compute incremental cost for all free locations\n    inc_arr = []\n    for loc in free_locs:\n        if placed.size == 0:\n            inc = 0.0\n        else:\n            flow_to = flow_matrix[f, placed]\n            flow_from = flow_matrix[placed, f]\n            # Clip distances to [0, 1] to avoid extreme values\n            dist_to = np.clip(distance_matrix[loc, locs], 0, 1)\n            dist_from = np.clip(distance_matrix[locs, loc], 0, 1)\n            inc = float(np.sum(flow_to * dist_to + flow_from * dist_from))\n        inc_arr.append(inc)\n\n    inc_arr = np.array(inc_arr, dtype=float)\n\n    # Select top-k lowest incremental costs\n    top_k = 7\n    if inc_arr.size <= top_k:\n        candidates_idx = np.argsort(inc_arr)\n    else:\n        candidates_idx = np.argpartition(inc_arr, top_k)[:top_k]\n        candidates_idx = candidates_idx[np.argsort(inc_arr[candidates_idx])]\n\n    # Randomly pick one among top-k\n    chosen_idx = int(np.random.choice(candidates_idx))\n    chosen_loc = int(free_locs[chosen_idx])\n\n    out = list(assign)\n    out[f] = chosen_loc\n    return out\n\n",
  "flow_distance_cosine_alignment_aug_89": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    if (assign == -1).sum() == 0:\n        return list(assign)\n\n    # facilities and locations that are still free\n    unassigned = np.where(assign == -1)[0]\n    used_locs = np.where(assign != -1)[0]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    # prepare matrices\n    flow_mat = flow_matrix.astype(float)\n    dist_mat = distance_matrix.astype(float)\n\n    # symmetric flow profile\n    F = flow_mat + flow_mat.T\n    # inverse distance profile\n    G = 1.0 / (dist_mat + 1e-6)\n\n    # normalise profiles\n    Fz = F / (np.linalg.norm(F, axis=1, keepdims=True) + 1e-12)\n    Gz = G / (np.linalg.norm(G, axis=1, keepdims=True) + 1e-12)\n\n    # already placed facilities and their locations\n    placed_fac = np.where(assign != -1)[0]\n    placed_loc = assign[placed_fac]\n\n    best_f, best_l = unassigned[0], free_locs[0]\n    best_score = -np.inf\n\n    for f in unassigned:\n        for l in free_locs:\n            # cosine alignment\n            align = float(np.dot(Fz[f], Gz[l]))\n            # incremental cost\n            if placed_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(\n                    flow_mat[f, placed_fac] * dist_mat[l, placed_loc] +\n                    flow_mat[placed_fac, f] * dist_mat[placed_loc, l]\n                ))\n            # deterministic tie\u2011breaker\n            noise = 1e-6 * (f * 1000 + l)\n            score = align - 0.002 * inc + noise\n            if score > best_score:\n                best_score = score\n                best_f, best_l = f, l\n\n    result = list(assign)\n    result[best_f] = best_l\n    return result\n\n",
  "flow_distance_cosine_alignment_aug_90": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    if (assign == -1).sum() == 0:\n        return list(assign)\n\n    unassigned = np.where(assign == -1)[0]\n    used_locs = np.where(assign != -1)[0]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    flow_mat = flow_matrix.astype(float)\n    dist_mat = distance_matrix.astype(float)\n\n    F = flow_mat + flow_mat.T\n    G = 1.0 / (dist_mat + 1e-6)\n\n    Fz = F / (np.linalg.norm(F, axis=1, keepdims=True) + 1e-12)\n    Gz = G / (np.linalg.norm(G, axis=1, keepdims=True) + 1e-12)\n\n    placed_fac = np.where(assign != -1)[0]\n    placed_loc = assign[placed_fac]\n\n    best_f, best_l = unassigned[0], free_locs[0]\n    best_score = -np.inf\n    idx = 0\n    while idx < len(unassigned):\n        f = unassigned[idx]\n        for l in free_locs:\n            align = float(np.dot(Fz[f], Gz[l]))\n            align = np.clip(align, 0, 1)   # bound the alignment\n            if placed_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.max(\n                    flow_mat[f, placed_fac] * dist_mat[l, placed_loc] +\n                    flow_mat[placed_fac, f] * dist_mat[placed_loc, l]\n                ))\n            noise = 1e-8 * (f + l)        # deterministic tie\u2011breaker\n            score = align - 0.0015 * inc + noise\n            if score > best_score:\n                best_score = score\n                best_f, best_l = f, l\n        idx += 1\n\n    result = list(assign)\n    result[best_f] = best_l\n    return result\n\n",
  "flow_distance_cosine_alignment_aug_91": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    if (assign == -1).sum() == 0:\n        return list(assign)\n\n    unassigned = np.where(assign == -1)[0]\n    used_locs = np.where(assign != -1)[0]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    flow_mat = flow_matrix.astype(float)\n    dist_mat = distance_matrix.astype(float)\n\n    F = flow_mat + flow_mat.T\n    G = 1.0 / (dist_mat + 1e-6)\n\n    Fz = F / (np.linalg.norm(F, axis=1, keepdims=True) + 1e-12)\n    Gz = G / (np.linalg.norm(G, axis=1, keepdims=True) + 1e-12)\n\n    placed_fac = np.where(assign != -1)[0]\n    placed_loc = assign[placed_fac]\n\n    scores = []\n    pairs = []\n    for f in unassigned:\n        for l in free_locs:\n            align = float(np.dot(Fz[f], Gz[l]))\n            align = np.clip(align, 0, 1)\n            if placed_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(\n                    flow_mat[f, placed_fac] * dist_mat[l, placed_loc] +\n                    flow_mat[placed_fac, f] * dist_mat[placed_loc, l]\n                ))\n            score = align - 0.003 * inc\n            pairs.append((f, l))\n            scores.append(score)\n\n    scores = np.array(scores)\n    top_k = min(7, len(scores))\n    top_idx = np.argpartition(-scores, top_k - 1)[:top_k]\n    top_scores = scores[top_idx]\n    top_pairs = [pairs[i] for i in top_idx]\n\n    # softmin selection\n    temp = 0.1\n    probs = np.exp(-top_scores / temp)\n    probs /= probs.sum()\n    chosen = np.argmax(probs * (np.arange(len(probs)) + 1e-12))\n    best_f, best_l = top_pairs[chosen]\n\n    result = list(assign)\n    result[best_f] = best_l\n    return result\n\n",
  "flow_distance_cosine_alignment_aug_92": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.array(current_assignment, dtype=int)\n    n = assign.size\n    if (assign == -1).sum() == 0:\n        return list(assign)\n\n    unassigned = np.where(assign == -1)[0]\n    used_locs = np.where(assign != -1)[0]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    flow_mat = flow_matrix.astype(float)\n    dist_mat = distance_matrix.astype(float)\n\n    F = flow_mat + flow_mat.T\n    G = 1.0 / (dist_mat + 1e-6)\n\n    Fz = F / (np.linalg.norm(F, axis=1, keepdims=True) + 1e-12)\n    Gz = G / (np.linalg.norm(G, axis=1, keepdims=True) + 1e-12)\n\n    placed_fac = np.where(assign != -1)[0]\n    placed_loc = assign[placed_fac]\n\n    best_f, best_l = unassigned[0], free_locs[0]\n    best_score = -np.inf\n\n    for f in unassigned:\n        for l in free_locs:\n            align = float(np.dot(Fz[f], Gz[l]))\n            align = np.clip(align, 0, 1)   # keep alignment in [0,1]\n            if placed_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.max(\n                    flow_mat[f, placed_fac] * dist_mat[l, placed_loc] +\n                    flow_mat[placed_fac, f] * dist_mat[placed_loc, l]\n                ))\n            noise = 1e-7 * (f - l)         # deterministic tie\u2011breaker\n            score = align - 0.01 * inc + noise\n            if score > best_score:\n                best_score = score\n                best_f, best_l = f, l\n\n    result = list(assign)\n    result[best_f] = best_l\n    return result\n\n",
  "min_incremental_cost_pair_cached_aug_93": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return a.tolist()\n    used = np.zeros(n, dtype=bool)\n    if a[a != -1].size:\n        used[a[a != -1]] = True\n    free = np.where(~used)[0]\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n    if ass.size == 0:\n        inc = np.zeros((un.size, free.size))\n    else:\n        flow_f_ass = flow_matrix[un[:, None], ass]          # (len(un), len(ass))\n        dist_l_locs = distance_matrix[free[:, None], locs]  # (len(free), len(locs))\n        inc1 = flow_f_ass @ dist_l_locs.T\n        flow_ass_f = flow_matrix[ass[:, None], un]          # (len(ass), len(un))\n        dist_locs_l = distance_matrix[locs[:, None], free]  # (len(locs), len(free))\n        inc2 = flow_ass_f.T @ dist_locs_l\n        inc = inc1 + inc2\n    noise = 1e-9 * (un[:, None] + free[None, :])\n    inc += noise\n    idx = np.unravel_index(np.argmin(inc), inc.shape)\n    best_f, best_l = un[idx[0]], free[idx[1]]\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_cost_pair_cached_aug_94": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return a.tolist()\n    used = np.zeros(n, dtype=bool)\n    if a[a != -1].size:\n        used[a[a != -1]] = True\n    free = np.where(~used)[0]\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n    if ass.size == 0:\n        inc = np.zeros((un.size, free.size))\n    else:\n        flow_f_ass = flow_matrix[un[:, None], ass]\n        dist_l_locs = distance_matrix[free[:, None], locs]\n        inc1 = flow_f_ass @ dist_l_locs.T\n        flow_ass_f = flow_matrix[ass[:, None], un]\n        dist_locs_l = distance_matrix[locs[:, None], free]\n        inc2 = flow_ass_f.T @ dist_locs_l\n        inc = inc1 + inc2\n    inc = np.clip(inc, 0, 1e6)\n    top_k = 7\n    flat_idx = np.argpartition(inc.ravel(), top_k - 1)[:top_k]\n    temp = 1.0\n    weights = np.exp(-temp * inc.ravel())\n    sum_weights = np.sum(weights) + 1e-12\n    probs = weights / sum_weights\n    probs_topk = probs[flat_idx]\n    probs_topk = probs_topk / (np.sum(probs_topk) + 1e-12)\n    rng = np.random.default_rng(seed=42)\n    chosen_idx = rng.choice(flat_idx, p=probs_topk)\n    f_idx, l_idx = np.unravel_index(chosen_idx, inc.shape)\n    best_f, best_l = un[f_idx], free[l_idx]\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_cost_pair_cached_aug_95": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n    used = np.zeros(n, dtype=bool)\n    if a[a != -1].size:\n        used[a[a != -1]] = True\n    free_locations = np.where(~used)[0]\n    assigned_facilities = np.where(a != -1)[0]\n    assigned_locations = a[assigned_facilities]\n    best_inc = np.inf\n    best_f = None\n    best_l = None\n    f_idx = 0\n    while f_idx < unassigned.size:\n        f = unassigned[f_idx]\n        l_idx = 0\n        while l_idx < free_locations.size:\n            l = free_locations[l_idx]\n            if assigned_facilities.size == 0:\n                inc = 0.0\n            else:\n                contrib = (\n                    flow_matrix[f, assigned_facilities] * distance_matrix[l, assigned_locations] +\n                    flow_matrix[assigned_facilities, f] * distance_matrix[assigned_locations, l]\n                )\n                contrib = np.clip(contrib, 0, 1e5)\n                inc = np.median(contrib)\n            inc += 1e-8 * (f - l)\n            if inc < best_inc:\n                best_inc = inc\n                best_f, best_l = f, l\n            l_idx += 1\n        f_idx += 1\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_cost_pair_cached_aug_96": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n    used = np.zeros(n, dtype=bool)\n    if a[a != -1].size:\n        used[a[a != -1]] = True\n    free_locations = np.where(~used)[0]\n    assigned_facilities = np.where(a != -1)[0]\n    assigned_locations = a[assigned_facilities]\n    candidates = [(f, l) for f in unassigned for l in free_locations]\n    def inc_cost(pair):\n        f, l = pair\n        if assigned_facilities.size == 0:\n            inc = 0.0\n        else:\n            inc = np.sum(flow_matrix[f, assigned_facilities] * distance_matrix[l, assigned_locations])\n        return inc\n    incs = np.array([inc_cost(pair) for pair in candidates])\n    incs = np.clip(incs, 0, 1e6)\n    idx = np.argmin(incs)\n    best_f, best_l = candidates[idx]\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_cost_lexicographic_aug_97": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 1: Syntactic rewrite, deterministic tie\u2011breaking with noise, while loops.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free_locations = np.flatnonzero(~used).astype(int)\n\n    # Pre\u2011compute facility total flow and location centrality\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)  # bound centrality\n\n    # Assigned facilities and their locations\n    assigned_fac = np.flatnonzero(assign != -1).astype(int)\n    assigned_loc = assign[assigned_fac].astype(int)\n\n    best_fac, best_loc = int(unassigned[0]), int(free_locations[0])\n    best_cost = np.inf\n\n    # Deterministic pseudo\u2011noise for tie\u2011breaking\n    def noise(f, l):\n        return ((f * 31 + l * 17) & 0xFFFF) / 1e6  # small deterministic noise\n\n    f_idx = 0\n    while f_idx < unassigned.size:\n        f = int(unassigned[f_idx])\n        l_idx = 0\n        while l_idx < free_locations.size:\n            l = int(free_locations[l_idx])\n            if assigned_fac.size == 0:\n                inc_cost = 0.0\n            else:\n                inc_cost = float(np.sum(flow_matrix[f, assigned_fac] *\n                                         distance_matrix[l, assigned_loc] +\n                                         flow_matrix[assigned_fac, f] *\n                                         distance_matrix[assigned_loc, l]))\n            inc_cost_noisy = inc_cost + noise(f, l)\n            if inc_cost_noisy < best_cost - 1e-12:\n                best_cost = inc_cost_noisy\n                best_fac, best_loc = f, l\n            l_idx += 1\n        f_idx += 1\n\n    result = assign.copy()\n    result[best_fac] = best_loc\n    return result.tolist()\n\n",
  "min_incremental_cost_lexicographic_aug_98": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 2: Parameter tuning with weighted scoring and top\u2011k selection.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free_locations = np.flatnonzero(~used).astype(int)\n\n    # Pre\u2011compute facility total flow (mean) and location centrality\n    pf = (flow_matrix.mean(axis=1) + flow_matrix.mean(axis=0)).astype(float) + 1e-12\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)\n\n    assigned_fac = np.flatnonzero(assign != -1).astype(int)\n    assigned_loc = assign[assigned_fac].astype(int)\n\n    # Compute incremental costs for all pairs\n    inc_mat = np.full((unassigned.size, free_locations.size), np.inf, dtype=float)\n    if assigned_fac.size > 0:\n        inc_mat = np.sum(flow_matrix[unassigned[:, None], assigned_fac] *\n                         distance_matrix[free_locations[None, :], assigned_loc], axis=2)\n        inc_mat += np.sum(flow_matrix[assigned_fac, unassigned[:, None]] *\n                         distance_matrix[assigned_loc[:, None], free_locations[None, :]], axis=2)\n\n    # Weighted score\n    weight_inc = 0.6\n    weight_pf  = 0.2\n    weight_cl  = 0.2\n    pf_inv = 1.0 / (pf[unassigned] + 1e-12)\n    cl_inv = 1.0 / (cl[free_locations] + 1e-12)\n    score_mat = weight_inc * inc_mat + weight_pf * pf_inv[:, None] + weight_cl * cl_inv[None, :]\n\n    # Select top_k candidates (lowest score)\n    top_k = 7\n    flat_indices = np.argpartition(score_mat.ravel(), top_k)[:top_k]\n    best_idx = flat_indices[0]\n    best_score = score_mat.ravel()[best_idx]\n    best_f, best_l = np.unravel_index(best_idx, score_mat.shape)\n    for idx in flat_indices:\n        f, l = np.unravel_index(idx, score_mat.shape)\n        if score_mat[f, l] < best_score - 1e-12:\n            best_score = score_mat[f, l]\n            best_f, best_l = f, l\n\n    result = assign.copy()\n    result[unassigned[best_f]] = free_locations[best_l]\n    return result.tolist()\n\n",
  "min_incremental_cost_lexicographic_aug_99": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 3: Softmin selection with random choice among top\u2011k and proxy approximation.\"\"\"\n    rng = np.random.default_rng(42)\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free_locations = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.mean(axis=1) + flow_matrix.mean(axis=0)).astype(float) + 1e-12\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)\n\n    assigned_fac = np.flatnonzero(assign != -1).astype(int)\n    assigned_loc = assign[assigned_fac].astype(int)\n\n    # Proxy incremental cost: only one direction\n    if assigned_fac.size > 0:\n        inc_mat = np.sum(flow_matrix[unassigned[:, None], assigned_fac] *\n                         distance_matrix[free_locations[None, :], assigned_loc], axis=2)\n    else:\n        inc_mat = np.zeros((unassigned.size, free_locations.size), dtype=float)\n\n    # Add small random noise for stochasticity\n    noise = rng.uniform(-1e-6, 1e-6, size=inc_mat.shape)\n    inc_mat += noise\n\n    # Softmin with temperature\n    temp = 0.5\n    probs = np.exp(-inc_mat / (temp + 1e-12))\n    probs /= probs.sum(axis=None, keepdims=True)\n\n    # Random choice weighted by probs\n    flat_index = rng.choice(inc_mat.size, p=probs.ravel())\n    f_idx, l_idx = np.unravel_index(flat_index, inc_mat.shape)\n\n    result = assign.copy()\n    result[unassigned[f_idx]] = free_locations[l_idx]\n    return result.tolist()\n\n",
  "min_incremental_cost_lexicographic_aug_100": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 4: Fully vectorized search with deterministic tie\u2011breaking.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free_locations = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.mean(axis=1) + flow_matrix.mean(axis=0)).astype(float) + 1e-12\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)\n\n    assigned_fac = np.flatnonzero(assign != -1).astype(int)\n    assigned_loc = assign[assigned_fac].astype(int)\n\n    # Broadcast to compute incremental costs\n    if assigned_fac.size > 0:\n        inc_mat = np.sum(flow_matrix[unassigned[:, None], assigned_fac] *\n                         distance_matrix[free_locations[None, :], assigned_loc], axis=2)\n        inc_mat += np.sum(flow_matrix[assigned_fac, unassigned[:, None]] *\n                         distance_matrix[assigned_loc[:, None], free_locations[None, :]], axis=2)\n    else:\n        inc_mat = np.zeros((unassigned.size, free_locations.size), dtype=float)\n\n    # Find minimal cost\n    min_cost = inc_mat.min()\n    mask = np.abs(inc_mat - min_cost) <= 1e-12\n    tie_f_idx, tie_l_idx = np.where(mask)\n    if tie_f_idx.size > 1:\n        pf_vals = pf[unassigned[tie_f_idx]]\n        cl_vals = cl[free_locations[tie_l_idx]]\n        order = np.lexsort((cl_vals, pf_vals))\n        best_idx = order[-1]  # highest pf, then highest cl\n        f_idx, l_idx = tie_f_idx[best_idx], tie_l_idx[best_idx]\n    else:\n        f_idx, l_idx = tie_f_idx[0], tie_l_idx[0]\n\n    result = assign.copy()\n    result[unassigned[f_idx]] = free_locations[l_idx]\n    return result.tolist()\n\n",
  "min_weighted_inc_by_free_dispersion_aug_101": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy assignment with vectorised incremental cost.\n    Uses a dispersion\u2011weighted penalty and deterministic noise for tie\u2011breaking.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # indices of unassigned facilities\n    un = np.flatnonzero(a == -1)\n    if un.size == 0:\n        return a.tolist()\n\n    # free locations\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used)\n\n    # dispersion of free locations\n    if free.size > 1:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        disp = np.std(D)\n    else:\n        disp = 0.0\n\n    # weighting factor (avoid division by zero)\n    w = 1.0 + 0.4 * (disp / (np.std(distance_matrix) + 1e-12))\n    w = np.clip(w, 0.0, 10.0)\n\n    # already assigned facilities\n    ass = np.flatnonzero(a != -1)\n    locs = a[ass].astype(int)\n\n    # incremental cost matrix\n    if ass.size == 0:\n        inc_mat = np.zeros((un.size, free.size), dtype=float)\n    else:\n        inc1 = np.einsum('fa,la->fl',\n                         flow_matrix[un[:, None], ass[None, :]],\n                         distance_matrix[free[:, None], locs[None, :]])\n        inc2 = np.einsum('af,lf->fl',\n                         flow_matrix[ass[:, None], un[None, :]],\n                         distance_matrix[locs[:, None], free[None, :]])\n        inc_mat = inc1 + inc2\n\n    # deterministic tie\u2011breaking noise\n    noise = np.arange(inc_mat.size, dtype=float).reshape(inc_mat.shape) * 1e-12\n    score = w * inc_mat + noise\n\n    idx = np.unravel_index(np.argmin(score), score.shape)\n    best_f = int(un[idx[0]])\n    best_l = int(free[idx[1]])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_weighted_inc_by_free_dispersion_aug_102": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Incremental assignment using while loops and soft\u2011min selection.\n    Dispersion is measured by the median of distances.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # indices of unassigned facilities (list comprehension)\n    un = [int(i) for i in np.flatnonzero(a == -1)]\n    if not un:\n        return a.tolist()\n\n    # free locations (list comprehension)\n    used = [False] * n\n    for idx in np.flatnonzero(a != -1):\n        used[int(a[idx])] = True\n    free = [int(i) for i in np.flatnonzero(~np.array(used, dtype=bool))]\n\n    # dispersion of free locations\n    if len(free) > 1:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        disp = np.median(D)\n    else:\n        disp = 0.0\n\n    # weighting factor\n    w = 1.0 + 0.6 * (disp / (np.std(distance_matrix) + 1e-12))\n    w = np.clip(w, 0.0, 10.0)\n\n    # already assigned facilities\n    ass = [int(i) for i in np.flatnonzero(a != -1)]\n    locs = a[ass].astype(int)\n\n    # incremental cost matrix (while loops)\n    inc_mat = np.zeros((len(un), len(free)), dtype=float)\n    i = 0\n    while i < len(un):\n        f = un[i]\n        j = 0\n        while j < len(free):\n            l = free[j]\n            inc = np.sum(flow_matrix[f, ass] * distance_matrix[l, locs]) + \\\n                  np.sum(flow_matrix[ass, f] * distance_matrix[locs, l])\n            inc_mat[i, j] = inc\n            j += 1\n        i += 1\n\n    score = w * inc_mat\n    # soft\u2011min selection\n    beta = 5.0\n    soft = np.exp(-beta * score)\n    probs = soft / (soft.sum() + 1e-12)\n    flat_idx = np.random.choice(inc_mat.size, p=probs.ravel())\n    i, j = divmod(flat_idx, len(free))\n    best_f = un[i]\n    best_l = free[j]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_weighted_inc_by_free_dispersion_aug_103": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy assignment with top\u2011k exploration.\n    Uses the range (max\u2011min) of distances as dispersion and adds a small noise.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # unassigned facilities\n    un = np.flatnonzero(a == -1)\n    if un.size == 0:\n        return a.tolist()\n\n    # free locations\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used)\n\n    # dispersion based on range\n    if free.size > 1:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        disp = np.max(D) - np.min(D)\n    else:\n        disp = 0.0\n\n    w = 1.0 + 0.3 * (disp / (np.std(distance_matrix) + 1e-12))\n    w = np.clip(w, 0.0, 10.0)\n\n    ass = np.flatnonzero(a != -1)\n    locs = a[ass].astype(int)\n\n    # incremental cost matrix\n    if ass.size == 0:\n        inc_mat = np.zeros((un.size, free.size), dtype=float)\n    else:\n        inc1 = np.einsum('fa,la->fl',\n                         flow_matrix[un[:, None], ass[None, :]],\n                         distance_matrix[free[:, None], locs[None, :]])\n        inc2 = np.einsum('af,lf->fl',\n                         flow_matrix[ass[:, None], un[None, :]],\n                         distance_matrix[locs[:, None], free[None, :]])\n        inc_mat = inc1 + inc2\n\n    # add tiny noise to avoid exact ties\n    noise = np.random.uniform(0, 1e-8, inc_mat.shape)\n    score = w * inc_mat + noise\n\n    # top\u2011k exploration\n    flat = score.ravel()\n    k = 5\n    top_k_idx = np.argpartition(flat, k)[:k]\n    chosen = np.random.choice(top_k_idx)\n    i, j = divmod(chosen, free.size)\n    best_f = int(un[i])\n    best_l = int(free[j])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_weighted_inc_by_free_dispersion_aug_104": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Assignment with random tie\u2011breaking among minimal scores.\n    Dispersion uses the mean of distances and the weight is clipped.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # unassigned facilities\n    un = np.flatnonzero(a == -1)\n    if un.size == 0:\n        return a.tolist()\n\n    # free locations\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used)\n\n    # dispersion by mean distance\n    if free.size > 1:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        disp = np.mean(D)\n    else:\n        disp = 0.0\n\n    w = 1.0 + 0.35 * (disp / (np.std(distance_matrix) + 1e-12))\n    w = np.clip(w, 0.5, 2.0)          # bound the weight\n\n    ass = np.flatnonzero(a != -1)\n    locs = a[ass].astype(int)\n\n    # incremental cost matrix\n    if ass.size == 0:\n        inc_mat = np.zeros((un.size, free.size), dtype=float)\n    else:\n        inc1 = np.einsum('fa,la->fl',\n                         flow_matrix[un[:, None], ass[None, :]],\n                         distance_matrix[free[:, None], locs[None, :]])\n        inc2 = np.einsum('af,lf->fl',\n                         flow_matrix[ass[:, None], un[None, :]],\n                         distance_matrix[locs[:, None], free[None, :]])\n        inc_mat = inc1 + inc2\n\n    score = w * inc_mat\n    min_score = np.min(score)\n    # find all indices with minimal score (within epsilon)\n    eps = 1e-12\n    mask = np.abs(score - min_score) < eps\n    flat_indices = np.flatnonzero(mask)\n    chosen = np.random.choice(flat_indices)\n    i, j = divmod(chosen, free.size)\n    best_f = int(un[i])\n    best_l = int(free[j])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "max_flow_to_free_then_place_aug_105": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy selection using vectorised operations and list comprehensions.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # --- Candidate facilities ---------------------------------------------\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # --- Symmetric flow matrix ---------------------------------------------\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # --- Total flow from each candidate to the other candidates -------------\n    flow_totals = np.array([sym_flow[c, candidates].sum() for c in candidates])\n    f = int(candidates[np.argmax(flow_totals)])   # facility to place next\n\n    # --- Free locations ----------------------------------------------------\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    # --- Assigned facilities and their locations --------------------------\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs_of_assigned = a[assigned].astype(int)\n\n    # --- Incremental cost for each free location --------------------------\n    inc_costs = []\n    for l in free_locs:\n        if assigned.size == 0:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs_of_assigned] +\n                               flow_matrix[assigned, f] * distance_matrix[locs_of_assigned, l]))\n        inc_costs.append(inc)\n\n    inc_costs = np.array(inc_costs)\n    inc_costs = np.clip(inc_costs, -1e12, 1e12)   # safety clipping\n\n    # --- Choose location with minimal incremental cost ---------------------\n    best_loc = int(free_locs[np.argmin(inc_costs)])\n    out = a.copy()\n    out[f] = best_loc\n    return out.tolist()\n\n",
  "max_flow_to_free_then_place_aug_106": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Deterministic\u2011noise tie\u2011breaking and random choice among top\u2011k minimal costs.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Candidates that are still unassigned\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Symmetric flow and total flow per candidate\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n    total_flow = np.array([sym_flow[c, candidates].sum() for c in candidates])\n    f = int(candidates[np.argmax(total_flow)])   # facility to place\n\n    # Free locations\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    # Assigned facilities\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs_of_assigned = a[assigned].astype(int)\n\n    # Incremental costs with deterministic noise for tie\u2011breaking\n    inc_costs = []\n    for l in free_locs:\n        if assigned.size == 0:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs_of_assigned] +\n                               flow_matrix[assigned, f] * distance_matrix[locs_of_assigned, l]))\n        inc_costs.append(inc)\n    inc_costs = np.array(inc_costs)\n    noise = np.arange(len(inc_costs)) * 1e-6          # deterministic noise\n    inc_costs += noise\n    inc_costs = np.clip(inc_costs, -1e12, 1e12)       # clip to avoid overflow\n\n    # Randomly pick among the top\u2011k smallest incremental costs\n    k = min(3, len(free_locs))\n    top_k_idx = np.argpartition(inc_costs, k - 1)[:k]\n    rng = np.random.default_rng()\n    chosen_idx = rng.choice(top_k_idx)\n    best_loc = int(free_locs[chosen_idx])\n\n    out = a.copy()\n    out[f] = best_loc\n    return out.tolist()\n\n",
  "max_flow_to_free_then_place_aug_107": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Soft\u2011min probabilistic placement with median aggregation.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Unassigned facilities\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Symmetric flow and flow totals\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n    flow_totals = np.array([sym_flow[c, candidates].sum() for c in candidates])\n    f = int(candidates[np.argmax(flow_totals)])   # facility to place\n\n    # Free locations\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    # Assigned facilities\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs_of_assigned = a[assigned].astype(int)\n\n    # Incremental cost using median of pairwise contributions\n    inc_costs = []\n    for l in free_locs:\n        if assigned.size == 0:\n            inc = 0.0\n        else:\n            contrib = (flow_matrix[f, assigned] * distance_matrix[l, locs_of_assigned] +\n                       flow_matrix[assigned, f] * distance_matrix[locs_of_assigned, l])\n            inc = float(np.median(contrib))\n        inc_costs.append(inc)\n    inc_costs = np.array(inc_costs)\n    inc_costs = np.clip(inc_costs, -1e12, 1e12)  # safety clipping\n\n    # Soft\u2011min probability distribution\n    alpha = 10.0\n    exp_vals = np.exp(-alpha * inc_costs)\n    probs = exp_vals / (exp_vals.sum() + 1e-12)   # epsilon to avoid division by zero\n    probs = np.clip(probs, 0.0, 1.0)              # ensure valid probabilities\n\n    rng = np.random.default_rng()\n    chosen_idx = rng.choice(len(free_locs), p=probs)\n    best_loc = int(free_locs[chosen_idx])\n\n    out = a.copy()\n    out[f] = best_loc\n    return out.tolist()\n\n",
  "max_flow_to_free_then_place_aug_108": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Approximate incremental cost using squared distances and random tie\u2011breaking.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Candidate facilities\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Symmetric flow and total flow per candidate\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n    total_flow = np.array([sym_flow[c, candidates].sum() for c in candidates])\n    f = int(candidates[np.argmax(total_flow)])   # facility to place\n\n    # Free locations\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    # Assigned facilities and their locations\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs_of_assigned = a[assigned].astype(int)\n\n    # Approximate incremental cost: squared distance weighted by flow\n    inc_costs = []\n    for l in free_locs:\n        if assigned.size == 0:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_matrix[f, assigned] * (distance_matrix[l, locs_of_assigned] ** 2) +\n                               flow_matrix[assigned, f] * (distance_matrix[locs_of_assigned, l] ** 2)))\n        inc_costs.append(inc)\n    inc_costs = np.array(inc_costs)\n    inc_costs = np.clip(inc_costs, -1e12, 1e12)  # clip for safety\n\n    # Randomly choose among the 5 smallest incremental costs\n    k = min(5, len(free_locs))\n    top_k_idx = np.argpartition(inc_costs, k - 1)[:k]\n    rng = np.random.default_rng()\n    chosen_idx = rng.choice(top_k_idx)\n    best_loc = int(free_locs[chosen_idx])\n\n    out = a.copy()\n    out[f] = best_loc\n    return out.tolist()\n\n",
  "min_incremental_plus_quadratic_penalty_aug_109": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy assignment with vectorized scoring and median distance.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Candidate facilities (unassigned) and locations (unused)\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # Normalised flow potential\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    best_score = np.inf\n    best_f = unassigned[0]\n    best_l = free_locs[0]\n\n    rng = np.random.default_rng(0)\n    for f in unassigned:\n        # Vectorised incremental cost for all free locations\n        inc_vec = np.dot(flow_matrix[f, assigned], distance_matrix[free_locs][:, locs]) + \\\n                  np.dot(flow_matrix[assigned, f], distance_matrix[locs][:, free_locs])\n        # Median distance from the candidate location to already used sites\n        if assigned.size:\n            far_vec = np.median(distance_matrix[free_locs][:, locs], axis=1)\n        else:\n            far_vec = np.median(distance_matrix[free_locs], axis=1)\n\n        # Small deterministic noise for tie\u2011breaking\n        noise = rng.random(free_locs.size) * 1e-8\n        score_vec = inc_vec + 0.15 * pf[f] * np.square(far_vec) + noise\n\n        idx = np.argmin(score_vec)\n        if score_vec[idx] < best_score:\n            best_score = score_vec[idx]\n            best_f = f\n            best_l = free_locs[idx]\n\n    a[best_f] = best_l\n    return a.tolist()\n\n",
  "min_incremental_plus_quadratic_penalty_aug_110": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy assignment using while loops and soft\u2011min selection.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Identify unassigned facilities and free locations\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # Normalised flow potential with clipping\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = np.clip((pf - pf.min()) / (pf.max() - pf.min() + 1e-12), 0.0, 1.0)\n\n    best_score = np.inf\n    best_f = unassigned[0]\n    best_l = free_locs[0]\n\n    rng = np.random.default_rng(1)\n    top_k = 5\n\n    f_idx = 0\n    while f_idx < unassigned.size:\n        f = unassigned[f_idx]\n        f_idx += 1\n\n        # Incremental cost for each free location\n        inc_vec = np.zeros(free_locs.size, dtype=float)\n        if assigned.size:\n            inc_vec = np.dot(flow_matrix[f, assigned], distance_matrix[free_locs][:, locs]) + \\\n                      np.dot(flow_matrix[assigned, f], distance_matrix[locs][:, free_locs])\n\n        # Distance penalty (median)\n        if assigned.size:\n            far_vec = np.median(distance_matrix[free_locs][:, locs], axis=1)\n        else:\n            far_vec = np.median(distance_matrix[free_locs], axis=1)\n\n        score_vec = inc_vec + 0.20 * pf[f] * np.square(far_vec)\n\n        # Keep only top_k lowest scores\n        if score_vec.size > top_k:\n            idx_top = np.argpartition(score_vec, top_k)[:top_k]\n            score_vec = score_vec[idx_top]\n            locs_top = free_locs[idx_top]\n        else:\n            locs_top = free_locs\n\n        # Soft\u2011min weighting\n        weights = np.exp(-10 * score_vec)\n        softmin_idx = np.argmin(weights)\n        cand_score = score_vec[softmin_idx]\n        if cand_score < best_score:\n            best_score = cand_score\n            best_f = f\n            best_l = locs_top[softmin_idx]\n\n    a[best_f] = best_l\n    return a.tolist()\n\n",
  "min_incremental_plus_quadratic_penalty_aug_111": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Randomised top\u2011k selection with maximum distance proxy.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # Flow potential normalisation\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    rng = np.random.default_rng(42)\n    top_k = 3\n\n    best_score = np.inf\n    best_f = unassigned[0]\n    best_l = free_locs[0]\n\n    f_idx = 0\n    while f_idx < unassigned.size:\n        f = unassigned[f_idx]\n        f_idx += 1\n\n        # Incremental cost\n        inc_vec = np.zeros(free_locs.size, dtype=float)\n        if assigned.size:\n            inc_vec = np.dot(flow_matrix[f, assigned], distance_matrix[free_locs][:, locs]) + \\\n                      np.dot(flow_matrix[assigned, f], distance_matrix[locs][:, free_locs])\n\n        # Proxy distance: maximum distance to already used sites\n        if assigned.size:\n            far_vec = np.max(distance_matrix[free_locs][:, locs], axis=1)\n        else:\n            far_vec = np.max(distance_matrix[free_locs], axis=1)\n\n        score_vec = inc_vec + 0.30 * pf[f] * np.square(far_vec)\n\n        # Random choice among top\u2011k lowest scores\n        if score_vec.size > top_k:\n            idx_top = np.argpartition(score_vec, top_k)[:top_k]\n            score_vec = score_vec[idx_top]\n            locs_top = free_locs[idx_top]\n        else:\n            locs_top = free_locs\n\n        chosen_idx = rng.choice(len(score_vec))\n        cand_score = score_vec[chosen_idx]\n        if cand_score < best_score:\n            best_score = cand_score\n            best_f = f\n            best_l = locs_top[chosen_idx]\n\n    a[best_f] = best_l\n    return a.tolist()\n\n",
  "min_incremental_plus_quadratic_penalty_aug_112": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorised argmin selection with clipping and dot products.\"\"\"\n    a_arr = np.asarray(current_assignment, dtype=int)\n    n = a_arr.size\n\n    unassigned = np.flatnonzero(a_arr == -1).astype(int)\n    if unassigned.size == 0:\n        return a_arr.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a_arr.any() != -1:\n        used[a_arr[a_arr != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a_arr != -1).astype(int)\n    locs = a_arr[assigned].astype(int)\n\n    # Normalised flow potential with clipping\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = np.clip((pf - pf.min()) / (pf.max() - pf.min() + 1e-12), 0.0, 1.0)\n\n    # Pre\u2011compute distance sub\u2011matrices for speed\n    dist_sub = distance_matrix[free][:, locs] if assigned.size else distance_matrix[free]\n    far_vec = np.max(dist_sub, axis=1) if assigned.size else np.max(distance_matrix[free], axis=1)\n\n    best_f = unassigned[0]\n    best_l = free[0]\n    best_score = np.inf\n\n    for f in unassigned:\n        # Incremental cost via dot products\n        if assigned.size:\n            inc = np.dot(flow_matrix[f, assigned], dist_sub) + \\\n                  np.dot(flow_matrix[assigned, f], dist_sub.T)\n        else:\n            inc = np.zeros(free.size, dtype=float)\n\n        score = inc + 0.20 * pf[f] * np.square(far_vec)\n\n        idx = np.argmin(score)\n        if score[idx] < best_score:\n            best_score = score[idx]\n            best_f = f\n            best_l = free[idx]\n\n    a_arr[best_f] = best_l\n    return a_arr.tolist()\n\n",
  "max_regret_ratio_insertion_aug_113": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    if np.all(a != -1):\n        return a.tolist()\n\n    # facilities that are still unassigned\n    unassigned = np.where(a == -1)[0]\n    # locations that are already used\n    used_locs = a[a != -1]\n    # free locations\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    eps = 1e-12\n    # deterministic noise to break ties\n    noise = np.arange(free_locs.size) * 1e-9\n\n    best_score = -np.inf\n    best_f = unassigned[0]\n    best_l = free_locs[0]\n\n    for f in unassigned:\n        # cost of assigning facility f to each free location\n        costs = np.array(\n            [np.sum(flow_matrix[f, a[a != -1]] * distance_matrix[l, a[a != -1]] +\n                    flow_matrix[a[a != -1], f] * distance_matrix[a[a != -1], l])\n             for l in free_locs], dtype=float)\n\n        idx = np.argsort(costs)\n        best = costs[idx[0]]\n        second = costs[idx[1]] if costs.size > 1 else best + 1.0\n        # regret ratio with noise for deterministic tie\u2011breaking\n        score = (second + noise[idx[0]]) / (best + eps)\n        score = np.clip(score, 0, np.inf)\n\n        if score > best_score:\n            best_score = score\n            best_f = f\n            best_l = free_locs[idx[0]]\n\n    a[best_f] = best_l\n    return a.tolist()\n\n",
  "max_regret_ratio_insertion_aug_114": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    if np.all(a != -1):\n        return a.tolist()\n\n    unassigned = np.where(a == -1)[0]\n    used_locs = a[a != -1]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n\n    eps = 1e-12\n    top_k = 3\n    scores = []\n\n    for f in unassigned:\n        costs = np.array(\n            [np.sum(flow_matrix[f, a[a != -1]] * distance_matrix[l, a[a != -1]] +\n                    flow_matrix[a[a != -1], f] * distance_matrix[a[a != -1], l])\n             for l in free_locs], dtype=float)\n\n        idx = np.argsort(costs)\n        best = costs[idx[0]]\n        second = costs[idx[1]] if costs.size > 1 else best + 1.0\n        # weighted score that favours the second\u2011best cost\n        score = (0.4 * best + 0.6 * second) / (best + eps)\n        score = np.clip(score, 0, np.inf)\n        scores.append((score, f, free_locs[idx[0]]))\n\n    # pick one of the top\u2011k scoring facilities at random\n    scores.sort(key=lambda x: -x[0])\n    top_candidates = scores[:top_k]\n    chosen = top_candidates[np.random.randint(len(top_candidates))]\n    a[chosen[1]] = chosen[2]\n    return a.tolist()\n\n",
  "max_regret_ratio_insertion_aug_115": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    if not np.any(a == -1):\n        return a.tolist()\n\n    unassigned = list(np.where(a == -1)[0])\n    used_locs = set(a[a != -1])\n    free_locs = [i for i in range(n) if i not in used_locs]\n    eps = 1e-12\n\n    best_score = -np.inf\n    best_f = unassigned[0]\n    best_l = free_locs[0]\n\n    while unassigned:\n        f = unassigned.pop(0)\n        costs = np.array(\n            [np.max(flow_matrix[f, a[a != -1]] * distance_matrix[l, a[a != -1]] +\n                    flow_matrix[a[a != -1], f] * distance_matrix[a[a != -1], l])\n             for l in free_locs], dtype=float)\n\n        idx = np.argsort(costs)\n        best = costs[idx[0]]\n        second = costs[idx[1]] if costs.size > 1 else best + 1.0\n        score = second / (best + eps)\n        score = np.clip(score, 0, np.inf)\n\n        if score > best_score:\n            best_score = score\n            best_f = f\n            best_l = free_locs[idx[0]]\n\n    a[best_f] = best_l\n    return a.tolist()\n\n",
  "max_regret_ratio_insertion_aug_116": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    if np.all(a != -1):\n        return a.tolist()\n\n    unassigned = np.where(a == -1)[0]\n    used_locs = a[a != -1]\n    free_locs = np.where(~np.isin(np.arange(n), used_locs))[0]\n    eps = 1e-12\n\n    # proxy: use sums of rows instead of exact delta\n    flow_row_sum = flow_matrix.sum(axis=1)\n    dist_row_sum = distance_matrix.sum(axis=1)\n\n    scores = []\n\n    for f in unassigned:\n        costs = np.array([flow_row_sum[f] * dist_row_sum[l] for l in free_locs], dtype=float)\n        idx = np.argsort(costs)\n        best = costs[idx[0]]\n        second = np.median(costs[idx[1:]]) if costs.size > 1 else best + 1.0\n\n        # softmin probability for the best location\n        probs = np.exp(-costs) / (np.exp(-costs).sum() + eps)\n        score = probs[idx[0]] * (second + eps)\n        score = np.clip(score, 0, np.inf)\n        scores.append((score, f, free_locs[idx[0]]))\n\n    # pick facility with highest soft\u2011weighted score\n    best = max(scores, key=lambda x: x[0])\n    a[best[1]] = best[2]\n    return a.tolist()\n\n",
  "facility_pair_seed_then_place_one_aug_117": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy selection with soft\u2011min weighting and deterministic tie\u2011breaking.\"\"\"\n    assign_arr = np.asarray(current_assignment, dtype=int)\n    n = assign_arr.size\n\n    unassigned_facilities = np.flatnonzero(assign_arr == -1).astype(int)\n    if unassigned_facilities.size == 0:\n        return assign_arr.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(assign_arr != -1):\n        used_loc[assign_arr[assign_arr != -1]] = True\n    free_locations = np.flatnonzero(~used_loc).astype(int)\n\n    assigned_facilities = np.flatnonzero(assign_arr != -1).astype(int)\n\n    # --- initial seeding ----------------------------------------------------\n    if (assigned_facilities.size == 0 and\n            unassigned_facilities.size >= 2 and\n            free_locations.size >= 2):\n        # facility pair with maximum symmetric flow\n        sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n        sub_flow = sym_flow[np.ix_(unassigned_facilities, unassigned_facilities)]\n        iu, ju\n\n",
  "location_pair_seed_then_best_facility_aug_118": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy incremental assignment with noise\u2011based tie breaking.\n    Uses list comprehensions and while\u2011loops for control flow.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    # indices of unassigned facilities\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    # indices of already assigned facilities\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used_loc = np.zeros(n, dtype=bool)\n    if ass.size:\n        used_loc[a[ass]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    # special case: no facilities assigned yet\n    if ass.size == 0 and free.size >= 2:\n        # pair with minimal distance\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        # add huge penalty on diagonal to avoid choosing same location\n        D += np.eye(D.shape[0], dtype=float) * 1e12\n        i, j = np.unravel_index(int(np.argmin(D)), D.shape)\n        l = int(free[i])\n        # facility with largest total flow\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(pf[un]))])\n        out = a.copy()\n        out[f] = l\n        return out.tolist()\n\n    # greedy search over all remaining facility\u2011location pairs\n    locs = a[ass].astype(int)\n    best_inc = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n    f_idx = 0\n    while f_idx < un.size:\n        f = int(un[f_idx])\n        l_idx = 0\n        while l_idx < free.size:\n            l = int(free[l_idx])\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n            # add tiny deterministic noise for deterministic tie breaking\n            inc += 1e-9 * (f_idx + l_idx)\n            if inc < best_inc:\n                best_inc, best_f, best_l = inc, f, l\n            l_idx += 1\n        f_idx += 1\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "location_pair_seed_then_best_facility_aug_119": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Weighted scoring with top\u2011k selection and random tie breaking.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used_loc = np.zeros(n, dtype=bool)\n    if ass.size:\n        used_loc[a[ass]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    if ass.size == 0 and free.size >= 2:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        D += np.eye(D.shape[0], dtype=float) * 1e12\n        i, j = np.unravel_index(int(np.argmin(D)), D.shape)\n        l = int(free[i])\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(pf[un]))])\n        out = a.copy()\n        out[f] = l\n        return out.tolist()\n\n    # compute all incremental costs\n    locs = a[ass].astype(int)\n    inc_matrix = np.empty((un.size, free.size), dtype=float)\n    f_idx = 0\n    while f_idx < un.size:\n        f = int(un[f_idx])\n        l_idx = 0\n        while l_idx < free.size:\n            l = int(free[l_idx])\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                # weighted combination of distance and flow\n                inc = 0.6 * np.sum(flow_matrix[f, ass] * distance_matrix[l, locs]) + \\\n                      0.4 * np.sum(flow_matrix[ass, f] * distance_matrix[locs, l])\n            # clip to avoid negative values\n            inc = np.clip(inc, 0.0, np.inf)\n            inc_matrix[f_idx, l_idx] = inc\n            l_idx += 1\n        f_idx += 1\n\n    # select top\u2011k smallest costs and choose one at random\n    top_k = 7\n    flat_idx = np.argsort(inc_matrix, axis=None)[:top_k]\n    chosen_idx = np.random.choice(flat_idx)\n    f_chosen = int(un[chosen_idx // free.size])\n    l_chosen = int(free[chosen_idx % free.size])\n\n    out = a.copy()\n    out[f_chosen] = l_chosen\n    return out.tolist()\n\n",
  "location_pair_seed_then_best_facility_aug_120": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Median\u2011based aggregation and softmin selection.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used_loc = np.zeros(n, dtype=bool)\n    if ass.size:\n        used_loc[a[ass]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    if ass.size == 0 and free.size >= 2:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        D += np.eye(D.shape[0], dtype=float) * 1e12\n        i, j = np.unravel_index(int(np.argmin(D)), D.shape)\n        l = int(free[i])\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(pf[un]))])\n        out = a.copy()\n        out[f] = l\n        return out.tolist()\n\n    locs = a[ass].astype(int)\n    # compute median of flow*distance instead of sum\n    inc_matrix = np.empty((un.size, free.size), dtype=float)\n    f_idx = 0\n    while f_idx < un.size:\n        f = int(un[f_idx])\n        l_idx = 0\n        while l_idx < free.size:\n            l = int(free[l_idx])\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                prod = flow_matrix[f, ass] * distance_matrix[l, locs] + \\\n                       flow_matrix[ass, f] * distance_matrix[locs, l]\n                inc = np.median(prod)\n            inc_matrix[f_idx, l_idx] = inc\n            l_idx += 1\n        f_idx += 1\n\n    # softmin selection with temperature beta\n    beta = 5.0\n    logits = -beta * inc_matrix\n    probs = np.exp(logits - np.max(logits, axis=None))  # for numerical stability\n    probs /= np.clip(probs.sum(), 1e-12, np.inf)\n    chosen = np.random.choice(un.size * free.size, p=probs.ravel())\n    f_chosen = int(un[chosen // free.size])\n    l_chosen = int(free[chosen % free.size])\n\n    out = a.copy()\n    out[f_chosen] = l_chosen\n    return out.tolist()\n\n",
  "location_pair_seed_then_best_facility_aug_121": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Proxy approximation using squared distances and mean flow, with top\u2011k random choice.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used_loc = np.zeros(n, dtype=bool)\n    if ass.size:\n        used_loc[a[ass]] = True\n    free = np.flatnonzero(~used_loc).astype(int)\n\n    if ass.size == 0 and free.size >= 2:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        D += np.eye(D.shape[0], dtype=float) * 1e12\n        i, j = np.unravel_index(int(np.argmin(D)), D.shape)\n        l = int(free[i])\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(pf[un]))])\n        out = a.copy()\n        out[f] = l\n        return out.tolist()\n\n    # proxy: use squared distance and mean flow\n    flow_mean = np.clip(flow_matrix.mean(), 1e-12, np.inf)\n    dist_sq = distance_matrix ** 2\n    locs = a[ass].astype(int)\n\n    inc_matrix = np.empty((un.size, free.size), dtype=float)\n    f_idx = 0\n    while f_idx < un.size:\n        f = int(un[f_idx])\n        l_idx = 0\n        while l_idx < free.size:\n            l = int(free[l_idx])\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = flow_mean * dist_sq[l, locs].sum()  # approximate cost\n            inc_matrix[f_idx, l_idx] = inc\n            l_idx += 1\n        f_idx += 1\n\n    # choose among top\u2011k minimal approximated costs\n    top_k = 5\n    flat_idx = np.argsort(inc_matrix, axis=None)[:top_k]\n    chosen_idx = np.random.choice(flat_idx)\n    f_chosen = int(un[chosen_idx // free.size])\n    l_chosen = int(free[chosen_idx % free.size])\n\n    out = a.copy()\n    out[f_chosen] = l_chosen\n    return out.tolist()\n\n",
  "anti_greedy_outlier_location_first_aug_122": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Early: assign to most isolated free location; late: min incremental cost.\n    Uses median isolation, list comprehensions, and inverted logic.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    # indices of unassigned facilities\n    candidates = np.flatnonzero(a == -1)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # which locations are already occupied\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    free_locs = np.flatnonzero(~occupied)\n\n    # progress: fraction already assigned\n    progress = 1.0 - (candidates.size / max(1, n))\n\n    # facilities that are already placed\n    placed_fac = np.flatnonzero(a != -1)\n    placed_locs = a[placed_fac].astype(int)\n\n    # early phase: choose most isolated free location\n    if progress >= 0.5:          # inverted condition\n        # compute isolation using median of distances to other free spots\n        if free_locs.size > 1:\n            dist_sub = distance_matrix[np.ix_(free_locs, free_locs)].astype(float)\n            iso_vals = np.median(dist_sub, axis=1)\n            idx = int(free_locs[np.argmax(iso_vals)])\n        else:\n            idx = int(free_locs[0])\n\n        best_fac = int(candidates[0])\n        best_inc = float('inf')\n        for f in candidates.astype(int):\n            inc = 0.0 if placed_fac.size == 0 else float(\n                np.sum(flow_matrix[f, placed_fac] * distance_matrix[idx, placed_locs] +\n                       flow_matrix[placed_fac, f] * distance_matrix[placed_locs, idx]))\n            if inc < best_inc:\n                best_inc, best_fac = inc, f\n\n        out = a.copy()\n        out[best_fac] = idx\n        return out.tolist()\n\n    # late phase: evaluate all free facility-location pairs\n    best_inc = float('inf')\n    best_f, best_l = int(candidates[0]), int(free_locs[0])\n    for f in candidates.astype(int):\n        for l in free_locs.astype(int):\n            inc = 0.0 if placed_fac.size == 0 else float(\n                np.sum(flow_matrix[f, placed_fac] * distance_matrix[l, placed_locs] +\n                       flow_matrix[placed_fac, f] * distance_matrix[placed_locs, l]))\n            if inc < best_inc:\n                best_inc, best_f, best_l = inc, f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "anti_greedy_outlier_location_first_aug_123": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Weighted cost evaluation with tuned thresholds and constants.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.flatnonzero(a == -1)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    free = np.flatnonzero(~occupied)\n\n    # progress: how many facilities are placed\n    progress = 1.0 - (unassigned.size / max(1, n))\n\n    placed_fac = np.flatnonzero(a != -1)\n    placed_locs = a[placed_fac].astype(int)\n\n    # early phase: most isolated free location (median isolation)\n    if progress < 0.6:  # tuned threshold\n        if free.size > 1:\n            sub_dist = distance_matrix[np.ix_(free, free)].astype(float)\n            iso = np.median(sub_dist, axis=1)\n            loc = int(free[np.argmax(iso)])\n        else:\n            loc = int(free[0])\n\n        best_fac = int(unassigned[0])\n        best_inc = float('inf')\n        for f in unassigned.astype(int):\n            inc = 0.0 if placed_fac.size == 0 else float(\n                np.sum(flow_matrix[f, placed_fac] * distance_matrix[loc, placed_locs] +\n                       flow_matrix[placed_fac, f] * distance_matrix[placed_locs, loc]))\n            if inc < best_inc:\n                best_inc, best_fac = inc, f\n\n        out = a.copy()\n        out[best_fac] = loc\n        return out.tolist()\n\n    # late phase: weighted incremental cost\n    best_inc = float('inf')\n    best_f, best_l = int(unassigned[0]), int(free[0])\n    for f in unassigned.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if placed_fac.size == 0 else float(\n                np.sum(flow_matrix[f, placed_fac] * distance_matrix[l, placed_locs] +\n                       flow_matrix[placed_fac, f] * distance_matrix[placed_locs, l]))\n            # weighted evaluation: 0.6 * distance + 0.4 * flow cost\n            weighted = 0.6 * inc + 0.4 * np.mean(flow_matrix[f, placed_fac])\n            if weighted < best_inc:\n                best_inc, best_f, best_l = weighted, f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "late_stage_minimax_blend_aug_124": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorised greedy selection with deterministic tie\u2011breaking.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    size = assign.size\n\n    # Candidates are indices that are still unassigned (-1)\n    cand = np.flatnonzero(assign == -1).astype(int)\n    if cand.size == 0:\n        return assign.tolist()\n\n    # Already used locations\n    used_loc = np.full(size, -1, dtype=int)\n    used_idx = np.flatnonzero(assign != -1).astype(int)\n    if used_idx.size:\n        used_loc[used_idx] = assign[used_idx]\n\n    # Free locations are those not yet used\n    avail = np.flatnonzero(~np.isin(np.arange(size), used_loc)).astype(int)\n\n    # Progress and lambda (weights)\n    progress = 1.0 - (cand.size / max(1, size))\n    lam = (progress - 0.55) / 0.45 + 1e-12          # avoid division by zero\n    lam = np.clip(lam, 0.0, 1.0)\n\n    # Weight parameters\n    w_inc, w_worst = 0.6, 0.4\n\n    best_score = np.inf\n    best_f, best_l = int(cand[0]), int(avail[0])\n\n    for f in cand:\n        # Flow contributions to already assigned facilities\n        if used_idx.size:\n            c1 = flow_matrix[f, used_idx] * distance_matrix[avail[:, None], used_loc[used_idx][None, :]]\n            c2 = flow_matrix[used_idx, f] * distance_matrix[used_loc[used_idx][:, None], avail[None, :]]\n            pair_sum = c1 + c2\n            worst = np.max(pair_sum, axis=0)\n            inc = np.sum(pair_sum, axis=0)\n        else:\n            worst = np.zeros(avail.size, dtype=float)\n            inc = np.zeros(avail.size, dtype=float)\n\n        score = w_inc * inc + w_worst * worst\n        # Deterministic noise for tie\u2011breaking\n        noise = 1e-6 * ((f + 1) * (avail + 1) % 1000)\n        score += noise\n\n        min_idx = np.argmin(score)\n        if score[min_idx] < best_score:\n            best_score = score[min_idx]\n            best_f, best_l = int(f), int(avail[min_idx])\n\n    out = assign.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "late_stage_minimax_blend_aug_125": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Random choice among top\u2011k candidates with deterministic seed.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    cand = np.flatnonzero(assign == -1).astype(int)\n    if cand.size == 0:\n        return assign.tolist()\n    used_idx = np.flatnonzero(assign != -1).astype(int)\n    used_loc = assign[used_idx]\n    avail = np.flatnonzero(~np.isin(np.arange(n), used_loc)).astype(int)\n\n    progress = 1.0 - (cand.size / max(1, n))\n    lam = (progress - 0.55) / 0.45 + 1e-12\n    lam = np.clip(lam, 0.0, 1.0)\n\n    w_inc, w_worst = 0.5, 0.5\n    top_k = 5\n\n    scores = np.full((cand.size, avail.size), np.inf, dtype=float)\n    for i, f in enumerate(cand):\n        if used_idx.size:\n            c1 = flow_matrix[f, used_idx] * distance_matrix[avail[:, None], used_loc[None, :]]\n            c2 = flow_matrix[used_idx, f] * distance_matrix[used_loc[used_idx][:, None], avail[None, :]]\n            pair_sum = c1 + c2\n            inc = np.mean(pair_sum, axis=0)\n            worst = np.max(pair_sum, axis=0)\n        else:\n            inc = np.zeros(avail.size, dtype=float)\n            worst = np.zeros(avail.size, dtype=float)\n        scores[i] = w_inc * inc + w_worst * worst\n\n    # Identify top\u2011k best scores\n    flat_indices = np.argpartition(scores.ravel(), top_k)[:top_k]\n    top_scores = scores.ravel()[flat_indices]\n    top_pairs = np.unravel_index(flat_indices, scores.shape)\n\n    # Deterministic random choice among top\u2011k\n    seed = int((top_pairs[0] + 1) * 1234567 + (top_pairs[1] + 1) * 7654321) % (2**32)\n    rng = np.random.RandomState(seed)\n    chosen_idx = rng.choice(len(top_scores))\n    best_f, best_l = int(cand[top_pairs[0][chosen_idx]]), int(avail[top_pairs[1][chosen_idx]])\n\n    out = assign.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "late_stage_minimax_blend_aug_126": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Approximate evaluation with squared distances and random top\u2011k selection.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    cand = np.flatnonzero(assign == -1).astype(int)\n    if cand.size == 0:\n        return assign.tolist()\n    used_idx = np.flatnonzero(assign != -1).astype(int)\n    used_loc = assign[used_idx]\n    avail = np.flatnonzero(~np.isin(np.arange(n), used_loc)).astype(int)\n\n    progress = 1.0 - (cand.size / max(1, n))\n    lam = np.sqrt(progress) + 1e-12   # smoother ramp\n    lam = np.clip(lam, 0.0, 1.0)\n\n    w_inc, w_worst = 0.6, 0.4\n    top_k = 3\n\n    scores = np.full((cand.size, avail.size), np.inf, dtype=float)\n    for i, f in enumerate(cand):\n        if used_idx.size:\n            c1 = flow_matrix[f, used_idx] * np.square(distance_matrix[avail[:, None], used_loc[None, :]])\n            c2 = flow_matrix[used_idx, f] * np.square(distance_matrix[used_loc[used_idx][:, None], avail[None, :]])\n            pair_sum = c1 + c2\n            inc = np.mean(pair_sum, axis=0)\n            worst = np.max(pair_sum, axis=0)\n        else:\n            inc = np.zeros(avail.size, dtype=float)\n            worst = np.zeros(avail.size, dtype=float)\n        scores[i] = w_inc * inc + w_worst * worst\n\n    # Random choice among top\u2011k after sorting\n    flat = scores.ravel()\n    idx = np.argpartition(flat, top_k)[:top_k]\n    top_scores = flat[idx]\n    top_pairs = np.unravel_index(idx, scores.shape)\n\n    seed = int((top_pairs[0][0] + 1) * 987654321 + (top_pairs[1][0] + 1) * 123456789) % (2**32)\n    rng = np.random.RandomState(seed)\n    chosen = rng.choice(len(top_scores))\n    best_f, best_l = int(cand[top_pairs[0][chosen]]), int(avail[top_pairs[1][chosen]])\n\n    out = assign.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "balanced_bipartite_greedy_step_aug_127": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorized construction with median cost, noise\u2011tied breaking and soft\u2011min selection.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a[a != -1].size:\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = np.clip(cl, 1e-12, 1.0)\n\n    progress = 1.0 - (un.size / max(1, n))\n    q = 0.15 + 0.70 * progress\n\n    uf_sorted = un[np.argsort(-pf[un])]\n    lf_sorted = free[np.argsort(-cl[free])]\n\n    f = int(uf_sorted[min(len(uf_sorted) - 1,\n                         int(q * (len(uf_sorted) - 1) + 0.5))])\n    l0 = int(lf_sorted[min(len(lf_sorted) - 1,\n                           int(q * (len(lf_sorted) - 1) + 0.5))])\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # Neighborhood selection\n    if free.size > 1:\n        k = min(8, free.size)\n        near = free[np.argsort(distance_matrix[free, l0])[:k]]\n    else:\n        near = np.array([l0], dtype=int)\n\n    # Incremental cost using median instead of sum\n    incs = []\n    for l in near:\n        if assigned.size == 0:\n            inc = 0.0\n        else:\n            inc = np.median(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                            flow_matrix[assigned, f] * distance_matrix[locs, l])\n        incs.append(inc + np.random.uniform(-1e-9, 1e-9))  # tie\u2011breaking noise\n\n    best_l = int(near[np.argmin(incs)])\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "balanced_bipartite_greedy_step_aug_128": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Inverted logic, weighted scoring, and mean cost aggregation.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a[a != -1].size:\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = np.clip(cl, 1e-12, 1.0)\n\n    progress = 1.0 - (un.size / max(1, n))\n    q = 0.10 + 0.80 * progress  # tweaked weight\n\n    uf_sorted = un[np.argsort(-pf[un])]\n    lf_sorted = free[np.argsort(-cl[free])]\n\n    f = int(uf_sorted[min(len(uf_sorted) - 1,\n                         int(q * (len(uf_sorted) - 1) + 0.5))])\n    l0 = int(lf_sorted[min(len(lf_sorted) - 1,\n                           int(q * (len(lf_sorted) - 1) + 0.5))])\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # Neighborhood selection with a larger radius\n    if free.size > 1:\n        k = min(12, free.size)\n        near = free[np.argsort(distance_matrix[free, l0])[:k]]\n    else:\n        near = np.array([l0], dtype=int)\n\n    # Incremental cost using mean instead of sum\n    incs = []\n    for l in near:\n        if assigned.size == 0:\n            inc = 0.0\n        else:\n            inc = np.mean(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                          flow_matrix[assigned, f] * distance_matrix[locs, l])\n        incs.append(inc)\n    best_l = int(near[np.argmin(incs)])\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "balanced_bipartite_greedy_step_aug_129": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"List\u2011comprehension heavy, random top\u2011k choice, and max\u2011based aggregation.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a[a != -1].size:\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = np.clip(cl, 1e-12, 1.0)\n\n    progress = 1.0 - (un.size / max(1, n))\n    q = 0.20 + 0.60 * progress\n\n    uf_sorted = un[np.argsort(-pf[un])]\n    lf_sorted = free[np.argsort(-cl[free])]\n\n    f = int(uf_sorted[min(len(uf_sorted) - 1,\n                         int(q * (len(uf_sorted) - 1) + 0.5))])\n    l0 = int(lf_sorted[min(len(lf_sorted) - 1,\n                           int(q * (len(lf_sorted) - 1) + 0.5))])\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # Neighborhood using list comprehension\n    near = np.array([free[i] for i in np.argsort(distance_matrix[free, l0])[:9]], dtype=int)\n\n    # Incremental cost with max aggregation\n    incs = [np.max(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                   flow_matrix[assigned, f] * distance_matrix[locs, l])\n            if assigned.size else 0.0\n            for l in near]\n\n    # Randomly pick among the best top\u20113\n    top_k = 3\n    best_indices = np.argsort(incs)[:top_k]\n    chosen = np.random.choice(best_indices)\n    best_l = int(near[chosen])\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "stochastic_rcl_facility_then_location_aug_130": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n\n\n",
  "adaptive_rcl_by_progress_aug_131": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"RCL size shrinks as progress increases; choose among best pairs with probability proportional to exp(-cost/T).\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a.any():\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locations = a[assigned].astype(int)\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    frac = 0.25 * (1.0 - progress) + 0.05\n\n    pairs, costs = [], []\n    for f in unassigned:\n        for l in free:\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locations] +\n                                   flow_matrix[assigned, f] * distance_matrix[locations, l]))\n            pairs.append((int(f), int(l)))\n            costs.append(inc)\n\n    costs = np.asarray(costs, dtype=float) + np.random.uniform(-1e-8, 1e-8, size=costs.shape)\n\n    k = max(1, int(np.ceil(0.30 * costs.size)) + 2)\n    idx = np.argsort(costs)[:k]\n\n    c = costs[idx]\n    c = c - c.min()\n    T = max(1e-6, 1.5 * (1.0 - progress) + 0.05)\n    p = np.exp(-c / T)\n    p = p / (p.sum() + 1e-12)\n\n    pick = int(np.random.choice(idx, p=p))\n    f, l = pairs[pick]\n\n    out = a.copy()\n    out[int(f)] = int(l)\n    return out.tolist()\n\n",
  "adaptive_rcl_by_progress_aug_132": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"RCL size shrinks as progress increases; choose among best pairs with probability proportional to softmin(-cost/T).\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a.any():\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locations = a[assigned].astype(int)\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    frac = 0.20 * (1.0 - progress) + 0.08\n\n    pairs, costs = [], []\n    i = 0\n    while i < unassigned.size:\n        f = int(unassigned[i])\n        j = 0\n        while j < free.size:\n            l = int(free[j])\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locations] +\n                                   flow_matrix[assigned, f] * distance_matrix[locations, l]))\n            pairs.append((f, l))\n            costs.append(inc)\n            j += 1\n        i += 1\n\n    costs = np.asarray(costs, dtype=float) + np.random.uniform(-1e-8, 1e-8, size=costs.shape)\n\n    k = max(1, int(np.ceil(0.35 * costs.size)))\n    idx = np.argsort(costs)[:k]\n\n    c = costs[idx]\n    c = c - c.min()\n    T = max(1e-6, 2.0 * (1.0 - progress) + 0.10)\n\n    p = 1.0 / (1.0 + c / T + 1e-12)          # softmin with epsilon\n    p = p / (p.sum() + 1e-12)\n\n    pick = int(np.random.choice(idx, p=p))\n    f, l = pairs[pick]\n\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "adaptive_rcl_by_progress_aug_133": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"RCL size shrinks as progress increases; choose among best pairs using median\u2011based cost and top\u2011k selection.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a.any():\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locations = a[assigned].astype(int)\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    frac = 0.15 * (1.0 - progress) + 0.10\n\n    pairs, costs = [], []\n    for f in unassigned:\n        for l in free:\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = np.median(flow_matrix[f, assigned] * distance_matrix[l, locations] +\n                                flow_matrix[assigned, f] * distance_matrix[locations, l])\n            pairs.append((int(f), int(l)))\n            costs.append(float(inc))\n\n    costs = np.asarray(costs, dtype=float) + np.random.uniform(-1e-8, 1e-8, size=costs.shape)\n\n    k = max(1, int(np.ceil(0.40 * costs.size)))\n    idx = np.argpartition(costs, k-1)[:k]   # top\u2011k via partition\n\n    c = costs[idx]\n    c = c - c.min()\n    T = max(1e-6, 1.8 * (1.0 - progress) + 0.07)\n\n    p = np.exp(-c / T)\n    p = p / (p.sum() + 1e-12)\n\n    pick = int(np.random.choice(idx, p=p))\n    f, l = pairs[pick]\n\n    out = a.copy()\n    out[int(f)] = int(l)\n    return out.tolist()\n\n",
  "adaptive_rcl_by_progress_aug_134": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"RCL size shrinks as progress increases; choose among best pairs with clipped probabilities.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a.any():\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locations = a[assigned].astype(int)\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    frac = 0.20 * (1.0 - progress) + 0.12\n\n    pairs, costs = [], []\n    for f in unassigned:\n        for l in free:\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locations] +\n                                   flow_matrix[assigned, f] * distance_matrix[locations, l]))\n            pairs.append((int(f), int(l)))\n            costs.append(inc)\n\n    costs = np.asarray(costs, dtype=float) + np.random.uniform(-1e-8, 1e-8, size=costs.shape)\n\n    k = max(1, int(np.ceil(0.45 * costs.size)))\n    idx = np.argsort(costs)[:k]\n\n    c = costs[idx]\n    c = c - c.min()\n    T = max(1e-6, 1.6 * (1.0 - progress) + 0.09)\n\n    p = np.exp(-c / T)\n    p = np.clip(p, 1e-12, None)                 # prevent zero probabilities\n    p = p / (p.sum() + 1e-12)\n\n    pick = int(np.random.choice(idx, p=p))\n    f, l = pairs[pick]\n\n    out = a.copy()\n    out[int(f)] = int(l)\n    return out.tolist()\n\n",
  "heavy_edge_match_then_place_aug_135": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy placement using vectorised operations.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # --- find unassigned facilities -------------------------------------------------\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    # --- identify free locations ----------------------------------------------------\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_locs = np.where(~used_loc)[0]\n\n    # --- symmetric flow matrix ------------------------------------------------------\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # --- pick facility with largest symmetric flow to another unassigned facility ----\n    if unassigned.size > 1:\n        sub = sym_flow[np.ix_(unassigned, unassigned)].copy()\n        np.fill_diagonal(sub, -np.inf)\n        i, j = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        fac = int(unassigned[i])\n    else:\n        fac = int(unassigned[0])\n\n    # --- assigned facilities and their locations ------------------------------------\n    assigned = np.where(a != -1)[0]\n    assigned_locs = a[assigned].astype(int)\n\n    # --- anchor facility for bias ---------------------------------------------------\n    if assigned.size:\n        anchor_idx = int(np.argmax(sym_flow[fac, assigned]))\n        anchor_fac = int(assigned[anchor_idx])\n        anchor_loc = int(a[anchor_fac])\n    else:\n        anchor_loc = None\n\n    # --- compute incremental cost for all free locations ----------------------------\n    if assigned.size:\n        inc_cost = np.sum(\n            flow_matrix[fac, assigned][:, None] * distance_matrix[free_locs, assigned_locs][None, :],\n            axis=0\n        ) + np.sum(\n            flow_matrix[assigned, fac][:, None] * distance_matrix[assigned_locs, free_locs][None, :],\n            axis=0\n        )\n    else:\n        inc_cost = np.zeros(free_locs.size)\n\n    # --- bias towards anchor location -----------------------------------------------\n    if anchor_loc is not None:\n        bias = 0.10 * distance_matrix[free_locs, anchor_loc] / (1.0 + 1e-12)\n        bias = np.clip(bias, 0, 10)\n    else:\n        bias = np.zeros_like(inc_cost)\n\n    # --- deterministic tie\u2011breaking noise --------------------------------------------\n    noise = 1e-9 * np.arange(free_locs.size)\n\n    # --- total score -----------------------------------------------------------------\n    score = inc_cost + bias + noise\n\n    # --- select best location --------------------------------------------------------\n    best_idx = int(np.argmin(score))\n    best_loc = int(free_locs[best_idx])\n\n    # --- update assignment ----------------------------------------------------------\n    out = a.copy()\n    out[fac] = best_loc\n    return out.tolist()\n\n",
  "heavy_edge_match_then_place_aug_136": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy placement with softmin selection among top\u2011k locations.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # --- unassigned facilities ------------------------------------------------------\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    # --- free locations ------------------------------------------------------------\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_locs = np.where(~used_loc)[0]\n\n    # --- symmetric flow -------------------------------------------------------------\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # --- select facility with max symmetric flow among unassigned -------------------\n    if unassigned.size > 1:\n        sub = sym_flow[np.ix_(unassigned, unassigned)].copy()\n        np.fill_diagonal(sub, -np.inf)\n        idx = int(np.argmax(sub))\n        fac = int(unassigned[idx])\n    else:\n        fac = int(unassigned[0])\n\n    # --- assigned facilities and locations -----------------------------------------\n    assigned = np.where(a != -1)[0]\n    assigned_locs = a[assigned].astype(int)\n\n    # --- anchor for bias ------------------------------------------------------------\n    if assigned.size:\n        anchor_idx = int(np.argmax(sym_flow[fac, assigned]))\n        anchor_fac = int(assigned[anchor_idx])\n        anchor_loc = int(a[anchor_fac])\n    else:\n        anchor_loc = None\n\n    # --- incremental cost per free location -----------------------------------------\n    if assigned.size:\n        inc_cost = np.sum(\n            flow_matrix[fac, assigned][:, None] * distance_matrix[free_locs, assigned_locs][None, :],\n            axis=0\n        ) + np.sum(\n            flow_matrix[assigned, fac][:, None] * distance_matrix[assigned_locs, free_locs][None, :],\n            axis=0\n        )\n    else:\n        inc_cost = np.zeros(free_locs.size)\n\n    # --- bias towards anchor --------------------------------------------------------\n    if anchor_loc is not None:\n        bias = 0.08 * distance_matrix[free_locs, anchor_loc] / (1.0 + 1e-12)\n        bias = np.clip(bias, 0, 8)\n    else:\n        bias = np.zeros_like(inc_cost)\n\n    # --- score with deterministic noise --------------------------------------------\n    noise = 2e-9 * np.arange(free_locs.size)\n    score = inc_cost + bias + noise\n\n    # --- softmin probabilities -----------------------------------------------------\n    # shift to avoid underflow\n    shift = np.max(score)\n    exp_vals = np.exp(-(score - shift))  # negative for softmin\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # --- choose among top_k locations ---------------------------------------------\n    top_k = 3\n    top_indices = np.argsort(score)[:top_k]\n    top_probs = probs[top_indices]\n    top_probs = top_probs / (np.sum(top_probs) + 1e-12)\n\n    chosen_idx = int(np.random.choice(top_indices, p=top_probs))\n    best_loc = int(free_locs[chosen_idx])\n\n    # --- update assignment ----------------------------------------------------------\n    out = a.copy()\n    out[fac] = best_loc\n    return out.tolist()\n\n",
  "heavy_edge_match_then_place_aug_137": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy placement using mean cost and anchor bias with deterministic noise.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # --- identify unassigned facilities --------------------------------------------\n    unassigned = [i for i, val in enumerate(a) if val == -1]\n    if not unassigned:\n        return a.tolist()\n\n    # --- free locations ------------------------------------------------------------\n    used_loc = [False] * n\n    for idx in np.where(a != -1)[0]:\n        used_loc[a[idx]] = True\n    free_locs = [i for i, used in enumerate(used_loc) if not used]\n\n    # --- symmetric flow -------------------------------------------------------------\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # --- pick facility with maximum symmetric flow --------------------------------\n    if len(unassigned) > 1:\n        sub = sym_flow[np.ix_(unassigned, unassigned)].copy()\n        np.fill_diagonal(sub, -np.inf)\n        i, j = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        fac = int(unassigned[i])\n    else:\n        fac = int(unassigned[0])\n\n    # --- assigned facilities and locations -----------------------------------------\n    assigned = [i for i, val in enumerate(a) if val != -1]\n    assigned_locs = [int(a[i]) for i in assigned]\n\n    # --- anchor facility ------------------------------------------------------------\n    if assigned:\n        anchor_idx = int(np.argmax(sym_flow[fac, assigned]))\n        anchor_fac = int(assigned[anchor_idx])\n        anchor_loc = int(a[anchor_fac])\n    else:\n        anchor_loc = None\n\n    # --- incremental cost per free location -----------------------------------------\n    if assigned:\n        inc_cost = np.mean(\n            flow_matrix[fac, assigned][:, None] * distance_matrix[free_locs, assigned_locs][None, :],\n            axis=0\n        ) + np.mean(\n            flow_matrix[assigned, fac][:, None] * distance_matrix[assigned_locs, free_locs][None, :],\n            axis=0\n        )\n    else:\n        inc_cost = np.zeros(len(free_locs))\n\n    # --- bias towards anchor --------------------------------------------------------\n    if anchor_loc is not None:\n        bias = 0.15 * distance_matrix[free_locs, anchor_loc] / (1.0 + 1e-12)\n        bias = np.clip(bias, 0, 15)\n    else:\n        bias = np.zeros_like(inc_cost)\n\n    # --- deterministic tie\u2011breaking noise --------------------------------------------\n    noise = 5e-10 * np.arange(len(free_locs))\n\n    # --- total score -----------------------------------------------------------------\n    score = inc_cost + bias + noise\n\n    # --- select location with minimal score -----------------------------------------\n    best_idx = int(np.argmin(score))\n    best_loc = int(free_locs[best_idx])\n\n    # --- update assignment ----------------------------------------------------------\n    out = a.copy()\n    out[fac] = best_loc\n    return out.tolist()\n\n",
  "heavy_edge_match_then_place_aug_138": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy placement with deterministic tie\u2011breaking and explicit max selection.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # --- unassigned facilities ------------------------------------------------------\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    # --- free locations ------------------------------------------------------------\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_locs = np.where(~used_loc)[0]\n\n    # --- symmetric flow -------------------------------------------------------------\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # --- facility with largest symmetric flow --------------------------------------\n    if unassigned.size > 1:\n        sub = sym_flow[np.ix_(unassigned, unassigned)].copy()\n        np.fill_diagonal(sub, -np.inf)\n        i, j = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        fac = int(unassigned[i])\n    else:\n        fac = int(unassigned[0])\n\n    # --- assigned facilities and locations -----------------------------------------\n    assigned = np.where(a != -1)[0]\n    assigned_locs = a[assigned].astype(int)\n\n    # --- anchor facility for bias ---------------------------------------------------\n    if assigned.size:\n        anchor_idx = int(np.argmax(sym_flow[fac, assigned]))\n        anchor_fac = int(assigned[anchor_idx])\n        anchor_loc = int(a[anchor_fac])\n    else:\n        anchor_loc = None\n\n    # --- incremental cost per free location -----------------------------------------\n    if assigned.size:\n        inc_cost = np.sum(\n            flow_matrix[fac, assigned][:, None] * distance_matrix[free_locs, assigned_locs][None, :],\n            axis=0\n        ) + np.sum(\n            flow_matrix[assigned, fac][:, None] * distance_matrix[assigned_locs, free_locs][None, :],\n            axis=0\n        )\n    else:\n        inc_cost = np.zeros(free_locs.size)\n\n    # --- bias towards anchor --------------------------------------------------------\n    if anchor_loc is not None:\n        bias = 0.05 * distance_matrix[free_locs, anchor_loc] / (1.0 + 1e-12)\n        bias = np.clip(bias, 0, 5)\n    else:\n        bias = np.zeros_like(inc_cost)\n\n    # --- deterministic noise for tie breaking --------------------------------------\n    noise = 1e-8 * np.arange(free_locs.size)\n\n    # --- total score -----------------------------------------------------------------\n    score = inc_cost + bias + noise\n\n    # --- choose location with maximum negative score (i.e., minimal score) ----------\n    best_idx = int(np.argmax(-score))\n    best_loc = int(free_locs[best_idx])\n\n    # --- update assignment ----------------------------------------------------------\n    out = a.copy()\n    out[fac] = best_loc\n    return out.tolist()\n\n",
  "min_inc_with_location_crowding_aug_139": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 1: Vectorized evaluation with softmin selection and median\u2011centroid.\n    \"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # Indices of unassigned facilities\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    # Indices of already assigned facilities\n    assigned_idx = np.flatnonzero(assign != -1).astype(int)\n\n    # Boolean mask of used locations\n    used_mask = np.zeros(n, dtype=bool)\n    if assigned_idx.size:\n        used_mask[assign[assigned_idx]] = True\n    free_locs = np.flatnonzero(~used_mask).astype(int)\n\n    used_locs = assign[assigned_idx].astype(int)\n\n    # Median\u2011centroid (robust to outliers)\n    centroid_loc = int(np.median(used_locs)) if assigned_idx.size else None\n\n    # Compute incremental cost for all combinations\n    if assigned_idx.size:\n        inc_matrix = (\n            np.sum(flow_matrix[unassigned[:, None], assigned_idx]\n                   * distance_matrix[free_locs[None, :], used_locs[None, :]], axis=2) +\n            np.sum(flow_matrix[assigned_idx[:, None], unassigned]\n                   * distance_matrix[used_locs[:, None], free_locs[None, :]], axis=2)\n        )\n    else:\n        inc_matrix = np.zeros((unassigned.size, free_locs.size), dtype=float)\n\n    # Crowd penalty\n    crowd_matrix = (\n        0.08 * distance_matrix[free_locs[:, None], centroid_loc]\n        if centroid_loc is not None else np.zeros((unassigned.size, free_locs.size))\n    )\n\n    # Total score\n    score_matrix = inc_matrix + crowd_matrix\n\n    # Add tiny deterministic noise to break ties\n    rng = np.random.default_rng(12345)\n    noise = rng.normal(scale=1e-9, size=score_matrix.shape)\n    score_matrix += noise\n\n    # Softmin selection with temperature\n    T = 0.5\n    exp_vals = np.exp(-score_matrix / (T + 1e-12))\n    probs = exp_vals / np.clip(exp_vals.sum(axis=1, keepdims=True), 1e-12, None)\n    flat_idx = np.argmax(probs)\n    best_f = unassigned[flat_idx // free_locs.size]\n    best_l = free_locs[flat_idx % free_locs.size]\n\n    out = assign.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_inc_with_flow_centrality_facility_aug_140": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy assignment based on eigenvector centrality (power iteration)\n    and incremental cost. Small random noise is added for deterministic\n    tie\u2011breaking.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Find unassigned facilities\n    candidates = np.where(a == -1)[0]\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Power iteration to approximate eigenvector centrality\n    flow_mat = (flow_matrix + flow_matrix.T).astype(float)\n    v = np.full(n, 1.0 / n, dtype=float)\n    for _ in range(15):                     # more iterations for stability\n        v = flow_mat @ v\n        v = v / (np.linalg.norm(v) + 1e-12)  # epsilon to avoid div\u2011by\u2011zero\n\n    v = np.abs(v)\n    f = int(candidates[np.argmax(v[candidates])])  # facility to place\n\n    # Determine free locations\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    # Already assigned facilities and their locations\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    # Find location with minimal incremental cost\n    best_cost = np.inf\n    best_loc = int(free[0])\n    for l in free:\n        if ass.size == 0:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                               flow_matrix[ass, f] * distance_matrix[locs, l]))\n        # add tiny noise for deterministic tie\u2011breaking\n        inc += 1e-12 * np.random.rand()\n        if inc < best_cost:\n            best_cost, best_loc = inc, int(l)\n\n    out = a.copy()\n    out[f] = best_loc\n    return out.tolist()\n\n",
  "min_inc_with_flow_centrality_facility_aug_141": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Uses median aggregation for incremental cost and selects a random\n    location among the top\u2011k cheapest options.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    # Eigenvector centrality via power iteration (fewer steps)\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    v = np.full(n, 1.0 / n, dtype=float)\n    for _ in range(10):\n        v = F @ v\n        v = v / (np.linalg.norm(v) + 1e-12)\n    v = np.abs(v)\n\n    f = int(unassigned[np.argmax(v[unassigned])])\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    # Compute incremental costs using median\n    costs = []\n    for l in free:\n        if ass.size == 0:\n            cost = 0.0\n        else:\n            cost = np.median(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                             flow_matrix[ass, f] * distance_matrix[locs, l])\n        costs.append(cost + 1e-12)  # tiny epsilon\n    costs = np.array(costs)\n\n    # Random choice among top\u2011k cheapest locations\n    top_k = 5\n    top_indices = np.argsort(costs)[:top_k]\n    chosen = np.random.choice(top_indices)\n    best_l = int(free[chosen])\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "min_inc_with_flow_centrality_facility_aug_142": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Uses mean centrality and maximum incremental cost for selection.\n    Centrality values are clipped to avoid extreme values.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    # Mean centrality (simple approximation)\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    centrality = np.mean(F, axis=0)\n    centrality = np.clip(centrality, 0.0, 1.0)  # prevent overflow\n    f = int(unassigned[np.argmax(centrality[unassigned])])\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    # Compute incremental cost using maximum instead of sum\n    best_cost = np.inf\n    best_l = int(free[0])\n    for l in free:\n        if ass.size == 0:\n            inc = 0.0\n        else:\n            inc = np.max(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                         flow_matrix[ass, f] * distance_matrix[locs, l])\n        # deterministic tie\u2011breaking with small noise\n        inc += 1e-12 * np.random.rand()\n        if inc < best_cost:\n            best_cost, best_l = inc, int(l)\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "min_inc_with_location_pagerank_aug_143": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy update using a deterministic tie\u2011breaker and a soft\u2011min score.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # indices of still\u2011unassigned flows\n    cand_f = np.flatnonzero(assign == -1).astype(int)\n    if cand_f.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    # PageRank on the inverse\u2011distance graph\n    inv_dist = 1.0 / (distance_matrix.astype(float) + 1e-12)\n    np.fill_diagonal(inv_dist, 0.0)\n    row_sums = inv_dist.sum(axis=1, keepdims=True) + 1e-12\n    P = inv_dist / row_sums\n    P = np.clip(P, 0.0, 1.0)\n\n    d = 0.85\n    pr = np.ones(n, dtype=float) / n\n    for _ in range(20):\n        pr = d * (P.T @ pr) + (1.0 - d) / n\n    pr = (pr - pr.min()) / (pr.max() - pr.min() + 1e-12)\n\n    ass = np.flatnonzero(assign != -1).astype(int)\n    locs = assign[ass].astype(int)\n\n    best_score = np.inf\n    best_f = cand_f[0]\n    best_l = free_locs[0]\n    noise_factor = 1e-9\n\n    f_idx = 0\n    while f_idx < cand_f.size:\n        f = cand_f[f_idx]\n        l_idx = 0\n        while l_idx < free_locs.size:\n            l = free_locs[l_idx]\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n            # lower inc and higher PageRank \u2192 lower score\n            score = inc + 0.3 * (1.0 - pr[l])\n            score += noise_factor * (f_idx * free_locs.size + l_idx)  # deterministic tie\u2011breaker\n            if score < best_score:\n                best_score = score\n                best_f = f\n                best_l = l\n            l_idx += 1\n        f_idx += 1\n\n    out = assign.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_inc_with_location_pagerank_aug_144": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Weighted scoring with top\u2011k random selection and mean\u2011based cost.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    cand_f = np.flatnonzero(assign == -1).astype(int)\n    if cand_f.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    # PageRank\n    inv_dist = 1.0 / (distance_matrix.astype(float) + 1e-12)\n    np.fill_diagonal(inv_dist, 0.0)\n    row_sums = inv_dist.sum(axis=1, keepdims=True) + 1e-12\n    P = inv_dist / row_sums\n    P = np.clip(P, 0.0, 1.0)\n\n    d = 0.85\n    pr = np.ones(n, dtype=float) / n\n    for _ in range(20):\n        pr = d * (P.T @ pr) + (1.0 - d) / n\n    pr = (pr - pr.min()) / (pr.max() - pr.min() + 1e-12)\n\n    ass = np.flatnonzero(assign != -1).astype(int)\n    locs = assign[ass].astype(int)\n\n    scores = []\n    for f in cand_f:\n        for l in free_locs:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.mean(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = 0.6 * inc + 0.4 * (1.0 - pr[l])  # weighted\n            scores.append((score, f, l))\n\n    top_k = 7\n    scores.sort(key=lambda x: x[0])\n    top_candidates = scores[:top_k]\n    _, best_f, best_l = top_candidates[np.random.randint(len(top_candidates))]\n\n    out = assign.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_inc_with_location_pagerank_aug_145": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Approximate cost with a maximum\u2011product proxy and deterministic noise.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    cand_f = np.flatnonzero(assign == -1).astype(int)\n    if cand_f.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    # PageRank\n    inv_dist = 1.0 / (distance_matrix.astype(float) + 1e-12)\n    np.fill_diagonal(inv_dist, 0.0)\n    row_sums = inv_dist.sum(axis=1, keepdims=True) + 1e-12\n    P = inv_dist / row_sums\n    P = np.clip(P, 0.0, 1.0)\n\n    d = 0.85\n    pr = np.ones(n, dtype=float) / n\n    for _ in range(20):\n        pr = d * (P.T @ pr) + (1.0 - d) / n\n    pr = (pr - pr.min()) / (pr.max() - pr.min() + 1e-12)\n\n    ass = np.flatnonzero(assign != -1).astype(int)\n    locs = assign[ass].astype(int)\n\n    best_score = np.inf\n    best_f = cand_f[0]\n    best_l = free_locs[0]\n    noise = 1e-8\n\n    for f in cand_f:\n        for l in free_locs:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.max(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc + 0.2 * (1.0 - pr[l]) + noise * (f + l)  # deterministic tie\u2011breaker\n            if score < best_score:\n                best_score = score\n                best_f = f\n                best_l = l\n\n    out = assign.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "directional_flow_asymmetry_priority_aug_146": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 1 \u2013 soft\u2011min selection with vectorised flow asymmetry.\n    \"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # Facilities that are still unassigned\n    candidates = [i for i, v in enumerate(assign) if v == -1]\n    if not candidates:\n        return assign.tolist()\n\n    assigned_fac = [i for i, v in enumerate(assign) if v != -1]\n    used_locs = np.zeros(n, dtype=bool)\n    if assigned_fac:\n        used_locs[assign[assigned_fac]] = True\n    free_locs = [i for i, used in enumerate(used_locs) if not used]\n\n    locs = assign[assigned_fac]\n\n    # Pick the facility with the largest flow asymmetry\n    if assigned_fac:\n        asym = np.abs(\n            flow_matrix[np.ix_(candidates, assigned_fac)].sum(axis=1) -\n            flow_matrix[np.ix_(assigned_fac, candidates)].sum(axis=0)\n        )\n        f = candidates[int(np.argmax(asym))]\n    else:\n        pf = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1))\n        f = candidates[int(np.argmax(pf[candidates]))]\n\n    # Compute incremental cost for every free location\n    incs = []\n    for l in free_locs:\n        if not assigned_fac:\n            inc = 0.0\n        else:\n            out_cost = np.sum(flow_matrix[f, assigned_fac] * distance_matrix[l, locs])\n            in_cost = np.sum(flow_matrix[assigned_fac, f] * distance_matrix[locs, l])\n            inc = float(out_cost + in_cost)\n        incs.append(inc)\n\n    incs = np.clip(np.array(incs, dtype=float), 0, 1e6)\n\n    # Soft\u2011min probabilities \u2013 avoid overflow with clipping\n    alpha = 10.0\n    probs_num = np.exp(-alpha * incs)\n    probs_den = probs_num.sum() + 1e-12          # epsilon for denominator\n    probs = probs_num / probs_den\n    best_l = free_locs[int(np.argmax(probs))]\n\n    out = assign.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "directional_flow_asymmetry_priority_aug_147": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 2 \u2013 while\u2011loop, mean aggregation, top\u2011k random choice with noise.\n    \"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    candidates = [i for i, v in enumerate(assign) if v == -1]\n    if not candidates:\n        return assign.tolist()\n\n    assigned_fac = [i for i, v in enumerate(assign) if v != -1]\n    used_locs = np.zeros(n, dtype=bool)\n    if assigned_fac:\n        used_locs[assign[assigned_fac]] = True\n    free_locs = [i for i, used in enumerate(used_locs) if not used]\n\n    locs = assign[assigned_fac]\n\n    # Facility selection\n    if assigned_fac:\n        asym = np.abs(\n            flow_matrix[np.ix_(candidates, assigned_fac)].sum(axis=1) -\n            flow_matrix[np.ix_(assigned_fac, candidates)].sum(axis=0)\n        )\n        f = candidates[int(np.argmax(asym))]\n    else:\n        pf = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1))\n        f = candidates[int(np.argmax(pf[candidates]))]\n\n    incs = np.empty(len(free_locs), dtype=float)\n    i = 0\n    while i < len(free_locs):\n        l = free_locs[i]\n        if not assigned_fac:\n            inc = 0.0\n        else:\n            out_cost = np.mean(flow_matrix[f, assigned_fac] * distance_matrix[l, locs])\n            in_cost = np.mean(flow_matrix[assigned_fac, f] * distance_matrix[locs, l])\n            inc = float(out_cost + in_cost)\n        # deterministic noise for tie breaking\n        inc += 1e-6 * (i + 1)\n        # divide by number of assigned facilities \u2013 epsilon protects against zero\n        inc = inc / (len(assigned_fac) + 1e-12)\n        incs[i] = inc\n        i += 1\n\n    incs = np.clip(incs, 0, 1e4)\n\n    # Pick among the best top_k candidates\n    top_k = 7\n    if len(incs) > top_k:\n        idx = np.argpartition(incs, top_k)[:top_k]\n        chosen = np.random.choice(idx)\n    else:\n        chosen = np.argmin(incs)\n\n    best_l = free_locs[chosen]\n    out = assign.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "min_inc_with_rank_sum_aug_148": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 1 \u2013 vectorised scoring with softmin, deterministic noise, and renamed variables.\n    \"\"\"\n    assignment = np.asarray(current_assignment, dtype=int)\n    n = assignment.size\n\n    # Candidates and free locations\n    candidates = np.flatnonzero(assignment == -1).astype(int)\n    if candidates.size == 0:\n        return assignment.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assignment != -1):\n        used[assignment[assignment != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    # Facility and location metrics\n    flow_sum = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    # Avoid division by zero\n    loc_centrality = 1.0 / (np.clip(distance_matrix.sum(axis=1).astype(float), 1e-12, None))\n\n    # Already assigned facilities and their locations\n    assigned_fac = np.flatnonzero(assignment != -1).astype(int)\n    assigned_loc = assignment[assigned_fac].astype(int)\n\n    # Build candidate pairs and incremental cost\n    pairs = []\n    incs = []\n    for f in candidates:\n        for l in free_locs:\n            if assigned_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, assigned_fac] * distance_matrix[l, assigned_loc] +\n                                   flow_matrix[assigned_fac, f] * distance_matrix[assigned_loc, l]))\n            pairs.append((f, l))\n            incs.append(inc)\n\n    incs = np.asarray(incs, dtype=float)\n    # Ranking: lower inc is better\n    inc_rank = np.argsort(np.argsort(incs))\n\n    f_vals = flow_sum[[f for f, _ in pairs]]\n    l_vals = loc_centrality[[l for _, l in pairs]]\n    f_rank = np.argsort(np.argsort(-f_vals))\n    l_rank = np.argsort(np.argsort(-l_vals))\n\n    # Combine scores with weights and add deterministic noise\n    noise = 1e-6 * np.arange(len(pairs))\n    score = inc_rank + 0.4 * f_rank + 0.4 * l_rank + noise\n    idx = int(np.argmin(score))\n    f, l = pairs[idx]\n\n    new_assignment = assignment.copy()\n    new_assignment[int(f)] = int(l)\n    return new_assignment.tolist()\n\n",
  "min_inc_with_rank_sum_aug_149": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 2 \u2013 list comprehensions, random top\u2011k selection, median aggregation.\n    \"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    cand = np.flatnonzero(assign == -1).astype(int)\n    if cand.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    flow_tot = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    loc_centr = 1.0 / (np.clip(distance_matrix.sum(axis=1).astype(float), 1e-12, None))\n\n    assigned_f = np.flatnonzero(assign != -1).astype(int)\n    assigned_l = assign[assigned_f].astype(int)\n\n    # Build pairs and incremental cost using list comprehensions\n    pairs = [(f, l) for f in cand for l in free]\n    incs = np.array([\n        0.0 if assigned_f.size == 0 else\n        float(np.sum(flow_matrix[f, assigned_f] * distance_matrix[l, assigned_l] +\n                     flow_matrix[assigned_f, f] * distance_matrix[assigned_l, l]))\n        for f, l in pairs\n    ], dtype=float)\n\n    # Use median instead of sum for incremental cost ranking\n    inc_rank = np.argsort(np.argsort(incs))\n\n    f_vals = flow_tot[[f for f, _ in pairs]]\n    l_vals = loc_centr[[l for _, l in pairs]]\n    f_rank = np.argsort(np.argsort(-f_vals))\n    l_rank = np.argsort(np.argsort(-l_vals))\n\n    # Combine with different weights\n    score = inc_rank + 0.3 * f_rank + 0.3 * l_rank\n\n    # Random choice among top 7\n    top_k = 7\n    top_indices = np.argpartition(score, top_k)[:top_k]\n    chosen = np.random.choice(top_indices)\n\n    f, l = pairs[chosen]\n    new_assign = assign.copy()\n    new_assign[int(f)] = int(l)\n    return new_assign.tolist()\n\n",
  "min_inc_with_rank_sum_aug_150": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 3 \u2013 explicit loops, deterministic noise, median aggregation, inverted condition.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # If all assigned, just return\n    if np.all(a != -1):\n        return a.tolist()\n\n    # Identify free facilities and locations\n    free_fac = np.flatnonzero(a == -1).astype(int)\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    pf = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    cl = 1.0 / (np.clip(distance_matrix.sum(axis=1).astype(float), 1e-12, None))\n\n    assigned_f = np.flatnonzero(a != -1).astype(int)\n    assigned_l = a[assigned_f].astype(int)\n\n    pairs = []\n    incs = []\n    for f in free_fac:\n        for l in free_locs:\n            if assigned_f.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, assigned_f] * distance_matrix[l, assigned_l] +\n                                   flow_matrix[assigned_f, f] * distance_matrix[assigned_l, l]))\n            pairs.append((f, l))\n            incs.append(inc)\n\n    incs = np.asarray(incs, dtype=float)\n    inc_rank = np.argsort(np.argsort(incs))\n    f_vals = pf[[f for f, _ in pairs]]\n    l_vals = cl[[l for _, l in pairs]]\n    f_rank = np.argsort(np.argsort(-f_vals))\n    l_rank = np.argsort(np.argsort(-l_vals))\n\n    # Deterministic noise using a fixed RNG\n    rng = np.random.default_rng(12345)\n    noise = rng.random(len(pairs)) * 1e-6\n\n    score = 0.3 * inc_rank + 0.35 * f_rank + 0.35 * l_rank + noise\n    idx = int(np.argmin(score))\n    f, l = pairs[idx]\n\n    out = a.copy()\n    out[int(f)] = int(l)\n    return out.tolist()\n\n",
  "min_inc_with_rank_sum_aug_151": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 4 \u2013 vectorised incremental cost, softmin with temperature, and epsilon safeguards.\n    \"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # Candidates and free locations\n    cand = np.flatnonzero(assign == -1).astype(int)\n    if cand.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free_l = np.flatnonzero(~used).astype(int)\n\n    # Facility and location metrics\n    flow_tot = (flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)).astype(float)\n    loc_centr = 1.0 / (np.clip(distance_matrix.sum(axis=1).astype(float), 1e-12, None))\n\n    assigned_f = np.flatnonzero(assign != -1).astype(int)\n    assigned_l = assign[assigned_f].astype(int)\n\n    # Build all candidate pairs\n    pairs = [(f, l) for f in cand for l in free_l]\n    incs = []\n\n    # Compute incremental cost for each pair\n    for f, l in pairs:\n        if assigned_f.size == 0:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_matrix[f, assigned_f] * distance_matrix[l, assigned_l] +\n                               flow_matrix[assigned_f, f] * distance_matrix[assigned_l, l]))\n        incs.append(inc)\n\n    incs = np.asarray(incs, dtype=float)\n    inc_rank = np.argsort(np.argsort(incs))\n\n    f_vals = flow_tot[[f for f, _ in pairs]]\n    l_vals = loc_centr[[l for _, l in pairs]]\n    f_rank = np.argsort(np.argsort(-f_vals))\n    l_rank = np.argsort(np.argsort(-l_vals))\n\n    # Softmin with temperature (lower score \u2192 higher probability)\n    temp = 0.5\n    combined = inc_rank + 0.35 * f_rank + 0.35 * l_rank\n    probs = np.exp(-combined / temp)\n    probs /= np.clip(probs.sum(), 1e-12, None)  # avoid division by zero\n\n    idx = int(np.random.choice(len(pairs), p=probs))\n    f, l = pairs[idx]\n\n    out = assign.copy()\n    out[int(f)] = int(l)\n    return out.tolist()\n\n",
  "min_inc_with_facility_hubs_first_aug_152": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # facilities that have not yet been placed\n    fac_unassigned = np.flatnonzero(assign == -1).astype(int)\n    if fac_unassigned.size == 0:\n        return assign.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    loc_free = np.flatnonzero(~used_loc).astype(int)\n\n    progress = 1.0 - (fac_unassigned.size / max(1, n))\n\n    # flow importance of each facility\n    flow_p = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n\n    # centrality of each location\n    central = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    central = np.clip(central, 0, 1e6)\n\n    assigned = np.flatnonzero(assign != -1).astype(int)\n    locs_assigned = assign[assigned].astype(int)\n\n    # ---------- later phase: pure incremental search ----------\n    if progress >= 0.45:\n        best_inc = np.inf\n        best_f = int(fac_unassigned[0])\n        best_l = int(loc_free[0])\n        for f in fac_unassigned:\n            for l in loc_free:\n                if assigned.size == 0:\n                    inc = 0.0\n                else:\n                    inc = float(np.sum(flow_matrix[f, assigned] *\n                                       distance_matrix[l, locs_assigned] +\n                                       flow_matrix[assigned, f] *\n                                       distance_matrix[locs_assigned, l]))\n                if inc < best_inc:\n                    best_inc = inc\n                    best_f = int(f)\n                    best_l = int(l)\n        out = assign.copy()\n        out[best_f] = best_l\n        return out.tolist()\n\n    # ---------- early phase: hub\u2011centric selection ----------\n    kf = max(1, int(np.ceil(0.20 * fac_unassigned.size)))\n    hub_candidates = fac_unassigned[np.argsort(-flow_p[fac_unassigned])[:kf]]\n    kl = max(1, int(np.ceil(0.20 * loc_free.size)))\n    central_candidates = loc_free[np.argsort(-central[loc_free])[:kl]]\n\n    best_inc = np.inf\n    best_f = int(hub_candidates[0])\n    best_l = int(central_candidates[0])\n    for f in hub_candidates:\n        for l in central_candidates:\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, assigned] *\n                                   distance_matrix[l, locs_assigned] +\n                                   flow_matrix[assigned, f] *\n                                   distance_matrix[locs_assigned, l]))\n            if inc < best_inc:\n                best_inc = inc\n                best_f = int(f)\n                best_l = int(l)\n    out = assign.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_inc_with_facility_hubs_first_aug_153": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free_loc = np.flatnonzero(~used).astype(int)\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-10)\n    cl = np.clip(cl, 0, 1e6)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.random.rand() * 1e-6\n\n    if progress < 0.55:          # tuned early\u2011phase threshold\n        kf = max(1, int(np.ceil(0.25 * unassigned.size)))  # tuned top\u2011k\n        hubs = unassigned[np.argsort(-pf[unassigned])[:kf]]\n        kl = max(1, int(np.ceil(0.25 * free_loc.size)))\n        cents = free_loc[np.argsort(-cl[free_loc])[:kl]]\n        best = np.inf\n        best_f = int(hubs[0])\n        best_l = int(cents[0])\n        for f in hubs:\n            for l in cents:\n                inc = 0.0 if assigned.size == 0 else float(\n                    np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                           flow_matrix[assigned, f] * distance_matrix[locs, l]))\n                inc += noise\n                if inc < best:\n                    best = inc\n                    best_f = int(f)\n                    best_l = int(l)\n        out = a.copy()\n        out[best_f] = best_l\n        return out.tolist()\n\n    # later phase: exhaustive incremental search\n    best = np.inf\n    best_f = int(unassigned[0])\n    best_l = int(free_loc[0])\n    for f in unassigned:\n        for l in free_loc:\n            inc = 0.0 if assigned.size == 0 else float(\n                np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                       flow_matrix[assigned, f] * distance_matrix[locs, l]))\n            inc += noise\n            if inc < best:\n                best = inc\n                best_f = int(f)\n                best_l = int(l)\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_inc_with_facility_hubs_first_aug_154": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = np.clip(cl, 0, 1e6)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # ---------- soft\u2011min selection ----------\n    alpha = 15.0\n    if progress < 0.5:\n        kf = max(1, int(np.ceil(0.18 * un.size)))\n        hubs = un[np.argsort(-pf[un])[:kf]]\n        kl = max(1, int(np.ceil(0.18 * free.size)))\n        cents = free[np.argsort(-cl[free])[:kl]]\n\n        inc_matrix = np.full((len(hubs), len(cents)), np.inf, dtype=float)\n        for i, f in enumerate(hubs):\n            for j, l in enumerate(cents):\n                if ass.size == 0:\n                    inc = 0.0\n                else:\n                    inc = float(np.sum(flow_matrix[f, ass] *\n                                       distance_matrix[l, locs] +\n                                       flow_matrix[ass, f] *\n                                       distance_matrix[locs, l]))\n                inc_matrix[i, j] = inc\n\n        w = np.exp(-alpha * inc_matrix)\n        idx = np.unravel_index(np.argmax(w, axis=None), w.shape)\n        best_f = int(hubs[idx[0]])\n        best_l = int(cents[idx[1]])\n        out = a.copy()\n        out[best_f] = best_l\n        return out.tolist()\n\n    # full search with soft\u2011min\n    inc_matrix = np.full((un.size, free.size), np.inf, dtype=float)\n    for i, f in enumerate(un):\n        for j, l in enumerate(free):\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass] *\n                                   distance_matrix[l, locs] +\n                                   flow_matrix[ass, f] *\n                                   distance_matrix[locs, l]))\n            inc_matrix[i, j] = inc\n\n    w = np.exp(-alpha * inc_matrix)\n    idx = np.unravel_index(np.argmax(w, axis=None), w.shape)\n    best_f = int(un[idx[0]])\n    best_l = int(free[idx[1]])\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "least_constrained_location_first_aug_155": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # Facilities that have not yet been placed\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    # Locations already occupied\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    # Pick a location that is least constrained: minimal variance of its distances\n    if free_locs.size > 1:\n        D = distance_matrix[np.ix_(free_locs, free_locs)].astype(float)\n        # Explicit variance formula \u2013 add epsilon to denominator\n        mean_d = np.mean(D, axis=1, keepdims=True)\n        var_d = np.mean((D - mean_d)**2, axis=1) / (D.shape[1] - 1 + 1e-12)\n        loc = int(free_locs[np.argmin(var_d)])\n    else:\n        loc = int(free_locs[0])\n\n    # Already placed facilities and their locations\n    placed_fac = np.flatnonzero(assign != -1).astype(int)\n    placed_locs = assign[placed_fac].astype(int)\n\n    # Compute incremental cost for each candidate facility\n    best_cost = float('inf')\n    best_fac = int(unassigned[0])\n    for f in unassigned.astype(int):\n        if placed_fac.size == 0:\n            inc = 0.0\n        else:\n            inc = float(\n                np.sum(flow_matrix[f, placed_fac] * distance_matrix[loc, placed_locs] +\n                       flow_matrix[placed_fac, f] * distance_matrix[placed_locs, loc])\n            )\n        # Tiny deterministic noise for tie\u2011breaking\n        inc += 1e-9 * f\n        if inc < best_cost:\n            best_cost = inc\n            best_fac = int(f)\n\n    result = assign.copy()\n    result[best_fac] = loc\n    return result.tolist()\n\n",
  "least_constrained_location_first_aug_156": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Unassigned facilities\n    cand_fac = np.flatnonzero(a == -1).astype(int)\n    if cand_fac.size == 0:\n        return a.tolist()\n\n    # Locations already used\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    # Robust variance proxy \u2013 median absolute deviation\n    if free_locs.size > 1:\n        D = distance_matrix[np.ix_(free_locs, free_locs)].astype(float)\n        med = np.median(D, axis=1, keepdims=True)\n        mad = np.median(np.abs(D - med), axis=1)\n        top_k = 5\n        top_idx = np.argpartition(mad, top_k - 1)[:top_k]\n        candidate_locs = free_locs[top_idx]\n    else:\n        candidate_locs = free_locs\n\n    # Facilities already placed\n    placed_fac = np.flatnonzero(a != -1).astype(int)\n    placed_locs = a[placed_fac].astype(int)\n\n    # Incremental cost matrix (facilities \u00d7 candidate locations)\n    inc_matrix = np.zeros((cand_fac.size, candidate_locs.size), dtype=float)\n    if placed_fac.size > 0:\n        flow_left = flow_matrix[cand_fac[:, None], placed_fac]          # (m, k)\n        dist_left = distance_matrix[candidate_locs[None, :], placed_locs]  # (1, k)\n        inc_matrix += np.sum(flow_left * dist_left, axis=1, keepdims=True)\n\n        flow_right = flow_matrix[placed_fac, cand_fac[:, None]]          # (k, m)\n        dist_right = distance_matrix[placed_locs[:, None], candidate_locs[None, :]]  # (k, 1)\n        inc_matrix += np.sum(flow_right * dist_right, axis=0, keepdims=True).T\n\n    # Deterministic noise for stable tie\u2011breaking\n    noise = 1e-8 * np.arange(cand_fac.size)[:, None]\n    inc_matrix += noise\n\n    # Pick the overall cheapest pair\n    best_idx = np.argmin(inc_matrix)\n    best_fac = int(cand_fac[best_idx // candidate_locs.size])\n    best_loc = int(candidate_locs[best_idx % candidate_locs.size])\n\n    out = a.copy()\n    out[best_fac] = best_loc\n    return out.tolist()\n\n",
  "least_constrained_location_first_aug_157": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Facilities still unplaced\n    free_fac = np.flatnonzero(a == -1).astype(int)\n    if free_fac.size == 0:\n        return a.tolist()\n\n    # Occupied locations\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    # Choose a location by weighted sum of distances to other free locations\n    if free_locs.size > 1:\n        D = distance_matrix[np.ix_(free_locs, free_locs)].astype(float)\n        weights = 1.0 / (np.arange(1, free_locs.size + 1) + 1e-12)\n        weighted_sum = np.sum(D * weights, axis=1)\n        loc = int(free_locs[np.argmin(weighted_sum)])\n    else:\n        loc = int(free_locs[0])\n\n    # Facilities already placed\n    placed_fac = np.flatnonzero(a != -1).astype(int)\n    placed_locs = a[placed_fac].astype(int)\n\n    # Incremental cost for each unplaced facility\n    if placed_fac.size == 0:\n        inc = np.zeros(free_fac.size)\n    else:\n        flow_part1 = flow_matrix[free_fac[:, None], placed_fac]   # (m, k)\n        dist_part1 = distance_matrix[loc, placed_locs]           # (k,)\n        inc1 = np.sum(flow_part1 * dist_part1, axis=1)\n\n        flow_part2 = flow_matrix[placed_fac, free_fac[:, None]]   # (k, m)\n        dist_part2 = distance_matrix[placed_locs[:, None], loc]   # (k,)\n        inc2 = np.sum(flow_part2 * dist_part2, axis=0)\n\n        inc = inc1 + inc2\n\n    # Softmin selection with a small temperature\n    alpha = 10.0\n    probs = np.exp(-alpha * inc)\n    probs /= np.clip(np.sum(probs), 1e-12, None)\n    chosen_idx = int(np.random.choice(free_fac.size, p=probs))\n    best_fac = int(free_fac[chosen_idx])\n\n    out = a.copy()\n    out[best_fac] = loc\n    return out.tolist()\n\n",
  "least_constrained_location_first_aug_158": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Unassigned facilities\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    # Used locations\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    # Pick the most central free location (minimal sum of distances to other free locations)\n    if free_locs.size > 1:\n        D = distance_matrix[np.ix_(free_locs, free_locs)].astype(float)\n        sum_dist = np.sum(D, axis=1)\n        loc = int(free_locs[np.argmin(sum_dist)])\n    else:\n        loc = int(free_locs[0])\n\n    # Facilities already placed\n    placed_fac = np.flatnonzero(a != -1).astype(int)\n    placed_locs = a[placed_fac].astype(int)\n\n    # Incremental cost for each unassigned facility\n    if placed_fac.size == 0:\n        inc_cost = np.zeros(unassigned.size)\n    else:\n        flow_left = flow_matrix[unassigned[:, None], placed_fac]          # (m, k)\n        dist_left = distance_matrix[loc, placed_locs]                    # (k,)\n        inc_left = np.sum(flow_left * dist_left, axis=1)\n\n        flow_right = flow_matrix[placed_fac, unassigned[:, None]]        # (k, m)\n        dist_right = distance_matrix[placed_locs[:, None], loc]          # (k,)\n        inc_right = np.sum(flow_right * dist_right, axis=0)\n\n        inc_cost = inc_left + inc_right\n\n    # Randomly pick among the top\u2011k cheapest facilities\n    top_k = 3\n    if inc_cost.size > top_k:\n        idx_top = np.argpartition(inc_cost, top_k - 1)[:top_k]\n    else:\n        idx_top = np.arange(inc_cost.size)\n\n    chosen = int(unassigned[np.random.choice(idx_top)])\n    out = a.copy()\n    out[chosen] = loc\n    return out.tolist()\n\n",
  "most_constrained_location_first_aug_159": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy selection that chooses the farthest free location and then the\n    facility that yields the smallest incremental cost.  Ties are broken\n    deterministically by adding a small noise proportional to the facility\n    index.\n    \"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # Find indices of unassigned facilities\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    # Determine used and free locations\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    # Pick the free location with the largest sum of distances\n    dist_sums = distance_matrix[free_locs].sum(axis=1)\n    l = free_locs[np.argmax(dist_sums)]\n\n    # Already placed facilities and their locations\n    placed_fac = np.flatnonzero(assign != -1).astype(int)\n    locs_of_placed = assign[placed_fac].astype(int)\n\n    # Compute incremental cost for each unassigned facility\n    best_inc = np.inf\n    best_fac = unassigned[0]\n    for f in unassigned:\n        inc = 0.0\n        if placed_fac.size > 0:\n            inc = float(\n                np.sum(flow_matrix[f, placed_fac] * distance_matrix[l, locs_of_placed] +\n                       flow_matrix[placed_fac, f] * distance_matrix[locs_of_placed, l])\n            )\n        # deterministic tie\u2011breaking noise\n        inc += 1e-6 * f\n        if inc < best_inc:\n            best_inc, best_fac = inc, f\n\n    out = assign.copy()\n    out[best_fac] = l\n    return out.tolist()\n\n",
  "most_constrained_location_first_aug_160": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Select the farthest free location and then pick a facility from the top\u2011k\n    lowest incremental costs uniformly at random.  A deterministic\n    random generator ensures reproducibility.\n    \"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    dist_sums = distance_matrix[free_locs].sum(axis=1)\n    l = free_locs[np.argmax(dist_sums)]\n\n    placed_fac = np.flatnonzero(assign != -1).astype(int)\n    locs_of_placed = assign[placed_fac].astype(int)\n\n    incs = np.empty(unassigned.size, dtype=float)\n    for idx, f in enumerate(unassigned):\n        incs[idx] = 0.0 if placed_fac.size == 0 else float(\n            np.sum(flow_matrix[f, placed_fac] * distance_matrix[l, locs_of_placed] +\n                   flow_matrix[placed_fac, f] * distance_matrix[locs_of_placed, l])\n        )\n\n    # Top\u2011k selection\n    top_k = 7\n    k = min(top_k, incs.size)\n    top_indices = np.argpartition(incs, k - 1)[:k]\n    rng = np.random.default_rng(0)\n    chosen_idx = rng.choice(top_indices)\n    chosen_fac = unassigned[chosen_idx]\n\n    out = assign.copy()\n    out[chosen_fac] = l\n    return out.tolist()\n\n",
  "most_constrained_location_first_aug_161": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Use a soft\u2011min selection: facilities with lower incremental cost receive\n    higher probability.  The temperature controls the sharpness; a small\n    epsilon prevents division by zero.\n    \"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    dist_sums = distance_matrix[free_locs].sum(axis=1)\n    l = free_locs[np.argmax(dist_sums)]\n\n    placed_fac = np.flatnonzero(assign != -1).astype(int)\n    locs_of_placed = assign[placed_fac].astype(int)\n\n    incs = np.empty(unassigned.size, dtype=float)\n    for idx, f in enumerate(unassigned):\n        incs[idx] = 0.0 if placed_fac.size == 0 else float(\n            np.sum(flow_matrix[f, placed_fac] * distance_matrix[l, locs_of_placed] +\n                   flow_matrix[placed_fac, f] * distance_matrix[locs_of_placed, l])\n        )\n\n    # Soft\u2011min probabilities\n    temp = 1.0\n    logits = -incs / (temp + 1e-12)\n    exp_logits = np.exp(logits - np.max(logits))  # stability\n    probs = exp_logits / (exp_logits.sum() + 1e-12)\n\n    rng = np.random.default_rng(0)\n    chosen_fac = unassigned[rng.choice(unassigned.size, p=probs)]\n\n    out = assign.copy()\n    out[chosen_fac] = l\n    return out.tolist()\n\n",
  "most_constrained_location_first_aug_162": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Approximate incremental cost using the mean distance and total flow.\n    The approximation reduces computation and uses np.clip to keep values\n    bounded.  Ties are resolved by adding a tiny deterministic noise.\n    \"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    dist_sums = distance_matrix[free_locs].sum(axis=1)\n    l = free_locs[np.argmax(dist_sums)]\n\n    placed_fac = np.flatnonzero(assign != -1).astype(int)\n    locs_of_placed = assign[placed_fac].astype(int)\n\n    # Proxy cost: mean distance * sum of flows\n    mean_dist = np.mean(distance_matrix[l, locs_of_placed]) if placed_fac.size > 0 else 0.0\n    proxy_costs = np.empty(unassigned.size, dtype=float)\n    for idx, f in enumerate(unassigned):\n        flow_sum = np.sum(flow_matrix[f, placed_fac]) if placed_fac.size > 0 else 0.0\n        proxy_costs[idx] = mean_dist * flow_sum + mean_dist * flow_sum  # symmetric part\n        proxy_costs[idx] = np.clip(proxy_costs[idx], 0.0, np.inf)\n\n    best_idx = np.argmin(proxy_costs)\n    # deterministic noise for ties\n    best_idx = np.argmin(proxy_costs + 1e-6 * np.arange(unassigned.size))\n    chosen_fac = unassigned[best_idx]\n\n    out = assign.copy()\n    out[chosen_fac] = l\n    return out.tolist()\n\n",
  "facility_similarity_bundle_aug_163": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 1 \u2013 heavy syntactic rewriting and vectorised logic.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # Candidates are indices where assignment is still -1\n    cand = [i for i, v in enumerate(assign) if v == -1]\n    if not cand:\n        return assign.tolist()\n\n    # Facilities already placed\n    placed = [i for i, v in enumerate(assign) if v != -1]\n    used_locs = np.zeros(n, dtype=bool)\n    if placed:\n        used_locs[assign[placed]] = True\n    free_locs = [i for i, v in enumerate(used_locs) if not v]\n\n    # Normalised flow matrix (symmetric)\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    norm_F = np.linalg.norm(F, axis=1, keepdims=True) + 1e-12\n    Fn = F / norm_F\n\n    if placed:\n        # Mean flow profile of already placed facilities\n        mu = np.mean(Fn[placed], axis=0)\n        mu /= np.linalg.norm(mu) + 1e-12\n        # Cosine similarity with unplaced facilities\n        sims = Fn[cand] @ mu\n        f = int(cand[int(np.argmax(sims))])\n    else:\n        # Pick facility with largest total flow\n        pf = F.sum(axis=1)\n        f = int(cand[int(np.argmax(pf[cand]))])\n\n    # Location selection\n    if placed:\n        locs = assign[placed].astype(int)\n        # Medoid of used locations\n        medoid_idx = int(np.argmin(distance_matrix[locs][:, locs].sum(axis=1)))\n        center = int(locs[medoid_idx])\n        l0 = int(free_locs[int(np.argmin(distance_matrix[free_locs, center]))])\n    else:\n        l0 = int(free_locs[int(np.argmin(distance_matrix[free_locs].sum(axis=1)))])\n\n    # Local refinement among nearest few\n    k = min(8, len(free_locs))\n    cand_locs = sorted(free_locs, key=lambda x: distance_matrix[x, l0])[:k]\n    best_inc = float('inf')\n    best_l = cand_locs[0]\n    for l in cand_locs:\n        if not placed:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_matrix[f, placed] * distance_matrix[l, locs] +\n                                 flow_matrix[placed, f] * distance_matrix[locs, l]))\n        if inc < best_inc:\n            best_inc = inc\n            best_l = l\n\n    out = assign.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "facility_similarity_bundle_aug_164": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 2 \u2013 parameter tuning with median aggregation and top\u2011k refinement.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # Identify unassigned facilities and free locations\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    placed = np.flatnonzero(assign != -1).astype(int)\n    used = np.zeros(n, dtype=bool)\n    if placed.size:\n        used[assign[placed]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # Symmetric flow matrix normalised row\u2011wise\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    norm_F = np.linalg.norm(F, axis=1, keepdims=True) + 1e-12\n    Fn = F / norm_F\n\n    if placed.size:\n        # Median instead of mean for robustness\n        mu = np.median(Fn[placed], axis=0)\n        mu /= np.linalg.norm(mu) + 1e-12\n        sims = Fn[unassigned] @ mu\n        f = int(unassigned[int(np.argmax(sims))])\n    else:\n        pf = F.sum(axis=1)\n        f = int(unassigned[int(np.argmax(pf[unassigned]))])\n\n    # Location selection with weighted distance cost\n    if placed.size:\n        locs = assign[placed].astype(int)\n        medoid_idx = int(np.argmin(distance_matrix[locs][:, locs].sum(axis=1)))\n        center = int(locs[medoid_idx])\n        l0 = int(free[int(np.argmin(distance_matrix[free, center]))])\n    else:\n        l0 = int(free[int(np.argmin(distance_matrix[free].sum(axis=1)))])\n\n    # Top\u2011k candidate refinement (k=7)\n    k = min(7, free.size)\n    cand = free[np.argsort(distance_matrix[free, l0])[:k]].astype(int)\n\n    best = float('inf')\n    best_l = int(cand[0])\n    for l in cand:\n        inc = 0.0 if not placed.size else float(\n            np.sum(flow_matrix[f, placed] * distance_matrix[l, locs] +\n                   flow_matrix[placed, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc\n            best_l = l\n\n    out = assign.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "facility_similarity_bundle_aug_165": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 3 \u2013 behavioral diversity: noise, random top\u2011k, softmin selection.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    placed = np.flatnonzero(assign != -1).astype(int)\n    used = np.zeros(n, dtype=bool)\n    if placed.size:\n        used[assign[placed]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # Symmetric flow matrix normalised\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    norm_F = np.linalg.norm(F, axis=1, keepdims=True) + 1e-12\n    Fn = F / norm_F\n\n    if placed.size:\n        mu = np.mean(Fn[placed], axis=0)\n        mu /= np.linalg.norm(mu) + 1e-12\n        sims = Fn[unassigned] @ mu\n        # Add deterministic noise for tie\u2011breaking\n        noise = np.arange(sims.size) * 1e-9\n        sims_noisy = sims + noise\n        # Random choice among top\u20113 similarities\n        top_k = 3\n        top_idx = np.argsort(-sims_noisy)[:top_k]\n        f = int(unassigned[np.random.choice(top_idx)])\n    else:\n        pf = F.sum(axis=1)\n        f = int(unassigned[int(np.argmax(pf[unassigned]))])\n\n    # Location selection using proxy distance (squared Euclidean)\n    if placed.size:\n        locs = assign[placed].astype(int)\n        medoid_idx = int(np.argmin(distance_matrix[locs][:, locs].sum(axis=1)))\n        center = int(locs[medoid_idx])\n        l0 = int(free[int(np.argmin(distance_matrix[free, center]))])\n    else:\n        l0 = int(free[int(np.argmin(distance_matrix[free].sum(axis=1)))])\n\n    # Softmin refinement over nearest 6 locations\n    k = min(6, free.size)\n    cand = free[np.argsort(distance_matrix[free, l0])[:k]].astype(int)\n    locs = assign[placed].astype(int)\n    incs = np.array([float(np.sum(flow_matrix[f, placed] * distance_matrix[l, locs] +\n                                 flow_matrix[placed, f] * distance_matrix[locs, l]))\n                     if placed.size else 0.0 for l in cand])\n    # Softmin weights\n    alpha = 0.5\n    weights = np.exp(-alpha * incs)\n    best_l = int(cand[np.argmax(weights)])\n\n    out = assign.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "facility_similarity_bundle_aug_166": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variant 4 \u2013 inverted conditionals and while loops, explicit clipping.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # Identify unassigned facilities\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    # Facilities already placed\n    placed = np.flatnonzero(assign != -1).astype(int)\n    used = np.zeros(n, dtype=bool)\n    if placed.size:\n        used[assign[placed]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # Normalised symmetric flow matrix\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    norm_F = np.linalg.norm(F, axis=1, keepdims=True) + 1e-12\n    Fn = F / norm_F\n\n    # Facility selection\n    if not placed.size:\n        pf = F.sum(axis=1)\n        f = int(unassigned[int(np.argmax(pf[unassigned]))])\n    else:\n        mu = np.mean(Fn[placed], axis=0)\n        mu /= np.linalg.norm(mu) + 1e-12\n        sims = Fn[unassigned] @ mu\n        f = int(unassigned[int(np.argmax(sims))])\n\n    # Location selection\n    if placed.size:\n        locs = assign[placed].astype(int)\n        # Medoid of used locations\n        medoid_idx = int(np.argmin(distance_matrix[locs][:, locs].sum(axis=1)))\n        center = int(locs[medoid_idx])\n        l0 = int(free[int(np.argmin(distance_matrix[free, center]))])\n    else:\n        l0 = int(free[int(np.argmin(distance_matrix[free].sum(axis=1)))])\n\n    # Local refinement via while loop\n    k = min(8, free.size)\n    cand_indices = np.argsort(distance_matrix[free, l0])[:k]\n    cand = free[cand_indices].astype(int)\n\n    best_inc = float('inf')\n    best_l = int(cand[0])\n    idx = 0\n    while idx < cand.size:\n        l = cand[idx]\n        if not placed.size:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_matrix[f, placed] * distance_matrix[l, locs] +\n                                 flow_matrix[placed, f] * distance_matrix[locs, l]))\n        if inc < best_inc:\n            best_inc = inc\n            best_l = l\n        idx += 1\n\n    out = assign.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "opportunity_cost_facility_choice_aug_167": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Weighted scoring with soft\u2011min location selection and random top\u2011k facility choice.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned_fac = np.flatnonzero(a == -1).astype(int)\n    if unassigned_fac.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    locs_assigned = a[assigned_fac]\n\n    def inc_costs(f: int) -> np.ndarray:\n        if assigned_fac.size == 0:\n            return np.zeros(free_locs.size, dtype=float)\n        return (flow_matrix[f, assigned_fac][:, None] *\n                distance_matrix[free_locs, locs_assigned] +\n                flow_matrix[assigned_fac, f][:, None] *\n                distance_matrix[locs_assigned, free_locs]).sum(axis=0)\n\n    # Compute a weighted score for each unassigned facility\n    scores = []\n    for f in unassigned_fac:\n        costs = inc_costs(f)\n        # 0.6*mean + 0.4*(max\u2011min) weighted score\n        score = 0.6 * np.mean(costs) + 0.4 * (np.max(costs) - np.min(costs))\n        # Normalise to [0,1]\n        score /= (np.max(costs) - np.min(costs) + 1e-12)\n        score = np.clip(score, 0, 1)\n        scores.append(score)\n    scores = np.array(scores)\n\n    # Randomly pick one facility among the top\u2011k scores\n    top_k = min(7, unassigned_fac.size)\n    top_indices = np.argsort(scores)[-top_k:]\n    chosen_idx = np.random.choice(top_indices)\n    chosen_f = unassigned_fac[chosen_idx]\n\n    # Soft\u2011min probability distribution over locations\n    costs = inc_costs(chosen_f)\n    probs = np.exp(-costs / (1.0 + 1e-12))          # soft\u2011min\n    probs /= probs.sum()\n    chosen_l = np.random.choice(free_locs, p=probs)\n\n    a[chosen_f] = chosen_l\n    return a.tolist()\n\n",
  "opportunity_cost_facility_choice_aug_168": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Median\u2011based scoring with random choice among top\u20113 cheapest locations.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned]\n\n    def inc_costs(f: int) -> np.ndarray:\n        if assigned.size == 0:\n            return np.zeros(free.size, dtype=float)\n        return (flow_matrix[f, assigned][:, None] *\n                distance_matrix[free, locs] +\n                flow_matrix[assigned, f][:, None] *\n                distance_matrix[locs, free]).sum(axis=0)\n\n    # Compute a median\u2011based score for each facility\n    scores = []\n    for f in unassigned:\n        costs = inc_costs(f)\n        score = np.median(costs) - np.min(costs) + 1e-12\n        score /= (np.max(costs) - np.min(costs) + 1e-12)\n        score = np.clip(score, 0, 1)\n        scores.append(score)\n    scores = np.array(scores)\n\n    # Randomly choose one of the top\u2011k facilities\n    top_k = min(5, unassigned.size)\n    top_indices = np.argsort(scores)[-top_k:]\n    chosen_f = unassigned[np.random.choice(top_indices)]\n\n    # Randomly pick among the three cheapest locations for that facility\n    costs = inc_costs(chosen_f)\n    top_locs = np.argsort(costs)[:3]\n    chosen_l = free[np.random.choice(top_locs)]\n\n    a[chosen_f] = chosen_l\n    return a.tolist()\n\n",
  "mean_plus_std_risk_averse_aug_169": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Risk\u2011averse greedy assignment using a while\u2011loop and vectorized mean/std.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.where(assign == -1)[0]\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    assigned = np.where(assign != -1)[0]\n    used = np.zeros(n, dtype=bool)\n    if assigned.size:\n        used[assign[assigned]] = True\n    free_nodes = np.where(~used)[0]\n    locs = assign[assigned]\n    dist_mat = distance_matrix\n\n    progress = 1.0 - (unassigned.size / float(max(1, n) + 1e-12))\n    k = np.clip(0.25 + 0.75 * progress, 0.0, 1.0)\n\n    best_score = np.inf\n    best_f = int(unassigned[0])\n    best_l = int(free_nodes[0])\n\n    f_idx = 0\n    while f_idx < unassigned.size:\n        f = int(unassigned[f_idx])\n        l_idx = 0\n        while l_idx < free_nodes.size:\n            l = int(free_nodes[l_idx])\n            if assigned.size == 0:\n                score = 0.0\n            else:\n                c = flow_matrix[f, assigned] * dist_mat[l, locs] + flow_matrix[assigned, f] * dist_mat[locs, l]\n                score = float(c.mean() + k * c.std())\n            if score < best_score:\n                best_score = score\n                best_f = f\n                best_l = l\n            l_idx += 1\n        f_idx += 1\n\n    result = assign.copy()\n    result[best_f] = best_l\n    return result.tolist()\n\n",
  "mean_plus_std_risk_averse_aug_170": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Weighted mean/std scoring with deterministic noise and random top\u20115 selection.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.where(assign == -1)[0]\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    assigned = np.where(assign != -1)[0]\n    used = np.zeros(n, dtype=bool)\n    used[assign[assigned]] = True\n    free_nodes = np.where(~used)[0]\n    locs = assign[assigned]\n\n    progress = 1.0 - (unassigned.size / float(max(1, n) + 1e-12))\n    k = np.clip(0.25 + 0.75 * progress, 0.0, 1.0)\n\n    scores = []\n    for f in unassigned:\n        for l in free_nodes:\n            if assigned.size == 0:\n                s = 0.0\n            else:\n                c = flow_matrix[f, assigned] * distance_matrix[l, locs] + flow_matrix[assigned, f] * distance_matrix[locs, l]\n                s = float(0.6 * c.mean() + 0.4 * c.std())\n            s += 1e-6 * (f + l)  # deterministic tie\u2011breaker\n            scores.append((s, f, l))\n\n    scores_arr = np.array(scores)\n    scores_arr = scores_arr[scores_arr[:,0].argsort()]\n    top_k = min(5, scores_arr.shape[0])\n    top_arr = scores_arr[:top_k]\n    idx = np.random.randint(0, top_k)\n    best_f, best_l = int(top_arr[idx,1]), int(top_arr[idx,2])\n\n    result = assign.copy()\n    result[best_f] = best_l\n    return result.tolist()\n\n",
  "mean_plus_std_risk_averse_aug_171": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Median/max aggregation with soft\u2011min sampling.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.where(assign == -1)[0]\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    assigned = np.where(assign != -1)[0]\n    used = np.zeros(n, dtype=bool)\n    used[assign[assigned]] = True\n    free_nodes = np.where(~used)[0]\n    locs = assign[assigned]\n\n    progress = 1.0 - (unassigned.size / float(max(1, n) + 1e-12))\n    k = np.clip(0.25 + 0.75 * progress, 0.0, 1.0)\n\n    scores = []\n    for f in unassigned:\n        for l in free_nodes:\n            if assigned.size == 0:\n                s = 0.0\n            else:\n                c = flow_matrix[f, assigned] * distance_matrix[l, locs] + flow_matrix[assigned, f] * distance_matrix[locs, l]\n                s = float(np.median(c) + k * np.max(c))\n            scores.append((s, f, l))\n\n    scores_arr = np.array(scores)\n    vals = scores_arr[:,0]\n    tau = 1.0\n    min_val = vals.min()\n    exp_vals = np.exp(-(vals - min_val) / (tau + 1e-12))\n    probs = exp_vals / exp_vals.sum()\n    idx = np.random.choice(len(scores), p=probs)\n    best_f, best_l = int(scores_arr[idx,1]), int(scores_arr[idx,2])\n\n    result = assign.copy()\n    result[best_f] = best_l\n    return result.tolist()\n\n",
  "mean_plus_std_risk_averse_aug_172": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorized sum/max aggregation with random selection among top\u20113.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.where(assign == -1)[0]\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    assigned = np.where(assign != -1)[0]\n    used = np.zeros(n, dtype=bool)\n    used[assign[assigned]] = True\n    free_nodes = np.where(~used)[0]\n    locs = assign[assigned]\n\n    progress = 1.0 - (unassigned.size / float(max(1, n) + 1e-12))\n    k = np.clip(0.25 + 0.75 * progress, 0.0, 1.0)\n\n    scores = []\n    for f in unassigned:\n        if assigned.size == 0:\n            arr = np.zeros(free_nodes.size)\n        else:\n            c1 = flow_matrix[f, assigned][:, None] * distance_matrix[free_nodes[:, None], locs]\n            c2 = flow_matrix[assigned, f][:, None] * distance_matrix[locs[:, None], free_nodes]\n            c_total = c1 + c2\n            agg = np.sum(c_total, axis=0) + k * np.max(c_total, axis=0)\n            arr = agg\n        for idx, l in enumerate(free_nodes):\n            scores.append((float(arr[idx]), f, l))\n\n    scores_arr = np.array(scores)\n    top_k = min(3, scores_arr.shape[0])\n    top_indices = np.argpartition(scores_arr[:,0], top_k-1)[:top_k]\n    idx = np.random.choice(top_indices)\n    best_f, best_l = int(scores_arr[idx,1]), int(scores_arr[idx,2])\n\n    result = assign.copy()\n    result[best_f] = best_l\n    return result.tolist()\n\n",
  "min_inc_with_soft_conflicts_aug_173": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 1 \u2013 Uses while loops, variable renaming, deterministic noise and\n    np.square for squaring operations.  The core logic remains unchanged.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Candidate facilities and free locations\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if assigned.size:\n        used[a[assigned]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    locs = a[assigned].astype(int)\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    best_score = float('inf')\n    best_f = int(candidates[0])\n    best_l = int(free_locs[0])\n\n    i = 0\n    while i < candidates.size:\n        f = int(candidates[i])\n        if assigned.size:\n            w = sym[f, assigned].astype(float)\n            wsum = float(w.sum())\n        else:\n            w = None\n            wsum = 1.0\n\n        j = 0\n        while j < free_locs.size:\n            l = int(free_locs[j])\n\n            inc = 0.0 if assigned.size == 0 else float(\n                np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                       flow_matrix[assigned, f] * distance_matrix[locs, l]))\n\n            if assigned.size == 0:\n                penalty = 0.0\n            else:\n                d = distance_matrix[l, locs].astype(float)\n                d_norm = (d - d.mean()) / (d.std() + 1e-12)\n                w_norm = (w - w.mean()) / (w.std() + 1e-12)\n                penalty = float(np.sum((d_norm - (-w_norm)) ** 2) /\n                                (assigned.size + 1e-12))\n\n            score = inc + 0.05 * penalty * (abs(inc) + 1.0)\n\n            # Deterministic tie\u2011breaker\n            score += 1e-6 * (f + l)\n\n            if score < best_score:\n                best_score = score\n                best_f = f\n                best_l = l\n\n            j += 1\n        i += 1\n\n    out = a.copy()\n    out[int(best_f)] = int(best_l)\n    return out.tolist()\n\n",
  "min_inc_with_soft_conflicts_aug_174": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 2 \u2013 Fully vectorised scoring with a random choice among the top\u2011k\n    best facility\u2011location pairs.  Weight factor is increased to 0.08.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if assigned.size:\n        used[a[assigned]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    locs = a[assigned].astype(int)\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    best_f = int(candidates[0])\n    best_l = int(free_locs[0])\n\n    # Vectorised computation of inc and penalty for each candidate\u2011location pair\n    inc_matrix = np.zeros((candidates.size, free_locs.size), dtype=float)\n    penalty_matrix = np.zeros_like(inc_matrix)\n\n    for idx_f, f in enumerate(candidates):\n        if assigned.size:\n            w = sym[f, assigned].astype(float)\n            d_mat = distance_matrix[free_locs[:, None], locs]  # shape (len(free), len(assigned))\n            inc_matrix[idx_f] = np.sum(\n                flow_matrix[f, assigned] * d_mat +\n                flow_matrix[assigned, f] * d_mat.T,\n                axis=1\n            )\n            d_norm = (d_mat - d_mat.mean(axis=1, keepdims=True)) / (\n                d_mat.std(axis=1, keepdims=True) + 1e-12\n            )\n            w_norm = (w - w.mean()) / (w.std() + 1e-12)\n            penalty_matrix[idx_f] = np.sum((d_norm - (-w_norm)) ** 2, axis=1) / (\n                assigned.size + 1e-12\n            )\n        else:\n            inc_matrix[idx_f] = 0.0\n            penalty_matrix[idx_f] = 0.0\n\n    score_matrix = inc_matrix + 0.08 * penalty_matrix * (np.abs(inc_matrix) + 1.0)\n\n    # Flatten and pick a random one among the top\u2011k smallest scores\n    flat_scores = score_matrix.ravel()\n    top_k = 5\n    top_indices = np.argpartition(flat_scores, top_k)[:top_k]\n    chosen = np.random.choice(top_indices)\n\n    best_f = int(candidates[chosen // free_locs.size])\n    best_l = int(free_locs[chosen % free_locs.size])\n\n    out = a.copy()\n    out[int(best_f)] = int(best_l)\n    return out.tolist()\n\n",
  "min_inc_with_soft_conflicts_aug_175": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 3 \u2013 Uses median\u2011based normalisation, np.max aggregation, and a\n    random pick from the top\u2011k candidates.  Penalty weight set to 0.10.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if assigned.size:\n        used[a[assigned]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    locs = a[assigned].astype(int)\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    best_f = int(candidates[0])\n    best_l = int(free_locs[0])\n\n    inc_matrix = np.zeros((candidates.size, free_locs.size), dtype=float)\n    penalty_matrix = np.zeros_like(inc_matrix)\n\n    for idx_f, f in enumerate(candidates):\n        if assigned.size:\n            w = sym[f, assigned].astype(float)\n            d_mat = distance_matrix[free_locs[:, None], locs]\n            inc_matrix[idx_f] = np.sum(\n                flow_matrix[f, assigned] * d_mat +\n                flow_matrix[assigned, f] * d_mat.T,\n                axis=1\n            )\n            # Median\u2011based normalisation\n            d_med = np.median(d_mat, axis=1, keepdims=True)\n            d_scale = np.median(np.abs(d_mat - d_med), axis=1, keepdims=True) + 1e-12\n            d_norm = (d_mat - d_med) / d_scale\n\n            w_med = np.median(w)\n            w_scale = np.median(np.abs(w - w_med)) + 1e-12\n            w_norm = (w - w_med) / w_scale\n\n            penalty_matrix[idx_f] = np.max((d_norm + w_norm) ** 2, axis=1) / (\n                assigned.size + 1e-12\n            )\n        else:\n            inc_matrix[idx_f] = 0.0\n            penalty_matrix[idx_f] = 0.0\n\n    score_matrix = inc_matrix + 0.10 * penalty_matrix * (np.abs(inc_matrix) + 1.0)\n\n    # Randomly pick from the best five pairs\n    flat_scores = score_matrix.ravel()\n    top_k = 5\n    top_indices = np.argpartition(flat_scores, top_k)[:top_k]\n    chosen = np.random.choice(top_indices)\n\n    best_f = int(candidates[chosen // free_locs.size])\n    best_l = int(free_locs[chosen % free_locs.size])\n\n    out = a.copy()\n    out[int(best_f)] = int(best_l)\n    return out.tolist()\n\n",
  "min_inc_with_soft_conflicts_aug_176": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 4 \u2013 Uses a proxy approximation for interaction cost and penalty.\n    The penalty is clipped to [0, 1] and a lighter weight (0.07) is applied.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if assigned.size:\n        used[a[assigned]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    locs = a[assigned].astype(int)\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    best_f = int(candidates[0])\n    best_l = int(free_locs[0])\n\n    inc_matrix = np.zeros((candidates.size, free_locs.size), dtype=float)\n    penalty_matrix = np.zeros_like(inc_matrix)\n\n    for idx_f, f in enumerate(candidates):\n        if assigned.size:\n            # Approximate interaction cost by average distance\n            avg_l_dist = np.mean(distance_matrix[free_locs[:, None], locs], axis=1)\n            inc_matrix[idx_f] = (\n                np.sum(flow_matrix[f, assigned]) * avg_l_dist +\n                np.sum(flow_matrix[assigned, f]) * avg_l_dist\n            )\n            # Simple penalty based on distance profile\n            d_mat = distance_matrix[free_locs[:, None], locs]\n            w = sym[f, assigned].astype(float)\n            d_norm = (d_mat - d_mat.mean()) / (d_mat.std() + 1e-12)\n            w_norm = (w - w.mean()) / (w.std() + 1e-12)\n            penalty_matrix[idx_f] = np.sum((d_norm + w_norm) ** 2, axis=1) / (\n                assigned.size + 1e-12\n            )\n        else:\n            inc_matrix[idx_f] = 0.0\n            penalty_matrix[idx_f] = 0.0\n\n    penalty_matrix = np.clip(penalty_matrix, 0.0, 1.0)  # bound penalty\n    score_matrix = inc_matrix + 0.07 * penalty_matrix * (np.abs(inc_matrix) + 1.0)\n\n    # Choose the best pair deterministically (no randomness)\n    flat_scores = score_matrix.ravel()\n    chosen = np.argmin(flat_scores)\n\n    best_f = int(candidates[chosen // free_locs.size])\n    best_l = int(free_locs[chosen % free_locs.size])\n\n    out = a.copy()\n    out[int(best_f)] = int(best_l)\n    return out.tolist()\n\n",
  "short_horizon_rollout_sample_aug_177": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 1 \u2013 vectorized cost evaluation with soft\u2011min selection.\n    \"\"\"\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n\n    # Indices of unassigned facilities and free locations\n    un0 = np.flatnonzero(a0 == -1).astype(int)\n    if un0.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a0 != -1):\n        used[a0[a0 != -1]] = True\n    free0 = np.flatnonzero(~used).astype(int)\n\n    # Current assignments\n    ass0 = np.flatnonzero(a0 != -1).astype(int)\n    locs0 = a0[ass0].astype(int)\n\n    # Broadcast to compute incremental costs for all candidate pairs\n    if ass0.size == 0:\n        inc_costs = np.zeros((un0.size, free0.size), dtype=float)\n    else:\n        f_mat = flow_matrix[np.ix_(un0, ass0)]          # shape (un, ass)\n        l_mat = distance_matrix[np.ix_(free0, locs0)]   # shape (free, locs)\n        inc_costs = f_mat @ l_mat + f_mat.T @ l_mat.T   # shape (un, free)\n\n    # Flatten pair list and costs\n    pairs = [(int(f), int(l)) for f in un0 for l in free0]\n    costs = inc_costs.ravel()\n\n    # Soft\u2011min weighting\n    beta = 10.0\n    weights = np.exp(-beta * costs)\n    weights /= (np.sum(weights) + 1e-12)  # epsilon to avoid div\u2011by\u2011zero\n\n    # Select top_k candidates (deterministic tie\u2011breaking by index)\n    top_k = min(7, max(3, int(0.10 * len(pairs))))\n    top_idx = np.argsort(costs)[:top_k]\n    top_weights = weights[top_idx]\n    top_weights /= (np.sum(top_weights) + 1e-12)\n\n    # Random\u2011like choice using weighted probabilities (deterministic via seed)\n    rng = np.random.default_rng(seed=42)\n    chosen_idx = rng.choice(top_idx, p=top_weights)\n    f_ch, l_ch = pairs[chosen_idx]\n\n    # Apply chosen assignment\n    out = a0.copy()\n    out[f_ch] = l_ch\n    return out.tolist()\n\n",
  "short_horizon_rollout_sample_aug_178": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 2 \u2013 list\u2011comprehension based pair generation and median aggregation.\n    \"\"\"\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n\n    un0 = np.flatnonzero(a0 == -1).astype(int)\n    if un0.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a0 != -1):\n        used[a0[a0 != -1]] = True\n    free0 = np.flatnonzero(~used).astype(int)\n\n    ass0 = np.flatnonzero(a0 != -1).astype(int)\n    locs0 = a0[ass0].astype(int)\n\n    # Variable renaming\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    # Generate all candidate pairs via list comprehension\n    pairs = [(int(f), int(l)) for f in un0 for l in free0]\n    inc_costs = []\n    for f, l in pairs:\n        if ass0.size == 0:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_mat[f, ass0] * dist_mat[l, locs0] +\n                               flow_mat[ass0, f] * dist_mat[locs0, l]))\n        inc_costs.append(inc)\n    costs = np.array(inc_costs, dtype=float)\n\n    # Median aggregation for selecting candidate group\n    top_k = min(8, max(4, int(0.12 * len(pairs))))\n    median_val = np.median(costs)\n    # Add deterministic noise to break ties\n    noise = np.arange(len(costs)) * 1e-6\n    sorted_idx = np.argsort(costs + noise)\n    cand_idx = sorted_idx[:top_k]\n\n    # Random choice among top_k using a fixed seed for determinism\n    rng = np.random.default_rng(seed=123)\n    chosen = rng.choice(cand_idx)\n    f_ch, l_ch = pairs[chosen]\n\n    # Update assignment\n    out = a0.copy()\n    out[f_ch] = l_ch\n    return out.tolist()\n\n",
  "short_horizon_rollout_sample_aug_179": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 3 \u2013 while\u2011loop control flow, max aggregation, and soft\u2011max sampling.\n    \"\"\"\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n\n    un0 = np.flatnonzero(a0 == -1).astype(int)\n    if un0.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a0 != -1):\n        used[a0[a0 != -1]] = True\n    free0 = np.flatnonzero(~used).astype(int)\n\n    ass0 = np.flatnonzero(a0 != -1).astype(int)\n    locs0 = a0[ass0].astype(int)\n\n    pairs = []\n    costs = []\n\n    i = 0\n    while i < un0.size:\n        f = int(un0[i])\n        j = 0\n        while j < free0.size:\n            l = int(free0[j])\n            if ass0.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass0] * distance_matrix[l, locs0] +\n                                   flow_matrix[ass0, f] * distance_matrix[locs0, l]))\n            pairs.append((f, l))\n            costs.append(inc)\n            j += 1\n        i += 1\n\n    costs = np.array(costs, dtype=float)\n    top_k = min(5, max(3, int(0.08 * len(pairs))))\n\n    # Soft\u2011max sampling (deterministic via seed)\n    beta = 8.0\n    logits = -beta * costs\n    max_logit = np.max(logits)\n    exp_vals = np.exp(logits - max_logit)  # stable\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # Choose top_k indices\n    cand_idx = np.argsort(probs)[-top_k:]\n    # Randomly pick one among them using deterministic seed\n    rng = np.random.default_rng(seed=7)\n    chosen = rng.choice(cand_idx)\n    f_ch, l_ch = pairs[chosen]\n\n    out = a0.copy()\n    out[f_ch] = l_ch\n    return out.tolist()\n\n",
  "short_horizon_rollout_sample_aug_180": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 4 \u2013 while\u2011loops, mean aggregation, deterministic noise, and clipping.\n    \"\"\"\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n\n    un0 = np.flatnonzero(a0 == -1).astype(int)\n    if un0.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a0 != -1):\n        used[a0[a0 != -1]] = True\n    free0 = np.flatnonzero(~used).astype(int)\n\n    ass0 = np.flatnonzero(a0 != -1).astype(int)\n    locs0 = a0[ass0].astype(int)\n\n    pairs = []\n    costs = []\n\n    i = 0\n    while i < un0.size:\n        f = int(un0[i])\n        j = 0\n        while j < free0.size:\n            l = int(free0[j])\n            if ass0.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass0] * distance_matrix[l, locs0] +\n                                   flow_matrix[ass0, f] * distance_matrix[locs0, l]))\n            pairs.append((f, l))\n            costs.append(inc)\n            j += 1\n        i += 1\n\n    costs = np.array(costs, dtype=float)\n    top_k = min(10, max(6, int(0.15 * len(pairs))))\n\n    # Mean aggregation for ranking\n    mean_val = np.mean(costs)\n    # Add deterministic noise (index scaled) before sorting\n    noise = np.arange(len(costs)) * 1e-7\n    sorted_idx = np.argsort(costs + noise)\n    cand_idx = sorted_idx[:top_k]\n\n    # Deterministic tie\u2011breaking: choose the one with smallest index\n    chosen = cand_idx[0]\n    f_ch, l_ch = pairs[chosen]\n\n    # Ensure the selected location is within bounds using np.clip\n    l_ch = int(np.clip(l_ch, 0, n - 1))\n\n    out = a0.copy()\n    out[f_ch] = l_ch\n    return out.tolist()\n\n",
  "beam_search_width3_one_step_aug_181": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Beam\u2011search variant that vectorises cost evaluation and uses\n    np.argpartition for the top\u2011K seeding step.  Variable names are\n    renamed for readability, and costs are clipped to avoid extreme\n    values.\n    \"\"\"\n    a0 = np.asarray(current_assignment, dtype=int)\n    n  = a0.size\n\n    # Positions that are still unassigned\n    unassigned = np.flatnonzero(a0 == -1).astype(int)\n    if unassigned.size == 0:\n        return a0.tolist()\n\n    # Helper to compute incremental cost for one move\n    def inc_pair(a: np.ndarray, f: int, l: int) -> float:\n        ass = np.flatnonzero(a != -1).astype(int)\n        if ass.size == 0:\n            return 0.0\n        locs = a[ass].astype(int)\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # Current used facilities\n    used = np.zeros(n, dtype=bool)\n    used[a0[a0 != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # Enumerate all candidate moves\n    moves = [(f, l) for f in unassigned for l in free]\n    costs = np.array([inc_pair(a0, f, l) for f, l in moves], dtype=float)\n\n    # Clip costs and add tiny epsilon to avoid exact ties\n    costs = np.clip(costs, 0, 1e6) + 1e-12\n\n    # Seed beam with the best K moves (vectorised selection)\n    K = min(12, len(costs))\n    seed_idx = np.argpartition(costs, K)[:K]\n    B = 3\n    beam = [(costs[i], a0.copy(), moves[i]) for i in seed_idx]\n    beam.sort(key=lambda x: x[0])\n    beam = beam[:B]\n\n    # Expand one additional layer for each beam element\n    new_beam = []\n    for base_cost, a, first_move in beam:\n        un = np.flatnonzero(a == -1).astype(int)\n        if un.size == 0:\n            new_beam.append((base_cost, a, first_move))\n            continue\n        used = np.zeros(n, dtype=bool)\n        used[a[a != -1]] = True\n        free = np.flatnonzero(~used).astype(int)\n        for f2 in un:\n            for l2 in free:\n                c = inc_pair(a, f2, l2)\n                b = a.copy()\n                b[f2] = l2\n                new_beam.append((base_cost + c, b, first_move))\n\n    new_beam.sort(key=lambda x: x[0])\n    best_first = new_beam[0][2]\n\n    # Apply the chosen first move to the original assignment\n    out = a0.copy()\n    out[best_first[0]] = best_first[1]\n    return out.tolist()\n\n",
  "beam_search_width3_one_step_aug_182": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant that introduces deterministic tie\u2011breaking noise and\n    selects a random move among the top\u2011k candidates.  The noise\n    ensures reproducible ordering when costs are equal.\n    \"\"\"\n    a0 = np.asarray(current_assignment, dtype=int)\n    n  = a0.size\n\n    unassigned = np.flatnonzero(a0 == -1).astype(int)\n    if unassigned.size == 0:\n        return a0.tolist()\n\n    def inc_pair(a: np.ndarray, f: int, l: int) -> float:\n        ass = np.flatnonzero(a != -1).astype(int)\n        if ass.size == 0:\n            return 0.0\n        locs = a[ass].astype(int)\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    used = np.zeros(n, dtype=bool)\n    used[a0[a0 != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    moves = [(f, l) for f in unassigned for l in free]\n    costs = np.array([inc_pair(a0, f, l) for f, l in moves], dtype=float)\n\n    # Add deterministic noise: each move gets a tiny unique offset\n    noise = np.arange(len(costs)) * 1e-9\n    costs += noise\n    costs = np.clip(costs, 0, 1e6)\n\n    # Seed beam with top K moves\n    K = min(12, len(costs))\n    top_idx = np.argpartition(costs, K)[:K]\n    B = 3\n    beam = [(costs[i], a0.copy(), moves[i]) for i in top_idx]\n    beam.sort(key=lambda x: x[0])\n    beam = beam[:B]\n\n    # Expand one more layer\n    new_beam = []\n    for base_cost, a, first_move in beam:\n        un = np.flatnonzero(a == -1).astype(int)\n        if un.size == 0:\n            new_beam.append((base_cost, a, first_move))\n            continue\n        used = np.zeros(n, dtype=bool)\n        used[a[a != -1]] = True\n        free = np.flatnonzero(~used).astype(int)\n        for f2 in un:\n            for l2 in free:\n                c = inc_pair(a, f2, l2)\n                b = a.copy()\n                b[f2] = l2\n                new_beam.append((base_cost + c, b, first_move))\n\n    new_beam.sort(key=lambda x: x[0])\n\n    # Randomly pick among the top\u2011k of the expanded beam\n    rng = np.random.default_rng(42)\n    top_k = min(5, len(new_beam))\n    chosen_idx = rng.choice(np.arange(top_k))\n    best_first = new_beam[chosen_idx][2]\n\n    out = a0.copy()\n    out[best_first[0]] = best_first[1]\n    return out.tolist()\n\n",
  "beam_search_width3_one_step_aug_183": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Soft\u2011min based selection: costs are transformed into probabilities\n    using a temperature\u2011scaled softmax.  The first move is sampled\n    according to these probabilities.  An approximate cost that uses\n    the maximum instead of the sum is employed for speed.\n    \"\"\"\n    a0 = np.asarray(current_assignment, dtype=int)\n    n  = a0.size\n\n    unassigned = np.flatnonzero(a0 == -1).astype(int)\n    if unassigned.size == 0:\n        return a0.tolist()\n\n    def inc_pair_max(a: np.ndarray, f: int, l: int) -> float:\n        ass = np.flatnonzero(a != -1).astype(int)\n        if ass.size == 0:\n            return 0.0\n        locs = a[ass].astype(int)\n        return float(np.max(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    used = np.zeros(n, dtype=bool)\n    used[a0[a0 != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    moves = [(f, l) for f in unassigned for l in free]\n    costs = np.array([inc_pair_max(a0, f, l) for f, l in moves], dtype=float)\n\n    # Soft\u2011min probabilities\n    temperature = 0.5\n    logits = -costs / (temperature + 1e-12)\n    exp_logits = np.exp(logits - np.max(logits))  # stability\n    probs = exp_logits / (np.sum(exp_logits) + 1e-12)\n\n    # Sample first move according to softmin\n    rng = np.random.default_rng(123)\n    chosen_idx = rng.choice(len(moves), p=probs)\n    first_move = moves[chosen_idx]\n\n    # Apply the chosen move\n    out = a0.copy()\n    out[first_move[0]] = first_move[1]\n    return out.tolist()\n\n",
  "beam_search_width3_one_step_aug_184": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Fully list\u2011comprehension based implementation.  Variable names\n    are shortened, and np.clip is used to keep costs within a sane\n    range.  The beam is expanded with a while\u2011loop for clarity.\n    \"\"\"\n    a0 = np.asarray(current_assignment, dtype=int)\n    n  = a0.size\n\n    unassigned = np.flatnonzero(a0 == -1).astype(int)\n    if unassigned.size == 0:\n        return a0.tolist()\n\n    def inc_pair(a: np.ndarray, f: int, l: int) -> float:\n        ass = np.flatnonzero(a != -1).astype(int)\n        if ass.size == 0:\n            return 0.0\n        locs = a[ass].astype(int)\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    used = np.zeros(n, dtype=bool)\n    used[a0[a0 != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    moves = [(f, l) for f in unassigned for l in free]\n    costs = np.array([inc_pair(a0, f, l) for f, l in moves], dtype=float)\n    costs = np.clip(costs, 0, 1e6)\n\n    K = min(12, len(costs))\n    seed_idx = np.argpartition(costs, K)[:K]\n    B = 3\n    beam = [(costs[i], a0.copy(), moves[i]) for i in seed_idx]\n    beam.sort(key=lambda x: x[0])\n    beam = beam[:B]\n\n    new_beam = []\n    while beam:\n        base_cost, a, first_move = beam.pop(0)\n        un = np.flatnonzero(a == -1).astype(int)\n        if un.size == 0:\n            new_beam.append((base_cost, a, first_move))\n            continue\n        used = np.zeros(n, dtype=bool)\n        used[a[a != -1]] = True\n        free = np.flatnonzero(~used).astype(int)\n        for f2 in un:\n            for l2 in free:\n                c = inc_pair(a, f2, l2)\n                b = a.copy()\n                b[f2] = l2\n                new_beam.append((base_cost + c, b, first_move))\n\n    new_beam.sort(key=lambda x: x[0])\n    best_first = new_beam[0][2]\n\n    out = a0.copy()\n    out[best_first[0]] = best_first[1]\n    return out.tolist()\n\n",
  "cross_entropy_pair_selection_aug_185": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # identify unassigned facilities and unused locations\n    unvisited = np.flatnonzero(a == -1).astype(int)\n    if unvisited.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free_nodes = np.flatnonzero(~used).astype(int)\n\n    # current assignments\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # vectorised construction of all possible pairs\n    f_list = np.repeat(unvisited, free_nodes.size)\n    l_list = np.tile(free_nodes, unvisited.size)\n    m = f_list.size\n\n    # base cost for each candidate pair (negative incremental cost)\n    if assigned.size == 0:\n        base = np.zeros(m, dtype=float)\n    else:\n        flow_f_ass = flow_matrix[f_list[:, None], assigned]\n        dist_l_locs = distance_matrix[l_list[:, None], locs]\n        flow_ass_f = flow_matrix[assigned[:, None], f_list]\n        dist_locs_l = distance_matrix[locs[:, None], l_list]\n        base = -np.sum(flow_f_ass * dist_l_locs + flow_ass_f * dist_locs_l, axis=1)\n\n    # normalise logits\n    logits = (base - np.mean(base)) / (np.std(base) + 1e-12)\n\n    # sample candidates according to current logits\n    S = min(200, max(40, 3 * m))\n    probs = np.exp(logits - np.max(logits))\n    probs = probs / (probs.sum() + 1e-12)\n    samp = np.random.choice(m, size=S, replace=True, p=probs)\n\n    # evaluate sampled costs\n    if assigned.size == 0:\n        costs = np.zeros(S, dtype=float)\n    else:\n        f_s = f_list[samp]\n        l_s = l_list[samp]\n        flow_f_ass_s = flow_matrix[f_s[:, None], assigned]\n        dist_l_locs_s = distance_matrix[l_s[:, None], locs]\n        flow_ass_f_s = flow_matrix[assigned[:, None], f_s]\n        dist_locs_l_s = distance_matrix[locs[:, None], l_s]\n        costs = np.sum(flow_f_ass_s * dist_l_locs_s + flow_ass_f_s * dist_locs_l_s, axis=1)\n\n    # elite set\n    elite_frac = 0.15\n    E = max(5, int(elite_frac * S))\n    elite_idx = samp[np.argsort(costs)[:E]]\n\n    # update logits toward elite samples\n    alpha = 0.6\n    counts = np.bincount(elite_idx, minlength=m).astype(float)\n    counts = counts / (counts.sum() + 1e-12)\n    logits = (1 - alpha) * logits + alpha * (np.log(counts + 1e-12) - np.log(1.0 / m))\n\n    # pick the MAP candidate\n    pick = int(np.argmax(logits))\n    f, l = f_list[pick], l_list[pick]\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "cross_entropy_pair_selection_aug_186": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    arr = np.asarray(current_assignment, dtype=int)\n    n = arr.size\n\n    # unassigned facilities and free locations\n    un = np.flatnonzero(arr == -1).astype(int)\n    if un.size == 0:\n        return arr.tolist()\n    used = np.zeros(n, dtype=bool)\n    if np.any(arr != -1):\n        used[arr[arr != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # existing assignments\n    ass = np.flatnonzero(arr != -1).astype(int)\n    locs = arr[ass].astype(int)\n\n    # pair arrays\n    f_arr = np.repeat(un, free.size)\n    l_arr = np.tile(free, un.size)\n    m = f_arr.size\n\n    # base cost\n    if ass.size == 0:\n        base = np.zeros(m, dtype=float)\n    else:\n        flow_f_ass = flow_matrix[f_arr[:, None], ass]\n        dist_l_locs = distance_matrix[l_arr[:, None], locs]\n        flow_ass_f = flow_matrix[ass[:, None], f_arr]\n        dist_locs_l = distance_matrix[locs[:, None], l_arr]\n        base = -np.sum(flow_f_ass * dist_l_locs + flow_ass_f * dist_locs_l, axis=1)\n\n    # use median for normalisation\n    logits = (base - np.median(base)) / (np.std(base) + 1e-12)\n\n    # deterministic tie\u2011breaking noise\n    noise = np.random.uniform(-1e-6, 1e-6, size=m)\n    logits += noise\n\n    # sampling\n    S = min(150, max(30, 2 * m))\n    probs = np.exp(logits - np.max(logits))\n    probs = probs / (probs.sum() + 1e-12)\n    samp = np.random.choice(m, size=S, replace=True, p=probs)\n\n    # evaluate sampled costs\n    if ass.size == 0:\n        costs = np.zeros(S, dtype=float)\n    else:\n        f_s = f_arr[samp]\n        l_s = l_arr[samp]\n        flow_f_ass_s = flow_matrix[f_s[:, None], ass]\n        dist_l_locs_s = distance_matrix[l_s[:, None], locs]\n        flow_ass_f_s = flow_matrix[ass[:, None], f_s]\n        dist_locs_l_s = distance_matrix[locs[:, None], l_s]\n        costs = np.sum(flow_f_ass_s * dist_l_locs_s + flow_ass_f_s * dist_locs_l_s, axis=1)\n\n    # elite set\n    elite_frac = 0.20\n    E = max(7, int(elite_frac * S))\n    elite_idx = samp[np.argsort(costs)[:E]]\n\n    # update logits\n    alpha = 0.5\n    counts = np.bincount(elite_idx, minlength=m).astype(float)\n    counts = counts / (counts.sum() + 1e-12)\n    logits = (1 - alpha) * logits + alpha * (np.log(counts + 1e-12) - np.log(1.0 / m))\n\n    # softmin selection\n    beta = 5.0\n    soft_probs = np.exp(-beta * logits)\n    soft_probs = soft_probs / (soft_probs.sum() + 1e-12)\n    pick = int(np.random.choice(m, p=soft_probs))\n    f, l = f_arr[pick], l_arr[pick]\n\n    out = arr.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "incremental_cost_with_symmetry_breaking_aug_187": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Vectorized implementation with bias favoring smaller location indices and deterministic tie\u2011breaking.\n    \"\"\"\n    # Rename for readability\n    assignment = np.asarray(current_assignment, dtype=int)\n    n = assignment.size\n\n",
  "dual_greedy_facility_and_location_aug_188": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 1 \u2013 basic syntactic rewrite with deterministic noise for tie\u2011breaking.\n    \"\"\"\n    # Local aliases\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned_facilities = np.flatnonzero(a == -1)\n    if unassigned_facilities.size == 0:\n        return a.tolist()\n\n    used_locations = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locations[a[a != -1]] = True\n    free_locations = np.flatnonzero(~used_locations)\n\n    assigned_facilities = np.flatnonzero(a != -1)\n    assigned_locations = a[assigned_facilities]\n\n    rng = np.random.default_rng(42)  # deterministic RNG\n\n    def inc(f, l):\n        if assigned_facilities.size == 0:\n            return 0.0\n        return float(\n            np.sum(flow_matrix[f, assigned_facilities] *\n                   distance_matrix[l, assigned_locations] +\n                   flow_matrix[assigned_facilities, f] *\n                   distance_matrix[assigned_locations, l])\n        )\n\n    f_best_l = {}\n    f_best_c = {}\n    for f in unassigned_facilities:\n        cs = np.array([inc(int(f), int(l)) for l in free_locations], dtype=float)\n        cs += rng.random(cs.size) * 1e-6  # deterministic tie\u2011breaker\n        j = int(np.argmin(cs))\n        f_best_l[int(f)] = int(free_locations[j])\n        f_best_c[int(f)] = float(cs[j])\n\n    l_best_f = {}\n    l_best_c = {}\n    for l in free_locations:\n        cs = np.array([inc(int(f), int(l)) for f in unassigned_facilities], dtype=float)\n        cs += rng.random(cs.size) * 1e-6\n        i = int(np.argmin(cs))\n        l_best_f[int(l)] = int(unassigned_facilities[i])\n        l_best_c[int(l)] = float(cs[i])\n\n    best_score = -np.inf\n    best_pair = (int(unassigned_facilities[0]), int(free_locations[0]))\n    for f in unassigned_facilities:\n        l = f_best_l[int(f)]\n        mutual = 1 if l_best_f[int(l)] == int(f) else 0\n        score = 2.0 * mutual - f_best_c[int(f)] - l_best_c[int(l)]\n        score = np.clip(score, -1e6, 1e6)  # safety bound\n        if score > best_score:\n            best_score = score\n            best_pair = (int(f), int(l))\n\n    out = a.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n\n",
  "partial_cost_gradient_descent_step_aug_189": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy assignment using vectorised force calculation and a while\u2011loop\n    for location selection.  Uses np.square for quadratic terms and\n    keeps the original greedy logic.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # nodes that still need a location\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    # nodes that already have a location\n    assigned = np.flatnonzero(a != -1).astype(int)\n\n    # which locations are already taken\n    used = np.zeros(n, dtype=bool)\n    if assigned.size:\n        used[a[assigned]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    # coordinates of already assigned locations\n    locs_assigned = a[assigned].astype(int)\n\n    # ---- choose the facility with the largest \u201cforce\u201d ----\n    if assigned.size:\n        force_out = flow_matrix[np.ix_(unassigned, assigned)].sum(axis=1)\n        force_in = flow_matrix[np.ix_(assigned, unassigned)].sum(axis=0)\n        force = (force_out + force_in).astype(float)\n        f = int(unassigned[np.argmax(force)])\n    else:\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(unassigned[np.argmax(pf[unassigned])])\n\n    # ---- pick the best free location for that facility ----\n    best_score = np.inf\n    best_l = int(free_locs[0])\n    idx = 0\n    while idx < free_locs.size:\n        l = int(free_locs[idx])\n        if assigned.size == 0:\n            # use the mean of squared distances\n            dist_sq = np.square(distance_matrix[l]).astype(float)\n            score = float(np.mean(dist_sq))\n        else:\n            w_out = flow_matrix[f, assigned].astype(float)\n            w_in = flow_matrix[assigned, f].astype(float)\n            w = w_out + w_in\n            wsum = float(w.sum() + 1e-12)\n            d = distance_matrix[l, locs_assigned].astype(float)\n            score = float(np.sum(w * np.square(d)) / wsum)\n        if score < best_score:\n            best_score = score\n            best_l = l\n        idx += 1\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "partial_cost_gradient_descent_step_aug_190": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant that tunes the scoring function: a weighted mix of\n    distance\u00b2 and raw flow, plus a top\u2011k selection for tie\u2011breaking.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if assigned.size:\n        used[a[assigned]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    locs_assigned = a[assigned].astype(int)\n\n    # ---- facility selection ----\n    if assigned.size:\n        force = (flow_matrix[np.ix_(unassigned, assigned)].sum(axis=1) +\n                 flow_matrix[np.ix_(assigned, unassigned)].sum(axis=0)).astype(float)\n        f = int(unassigned[np.argmax(force)])\n    else:\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(unassigned[np.argmax(pf[unassigned])])\n\n    # ---- location scoring with tuned weights ----\n    scores = np.full(free_locs.size, np.inf, dtype=float)\n    weight_dist = 0.6  # tuned weight for distance\n    for idx, l in enumerate(free_locs):\n        if assigned.size == 0:\n            dist_sq = np.square(distance_matrix[l]).astype(float)\n            score = float(np.mean(dist_sq))\n        else:\n            w_out = flow_matrix[f, assigned].astype(float)\n            w_in = flow_matrix[assigned, f].astype(float)\n            w = w_out + w_in\n            wsum = float(w.sum() + 1e-12)\n            d = distance_matrix[l, locs_assigned].astype(float)\n            # weighted mix of distance\u00b2 and flow magnitude\n            dist_component = np.sum(weight_dist * np.square(d))\n            flow_component = np.sum((1 - weight_dist) * w)\n            score = float((dist_component + flow_component) / wsum)\n        scores[idx] = score\n\n    # ---- top\u2011k tie\u2011breaking (k=7) ----\n    top_k = min(7, scores.size)\n    best_idx = np.argsort(scores)[:top_k][0]\n    best_l = int(free_locs[best_idx])\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "partial_cost_gradient_descent_step_aug_191": "import numpy as np\nfrom typing import List\nimport random\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Adds deterministic noise for tie\u2011breaking, uses median for the\n    unassigned\u2011first case, and randomly chooses among the top\u2011k\n    candidates.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if assigned.size:\n        used[a[assigned]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    locs_assigned = a[assigned].astype(int)\n\n    # facility selection\n    if assigned.size:\n        force = (flow_matrix[np.ix_(unassigned, assigned)].sum(axis=1) +\n                 flow_matrix[np.ix_(assigned, unassigned)].sum(axis=0)).astype(float)\n        f = int(unassigned[np.argmax(force)])\n    else:\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(unassigned[np.argmax(pf[unassigned])])\n\n    # seed for deterministic noise based on current assignment\n    seed_val = hash(tuple(current_assignment)) & 0xffffffff\n    rng = random.Random(seed_val)\n\n    scores = np.full(free_locs.size, np.inf, dtype=float)\n    for idx, l in enumerate(free_locs):\n        if assigned.size == 0:\n            dist_sq = np.square(distance_matrix[l]).astype(float)\n            # use median instead of mean\n            score = float(np.median(dist_sq))\n        else:\n            w_out = flow_matrix[f, assigned].astype(float)\n            w_in = flow_matrix[assigned, f].astype(float)\n            w = w_out + w_in\n            wsum = float(w.sum() + 1e-12)\n            d = distance_matrix[l, locs_assigned].astype(float)\n            score = float(np.sum(w * np.square(d)) / wsum)\n        # deterministic noise for tie\u2011breaking\n        score += 1e-6 * idx\n        scores[idx] = score\n\n    # random choice among the top\u2011k (k=5)\n    top_k = min(5, scores.size)\n    best_candidates = np.argsort(scores)[:top_k]\n    chosen_idx = rng.choice(best_candidates)\n    best_l = int(free_locs[chosen_idx])\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "partial_cost_gradient_descent_step_aug_192": "import numpy as np\nfrom typing import List\nimport random\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Uses np.max for the flow sum, clips scores to a safe range,\n    and selects a random location among the top\u2011k candidates.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if assigned.size:\n        used[a[assigned]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    locs_assigned = a[assigned].astype(int)\n\n    # facility selection\n    if assigned.size:\n        force = (flow_matrix[np.ix_(unassigned, assigned)].sum(axis=1) +\n                 flow_matrix[np.ix_(assigned, unassigned)].sum(axis=0)).astype(float)\n        f = int(unassigned[np.argmax(force)])\n    else:\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(unassigned[np.argmax(pf[unassigned])])\n\n    # scoring\n    scores = np.full(free_locs.size, np.inf, dtype=float)\n    for idx, l in enumerate(free_locs):\n        if assigned.size == 0:\n            dist_sq = np.square(distance_matrix[l]).astype(float)\n            score = float(np.max(dist_sq))\n        else:\n            w_out = flow_matrix[f, assigned].astype(float)\n            w_in = flow_matrix[assigned, f].astype(float)\n            w = w_out + w_in\n            # use np.max for the flow sum to reduce influence of large flows\n            wsum = float(np.max([w.sum(), 1e-12]))\n            d = distance_matrix[l, locs_assigned].astype(float)\n            score = float(np.sum(w * np.square(d)) / wsum)\n        # clip to avoid extreme values\n        scores[idx] = np.clip(score, 0, 1e6)\n\n    # random choice among top\u2011k (k=6)\n    top_k = min(6, scores.size)\n    best_candidates = np.argsort(scores)[:top_k]\n    chosen_idx = random.choice(best_candidates)\n    best_l = int(free_locs[chosen_idx])\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "two_step_lookahead_best_pair_aug_193": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 1 \u2013 uses list\u2011comprehensions, vectorised cost computation and inverted\n    conditional logic. Variable names are renamed for clarity.\n    \"\"\"\n    cur_assign = np.asarray(current_assignment, dtype=int)\n    n = cur_assign.size\n\n    # Find unassigned facilities and free locations using list comprehensions\n    un = np.array([i for i in range(n) if cur_assign[i] == -1], dtype=int)\n    if un.size == 0:\n        return cur_assign.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if cur_assign[cur_assign != -1].size:\n        used_locs[cur_assign[cur_assign != -1]] = True\n    free = np.array([i for i in range(n) if not used_locs[i]], dtype=int)\n\n    # Current assignments\n    ass_idx = np.array([i for i in range(n) if cur_assign[i] != -1], dtype=int)\n    ass_locs = cur_assign[ass_idx]\n\n    flow_mat, dist_mat = flow_matrix, distance_matrix\n\n    def inc_cost(f: int, l: int, a_idx: np.ndarray, a_locs: np.ndarray) -> float:\n        \"\"\"Vectorised incremental cost for placing facility f at location l.\"\"\"\n        if a_idx.size == 0:\n            return 0.0\n        # Broadcast to compute all interactions at once\n        cost = np.sum(flow_mat[f, a_idx] * dist_mat[l, a_locs] +\n                      flow_mat[a_idx, f] * dist_mat[a_locs, l])\n        return float(cost)\n\n    best_score = np.inf\n    best_f, best_l = un[0], free[0]\n\n    for f in un:\n        for l in free:\n            inc = inc_cost(f, l, ass_idx, ass_locs)\n\n            # One\u2011step lookahead: greedily place the next best pair\n            rem_fac = [x for x in un if x != f]\n            rem_loc = [x for x in free if x != l]\n\n            if not rem_fac or not rem_loc:\n                la = 0.0\n            else:\n                new_a_idx = np.concatenate([ass_idx, [f]])\n                new_a_locs = np.concatenate([ass_locs, [l]])\n                la_best = np.inf\n                for f2 in rem_fac:\n                    for l2 in rem_loc:\n                        c = inc_cost(f2, l2, new_a_idx, new_a_locs)\n                        if c < la_best:\n                            la_best = c\n                la = la_best\n\n            score = inc + 0.35 * la\n            if score < best_score:\n                best_score = score\n                best_f, best_l = f, l\n\n    out = cur_assign.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "two_step_lookahead_best_pair_aug_194": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 2 \u2013 introduces a tunable look\u2011ahead weight (0.45) and a softmin\n    selection over all candidate pairs. Uses vectorised cost computation.\n    \"\"\"\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n\n    un = np.flatnonzero(cur == -1)\n    if un.size == 0:\n        return cur.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if cur[cur != -1].size:\n        used[cur[cur != -1]] = True\n    free = np.flatnonzero(~used)\n\n    ass_idx = np.flatnonzero(cur != -1)\n    ass_locs = cur[ass_idx]\n\n    flow, dist = flow_matrix, distance_matrix\n\n    def inc_cost(f, l, a_idx, a_locs):\n        if a_idx.size == 0:\n            return 0.0\n        return float(np.sum(flow[f, a_idx] * dist[l, a_locs] +\n                            flow[a_idx, f] * dist[a_locs, l]))\n\n    scores = []\n    candidates = []\n    for f in un:\n        for l in free:\n            inc = inc_cost(f, l, ass_idx, ass_locs)\n\n            # lookahead\n            rem_f = un[un != f]\n            rem_l = free[free != l]\n            if rem_f.size == 0 or rem_l.size == 0:\n                la = 0.0\n            else:\n                new_a_idx = np.concatenate([ass_idx, [f]])\n                new_a_locs = np.concatenate([ass_locs, [l]])\n                la_best = np.inf\n                for f2 in rem_f:\n                    for l2 in rem_l:\n                        c = inc_cost(f2, l2, new_a_idx, new_a_locs)\n                        if c < la_best:\n                            la_best = c\n                la = la_best\n\n            score = inc + 0.45 * la\n            scores.append(score)\n            candidates.append((f, l))\n\n    # softmin over all scores\n    temp = 1.0\n    exp_scores = np.exp(-np.array(scores) / (temp + 1e-12))\n    probs = exp_scores / np.clip(np.sum(exp_scores), 1e-12, None)\n    idx = np.random.choice(len(candidates), p=probs)\n    best_f, best_l = candidates[idx]\n\n    out = cur.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "two_step_lookahead_best_pair_aug_195": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 3 \u2013 uses median aggregation for incremental cost, adds deterministic\n    noise for tie\u2011breaking, and selects randomly among the top\u20113 lowest scores.\n    \"\"\"\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n\n    un = np.flatnonzero(cur == -1)\n    if un.size == 0:\n        return cur.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if cur[cur != -1].size:\n        used[cur[cur != -1]] = True\n    free = np.flatnonzero(~used)\n\n    ass_idx = np.flatnonzero(cur != -1)\n    ass_locs = cur[ass_idx]\n\n    flow, dist = flow_matrix, distance_matrix\n\n    def inc_cost(f, l, a_idx, a_locs):\n        if a_idx.size == 0:\n            return 0.0\n        # median of pairwise products\n        prod = flow[f, a_idx] * dist[l, a_locs] + flow[a_idx, f] * dist[a_locs, l]\n        return float(np.median(prod))\n\n    scores = []\n    candidates = []\n    for f in un:\n        for l in free:\n            inc = inc_cost(f, l, ass_idx, ass_locs)\n\n            rem_f = un[un != f]\n            rem_l = free[free != l]\n            if rem_f.size == 0 or rem_l.size == 0:\n                la = 0.0\n            else:\n                new_a_idx = np.concatenate([ass_idx, [f]])\n                new_a_locs = np.concatenate([ass_locs, [l]])\n                la_best = np.inf\n                for f2 in rem_f:\n                    for l2 in rem_l:\n                        c = inc_cost(f2, l2, new_a_idx, new_a_locs)\n                        if c < la_best:\n                            la_best = c\n                la = la_best\n\n            # deterministic noise for tie\u2011breaking\n            noise = 1e-6 * (f + l)\n            score = inc + 0.35 * la + noise\n            scores.append(score)\n            candidates.append((f, l))\n\n    # choose among the three best candidates\n    top_k = 3\n    sorted_idx = np.argsort(scores)\n    top_idx = sorted_idx[:min(top_k, len(sorted_idx))]\n    rng = np.random.default_rng(42)\n    chosen = rng.choice(top_idx)\n    best_f, best_l = candidates[chosen]\n\n    out = cur.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "two_step_lookahead_best_pair_aug_196": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 4 \u2013 replaces the exact incremental cost with a proxy using the\n    maximum interaction term, applies a softer look\u2011ahead weighting,\n    and clips intermediate values to avoid numerical overflow.\n    \"\"\"\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n\n    un = np.flatnonzero(cur == -1)\n    if un.size == 0:\n        return cur.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if cur[cur != -1].size:\n        used[cur[cur != -1]] = True\n    free = np.flatnonzero(~used)\n\n    ass_idx = np.flatnonzero(cur != -1)\n    ass_locs = cur[ass_idx]\n\n    flow, dist = flow_matrix, distance_matrix\n\n    def inc_cost(f, l, a_idx, a_locs):\n        if a_idx.size == 0:\n            return 0.0\n        # proxy: maximum of pairwise products\n        prod = flow[f, a_idx] * dist[l, a_locs] + flow[a_idx, f] * dist[a_locs, l]\n        return float(np.clip(np.max(prod), 0, 1e9))\n\n    scores = []\n    candidates = []\n    for f in un:\n        for l in free:\n            inc = inc_cost(f, l, ass_idx, ass_locs)\n\n            rem_f = un[un != f]\n            rem_l = free[free != l]\n            if rem_f.size == 0 or rem_l.size == 0:\n                la = 0.0\n            else:\n                new_a_idx = np.concatenate([ass_idx, [f]])\n                new_a_locs = np.concatenate([ass_locs, [l]])\n                la_best = np.inf\n                for f2 in rem_f:\n                    for l2 in rem_l:\n                        c = inc_cost(f2, l2, new_a_idx, new_a_locs)\n                        if c < la_best:\n                            la_best = c\n                la = la_best\n\n            # softmin weighting with temperature 0.5\n            score = inc + 0.5 * la\n            scores.append(score)\n            candidates.append((f, l))\n\n    # compute probabilities via softmin\n    temp = 0.5\n    exp_scores = np.exp(-np.array(scores) / (temp + 1e-12))\n    probs = exp_scores / np.clip(np.sum(exp_scores), 1e-12, None)\n    rng = np.random.default_rng(99)\n    idx = rng.choice(len(candidates), p=probs)\n    best_f, best_l = candidates[idx]\n\n    out = cur.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_location_neighborhood_aug_197": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy incremental assignment with deterministic tie\u2011breaking and\n    vectorised cost evaluation.  Uses mean centrality to pick the first\n    location when no facility has been assigned yet.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.flatnonzero(a == -1).astype(int)\n\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    # ---------- first move ----------\n    if assigned_fac.size == 0:\n        centrality = np.mean(distance_matrix[free_locs], axis=1)\n        idx = int(np.argmin(centrality))\n        chosen_loc = int(free_locs[idx])\n        f = int(unassigned[0])\n        out = a.copy()\n        out[f] = chosen_loc\n        return out.tolist()\n\n    # ---------- candidate locations ----------\n    k = max(2, int(np.ceil(0.25 * free_locs.size)))\n    cand_mask = np.zeros(n, dtype=bool)\n    for loc in assigned_loc:\n        dists = distance_matrix[free_locs, loc].astype(float)\n        nearest_idx = np.argsort(dists)[:min(k, free_locs.size)]\n        cand_mask[free_locs[nearest_idx]] = True\n    cand_locs = free_locs[cand_mask[free_locs]]\n\n    # ---------- search ----------\n    best_cost = np.inf\n    best_f = int(unassigned[0])\n    best_l = int(cand_locs[0])\n\n    for f in unassigned.astype(int):\n        inc_vec = (flow_matrix[f, assigned_fac] @ distance_matrix[cand_locs][:, assigned_loc]) + \\\n                  (flow_matrix[assigned_fac, f] @ distance_matrix[assigned_loc][:, cand_locs])\n        inc_vec = np.clip(inc_vec, 0, 1e12)           # safeguard against overflow\n        noise = 1e-9 * np.arange(cand_locs.size)     # deterministic tie\u2011breaker\n        inc_vec += noise\n        idx_min = int(np.argmin(inc_vec))\n        if inc_vec[idx_min] < best_cost:\n            best_cost = inc_vec[idx_min]\n            best_f = int(f)\n            best_l = int(cand_locs[idx_min])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_location_neighborhood_aug_198": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Randomly selects among the top\u2011k best incremental pairs.  Uses\n    maximum centrality for the initial placement and deterministic\n    noise for tie\u2011breaking.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.flatnonzero(a == -1).astype(int)\n\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    # ---------- first move ----------\n    if assigned_fac.size == 0:\n        centrality = np.max(distance_matrix[free_locs], axis=1).astype(float)\n        idx = int(np.argmin(centrality))\n        chosen_loc = int(free_locs[idx])\n        f = int(unassigned[0])\n        out = a.copy()\n        out[f] = chosen_loc\n        return out.tolist()\n\n    # ---------- candidate locations ----------\n    k = max(4, int(np.ceil(0.35 * free_locs.size)))  # distinct threshold\n    cand_mask = np.zeros(n, dtype=bool)\n    for loc in assigned_loc:\n        dists = distance_matrix[free_locs, loc].astype(float)\n        nearest_idx = np.argsort(dists)[:min(k, free_locs.size)]\n        cand_mask[free_locs[nearest_idx]] = True\n    cand_locs = free_locs[cand_mask[free_locs]]\n\n    # ---------- search ----------\n    best_f = int(unassigned[0])\n    best_l = int(cand_locs[0])\n    best_cost = np.inf\n\n    for f in unassigned.astype(int):\n        inc_vec = (flow_matrix[f, assigned_fac] @ distance_matrix[cand_locs][:, assigned_loc]) + \\\n                  (flow_matrix[assigned_fac, f] @ distance_matrix[assigned_loc][:, cand_locs])\n        inc_vec = np.clip(inc_vec, 0, 1e12)\n        sorted_idx = np.argsort(inc_vec)\n        top_k = min(5, inc_vec.size)\n        top_indices = sorted_idx[:top_k]\n        chosen_idx = int(np.random.choice(top_indices))\n        chosen_cost = inc_vec[chosen_idx]\n        # deterministic noise for tie\u2011breaking\n        if chosen_cost + 1e-9 * chosen_idx < best_cost:\n            best_cost = chosen_cost\n            best_f = f\n            best_l = int(cand_locs[chosen_idx])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "surrogate_linear_assignment_pick_aug_199": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # facilities that are still unassigned\n    unassigned_fac = np.flatnonzero(a == -1)\n    if unassigned_fac.size == 0:\n        return a.tolist()\n\n    # locations already taken\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs)\n\n    # already assigned facilities and their locations\n    assigned_fac = np.flatnonzero(a != -1)\n    assigned_locs = a[assigned_fac]\n\n    # ---- facility weight ---------------------------------------------------\n    if assigned_fac.size:\n        wf = (flow_matrix[np.ix_(unassigned_fac, assigned_fac)].sum(axis=1) +\n              flow_matrix[np.ix_(assigned_fac, unassigned_fac)].sum(axis=0))\n    else:\n        wf = flow_matrix[unassigned_fac].sum(axis=1) + flow_matrix[:, unassigned_fac].sum(axis=0)\n    wf = np.clip(wf, 0, None).astype(float)\n\n    # ---- location weight ---------------------------------------------------\n    if assigned_fac.size:\n        wl = distance_matrix[np.ix_(free_locs, assigned_locs)].sum(axis=1)\n    else:\n        wl = distance_matrix[free_locs].sum(axis=1)\n    wl = np.clip(wl, 0, None).astype(float)\n\n    # add tiny deterministic noise for stable tie\u2011breaking\n    rng = np.random.default_rng(seed=42)\n    wf += 1e-8 * rng.random(wf.shape)\n    wl += 1e-8 * rng.random(wl.shape)\n\n    # surrogate cost matrix\n    C = np.outer(wf, wl) + 1e-12          # avoid division by zero\n\n    # greedy assignment: take cheapest remaining pair iteratively\n    rows = list(range(C.shape[0]))\n    cols = list(range(C.shape[1]))\n    chosen = []\n    C_work = C.copy()\n    while rows and cols:\n        idx = np.argmin(C_work[np.ix_(rows, cols)])\n        i, j = divmod(idx, len(cols))\n        r, c = rows[i], cols[j]\n        chosen.append((r, c))\n        rows.pop(i)\n        cols.pop(j)\n        if not rows or not cols:\n            break\n\n    # evaluate incremental cost for the best few candidates\n    best_inc = float(\"inf\")\n    best_f, best_l = int(unassigned_fac[0]), int(free_locs[0])\n    for r, c in chosen[:4]:\n        f = int(unassigned_fac[r])\n        l = int(free_locs[c])\n        inc = 0.0\n        if assigned_fac.size:\n            inc = float(np.sum(flow_matrix[f, assigned_fac] * distance_matrix[l, assigned_locs] +\n                               flow_matrix[assigned_fac, f] * distance_matrix[assigned_locs, l]))\n        if inc < best_inc:\n            best_inc, best_f, best_l = inc, f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "surrogate_linear_assignment_pick_aug_200": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used)\n\n    assigned = np.flatnonzero(a != -1)\n    locs = a[assigned]\n\n    # facility weight: weighted sum of flows (0.6 / 0.4 split)\n    if assigned.size:\n        wf = (0.6 * flow_matrix[np.ix_(unassigned, assigned)].sum(axis=1) +\n              0.4 * flow_matrix[np.ix_(assigned, unassigned)].sum(axis=0))\n    else:\n        wf = flow_matrix[unassigned].sum(axis=1) + flow_matrix[:, unassigned].sum(axis=0)\n    wf = np.clip(wf, 0, None).astype(float)\n\n    # location weight: median distance to already used locations\n    if assigned.size:\n        wl = np.median(distance_matrix[np.ix_(free, locs)], axis=1)\n    else:\n        wl = np.median(distance_matrix[free], axis=1)\n    wl = np.clip(wl, 0, None).astype(float)\n\n    # surrogate cost matrix\n    C = np.outer(wf, wl)\n\n    # softmin with temperature\n    temperature = 1.0\n    soft = np.exp(-C / (temperature + 1e-12))\n    probs = soft / (soft.sum() + 1e-12)\n\n    # choose among top_k candidates\n    top_k = 7\n    flat_idx = np.argpartition(-probs, top_k - 1)[:top_k]\n    rows_flat = flat_idx // C.shape[1]\n    cols_flat = flat_idx % C.shape[1]\n\n    rng = np.random.default_rng(seed=24)\n    choice = rng.choice(len(rows_flat))\n    r, c = rows_flat[choice], cols_flat[choice]\n    f = int(unassigned[r])\n    l = int(free[c])\n\n    # incremental cost for this pair\n    inc = 0.0\n    if assigned.size:\n        inc = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                           flow_matrix[assigned, f] * distance_matrix[locs, l]))\n\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "surrogate_linear_assignment_pick_aug_201": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # list comprehension for unassigned facilities\n    unassigned = np.array([i for i, v in enumerate(a) if v == -1], dtype=int)\n    if not unassigned.size:\n        return a.tolist()\n\n    # used locations via boolean mask\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.array([i for i, v in enumerate(used) if not v], dtype=int)\n\n    assigned = np.array([i for i, v in enumerate(a) if v != -1], dtype=int)\n    locs = a[assigned]\n\n    # facility weight: sum of flows to assigned (use np.max for aggregation)\n    if assigned.size:\n        wf = np.max(flow_matrix[np.ix_(unassigned, assigned)], axis=1)\n    else:\n        wf = np.max(flow_matrix[unassigned], axis=1)\n    wf = np.clip(wf, 0, None).astype(float)\n\n    # location weight: sum of distances to used locations (with deterministic noise)\n    if assigned.size:\n        wl = distance_matrix[np.ix_(free, locs)].sum(axis=1)\n    else:\n        wl = distance_matrix[free].sum(axis=1)\n    wl = np.clip(wl, 0, None).astype(float)\n    rng = np.random.default_rng(seed=99)\n    wl += 1e-9 * rng.random(wl.shape)\n\n    # surrogate cost\n    C = np.outer(wf, wl) + 1e-12\n\n    # greedy selection via while loop (inverted logic)\n    rows = list(range(C.shape[0]))\n    cols = list(range(C.shape[1]))\n    chosen = []\n    C_work = C.copy()\n    while len(rows) > 0 and len(cols) > 0:\n        idx = np.argmin(C_work[np.ix_(rows, cols)])\n        i, j = divmod(idx, len(cols))\n        r, c = rows[i], cols[j]\n        chosen.append((r, c))\n        rows.pop(i)\n        cols.pop(j)\n        if not rows or not cols:\n            break\n\n    # pick best incremental cost among first three candidates\n    best_inc = float(\"inf\")\n    best_f, best_l = int(unassigned[0]), int(free[0])\n    for r, c in chosen[:3]:\n        f = int(unassigned[r])\n        l = int(free[c])\n        inc = 0.0\n        if assigned.size:\n            inc = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                               flow_matrix[assigned, f] * distance_matrix[locs, l]))\n        if inc < best_inc:\n            best_inc, best_f, best_l = inc, f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "surrogate_linear_assignment_pick_aug_202": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used)\n\n    assigned = np.flatnonzero(a != -1)\n    locs = a[assigned]\n\n    # facility weight: weighted sum of flows (0.6 flow + 0.4 distance influence)\n    if assigned.size:\n        wf = (0.6 * flow_matrix[np.ix_(unassigned, assigned)].sum(axis=1) +\n              0.4 * flow_matrix[np.ix_(assigned, unassigned)].sum(axis=0))\n    else:\n        wf = flow_matrix[unassigned].sum(axis=1) + flow_matrix[:, unassigned].sum(axis=0)\n    wf = np.clip(wf, 0, None).astype(float)\n\n    # location weight: sum of distances to used locations\n    if assigned.size:\n        wl = distance_matrix[np.ix_(free, locs)].sum(axis=1)\n    else:\n        wl = distance_matrix[free].sum(axis=1)\n    wl = np.clip(wl, 0, None).astype(float)\n\n    # surrogate cost matrix\n    C = np.outer(wf, wl)\n\n    # vectorised selection of the absolute best pair\n    idx_flat = np.argmin(C)\n    f_idx, l_idx = divmod(idx_flat, C.shape[1])\n    f = int(unassigned[f_idx])\n    l = int(free[l_idx])\n\n    # incremental cost for chosen pair\n    inc = 0.0\n    if assigned.size:\n        inc = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                           flow_matrix[assigned, f] * distance_matrix[locs, l]))\n\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "flow_community_then_central_match_aug_203": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur_assign = np.asarray(current_assignment, dtype=int)\n    n = cur_assign.size\n    unassigned = np.where(cur_assign == -1)[0]\n    if unassigned.size == 0:\n        return cur_assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(cur_assign != -1):\n        used[cur_assign[cur_assign != -1]] = True\n    free_positions = np.where(~used)[0]\n\n    dist_mat = distance_matrix  # rename\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    k = min(6, max(1, unassigned.size - 1))\n    scores = np.zeros(unassigned.size, dtype=float)\n    for idx, f in enumerate(unassigned):\n        neigh = sym[f, unassigned]\n        neigh = neigh.copy()\n        neigh[idx] = -np.inf\n        topk_vals = np.partition(neigh, -k)[-k:] if k > 0 else np.array([0.0])\n        scores[idx] = float(np.median(topk_vals))\n    noise = 1e-6 * np.arange(unassigned.size)\n    scores += noise\n    chosen_fac = int(unassigned[np.argmax(scores)])\n\n    free_dist_sum = dist_mat[free_positions].sum(axis=1)\n    beta = 10.0\n    weights = np.exp(-beta * free_dist_sum)\n    chosen_pos = int(free_positions[np.argmax(weights)])\n\n    out = cur_assign.copy()\n    out[chosen_fac] = chosen_pos\n    return out.tolist()\n\n",
  "flow_community_then_central_match_aug_204": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n    unassigned = np.where(cur == -1)[0]\n    if unassigned.size == 0:\n        return cur.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(cur != -1):\n        used[cur[cur != -1]] = True\n    free = np.where(~used)[0]\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    top_k = 7\n    k = min(top_k, max(1, unassigned.size - 1))\n    scores = np.zeros(unassigned.size, dtype=float)\n    for i, f in enumerate(unassigned):\n        neigh = sym[f, unassigned]\n        neigh[i] = -np.inf\n        top_vals = np.partition(neigh, -k)[-k:]\n        scores[i] = np.max(top_vals) / (k + 1e-12)  # weighted by max, divide with epsilon\n    rng = np.random.default_rng()\n    best_idx = int(rng.choice(np.where(scores == np.max(scores))[0]))\n    chosen_fac = int(unassigned[best_idx])\n\n    centrality = distance_matrix[free].sum(axis=1)\n    centrality_clipped = np.clip(centrality, 0, np.inf)\n    chosen_pos = int(free[np.argmax(centrality_clipped)])\n\n    out = cur.copy()\n    out[chosen_fac] = chosen_pos\n    return out.tolist()\n\n",
  "flow_community_then_central_match_aug_205": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    candidates = np.where(assign == -1)[0]\n    if candidates.size == 0:\n        return assign.tolist()\n\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        occupied[assign[assign != -1]] = True\n    slots = np.where(~occupied)[0]\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    top_k = 5\n    scores = np.zeros(candidates.size, dtype=float)\n    for idx, f in enumerate(candidates):\n        neigh = sym[f, candidates]\n        neigh[idx] = -np.inf\n        top_vals = np.partition(neigh, -top_k)[-top_k:]\n        scores[idx] = np.sum(top_vals) / (top_k + 1e-12)  # sum aggregation\n    rng = np.random.default_rng()\n    best_indices = np.where(scores == np.max(scores))[0]\n    chosen_fac = int(candidates[rng.choice(best_indices)])\n\n    loc_scores = distance_matrix[slots].sum(axis=1)\n    noise = 1e-8 * np.arange(slots.size)\n    loc_scores += noise\n    chosen_slot = int(slots[np.argmin(loc_scores)])\n\n    out = assign.copy()\n    out[chosen_fac] = chosen_slot\n    return out.tolist()\n\n",
  "flow_community_then_central_match_aug_206": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n    unassigned = np.where(cur == -1)[0]\n    if unassigned.size == 0:\n        return cur.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(cur != -1):\n        used[cur[cur != -1]] = True\n    free = np.where(~used)[0]\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    # Density as sum of flows to all unassigned facilities\n    density = np.sum(sym[:, unassigned], axis=1)\n    fac_idx = int(unassigned[np.argmax(density[unassigned])])\n\n    # Inverse distance weighted centrality\n    inv_dist = 1.0 / (distance_matrix[free][:, :] + 1e-12)\n    weighted = inv_dist.sum(axis=1)\n    weighted_clipped = np.clip(weighted, 0, None)\n    loc_idx = int(free[np.argmax(weighted_clipped)])\n\n    out = cur.copy()\n    out[fac_idx] = loc_idx\n    return out.tolist()\n\n",
  "min_incremental_with_cost_variance_regularizer_aug_207": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorized selection with incremental cost + variance penalty.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Unassigned facilities\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    # Locations already taken\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    # Assigned facilities and their locations\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    lam = 0.3\n    eps = 1e-12\n    best_score = np.inf\n    best_f, best_l = unassigned[0], free_locs[0]\n\n    for f in unassigned:\n        # Interaction vectors with already assigned facilities\n        flow_to = flow_matrix[f, assigned_fac].astype(float)\n        flow_from = flow_matrix[assigned_fac, f].astype(float)\n        for l in free_locs:\n            if assigned_fac.size == 0:\n                inc = 0.0\n                var = 0.0\n            else:\n                vec = (flow_to * distance_matrix[l, assigned_loc] +\n                       flow_from * distance_matrix[assigned_loc, l]).astype(float)\n                inc = float(vec.sum())\n                var = float(np.var(vec)) if vec.size > 1 else 0.0\n                var = np.clip(var, 0.0, np.inf)  # safety clip\n            # deterministic tie\u2011breaking noise\n            noise = 1e-6 * (f + l)\n            score = inc + lam * var + noise\n            if score < best_score:\n                best_score, best_f, best_l = score, f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_with_cost_variance_regularizer_aug_208": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Selection using while loop, top\u2011k random choice, and softmin weighting.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    lam = 0.4\n    eps = 1e-12\n    best_f, best_l = unassigned[0], free_locs[0]\n    best_score = np.inf\n\n    # Build list of candidate pairs\n    candidates = []\n    for f in unassigned:\n        flow_to = flow_matrix[f, assigned_fac].astype(float)\n        flow_from = flow_matrix[assigned_fac, f].astype(float)\n        for l in free_locs:\n            if assigned_fac.size == 0:\n                inc = 0.0\n                var = 0.0\n            else:\n                vec = (flow_to * distance_matrix[l, assigned_loc] +\n                       flow_from * distance_matrix[assigned_loc, l]).astype(float)\n                inc = float(vec.sum())\n                var = float(np.var(vec)) if vec.size > 1 else 0.0\n            score = inc + lam * var\n            candidates.append((score, f, l))\n\n    # Process candidates with a while loop and softmin weighting\n    idx = np.arange(len(candidates))\n    while idx.size > 0:\n        scores = np.array([candidates[i][0] for i in idx])\n        tau = 1.0\n        weights = np.exp(-scores / (tau + eps))\n        weights /= np.sum(weights) + eps\n        chosen = np.random.choice(idx, p=weights)\n        score, f, l = candidates[chosen]\n        if score < best_score:\n            best_score, best_f, best_l = score, f, l\n        idx = idx[idx != chosen]  # remove chosen\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_with_cost_variance_regularizer_aug_209": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"List\u2011comprehension based selection with median aggregation and proxy variance.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    lam = 0.6\n    eps = 1e-12\n    best_f, best_l = unassigned[0], free_locs[0]\n    best_score = np.inf\n\n    for f in unassigned:\n        flow_to = flow_matrix[f, assigned_fac].astype(float)\n        flow_from = flow_matrix[assigned_fac, f].astype(float)\n        for l in free_locs:\n            if assigned_fac.size == 0:\n                inc = 0.0\n                var = 0.0\n            else:\n                vec = (flow_to * distance_matrix[l, assigned_loc] +\n                       flow_from * distance_matrix[assigned_loc, l]).astype(float)\n                inc = float(np.mean(vec))  # use mean instead of sum\n                var = float((np.max(vec) - np.min(vec)) * 0.5) if vec.size > 1 else 0.0\n                var = np.clip(var, 0.0, np.inf)  # safety clip\n            noise = 1e-6 * (f - l)  # deterministic tie\u2011breaking\n            score = inc + lam * var + noise\n            if score < best_score:\n                best_score, best_f, best_l = score, f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_with_cost_variance_regularizer_aug_210": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Product\u2011based scoring with clipping and epsilon handling.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    lam = 0.4\n    eps = 1e-12\n    best_f, best_l = unassigned[0], free_locs[0]\n    best_score = np.inf\n\n    for f in unassigned:\n        flow_to = flow_matrix[f, assigned_fac].astype(float)\n        flow_from = flow_matrix[assigned_fac, f].astype(float)\n        for l in free_locs:\n            if assigned_fac.size == 0:\n                inc = 1.0  # neutral multiplicative factor\n                var = 0.0\n            else:\n                vec = (flow_to * distance_matrix[l, assigned_loc] +\n                       flow_from * distance_matrix[assigned_loc, l]).astype(float) + eps\n                inc = float(np.prod(vec))\n                inc = np.clip(inc, 0.0, 1e12)  # prevent overflow\n                var = float(np.var(vec)) if vec.size > 1 else 0.0\n            noise = 1e-8 * (f + l)  # deterministic noise\n            score = inc + lam * var + noise\n            if score < best_score:\n                best_score, best_f, best_l = score, f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "max_bottleneck_flow_pair_then_best_location_aug_211": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Variation 1: Syntactic & Structural Rewriting with vectorized incremental cost.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # Unassigned facilities\n    unassigned = np.flatnonzero(a == -1)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs)\n\n    assigned_fac = np.flatnonzero(a != -1)\n    loc_of_assigned = a[assigned_fac]\n\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    if unassigned.size >= 2:\n        sub = sym_flow[np.ix_(unassigned, unassigned)]\n        np.fill_diagonal(sub, -np.inf)\n        i, _ = np.unravel_index(np.argmax(sub), sub.shape)\n        facility = int(unassigned[i])\n    else:\n        facility = int(unassigned[0])\n\n    if assigned_fac.size == 0:\n        inc_costs = np.zeros(free_locs.size)\n    else:\n        flow_to_ass = flow_matrix[facility, assigned_fac]\n        flow_from_ass = flow_matrix[assigned_fac, facility]\n        dist_fac_to_ass = distance_matrix[free_locs[:, None], loc_of_assigned]\n        dist_ass_to_fac = distance_matrix[loc_of_assigned[:, None], free_locs]\n        inc_costs = np.sum(flow_to_ass * dist_fac_to_ass + flow_from_ass * dist_ass_to_fac, axis=1)\n\n    inc_costs = np.clip(inc_costs, 0, np.square(1e4))\n\n    best_idx = np.argmin(inc_costs)\n    best_loc = int(free_locs[best_idx])\n\n    out = a.copy()\n    out[facility] = best_loc\n    return out.tolist()\n\n",
  "centrality_regret_blend_aug_212": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned_fac = np.where(a != -1)[0]\n    assigned_locs = a[assigned_fac]\n\n    eps = 1e-12\n    inv_sum = 1.0 / (distance_matrix.sum(axis=1).astype(float) + eps)\n    c = (inv_sum - inv_sum.min()) / (inv_sum.max() - inv_sum.min() + eps)\n    c = np.clip(c, 0.0, 1.0)\n\n    def compute_delta(fac, loc):\n        if assigned_fac.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[fac, assigned_fac] * distance_matrix[loc, assigned_locs] +\n                            flow_matrix[assigned_fac, fac] * distance_matrix[assigned_locs, loc]))\n\n    best_score = -np.inf\n    best_f, best_l = int(unassigned[0]), int(free_locs[0])\n\n    for f in unassigned:\n        costs = np.array([compute_delta(int(f), int(l)) for l in free_locs], dtype=float)\n        sorted_idx = np.argsort(costs)\n        l_best = int(free_locs[sorted_idx[0]])\n        regret = float(costs[sorted_idx[1]] - costs[sorted_idx[0]]) if costs.size > 1 else float(\"inf\")\n        score = regret * (0.6 + 0.4 * c[l_best])\n        noise = 1e-6 * np.sin(f * 12.9898 + l_best * 78.233)\n        score += noise\n        if score > best_score:\n            best_score = score\n            best_f, best_l = int(f), int(l_best)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "centrality_regret_blend_aug_213": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned_fac = np.where(a != -1)[0]\n    assigned_locs = a[assigned_fac]\n\n    eps = 1e-12\n    inv_sum = 1.0 / (distance_matrix.sum(axis=1).astype(float) + eps)\n    c = (inv_sum - inv_sum.min()) / (inv_sum.max() - inv_sum.min() + eps)\n    c = np.clip(c, 0.0, 1.0)\n\n    def delta(fac, loc):\n        if assigned_fac.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[fac, assigned_fac] * distance_matrix[loc, assigned_locs] +\n                            flow_matrix[assigned_fac, fac] * distance_matrix[assigned_locs, loc]))\n\n    rng = np.random.default_rng(seed=42)\n    best_f, best_l = int(unassigned[0]), int(free_locs[0])\n    best_score = -np.inf\n\n    for f in unassigned:\n        costs = np.array([delta(int(f), int(l)) for l in free_locs], dtype=float)\n        sorted_idx = np.argsort(costs)\n        top_k = min(3, costs.size)\n        top_locs = free_locs[sorted_idx[:top_k]]\n        probs = np.exp(-costs[sorted_idx[:top_k]] / (1.0 + eps))\n        probs = probs / probs.sum()\n        chosen_loc = rng.choice(top_locs, p=probs)\n        regret = float(costs[sorted_idx[1]] - costs[sorted_idx[0]]) if costs.size > 1 else float(\"inf\")\n        score = 0.5 * regret + 0.5 * c[chosen_loc]\n        if score > best_score:\n            best_score = score\n            best_f, best_l = int(f), int(chosen_loc)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "centrality_regret_blend_aug_214": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned_fac = np.where(a != -1)[0]\n    assigned_locs = a[assigned_fac]\n\n    eps = 1e-12\n    farthest = distance_matrix.max(axis=1).astype(float)\n    inv_farthest = 1.0 / (farthest + eps)\n    c = (inv_farthest - inv_farthest.min()) / (inv_farthest.max() - inv_farthest.min() + eps)\n    c = np.clip(c, 0.0, 1.0)\n\n    def delta(fac, loc):\n        if assigned_fac.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[fac, assigned_fac] * distance_matrix[loc, assigned_locs] +\n                            flow_matrix[assigned_fac, fac] * distance_matrix[assigned_locs, loc]))\n\n    best_f, best_l = int(unassigned[0]), int(free_locs[0])\n    best_score = -np.inf\n    temperature = 0.5\n\n    for f in unassigned:\n        costs = np.array([delta(int(f), int(l)) for l in free_locs], dtype=float)\n        median_cost = np.median(costs)\n        logits = -costs / (temperature + eps)\n        probs = np.exp(logits - np.max(logits))\n        probs = probs / probs.sum()\n        chosen_loc = np.random.choice(free_locs, p=probs)\n        regret = float(costs.min() - np.partition(costs, 1)[1]) if costs.size > 1 else float(\"inf\")\n        score = regret * 0.4 + (median_cost - costs.min()) * 0.6 + c[chosen_loc] * 0.1\n        noise = 1e-7 * np.cos(f * 3.14159 + chosen_loc * 2.71828)\n        score += noise\n        if score > best_score:\n            best_score = score\n            best_f, best_l = int(f), int(chosen_loc)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "centrality_regret_blend_aug_215": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned_fac = np.where(a != -1)[0]\n    assigned_locs = a[assigned_fac]\n\n    eps = 1e-12\n    max_dist = distance_matrix.max(axis=1).astype(float)\n    inv_max = 1.0 / (max_dist + eps)\n    c = (inv_max - inv_max.min()) / (inv_max.max() - inv_max.min() + eps)\n    c = np.clip(c, 0.0, 1.0)\n\n    def delta(fac, loc):\n        if assigned_fac.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[fac, assigned_fac] * distance_matrix[loc, assigned_locs] +\n                            flow_matrix[assigned_fac, fac] * distance_matrix[assigned_locs, loc]))\n\n    best_f, best_l = int(unassigned[0]), int(free_locs[0])\n    best_score = -np.inf\n\n    for f in unassigned:\n        costs = np.array([delta(int(f), int(l)) for l in free_locs], dtype=float)\n        top_k = min(5, costs.size)\n        sorted_idx = np.argsort(costs)\n        top_locs = free_locs[sorted_idx[:top_k]]\n        inv_costs = 1.0 / (costs[sorted_idx[:top_k]] + eps)\n        probs = inv_costs / inv_costs.sum()\n        chosen_loc = np.random.choice(top_locs, p=probs)\n        regret = float(costs[sorted_idx[1]] - costs[sorted_idx[0]]) if costs.size > 1 else float(\"inf\")\n        score = regret * 0.3 + (costs.max() - costs.min()) * 0.4 + c[chosen_loc] * 0.3\n        score = np.clip(score, -1e9, 1e9)\n        if score > best_score:\n            best_score = score\n            best_f, best_l = int(f), int(chosen_loc)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "farthest_location_then_max_flow_facility_aug_216": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    # Facilities that are still free\n    candidates = np.flatnonzero(assign == -1).astype(int)\n    if candidates.size == 0:\n        return assign.tolist()\n\n    # Mask of used locations\n    used_mask = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_mask[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used_mask).astype(int)\n\n    # Facilities that have already been assigned\n    assigned_fac = np.flatnonzero(assign != -1).astype(int)\n\n    # First step: nothing has been assigned yet\n    if assigned_fac.size == 0:\n        per = distance_matrix[free_locs].sum(axis=1)\n        per = np.clip(per, 0, 1e12)          # safety clip\n        # tiny deterministic noise for tie\u2011breaking\n        rng = np.random.default_rng()\n        noise = rng.uniform(-1e-9, 1e-9, size=per.shape)\n        l = int(free_locs[int(np.argmax(per + noise))])\n\n        total_flow = flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)\n        f = int(candidates[int(np.argmax(total_flow[candidates]))])\n\n        out = assign.copy()\n        out[f] = l\n        return out.tolist()\n\n    # Farthest free location (max of minimum distances)\n    min_dists = np.min(distance_matrix[np.ix_(free_locs, assign[assigned_fac])], axis=1)\n    min_dists = np.clip(min_dists, 0, 1e12)\n    rng = np.random.default_rng()\n    noise = rng.uniform(-1e-9, 1e-9, size=min_dists.shape)\n    l = int(free_locs[int(np.argmax(min_dists + noise))])\n\n    # Facility with strongest interaction to already assigned ones\n    inter = (flow_matrix[np.ix_(candidates, assigned_fac)].sum(axis=1) +\n             flow_matrix[np.ix_(assigned_fac, candidates)].sum(axis=0))\n    inter = np.clip(inter, 0, 1e12)\n    noise = rng.uniform(-1e-9, 1e-9, size=inter.shape)\n    f = int(candidates[int(np.argmax(inter + noise))])\n\n    out = assign.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "farthest_location_then_max_flow_facility_aug_217": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    used_mask = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_mask[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used_mask).astype(int)\n\n    assigned_fac = np.flatnonzero(assign != -1).astype(int)\n\n    if assigned_fac.size == 0:\n        per = distance_matrix[free_locs].sum(axis=1)\n        per = np.clip(per, 0, 1e12)\n        l = int(free_locs[int(np.argmax(per))])\n\n        total_flow = flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)\n        f = int(unassigned[int(np.argmax(total_flow[unassigned]))])\n\n        out = assign.copy()\n        out[f] = l\n        return out.tolist()\n\n    # Weighted distance metric (70% min distance, 30% mean distance)\n    min_dists = np.min(distance_matrix[np.ix_(free_locs, assign[assigned_fac])], axis=1)\n    mean_dists = np.mean(distance_matrix[np.ix_(free_locs, assign[assigned_fac])], axis=1)\n    weighted_score = 0.7 * min_dists + 0.3 * mean_dists\n    weighted_score = np.clip(weighted_score, 0, 1e12)\n\n    # Random choice among the top\u20115 candidates\n    top_k = 5\n    top_indices = np.argpartition(weighted_score, -top_k)[-top_k:]\n    chosen_idx = int(np.random.choice(top_indices))\n    l = int(free_locs[chosen_idx])\n\n    # Interaction score with weighted components\n    inter_assigned = flow_matrix[np.ix_(unassigned, assigned_fac)].sum(axis=1)\n    inter_unassigned = flow_matrix[np.ix_(assigned_fac, unassigned)].sum(axis=0)\n    inter_score = 0.6 * inter_assigned + 0.4 * inter_unassigned\n    inter_score = np.clip(inter_score, 0, 1e12)\n    f = int(unassigned[int(np.argmax(inter_score))])\n\n    out = assign.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "farthest_location_then_max_flow_facility_aug_218": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    used_mask = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_mask[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used_mask).astype(int)\n\n    assigned_fac = np.flatnonzero(assign != -1).astype(int)\n\n    if assigned_fac.size == 0:\n        per = distance_matrix[free_locs].sum(axis=1)\n        per = np.clip(per, 0, 1e12)\n        l = int(free_locs[int(np.argmax(per))])\n\n        total_flow = flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)\n        f = int(unassigned[int(np.argmax(total_flow[unassigned]))])\n\n        out = assign.copy()\n        out[f] = l\n        return out.tolist()\n\n    # Median distance metric\n    dist_sub = distance_matrix[np.ix_(free_locs, assign[assigned_fac])]\n    median_dist = np.median(dist_sub, axis=1)\n    median_dist = np.clip(median_dist, 0, 1e12)\n    rng = np.random.default_rng()\n    noise = rng.uniform(-1e-9, 1e-9, size=median_dist.shape)\n    l = int(free_locs[int(np.argmax(median_dist + noise))])\n\n    # Max interaction metric\n    inter = (flow_matrix[np.ix_(unassigned, assigned_fac)].max(axis=1) +\n             flow_matrix[np.ix_(assigned_fac, unassigned)].max(axis=0))\n    inter = np.clip(inter, 0, 1e12)\n    f = int(unassigned[int(np.argmax(inter))])\n\n    out = assign.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "farthest_location_then_max_flow_facility_aug_219": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    unassigned = np.flatnonzero(assign == -1).astype(int)\n    if unassigned.size == 0:\n        return assign.tolist()\n\n    used_mask = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_mask[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used_mask).astype(int)\n\n    assigned_fac = np.flatnonzero(assign != -1).astype(int)\n\n    if assigned_fac.size == 0:\n        per = distance_matrix[free_locs].sum(axis=1)\n        per = np.clip(per, 0, 1e12)\n        l = int(free_locs[int(np.argmax(per))])\n\n        total_flow = flow_matrix.sum(axis=0) + flow_matrix.sum(axis=1)\n        f = int(unassigned[int(np.argmax(total_flow[unassigned]))])\n\n        out = assign.copy()\n        out[f] = l\n        return out.tolist()\n\n    # Squared distance metric (proxy approximation)\n    sub_dist = distance_matrix[np.ix_(free_locs, assign[assigned_fac])]\n    min_sq = np.min(np.square(sub_dist), axis=1)\n    min_sq = np.clip(min_sq, 0, 1e12)\n\n    # Random choice among the top\u20113 candidates\n    top_k = 3\n    top_indices = np.argpartition(min_sq, -top_k)[-top_k:]\n    chosen_idx = int(np.random.choice(top_indices))\n    l = int(free_locs[chosen_idx])\n\n    # Interaction via sum but scaled\n    inter = flow_matrix[np.ix_(unassigned, assigned_fac)].sum(axis=1) + \\\n            flow_matrix[np.ix_(assigned_fac, unassigned)].sum(axis=0)\n    inter = np.clip(inter, 0, 1e12)\n    f = int(unassigned[int(np.argmax(inter))])\n\n    out = assign.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "degree_corrected_flow_then_place_aug_220": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy assignment that iteratively picks the facility with the highest\n    (flow to already assigned)/(1+flow to unassigned) ratio and then chooses\n    the location that yields the minimal incremental cost.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Find unassigned facilities and free locations\n    unassigned_fac = np.flatnonzero(a == -1).astype(int)\n    if unassigned_fac.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if a.any():\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    # Symmetric flow matrix for convenience\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # Facilities already assigned\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_locs = a[assigned_fac].astype(int)\n\n    if assigned_fac.size == 0:\n        # No facility assigned yet \u2013 pick the one with the largest total flow\n        total_flow = sym_flow[unassigned_fac].sum(axis=1)\n        chosen_fac = int(unassigned_fac[np.argmax(total_flow)])\n    else:\n        # Compute scores for each candidate facility\n        to_ass = sym_flow[np.ix_(unassigned_fac, assigned_fac)].sum(axis=1)\n        to_un   = sym_flow[np.ix_(unassigned_fac, unassigned_fac)].sum(axis=1)\n        denom   = 1.0 + to_un + 1e-12          # epsilon to avoid div\u2011by\u2011zero\n        score   = to_ass / denom\n        chosen_fac = int(unassigned_fac[np.argmax(score)])\n\n    # Find the best free location for the chosen facility\n    best_loc = free_locs[0]\n    best_inc = float(\"inf\")\n    f = chosen_fac\n    for l in free_locs.astype(int):\n        inc = 0.0\n        if assigned_fac.size > 0:\n            inc = float(np.sum(\n                flow_matrix[f, assigned_fac] * distance_matrix[l, assigned_locs] +\n                flow_matrix[assigned_fac, f] * distance_matrix[assigned_locs, l]\n            ))\n        if inc < best_inc:\n            best_inc, best_loc = inc, int(l)\n\n    out = a.copy()\n    out[chosen_fac] = best_loc\n    return out.tolist()\n\n",
  "degree_corrected_flow_then_place_aug_221": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant that uses a weighted score with a small random tie\u2011breaker\n    and selects the top\u2011k candidates before final greedy choice.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a.any():\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    if assigned.size == 0:\n        mass = sym[unassigned].sum(axis=1)\n        idx = int(unassigned[np.argmax(mass)])\n    else:\n        to_ass = sym[np.ix_(unassigned, assigned)].sum(axis=1)\n        to_un   = sym[np.ix_(unassigned, unassigned)].sum(axis=1)\n        denom   = 1.0 + to_un + 1e-12\n        # 0.7 weight for to_ass, 0.3 for to_un\n        score = 0.7 * to_ass / denom + 0.3 * (1.0 / (1.0 + denom))\n        # Add tiny noise for deterministic tie\u2011breaking\n        noise = np.random.uniform(-1e-6, 1e-6, size=score.shape)\n        score += noise\n        # Take top\u2011k (k=5) candidates\n        k = 5\n        topk_idx = np.argpartition(-score, k-1)[:k]\n        chosen = int(unassigned[np.argmax(score[topk_idx])])\n\n    best_l = free[0]\n    best = float(\"inf\")\n    f = chosen\n    for l in free.astype(int):\n        inc = 0.0\n        if assigned.size > 0:\n            inc = float(np.sum(\n                flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                flow_matrix[assigned, f] * distance_matrix[locs, l]\n            ))\n        if inc < best:\n            best, best_l = inc, int(l)\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "degree_corrected_flow_then_place_aug_222": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Soft\u2011minimum variant: computes a soft\u2011min over candidate facilities\n    and then randomly selects one among the top\u20113.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a.any():\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    if assigned.size == 0:\n        total = sym[candidates].sum(axis=1)\n        idx = int(candidates[np.argmax(total)])\n    else:\n        to_ass = sym[np.ix_(candidates, assigned)].sum(axis=1)\n        to_un   = sym[np.ix_(candidates, candidates)].sum(axis=1)\n        denom   = 1.0 + to_un + 1e-12\n        # soft\u2011min: use negative exponential\n        score = -np.exp(-to_ass / denom)\n        # Randomly pick one among top\u20113 lowest scores\n        top3 = np.argpartition(score, 2)[:3]\n        chosen = int(candidates[np.random.choice(top3)])\n\n    best_l = free[0]\n    best = float(\"inf\")\n    f = chosen\n    for l in free.astype(int):\n        inc = 0.0\n        if assigned.size > 0:\n            inc = float(np.sum(\n                flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                flow_matrix[assigned, f] * distance_matrix[locs, l]\n            ))\n        if inc < best:\n            best, best_l = inc, int(l)\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "degree_corrected_flow_then_place_aug_223": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Median\u2011based aggregation variant that clips intermediate values\n    to keep them bounded and uses a deterministic tie\u2011breaker.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if a.any():\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    if assigned.size == 0:\n        mass = sym[unassigned].sum(axis=1)\n        idx = int(unassigned[np.argmax(mass)])\n    else:\n        to_ass = sym[np.ix_(unassigned, assigned)].sum(axis=1)\n        to_un   = sym[np.ix_(unassigned, unassigned)].sum(axis=1)\n        denom   = 1.0 + to_un + 1e-12\n        # Use median of scores instead of mean\n        score = np.median(to_ass / denom)\n        # Clip score between 0 and 1\n        score = np.clip(score, 0.0, 1.0)\n        # Deterministic tie\u2011breaker: add small integer based on index\n        tie_break = np.arange(unassigned.size) * 1e-7\n        score_vec = to_ass / denom + tie_break\n        idx = int(unassigned[np.argmax(score_vec)])\n\n    best_l = free_locs[0]\n    best = float(\"inf\")\n    f = idx\n    for l in free_locs.astype(int):\n        inc = 0.0\n        if assigned.size > 0:\n            inc = float(np.sum(\n                flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                flow_matrix[assigned, f] * distance_matrix[locs, l]\n            ))\n        if inc < best:\n            best, best_l = inc, int(l)\n\n    out = a.copy()\n    out[f] = best_l\n    return out.tolist()\n\n",
  "triadic_closure_anchor_aug_224": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n    candidates = np.flatnonzero(assign == -1).astype(int)\n    if candidates.size == 0:\n        return assign.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_locs[assign[assign != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    assigned_fac = np.flatnonzero(assign != -1).astype(int)\n    if assigned_fac.size < 2:\n        locs = assign[assigned_fac].astype(int)\n        best = float(\"inf\")\n        best_f = int(candidates[0])\n        best_l = int(free_locs[0])\n        for f in candidates.astype(int):\n            for l in free_locs.astype(int):\n                inc = 0.0 if assigned_fac.size == 0 else float(\n                    np.sum(flow_matrix[f, assigned_fac] * distance_matrix[l, locs] +\n                           flow_matrix[assigned_fac, f] * distance_matrix[locs, l]))\n                if inc < best:\n                    best, best_f, best_l = inc, int(f), int(l)\n        out = assign.copy()\n        out[best_f] = best_l\n        return out.tolist()\n\n    locs = assign[assigned_fac].astype(int)\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    scores = np.zeros(candidates.size, dtype=float)\n    top2_idx = np.zeros((candidates.size, 2), dtype=int)\n    for i, f in enumerate(candidates):\n        vals = sym[int(f), assigned_fac].astype(float)\n        idx = np.argsort(-vals)[:2]\n        scores[i] = float(vals[idx].sum())\n        top2_idx[i, :] = idx\n\n    i = int(np.argmax(scores))\n    f = int(candidates[i])\n    a1 = int(assigned_fac[top2_idx[i, 0]])\n    a2 = int(assigned_fac[top2_idx[i, 1]])\n    l1 = int(assign[a1])\n    l2 = int(assign[a2])\n\n    dsum = (distance_matrix[free_locs, l1] + distance_matrix[free_locs, l2]).astype(float) + 1e-12\n    dsum = np.clip(dsum, 0, None)\n    l = int(free_locs[int(np.argmin(dsum))])\n\n    out = assign.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "eigen_embedding_match_remaining_aug_225": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Embed remaining facilities/locations into 1\u2011D via eigenvectors;\n    match the most extreme facility with the nearest location.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # Indices of unassigned facilities and free locations\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_nodes = np.where(~used)[0]\n\n    # --- Flow Laplacian (Fiedler vector) ------------------------------------\n    W = (flow_matrix + flow_matrix.T).astype(float)\n    L = np.diag(W.sum(axis=1)) - W\n    vals, vecs = np.linalg.eigh(L)\n    vf = vecs[:, 1] if vals.size >= 2 else vecs[:, 0]\n    vf = (vf - vf.min()) / (vf.max() - vf.min() + 1e-12)\n\n    # --- Distance similarity Laplacian --------------------------------------\n    S = 1.0 / (distance_matrix.astype(float) + 1e-6)\n    Ls = np.diag(S.sum(axis=1)) - S\n    vals2, vecs2 = np.linalg.eigh(Ls)\n    vl = vecs2[:, 1] if vals2.size >= 2 else vecs2[:, 0]\n    vl = (vl - vl.min()) / (vl.max() - vl.min() + 1e-12)\n\n    # --- Select facility -----------------------------------------------------\n    diff = np.abs(vf[unassigned] - 0.5)\n    # deterministic tie\u2011breaker: tiny increasing noise\n    noise = np.arange(unassigned.size) * 1e-9\n    idx_f = unassigned[np.argmax(diff + noise)]\n    target = vf[idx_f]\n\n    # --- Select location -----------------------------------------------------\n    dist = np.abs(vl[free_nodes] - target)\n    dist += np.arange(free_nodes.size) * 1e-9  # tie\u2011breaker\n    idx_l = free_nodes[np.argmin(dist)]\n\n    a[idx_f] = idx_l\n    return a.tolist()\n\n",
  "eigen_embedding_match_remaining_aug_226": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Use a soft\u2011min strategy for picking the location and a top\u2011k random\n    selection among the nearest candidates.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.shape[0]\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_mask = np.zeros(n, dtype=bool)\n    used_mask[a[a != -1]] = True\n    free_nodes = np.where(~used_mask)[0]\n\n    # Flow embedding (second eigenvector)\n    W = (flow_matrix + flow_matrix.T).astype(float)\n    L = np.diag(W.sum(axis=1)) - W\n    vals, vecs = np.linalg.eigh(L)\n    vf = vecs[:, 1] if vals.size > 1 else vecs[:, 0]\n    vf = (vf - vf.min()) / (vf.max() - vf.min() + 1e-12)\n\n    # Distance similarity embedding\n    S = 1.0 / (distance_matrix.astype(float) + 1e-6)\n    Ls = np.diag(S.sum(axis=1)) - S\n    vals2, vecs2 = np.linalg.eigh(Ls)\n    vl = vecs2[:, 1] if vals2.size > 1 else vecs2[:, 0]\n    vl = (vl - vl.min()) / (vl.max() - vl.min() + 1e-12)\n\n    # Facility with most extreme embedding\n    extremes = np.abs(vf[unassigned] - 0.5)\n    idx_f = unassigned[np.argmax(extremes)]\n    target = vf[idx_f]\n\n    # Distances to free locations\n    dist = np.abs(vl[free_nodes] - target)\n\n    # Soft\u2011min selection with temperature \u03b1\n    alpha = 4.0\n    weights = np.exp(-alpha * dist)\n    probs = weights / (weights.sum() + 1e-12)  # \u03b5\u2011safe division\n    idx_l = np.random.choice(free_nodes, p=probs)\n\n    a[idx_f] = idx_l\n    return a.tolist()\n\n",
  "eigen_embedding_match_remaining_aug_227": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Use vectorised operations, invert some conditionals, and\n    apply deterministic tie\u2011breaking via np.max.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free_nodes = np.where(~used)[0]\n\n    # Flow Laplacian and its second eigenvector\n    W = (flow_matrix + flow_matrix.T).astype(float)\n    L = np.diag(W.sum(axis=1)) - W\n    vals, vecs = np.linalg.eigh(L)\n    vf = vecs[:, 1] if vals.size > 1 else vecs[:, 0]\n    vf = (vf - vf.min()) / (vf.max() - vf.min() + 1e-12)\n\n    # Distance similarity Laplacian\n    S = 1.0 / (distance_matrix.astype(float) + 1e-6)\n    Ls = np.diag(S.sum(axis=1)) - S\n    vals2, vecs2 = np.linalg.eigh(Ls)\n    vl = vecs2[:, 1] if vals2.size > 1 else vecs2[:, 0]\n    vl = (vl - vl.min()) / (vl.max() - vl.min() + 1e-12)\n\n    # Facility with extreme embedding (use np.max for tie\u2011breaking)\n    extremes = np.abs(vf[unassigned] - 0.5)\n    # tiny increasing noise via np.linspace to break ties deterministically\n    noise = np.linspace(0, 1e-9, extremes.size)\n    idx_f = unassigned[np.argmax(extremes + noise)]\n    target = vf[idx_f]\n\n    # Distances to free locations\n    dist = np.abs(vl[free_nodes] - target)\n\n    # Choose the nearest location; if ties, pick the one with the largest index\n    min_dist = dist.min()\n    candidates = free_nodes[dist <= min_dist + 1e-9]\n    idx_l = candidates.max()\n\n    a[idx_f] = idx_l\n    return a.tolist()\n\n",
  "robust_trimmed_mean_incremental_aug_228": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    assigned_locs = a[assigned].astype(int)\n\n    trim = 0.25\n    best_score = np.inf\n    best_f, best_l = candidates[0], free_locs[0]\n\n    for f in candidates:\n        for l in free_locs:\n            if assigned.size == 0:\n                score = 0.0\n            else:\n                v = (flow_matrix[f, assigned] * distance_matrix[l, assigned_locs] +\n                     flow_matrix[assigned, f] * distance_matrix[assigned_locs, l]).astype(float)\n                v_sorted = np.sort(v)\n                k = int(np.floor(trim * v_sorted.size))\n                if v_sorted.size - 2 * k <= 0:\n                    tmean = float(v_sorted.mean())\n                else:\n                    tmean = float(v_sorted[k:-k].mean())\n                tmean = np.clip(tmean, 1e-12, None)\n                denom = (tmean * v.size + 1e-12)\n                score = tmean * float(v.sum() / denom)\n            if score < best_score:\n                best_score, best_f, best_l = score, f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "greedy_with_location_sparsity_penalty_aug_229": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy incremental cost with a soft\u2011min selection and median proximity.\"\"\"\n    flow, dist = flow_matrix, distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # indices of still unassigned facilities\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    # indices of already used locations\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # already assigned facilities and their locations\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    lam = 0.30  # penalty weight\n\n    # ----- incremental cost for every free location -----\n    if ass.size == 0:\n        inc = np.zeros(free.size, dtype=float)\n    else:\n        inc_part1 = flow[un[:, None], ass] * dist[free[:, None], locs]\n        inc_part2 = flow[ass[None, :], un[:, None]] * dist[locs[None, :], free[:, None]]\n        inc = np.sum(inc_part1 + inc_part2, axis=1)\n\n    # ----- proximity penalty -----\n    if ass.size == 0:\n        prox = np.median(dist[free], axis=1)\n    else:\n        dmin = np.min(dist[free[:, None], locs], axis=1)\n        prox = 1.0 / (dmin + 1e-12)          # epsilon to avoid division by zero\n\n    # ----- scoring -----\n    score = inc + lam * prox * (np.abs(inc) + 1.0)\n\n    # deterministic noise to break ties\n    noise = np.arange(free.size) * 1e-8\n    score += noise\n\n    best_idx = np.argmin(score)\n    best_f = int(un[0])          # only one facility is chosen in each call\n    best_l = int(free[best_idx])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "greedy_with_location_sparsity_penalty_aug_230": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Top\u2011k weighted selection with deterministic tie\u2011breaking.\"\"\"\n    flow, dist = flow_matrix, distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    lam = 0.45  # tuned penalty weight\n    top_k = 5   # number of top candidates to consider\n\n    if ass.size == 0:\n        inc = np.zeros(free.size, dtype=float)\n    else:\n        inc_part1 = flow[un[:, None], ass] * dist[free[:, None], locs]\n        inc_part2 = flow[ass[None, :], un[:, None]] * dist[locs[None, :], free[:, None]]\n        inc = np.sum(inc_part1 + inc_part2, axis=1)\n\n    if ass.size == 0:\n        prox = np.median(dist[free], axis=1)\n    else:\n        dmin = np.min(dist[free[:, None], locs], axis=1)\n        prox = 1.0 / (dmin + 1e-12)\n\n    score = inc + lam * prox * (np.abs(inc) + 1.0)\n\n    # deterministic noise for reproducible tie breaking\n    rng = np.random.default_rng(seed=int(np.sum(a)) + 1)\n    noise = rng.random(score.shape) * 1e-8\n    score += noise\n\n    # choose among the top\u2011k lowest scores\n    idx_sorted = np.argsort(score)\n    candidates = idx_sorted[:min(top_k, len(idx_sorted))]\n    chosen_idx = candidates[0]  # deterministic selection of the best among the top\u2011k\n\n    best_f = int(un[0])\n    best_l = int(free[chosen_idx])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "greedy_with_location_sparsity_penalty_aug_231": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"While\u2011loop based implementation with max\u2011based aggregation.\"\"\"\n    flow, dist = flow_matrix, distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    lam = 0.35\n    best_score = np.inf\n    best_f = int(un[0])\n    best_l = int(free[0])\n\n    idx_f = 0\n    while idx_f < un.size:\n        f = int(un[idx_f])\n        idx_l = 0\n        while idx_l < free.size:\n            l = int(free[idx_l])\n\n            if ass.size == 0:\n                inc = 0.0\n                prox = np.median(dist[l])\n            else:\n                inc = np.max(flow[f, ass] * dist[l, locs] +\n                             flow[ass, f] * dist[locs, l])\n                dmin = np.min(dist[l, locs])\n                prox = 1.0 / (dmin + 1e-12)\n\n            score = inc + lam * prox * (np.abs(inc) + 1.0)\n\n            if score < best_score:\n                best_score = score\n                best_f = f\n                best_l = l\n\n            idx_l += 1\n        idx_f += 1\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "greedy_with_location_sparsity_penalty_aug_232": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Approximate proximity with min\u2011distance proxy and random top\u2011k choice.\"\"\"\n    flow, dist = flow_matrix, distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    lam = 0.25\n    top_k = 7\n\n    if ass.size == 0:\n        inc = np.zeros(free.size, dtype=float)\n    else:\n        inc_part1 = flow[un[:, None], ass] * dist[free[:, None], locs]\n        inc_part2 = flow[ass[None, :], un[:, None]] * dist[locs[None, :], free[:, None]]\n        inc = np.sum(inc_part1 + inc_part2, axis=1)\n\n    # proxy proximity: use inverse of minimal distance to already used locations\n    if ass.size == 0:\n        prox = np.median(dist[free], axis=1)\n    else:\n        dmin = np.min(dist[free[:, None], locs], axis=1)\n        prox = 1.0 / (dmin + 1e-12)\n\n    score = inc + lam * prox * (np.abs(inc) + 1.0)\n\n    # clip to avoid overflow\n    score = np.clip(score, 0, 1e6)\n\n    rng = np.random.default_rng(seed=int(np.sum(a)) + 2)\n    idx_sorted = np.argsort(score)\n    top_candidates = idx_sorted[:min(top_k, len(idx_sorted))]\n    chosen_idx = rng.choice(top_candidates)\n\n    best_f = int(un[0])\n    best_l = int(free[chosen_idx])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "progressive_beam_top_pairs_aug_233": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 1: Heavy syntactic rewrite.\n    \u2022 Renamed variables (flow_matrix \u2192 flow_mat, distance_matrix \u2192 dist_mat).\n    \u2022 Replaced inner loops with vectorised computations.\n    \u2022 Used while\u2011loop for beam expansion.\n    \u2022 Added epsilon to denominators and used np.clip where necessary.\n    \"\"\"\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n    # Find unassigned facilities\n    unassigned = np.flatnonzero(a0 == -1).astype(int)\n    if unassigned.size == 0:\n        return a0.tolist()\n\n    # Track used locations\n    used = np.zeros(n, dtype=bool)\n    if a0.any() and (a0 != -1).any():\n        used[a0[a0 != -1]] = True\n    free_loc = np.flatnonzero(~used).astype(int)\n\n    # Current assignments\n    assigned_fac = np.flatnonzero(a0 != -1).astype(int)\n    assigned_loc = a0[assigned_fac].astype(int)\n\n    def incremental_cost(a: np.ndarray, f: int, l: int) -> float:\n        if assigned_fac.size == 0:\n            return 0.0\n        # Vectorised incremental cost\n        f = int(f)\n        l = int(l)\n        return float(\n            np.sum(flow_mat[f, assigned_fac] * dist_mat[l, assigned_loc]) +\n            np.sum(flow_mat[assigned_fac, f] * dist_mat[assigned_loc, l])\n        )\n\n    progress = 1.0 - (unassigned.size / max(1, n + 1e-12))\n    beam_width = int(max(3, min(12, 3 + round(12 * (1.0 - progress)))))\n\n    # Build all candidate pairs and costs\n    cand_f, cand_l = np.meshgrid(unassigned, free_loc, indexing='ij')\n    cand_f = cand_f.ravel()\n    cand_l = cand_l.ravel()\n    costs = np.array([incremental_cost(a0, f, l) for f, l in zip(cand_f, cand_l)])\n\n    # Sort and keep top beam_width * 4 candidates\n    top_idx = np.argsort(costs)[:min(len(costs), beam_width * 4)]\n    cand = list(zip(cand_f[top_idx], cand_l[top_idx]))\n\n    best_score = float(\"inf\")\n    best_pair = cand[0]\n\n    # Beam expansion with while loop\n    idx = 0\n    while idx < len(cand):\n        f, l = cand[idx]\n        a1 = a0.copy()\n        a1[f] = l\n        un1 = np.flatnonzero(a1 == -1).astype(int)\n        used1 = np.zeros(n, dtype=bool)\n        used1[a1[a1 != -1]] = True\n        free1 = np.flatnonzero(~used1).astype(int)\n\n        inc1 = incremental_cost(a0, f, l)\n        if un1.size == 0 or free1.size == 0:\n            score = inc1\n        else:\n            # Find best next incremental cost\n            next_costs = [incremental_cost(a1, f2, l2) for f2 in un1 for l2 in free1]\n            best_next = min(next_costs) if next_costs else 0.0\n            score = inc1 + 0.25 * best_next\n\n        if score < best_score:\n            best_score = score\n            best_pair = (f, l)\n        idx += 1\n\n    out = a0.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n\n",
  "progressive_beam_top_pairs_aug_234": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 2: Parameter tuning & softmin selection.\n    \u2022 Weight for future cost increased from 0.25 to 0.5.\n    \u2022 Top_k increased to 7.\n    \u2022 Added deterministic noise for tie\u2011breaking.\n    \u2022 Softmin (exponential) used instead of strict argmin.\n    \u2022 Epsilon added to denominators and np.clip used on probabilities.\n    \"\"\"\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n    unassigned = np.flatnonzero(a0 == -1).astype(int)\n    if unassigned.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a0.any() and (a0 != -1).any():\n        used[a0[a0 != -1]] = True\n    free_loc = np.flatnonzero(~used).astype(int)\n\n    assigned_fac = np.flatnonzero(a0 != -1).astype(int)\n    assigned_loc = a0[assigned_fac].astype(int)\n\n    def inc_cost(a: np.ndarray, f: int, l: int) -> float:\n        if assigned_fac.size == 0:\n            return 0.0\n        return float(\n            np.sum(flow_mat[f, assigned_fac] * dist_mat[l, assigned_loc]) +\n            np.sum(flow_mat[assigned_fac, f] * dist_mat[assigned_loc, l])\n        )\n\n    progress = 1.0 - (unassigned.size / max(1, n + 1e-12))\n    beam_width = int(max(3, min(12, 3 + round(12 * (1.0 - progress)))))\n\n    # Generate all pairs\n    cand_f, cand_l = np.meshgrid(unassigned, free_loc, indexing='ij')\n    cand_f = cand_f.ravel()\n    cand_l = cand_l.ravel()\n    costs = np.array([inc_cost(a0, f, l) for f, l in zip(cand_f, cand_l)])\n\n    # Add deterministic noise\n    noise = 1e-6 * np.arange(costs.size)\n    costs_noisy = costs + noise\n\n    top_k = min(len(costs_noisy), beam_width * 4)\n    top_idx = np.argpartition(costs_noisy, top_k)[:top_k]\n    cand = list(zip(cand_f[top_idx], cand_l[top_idx]))\n\n    best_score = float(\"inf\")\n    best_pair = cand[0]\n\n    for f, l in cand:\n        a1 = a0.copy()\n        a1[f] = l\n        un1 = np.flatnonzero(a1 == -1).astype(int)\n        used1 = np.zeros(n, dtype=bool)\n        used1[a1[a1 != -1]] = True\n        free1 = np.flatnonzero(~used1).astype(int)\n\n        inc1 = inc_cost(a0, f, l)\n        if un1.size == 0 or free1.size == 0:\n            score = inc1\n        else:\n            next_costs = [inc_cost(a1, f2, l2) for f2 in un1 for l2 in free1]\n            best_next = min(next_costs) if next_costs else 0.0\n            score = inc1 + 0.5 * best_next  # increased weight\n\n        if score < best_score:\n            best_score = score\n            best_pair = (f, l)\n\n    # Softmin selection among top candidates\n    scores = np.array([inc_cost(a0, f, l) for f, l in cand])\n    alpha = 10.0\n    probs = np.exp(-alpha * scores)\n    probs = np.clip(probs, 1e-12, None)\n    probs = probs / (np.sum(probs) + 1e-12)\n    chosen_idx = np.random.choice(len(cand), p=probs)\n    best_pair = cand[chosen_idx]\n\n    out = a0.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n\n",
  "progressive_beam_top_pairs_aug_235": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 3: Proxy approximations and median aggregation.\n    \u2022 Uses np.max instead of np.sum for incremental cost.\n    \u2022 Median used for beam selection.\n    \u2022 Random choice among top\u2011k for tie\u2011breaking.\n    \u2022 Epsilon added to denominators, np.clip used on bounds.\n    \"\"\"\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n    unassigned = np.flatnonzero(a0 == -1).astype(int)\n    if unassigned.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a0.any() and (a0 != -1).any():\n        used[a0[a0 != -1]] = True\n    free_loc = np.flatnonzero(~used).astype(int)\n\n    assigned_fac = np.flatnonzero(a0 != -1).astype(int)\n    assigned_loc = a0[assigned_fac].astype(int)\n\n    def inc_cost(a: np.ndarray, f: int, l: int) -> float:\n        if assigned_fac.size == 0:\n            return 0.0\n        return float(\n            np.max(flow_mat[f, assigned_fac] * dist_mat[l, assigned_loc]) +\n            np.max(flow_mat[assigned_fac, f] * dist_mat[assigned_loc, l])\n        )\n\n    progress = 1.0 - (unassigned.size / max(1, n + 1e-12))\n    beam_width = int(max(3, min(12, 3 + round(12 * (1.0 - progress)))))\n\n    cand_f, cand_l = np.meshgrid(unassigned, free_loc, indexing='ij')\n    cand_f = cand_f.ravel()\n    cand_l = cand_l.ravel()\n    costs = np.array([inc_cost(a0, f, l) for f, l in zip(cand_f, cand_l)])\n\n    # Median based top selection\n    median_cost = np.median(costs)\n    mask = costs <= median_cost\n    cand = list(zip(cand_f[mask], cand_l[mask]))\n\n    best_score = float(\"inf\")\n    best_pair = cand[0] if cand else (unassigned[0], free_loc[0])\n\n    for f, l in cand:\n        a1 = a0.copy()\n        a1[f] = l\n        un1 = np.flatnonzero(a1 == -1).astype(int)\n        used1 = np.zeros(n, dtype=bool)\n        used1[a1[a1 != -1]] = True\n        free1 = np.flatnonzero(~used1).astype(int)\n\n        inc1 = inc_cost(a0, f, l)\n        if un1.size == 0 or free1.size == 0:\n            score = inc1\n        else:\n            next_costs = [inc_cost(a1, f2, l2) for f2 in un1 for l2 in free1]\n            best_next = min(next_costs) if next_costs else 0.0\n            score = inc1 + 0.25 * best_next\n\n        if score < best_score:\n            best_score = score\n            best_pair = (f, l)\n\n    # Random tie\u2011breaking among top 5 if multiple best\n    top_candidates = [cand for cand in cand if abs(inc_cost(a0, *cand) - best_score) < 1e-6]\n    chosen_pair = np.random.choice(top_candidates) if top_candidates else best_pair\n\n    out = a0.copy()\n    out[chosen_pair[0]] = chosen_pair[1]\n    return out.tolist()\n\n",
  "progressive_beam_top_pairs_aug_236": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 4: Mixed rewriting, random tie\u2011breaking, and modified beam width.\n    \u2022 Uses while\u2011loops for candidate generation.\n    \u2022 Beam width depends on a different heuristic.\n    \u2022 Random choice among top\u2011k when scores are equal.\n    \u2022 Added epsilon and np.clip where needed.\n    \"\"\"\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n    unassigned = np.flatnonzero(a0 == -1).astype(int)\n    if unassigned.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a0.any() and (a0 != -1).any():\n        used[a0[a0 != -1]] = True\n    free_loc = np.flatnonzero(~used).astype(int)\n\n    assigned_fac = np.flatnonzero(a0 != -1).astype(int)\n    assigned_loc = a0[assigned_fac].astype(int)\n\n    def inc_cost(a: np.ndarray, f: int, l: int) -> float:\n        if assigned_fac.size == 0:\n            return 0.0\n        return float(\n            np.sum(flow_mat[f, assigned_fac] * dist_mat[l, assigned_loc]) +\n            np.sum(flow_mat[assigned_fac, f] * dist_mat[assigned_loc, l])\n        )\n\n    progress = 1.0 - (unassigned.size / max(1, n + 1e-12))\n    # New beam width heuristic: inversely proportional to remaining steps\n    beam_width = int(max(3, min(12, 4 + round(8 * progress))))\n\n    # Generate candidates with while loop\n    cand = []\n    idx_f = 0\n    while idx_f < unassigned.size:\n        f = int(unassigned[idx_f])\n        idx_l = 0\n        while idx_l < free_loc.size:\n            l = int(free_loc[idx_l])\n            cand.append((f, l))\n            idx_l += 1\n        idx_f += 1\n\n    costs = np.array([inc_cost(a0, f, l) for f, l in cand])\n    top_k = min(len(costs), beam_width * 3)\n    top_idx = np.argpartition(costs, top_k)[:top_k]\n    cand = [cand[i] for i in top_idx]\n\n    best_score = float(\"inf\")\n    best_pair = cand[0] if cand else (unassigned[0], free_loc[0])\n\n    for f, l in cand:\n        a1 = a0.copy()\n        a1[f] = l\n        un1 = np.flatnonzero(a1 == -1).astype(int)\n        used1 = np.zeros(n, dtype=bool)\n        used1[a1[a1 != -1]] = True\n        free1 = np.flatnonzero(~used1).astype(int)\n\n        inc1 = inc_cost(a0, f, l)\n        if un1.size == 0 or free1.size == 0:\n            score = inc1\n        else:\n            next_costs = [inc_cost(a1, f2, l2) for f2 in un1 for l2 in free1]\n            best_next = min(next_costs) if next_costs else 0.0\n            score = inc1 + 0.25 * best_next\n\n        if score < best_score:\n            best_score = score\n            best_pair = (f, l)\n\n    # Random tie\u2011breaking among candidates with identical best score\n    tied = [c for c in cand if abs(inc_cost(a0, *c) - best_score) < 1e-6]\n    chosen_pair = np.random.choice(tied) if tied else best_pair\n\n    out = a0.copy()\n    out[chosen_pair[0]] = chosen_pair[1]\n    return out.tolist()\n\n",
  "min_incremental_using_flow_normalization_aug_237": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy selection with degree\u2011normalised flows and deterministic tie\u2011breaking noise.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Unassigned facilities\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Occupied locations\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    free_locs = np.flatnonzero(~occupied).astype(int)\n\n    # Already assigned facilities and their locations\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    # Degree\u2011based normalisation (avoid division by zero)\n    deg_out = flow_matrix.sum(axis=1).astype(float) + 1e-12\n    deg_in  = flow_matrix.sum(axis=0).astype(float) + 1e-12\n\n    best_cost = float(\"inf\")\n    best_f, best_l = int(candidates[0]), int(free_locs[0])\n\n    # Tiny deterministic noise for tie\u2011breaking\n    noise_scale = 1e-8\n    for idx_f, f in enumerate(candidates):\n        for idx_l, l in enumerate(free_locs):\n            if assigned_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(\n                    np.sum(\n                        (flow_matrix[f, assigned_fac] / deg_out[f]) * distance_matrix[l, assigned_loc]\n                        + (flow_matrix[assigned_fac, f] / deg_in[f]) * distance_matrix[assigned_loc, l]\n                    )\n                )\n            inc += noise_scale * (idx_f * free_locs.size + idx_l)  # deterministic tie\u2011break\n            if inc < best_cost:\n                best_cost, best_f, best_l = inc, int(f), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_using_flow_normalization_aug_238": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Top\u2011k cost selection with a deterministic random choice among the best candidates.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Facilities still free to assign\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Locations already taken\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    free_locs = np.flatnonzero(~occupied).astype(int)\n\n    # Assigned facilities and their locations\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    deg_out = flow_matrix.sum(axis=1).astype(float) + 1e-12\n    deg_in  = flow_matrix.sum(axis=0).astype(float) + 1e-12\n\n    # Build full cost matrix for all candidate pairs\n    cost_mat = np.full((candidates.size, free_locs.size), np.inf, dtype=float)\n    for i, f in enumerate(candidates):\n        for j, l in enumerate(free_locs):\n            if assigned_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(\n                    np.sum(\n                        (flow_matrix[f, assigned_fac] / deg_out[f]) * distance_matrix[l, assigned_loc]\n                        + (flow_matrix[assigned_fac, f] / deg_in[f]) * distance_matrix[assigned_loc, l]\n                    )\n                )\n            cost_mat[i, j] = inc\n\n    # Choose top_k cheapest pairs and pick one deterministically\n    top_k = 7\n    flat_idx = np.argpartition(cost_mat.ravel(), top_k)[:top_k]\n    rng = np.random.default_rng(42)\n    chosen = rng.choice(flat_idx, size=1, replace=False)[0]\n    best_f = int(candidates[chosen // free_locs.size])\n    best_l = int(free_locs[chosen % free_locs.size])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "location_kmedoids_seed_then_best_facility_aug_239": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n    candidates = np.where(cur == -1)[0]\n    if candidates.size == 0:\n        return cur.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(cur != -1):\n        used[cur[cur != -1]] = True\n    free_locs = np.where(~used)[0]\n\n    # Medoid based on median distance among free locations\n    if free_locs.size > 1:\n        D = distance_matrix[np.ix_(free_locs, free_locs)].astype(float)\n        median_dist = np.median(D, axis=1)\n        l = free_locs[np.argmin(median_dist)]\n    else:\n        l = free_locs[0]\n\n    assigned = np.where(cur != -1)[0]\n    locs = cur[assigned].astype(int)\n\n    # Incremental cost for each candidate facility\n    flow_tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    inc = np.zeros(flow_matrix.shape[0], dtype=float)\n    if assigned.size > 0:\n        inc = np.sum(flow_matrix[:, assigned] * distance_matrix[l, locs] +\n                     flow_matrix[assigned, :].T * distance_matrix[locs, l], axis=1)\n    # Mask non\u2011candidates\n    scores = inc - 1e-9 * flow_tot\n    best_idx = candidates[np.argmin(scores[candidates])]\n    out = cur.copy()\n    out[best_idx] = l\n    return out.tolist()\n\n",
  "location_kmedoids_seed_then_best_facility_aug_240": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n    candidates = np.where(cur == -1)[0]\n    if candidates.size == 0:\n        return cur.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(cur != -1):\n        used[cur[cur != -1]] = True\n    free_locs = np.where(~used)[0]\n\n    # Medoid using mean distance\n    if free_locs.size > 1:\n        D = distance_matrix[np.ix_(free_locs, free_locs)].astype(float)\n        mean_dist = np.mean(D, axis=1)\n        l = free_locs[np.argmin(mean_dist)]\n    else:\n        l = free_locs[0]\n\n    assigned = np.where(cur != -1)[0]\n    locs = cur[assigned].astype(int)\n\n    flow_tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    inc = np.zeros(flow_matrix.shape[0], dtype=float)\n    if assigned.size > 0:\n        inc = np.sum(flow_matrix[:, assigned] * distance_matrix[l, locs] +\n                     flow_matrix[assigned, :].T * distance_matrix[locs, l], axis=1)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(flow_matrix.shape[0], dtype=float)\n    scores = inc - 1e-9 * flow_tot + noise\n\n    # Top\u2011k selection with deterministic RNG\n    top_k = 5\n    idx_sorted = np.argsort(scores)\n    top_candidates = [i for i in idx_sorted if i in candidates][:top_k]\n    rng = np.random.default_rng(seed=42)\n    chosen = rng.choice(top_candidates)\n\n    out = cur.copy()\n    out[chosen] = l\n    return out.tolist()\n\n",
  "location_kmedoids_seed_then_best_facility_aug_241": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n    candidates = [i for i in range(n) if cur[i] == -1]\n    if not candidates:\n        return cur.tolist()\n\n    used = [False] * n\n    for idx in cur[cur != -1]:\n        used[idx] = True\n    free_locs = [i for i, u in enumerate(used) if not u]\n\n    # Medoid using maximum distance sum\n    if len(free_locs) > 1:\n        D = distance_matrix[np.ix_(free_locs, free_locs)].astype(float)\n        max_sum = np.max(D.sum(axis=1))\n        l = free_locs[int(np.where(D.sum(axis=1) == max_sum)[0][0])]\n    else:\n        l = free_locs[0]\n\n    assigned = [i for i in range(n) if cur[i] != -1]\n    locs = [cur[i] for i in assigned]\n\n    flow_tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n\n    inc = []\n    for f in range(n):\n        if f in candidates:\n            if assigned:\n                inc_f = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                                     flow_matrix[assigned, f] * distance_matrix[locs, l]))\n            else:\n                inc_f = 0.0\n            inc.append(inc_f)\n        else:\n            inc.append(float('inf'))\n\n    # Weighted score with deterministic noise\n    scores = [0.6 * inc[i] + 0.4 * flow_tot[i] + 1e-9 * i for i in range(n)]\n\n    # Find best candidate using a while loop\n    best_f = candidates[0]\n    best_score = scores[best_f]\n    idx = 0\n    while idx < len(candidates):\n        f = candidates[idx]\n        if scores[f] < best_score:\n            best_score = scores[f]\n            best_f = f\n        idx += 1\n\n    out = cur.copy()\n    out[best_f] = l\n    return out.tolist()\n\n",
  "location_kmedoids_seed_then_best_facility_aug_242": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n    candidates = [i for i in range(n) if cur[i] == -1]\n    if not candidates:\n        return cur.tolist()\n\n    used = [False] * n\n    for idx in cur[cur != -1]:\n        used[idx] = True\n    free_locs = [i for i, u in enumerate(used) if not u]\n\n    # Medoid using mean distance\n    if len(free_locs) > 1:\n        D = distance_matrix[np.ix_(free_locs, free_locs)].astype(float)\n        mean_dist = np.mean(D, axis=1)\n        l = free_locs[int(np.argmin(mean_dist))]\n    else:\n        l = free_locs[0]\n\n    assigned = [i for i in range(n) if cur[i] != -1]\n    locs = [cur[i] for i in assigned]\n\n    flow_tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n\n    inc = []\n    for f in range(n):\n        if f in candidates:\n            if assigned:\n                inc_f = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                                     flow_matrix[assigned, f] * distance_matrix[locs, l]))\n            else:\n                inc_f = 0.0\n            inc.append(inc_f)\n        else:\n            inc.append(float('inf'))\n\n    # Softmax weighting of negative scores with deterministic noise\n    scores = np.array(inc, dtype=float) - 1e-9 * flow_tot\n    scores += 1e-9 * np.arange(n, dtype=float)\n    exp_vals = np.exp(-scores / (1e-1 + 1e-12))\n    probs = exp_vals / np.clip(exp_vals.sum(), 1e-12, None)\n    best_f = int(np.argmax(probs[candidates]))\n\n    out = cur.copy()\n    out[best_f] = l\n    return out.tolist()\n\n",
  "flow_aware_location_pairing_aug_243": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    curr = np.asarray(current_assignment, dtype=int)\n    n = curr.size\n    # find unassigned facilities\n    unassigned = np.flatnonzero(curr == -1).astype(int)\n    if unassigned.size == 0:\n        return curr.tolist()\n\n    # used locations\n    used = np.zeros(n, dtype=bool)\n    if np.any(curr != -1):\n        used[curr[curr != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    # symmetric flow\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # pick facility pair with max symmetric flow\n    if unassigned.size >= 2:\n        sub = sym_flow[np.ix_(unassigned, unassigned)].copy()\n        np.fill_diagonal(sub, -np.inf)\n        idx = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        f1, f2 = int(unassigned[idx[0]]), int(unassigned[idx[1]])\n    else:\n        f1 = f2 = int(unassigned[0])\n\n    # pick two closest free locations\n    if free_locs.size >= 2:\n        D = distance_matrix[np.ix_(free_locs, free_locs)].astype(float).copy()\n        np.fill_diagonal(D, np.inf)\n        D = np.clip(D, 1e-12, None)          # avoid infinities\n        idx = np.unravel_index(int(np.argmin(D)), D.shape)\n        l1, l2 = int(free_locs[idx[0]]), int(free_locs[idx[1]])\n    else:\n        l1 = l2 = int(free_locs[0])\n\n    # assigned facilities and their locations\n    assigned = np.flatnonzero(curr != -1).astype(int)\n    locs = curr[assigned].astype(int)\n\n    # incremental cost function\n    def inc(f: int, l: int) -> float:\n        if assigned.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                           flow_matrix[assigned, f] * distance_matrix[locs, l]))\n\n    # evaluate options\n    options = [(f1, l1), (f1, l2), (f2, l1), (f2, l2)]\n    best_cost = float(\"inf\")\n    best_pair = options[0]\n    for f, l in options:\n        c = inc(f, l)\n        if c < best_cost:\n            best_cost = c\n            best_pair = (f, l)\n\n    out = curr.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n\n",
  "flow_aware_location_pairing_aug_244": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    size = assign.size\n\n    # unassigned facilities\n    cand_fac = np.flatnonzero(assign == -1).astype(int)\n    if cand_fac.size == 0:\n        return assign.tolist()\n\n    # used locations\n    used_loc = np.zeros(size, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    avail_loc = np.flatnonzero(~used_loc).astype(int)\n\n    # symmetric flow\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # choose pair with max symmetric flow\n    if cand_fac.size >= 2:\n        submat = sym_flow[np.ix_(cand_fac, cand_fac)].copy()\n        np.fill_diagonal(submat, -np.inf)\n        idx = np.unravel_index(int(np.argmax(submat)), submat.shape)\n        f_a, f_b = int(cand_fac[idx[0]]), int(cand_fac[idx[1]])\n    else:\n        f_a = f_b = int(cand_fac[0])\n\n    # two closest free locations\n    if avail_loc.size >= 2:\n        Dmat = distance_matrix[np.ix_(avail_loc, avail_loc)].astype(float).copy()\n        np.fill_diagonal(Dmat, np.inf)\n        Dmat = np.clip(Dmat, 1e-12, None)\n        idx = np.unravel_index(int(np.argmin(Dmat)), Dmat.shape)\n        l_a, l_b = int(avail_loc[idx[0]]), int(avail_loc[idx[1]])\n    else:\n        l_a = l_b = int(avail_loc[0])\n\n    # current assignments\n    assigned_fac = np.flatnonzero(assign != -1).astype(int)\n    assigned_loc = assign[assigned_fac].astype(int)\n\n    # incremental cost\n    def inc_cost(f: int, l: int) -> float:\n        if assigned_fac.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, assigned_fac] * distance_matrix[l, assigned_loc] +\n                           flow_matrix[assigned_fac, f] * distance_matrix[assigned_loc, l]))\n\n    # evaluate options\n    opts = [(f_a, l_a), (f_a, l_b), (f_b, l_a), (f_b, l_b)]\n    costs = np.array([inc_cost(f, l) for f, l in opts], dtype=float)\n\n    # softmin probabilities\n    temp = 1.0\n    probs = np.exp(-costs / (temp + 1e-12))\n    probs /= np.clip(probs.sum(), 1e-12, None)\n\n    # choose among top 3 with random weighted by probs\n    top_k = min(3, len(opts))\n    top_idx = np.argsort(costs)[:top_k]\n    chosen = np.random.choice(top_idx, p=probs[top_idx] / np.clip(probs[top_idx].sum(), 1e-12, None))\n    best_pair = opts[chosen]\n\n    out = assign.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n\n",
  "flow_aware_location_pairing_aug_245": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n\n    # unassigned\n    fac_un = np.flatnonzero(cur == -1).astype(int)\n    if fac_un.size == 0:\n        return cur.tolist()\n\n    # used locations\n    used = np.zeros(n, dtype=bool)\n    if np.any(cur != -1):\n        used[cur[cur != -1]] = True\n    loc_free = np.flatnonzero(~used).astype(int)\n\n    # symmetric flow\n    sym_f = (flow_matrix + flow_matrix.T).astype(float)\n\n    # pick pair with max sym flow\n    if fac_un.size >= 2:\n        sub = sym_f[np.ix_(fac_un, fac_un)].copy()\n        np.fill_diagonal(sub, -np.inf)\n        idx = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        f1, f2 = int(fac_un[idx[0]]), int(fac_un[idx[1]])\n    else:\n        f1 = f2 = int(fac_un[0])\n\n    # pick two farthest free locations using np.max (instead of min)\n    if loc_free.size >= 2:\n        D = distance_matrix[np.ix_(loc_free, loc_free)].astype(float).copy()\n        np.fill_diagonal(D, -np.inf)\n        idx = np.unravel_index(int(np.argmax(D)), D.shape)\n        l1, l2 = int(loc_free[idx[0]]), int(loc_free[idx[1]])\n    else:\n        l1 = l2 = int(loc_free[0])\n\n    # assigned facilities\n    fac_ass = np.flatnonzero(cur != -1).astype(int)\n    loc_ass = cur[fac_ass].astype(int)\n\n    # incremental cost using median\n    def inc(f: int, l: int) -> float:\n        if fac_ass.size == 0:\n            return 0.0\n        prod1 = flow_matrix[f, fac_ass] * distance_matrix[l, loc_ass]\n        prod2 = flow_matrix[fac_ass, f] * distance_matrix[loc_ass, l]\n        return float(np.median(np.concatenate([prod1, prod2])))\n\n    # evaluate options\n    options = [(f1, l1), (f1, l2), (f2, l1), (f2, l2)]\n    costs = np.array([inc(f, l) for f, l in options], dtype=float)\n    best_idx = int(np.argmin(costs))\n    best_pair = options[best_idx]\n\n    out = cur.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n\n",
  "min_incremental_with_flow_skewness_penalty_aug_246": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n    lam = 0.15\n\n    def skewness(x: np.ndarray) -> float:\n        x = x.astype(float)\n        m = float(np.mean(x))\n        s = float(np.std(x)) + 1e-12\n        z = (x - m) / s\n        sk = float(np.mean(z ** 3))\n        return float(np.clip(sk, -1.0, 1.0))\n\n    best_score = float(\"inf\")\n    best_f = int(unassigned[0])\n    best_l = int(free[0])\n\n    idx = 0\n    while idx < unassigned.size:\n        f = int(unassigned[idx])\n        rem = sym_flow[f, unassigned].copy().astype(float)\n        rem[unassigned == f] = 0.0\n        sk = abs(skewness(rem)) if rem.size >= 3 else 0.0\n        for l in free:\n            inc = 0.0 if assigned.size == 0 else float(\n                np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                       flow_matrix[assigned, f] * distance_matrix[locs, l]))\n            score = inc + lam * sk * (abs(inc) + 1.0)\n            if score < best_score:\n                best_score, best_f, best_l = score, f, int(l)\n        idx += 1\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_with_flow_skewness_penalty_aug_247": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n    lam = 0.25\n\n    def skewness(x: np.ndarray) -> float:\n        x = x.astype(float)\n        m = float(np.mean(x))\n        s = float(np.std(x)) + 1e-12\n        z = (x - m) / s\n        sk = float(np.mean(z ** 3))\n        return float(np.clip(sk, -1.0, 1.0))\n\n    scores = []\n    pairs = []\n    for f in unassigned:\n        rem = sym_flow[f, unassigned].copy().astype(float)\n        rem[unassigned == f] = 0.0\n        sk = abs(skewness(rem)) if rem.size >= 3 else 0.0\n        for l in free:\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                contrib = (flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                           flow_matrix[assigned, f] * distance_matrix[locs, l])\n                inc = float(np.max(contrib))\n            score = inc + lam * sk * (abs(inc) + 1.0)\n            scores.append(score)\n            pairs.append((f, int(l)))\n\n    scores = np.array(scores)\n    top_k = min(7, len(scores))\n    top_indices = np.argpartition(scores, top_k)[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n    best_f, best_l = pairs[chosen_idx]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_with_flow_skewness_penalty_aug_248": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n    lam = 0.15\n\n    def skewness(x: np.ndarray) -> float:\n        x = x.astype(float)\n        m = float(np.mean(x))\n        s = float(np.std(x)) + 1e-12\n        z = (x - m) / s\n        sk = float(np.median(z ** 3))\n        return float(np.clip(sk, -1.0, 1.0))\n\n    best_score = float(\"inf\")\n    best_f = int(unassigned[0])\n    best_l = int(free[0])\n    pair_idx = 0\n    for f in unassigned:\n        rem = sym_flow[f, unassigned].copy().astype(float)\n        rem[unassigned == f] = 0.0\n        sk = abs(skewness(rem)) if rem.size >= 3 else 0.0\n        for l in free:\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                                    flow_matrix[assigned, f] * distance_matrix[locs, l]))\n            score = inc + lam * sk * (abs(inc) + 1.0)\n            score += 1e-6 * pair_idx\n            if score < best_score:\n                best_score, best_f, best_l = score, int(f), int(l)\n            pair_idx += 1\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "min_incremental_with_flow_skewness_penalty_aug_249": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n    lam = 0.2\n\n    def skewness_proxy(x: np.ndarray) -> float:\n        x = x.astype(float)\n        mx = float(np.max(x))\n        mn = float(np.min(x))\n        sk = (mx - mn) / (mx + mn + 1e-12)\n        return float(np.clip(sk, -1.0, 1.0))\n\n    scores = []\n    pairs = []\n    for f in unassigned:\n        rem = sym_flow[f, unassigned].copy().astype(float)\n        rem[unassigned == f] = 0.0\n        sk = abs(skewness_proxy(rem)) if rem.size >= 3 else 0.0\n        for l in free:\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.max(flow_matrix[f, assigned] * distance_matrix[l, locs] +\n                                    flow_matrix[assigned, f] * distance_matrix[locs, l]))\n            score = inc + lam * sk * (abs(inc) + 1.0)\n            scores.append(score)\n            pairs.append((f, int(l)))\n\n    scores = np.array(scores)\n    top_k = min(10, len(scores))\n    top_indices = np.argpartition(scores, top_k)[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n    best_f, best_l = pairs[chosen_idx]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "max_regret3_facility_then_best_location_aug_250": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # candidates that are still unassigned\n    cand = np.flatnonzero(a == -1).astype(int)\n    if cand.size == 0:\n        return a.tolist()\n\n    # which locations are already occupied\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    avail = np.flatnonzero(~occupied).astype(int)\n\n    # facilities that are already assigned\n    assigned = np.flatnonzero(a != -1).astype(int)\n    assigned_locs = a[assigned].astype(int)\n\n    def inc(f: int, l: int) -> float:\n        \"\"\"Incremental cost of assigning facility `f` to location `l`.\"\"\"\n        if assigned.size == 0:\n            return 0.0\n        return float(np.sum(\n            flow_mat[f, assigned] * dist_mat[l, assigned_locs] +\n            flow_mat[assigned, f] * dist_mat[assigned_locs, l]))\n\n    best_regret = -np.inf\n    best_f = int(cand[0])\n    best_l = int(avail[0])\n\n    idx = 0\n    while idx < cand.size:\n        f = int(cand[idx])\n\n        # vectorised cost calculation for all free locations\n        costs = np.array([inc(f, int(l)) for l in avail], dtype=float)\n\n        # deterministic tie\u2011breaking noise\n        costs += 1e-6 * np.arange(costs.size)\n        costs = np.clip(costs, 0, None)\n\n        if costs.size == 1:\n            regret = np.inf\n            l_pick = int(avail[0])\n        else:\n            sorted_idx = np.argsort(costs)\n            l_pick = int(avail[sorted_idx[0]])\n            k = min(2, costs.size - 1)  # third best (or second best)\n            regret = float(costs[sorted_idx[k]] - costs[sorted_idx[0]])\n\n        if regret > best_regret:\n            best_regret = regret\n            best_f = int(f)\n            best_l = int(l_pick)\n\n        idx += 1\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "max_regret3_facility_then_best_location_aug_251": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    cand = np.flatnonzero(a == -1).astype(int)\n    if cand.size == 0:\n        return a.tolist()\n\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    avail = np.flatnonzero(~occupied).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    assigned_locs = a[assigned].astype(int)\n\n    def inc(f: int, l: int) -> float:\n        \"\"\"Weighted incremental cost: 0.6 * (flow*dist) + 0.4 * (abs(flow)+abs(dist)).\"\"\"\n        if assigned.size == 0:\n            return 0.0\n        flow_term = flow_mat[f, assigned] + flow_mat[assigned, f]\n        dist_term = dist_mat[l, assigned_locs] + dist_mat[assigned_locs, l]\n        return float(0.6 * np.sum(flow_term * dist_term) +\n                     0.4 * np.sum(np.abs(flow_term) + np.abs(dist_term)))\n\n    best_regret = -np.inf\n    best_f = int(cand[0])\n    best_l = int(avail[0])\n\n    for f in cand.astype(int):\n        costs = np.array([inc(f, int(l)) for l in avail], dtype=float)\n        costs += 1e-8 * np.arange(costs.size)          # deterministic noise\n        costs = np.clip(costs, 0, None)\n\n        if costs.size == 1:\n            regret = np.inf\n            l_pick = int(avail[0])\n        else:\n            sorted_idx = np.argsort(costs)\n            l_pick = int(avail[sorted_idx[0]])\n            k = min(2, costs.size - 1)\n            regret = float(costs[sorted_idx[k]] - costs[sorted_idx[0]])\n\n        if regret > best_regret:\n            best_regret = regret\n            best_f = int(f)\n            best_l = int(l_pick)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "max_regret3_facility_then_best_location_aug_252": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    cand = np.flatnonzero(a == -1).astype(int)\n    if cand.size == 0:\n        return a.tolist()\n\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    avail = np.flatnonzero(~occupied).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    assigned_locs = a[assigned].astype(int)\n\n    def inc(f: int, l: int) -> float:\n        if assigned.size == 0:\n            return 0.0\n        return float(np.sum(\n            flow_mat[f, assigned] * dist_mat[l, assigned_locs] +\n            flow_mat[assigned, f] * dist_mat[assigned_locs, l]))\n\n    best_regret = -np.inf\n    best_f = int(cand[0])\n    best_l = int(avail[0])\n\n    rng = np.random.default_rng()\n    top_k = 3\n\n    for f in cand.astype(int):\n        costs = np.array([inc(f, int(l)) for l in avail], dtype=float)\n        costs = np.clip(costs, 0, None)\n\n        if costs.size == 1:\n            regret = np.inf\n            l_pick = int(avail[0])\n        else:\n            sorted_idx = np.argsort(costs)\n            top_indices = sorted_idx[:top_k]\n            l_pick = int(avail[rng.choice(top_indices)])\n            # median\u2011based regret\n            regret = float(np.median(costs) - costs[sorted_idx[0]])\n\n        if regret > best_regret:\n            best_regret = regret\n            best_f = int(f)\n            best_l = int(l_pick)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "max_regret3_facility_then_best_location_aug_253": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    cand = np.flatnonzero(a == -1).astype(int)\n    if cand.size == 0:\n        return a.tolist()\n\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    avail = np.flatnonzero(~occupied).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    assigned_locs = a[assigned].astype(int)\n\n    def inc(f: int, l: int) -> float:\n        if assigned.size == 0:\n            return 0.0\n        # proxy approximation: dot of summed flows and distances\n        flow_sum = flow_mat[f, assigned] + flow_mat[assigned, f]\n        dist_sum = dist_mat[l, assigned_locs] + dist_mat[assigned_locs, l]\n        return float(np.dot(flow_sum, dist_sum))\n\n    best_regret = -np.inf\n    best_f = int(cand[0])\n    best_l = int(avail[0])\n\n    rng = np.random.default_rng()\n\n    for f in cand.astype(int):\n        costs = np.array([inc(f, int(l)) for l in avail], dtype=float)\n        costs += 1e-9 * np.arange(costs.size)          # deterministic tie\u2011breaking\n        costs = np.clip(costs, 0, None)\n\n        if costs.size == 1:\n            regret = np.inf\n            l_pick = int(avail[0])\n        else:\n            sorted_idx = np.argsort(costs)\n            l_pick = int(avail[sorted_idx[0]])\n            # max\u2011based regret\n            regret = float(np.max(costs) - costs[sorted_idx[0]])\n\n        if regret > best_regret:\n            best_regret = regret\n            best_f = int(f)\n            best_l = int(l_pick)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "stochastic_unassigned_sampling_min_inc_aug_254": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"While\u2011loop implementation with deterministic noise and vectorized cost.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Facilities that are still unassigned\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    # Locations that are still free\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # Randomly sample a subset of candidates\n    rng = np.random.default_rng()\n    fu = min(unassigned.size, max(3, int(np.ceil(0.35 * unassigned.size))))\n    fl = min(free.size, max(3, int(np.ceil(0.35 * free.size))))\n    sampled_f = rng.choice(unassigned, size=fu, replace=False)\n    sampled_l = rng.choice(free, size=fl, replace=False)\n\n    # Current assignments\n    assigned = np.flatnonzero(a != -1).astype(int)\n    assigned_locs = a[assigned].astype(int)\n\n    best_inc = np.inf\n    best_f, best_l = int(sampled_f[0]), int(sampled_l[0])\n\n    # Iterate over sampled pairs with while loops\n    i = 0\n    while i < sampled_f.size:\n        f = int(sampled_f[i])\n        j = 0\n        while j < sampled_l.size:\n            l = int(sampled_l[j])\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, assigned_locs] +\n                                  flow_matrix[assigned, f] * distance_matrix[assigned_locs, l]))\n            # deterministic noise to break ties\n            inc += 1e-9 * (f + l)\n            if inc < best_inc:\n                best_inc, best_f, best_l = inc, f, l\n            j += 1\n        i += 1\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "stochastic_unassigned_sampling_min_inc_aug_255": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"List\u2011comprehension version with softmin selection and median aggregation.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    rng = np.random.default_rng()\n    fu = min(unassigned.size, max(3, int(np.ceil(0.35 * unassigned.size))))\n    fl = min(free.size, max(3, int(np.ceil(0.35 * free.size))))\n    sampled_f = rng.choice(unassigned, size=fu, replace=False)\n    sampled_l = rng.choice(free, size=fl, replace=False)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    assigned_locs = a[assigned].astype(int)\n\n    # Compute incremental costs with median aggregation\n    inc_costs = [(f, l,\n                  float(np.median(flow_matrix[f, assigned] * distance_matrix[l, assigned_locs] +\n                                  flow_matrix[assigned, f] * distance_matrix[assigned_locs, l]))\n                  if assigned.size > 0 else 0.0)\n                 for f in sampled_f for l in sampled_l]\n\n    costs = np.array([c[2] for c in inc_costs], dtype=float)\n\n    # Softmin weighting\n    eps = 1e-12\n    temp = np.clip(1.0, 1e-6, None)          # temperature\n    weights = np.exp(-costs / (temp + eps))\n    probs = weights / (np.sum(weights) + eps)\n\n    # Randomly pick one pair according to softmin probabilities\n    idx = rng.choice(len(inc_costs), p=probs)\n    best_f, best_l, _ = inc_costs[idx]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "stochastic_unassigned_sampling_min_inc_aug_256": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Top\u2011k selection with weighted sum and deterministic tie\u2011breaking.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    rng = np.random.default_rng()\n    fu = min(unassigned.size, max(3, int(np.ceil(0.35 * unassigned.size))))\n    fl = min(free.size, max(3, int(np.ceil(0.35 * free.size))))\n    sampled_f = rng.choice(unassigned, size=fu, replace=False)\n    sampled_l = rng.choice(free, size=fl, replace=False)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    assigned_locs = a[assigned].astype(int)\n\n    # Weighted incremental cost: 0.6*flow + 0.4*dist\n    inc_list = [(f, l,\n                 float(np.sum(0.6 * flow_matrix[f, assigned] * distance_matrix[l, assigned_locs] +\n                              0.4 * flow_matrix[assigned, f] * distance_matrix[assigned_locs, l]))\n                 if assigned.size > 0 else 0.0)\n                for f in sampled_f for l in sampled_l]\n\n    costs = np.array([c[2] for c in inc_list], dtype=float)\n\n    # Top\u2011k smallest costs\n    k = min(5, len(costs))\n    top_indices = np.argpartition(costs, k - 1)[:k]\n    top_costs = costs[top_indices]\n\n    # Deterministic tie\u2011breaking with small noise\n    noise = np.array([1e-9 * (inc_list[i][0] + inc_list[i][1]) for i in top_indices])\n    best_idx = top_indices[np.argmin(top_costs + noise)]\n\n    best_f, best_l, _ = inc_list[best_idx]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "stochastic_unassigned_sampling_min_inc_aug_257": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Full matrix computation, mean aggregation, deterministic noise.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    assigned_locs = a[assigned].astype(int)\n\n    if assigned.size == 0:\n        # No cost yet \u2013 pick the first pair deterministically\n        best_f = int(unassigned[0])\n        best_l = int(free[0])\n    else:\n        # Broadcasted computation of incremental costs\n        part1 = np.einsum('fi,li->fl',\n                          flow_matrix[unassigned[:, None], assigned],\n                          distance_matrix[free[:, None], assigned_locs])\n        part2 = np.einsum('fi,li->fl',\n                          flow_matrix[assigned[:, None], unassigned[:, None]],\n                          distance_matrix[assigned_locs[:, None], free[:, None]])\n        inc_mat = (part1 + part2) / (assigned.size + 1e-12)   # mean aggregation\n\n        # Deterministic noise to break ties\n        noise = 1e-9 * (unassigned[:, None] + free[None, :])\n        inc_mat += noise\n\n        idx_flat = np.argmin(inc_mat)\n        best_f = int(unassigned[idx_flat // free.size])\n        best_l = int(free[idx_flat % free.size])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "simulated_annealing_pair_choice_aug_258": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    # Identify unassigned facilities and free locations\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs_assigned = a[assigned]\n\n    # Generate pairs via a while loop\n    pairs = []\n    idx = 0\n    while idx < unassigned.size:\n        f = unassigned[idx]\n        for l in free_locs:\n            pairs.append((int(f), int(l)))\n        idx += 1\n\n    m = len(pairs)\n    costs = np.empty(m, dtype=float)\n\n    if assigned.size == 0:\n        costs.fill(0.0)\n    else:\n        for i, (f, l) in enumerate(pairs):\n            costs[i] = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs_assigned] +\n                                    flow_matrix[assigned, f] * distance_matrix[locs_assigned, l]))\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    T = 2.0 * (1.0 - progress) + 0.05\n    T = np.clip(T, 1e-6, 5.0)\n\n    # Tiny deterministic noise to break ties\n    noise = np.arange(m) * 1e-9\n    costs_adj = costs + noise\n\n    # Softmin probability\n    exp_vals = np.exp(-costs_adj / T)\n    probs = exp_vals / (exp_vals.sum() + 1e-12)\n\n    idx_choice = int(np.random.choice(m, p=probs))\n    f_sel, l_sel = pairs[idx_choice]\n\n    out = a.copy()\n    out[int(f_sel)] = int(l_sel)\n    return out.tolist()\n\n",
  "simulated_annealing_pair_choice_aug_259": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs_assigned = a[assigned]\n\n    pairs = [(int(f), int(l)) for f in unassigned for l in free_locs]\n    m = len(pairs)\n    costs = np.empty(m, dtype=float)\n\n    if assigned.size == 0:\n        costs.fill(0.0)\n    else:\n        for i, (f, l) in enumerate(pairs):\n            costs[i] = float(np.sum(flow_matrix[f, assigned] * distance_matrix[l, locs_assigned] +\n                                    flow_matrix[assigned, f] * distance_matrix[locs_assigned, l]))\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    T = 1.5 * (1.0 - progress) + 0.1\n    T = np.clip(T, 1e-6, 3.0)\n\n    # Add deterministic noise to avoid exact ties\n    noise = np.linspace(0, 1e-8, m)\n    costs_noisy = costs + noise\n\n    # Top\u2011k selection\n    top_k = 7\n    if top_k > m:\n        top_k = m\n    top_indices = np.argpartition(costs_noisy, top_k - 1)[:top_k]\n\n    # Random choice among the best candidates\n    idx_choice = int(np.random.choice(top_indices))\n    f_sel, l_sel = pairs[idx_choice]\n\n    out = a.copy()\n    out[int(f_sel)] = int(l_sel)\n    return out.tolist()\n\n",
  "simulated_annealing_pair_choice_aug_260": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs_assigned = a[assigned]\n\n    pairs = [(int(f), int(l)) for f in unassigned for l in free_locs]\n    m = len(pairs)\n    costs = np.empty(m, dtype=float)\n\n    if assigned.size == 0:\n        costs.fill(0.0)\n    else:\n        for i, (f, l) in enumerate(pairs):\n            # Use mean instead of sum as aggregation\n            costs[i] = float(np.mean(flow_matrix[f, assigned] * distance_matrix[l, locs_assigned] +\n                                     flow_matrix[assigned, f] * distance_matrix[locs_assigned, l]))\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    T = 2.0 * (1.0 - progress) + 0.05\n    T = np.clip(T, 1e-6, 4.0)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(m) * 1e-9\n    costs_adj = costs + noise\n\n    # Softmin probabilities\n    exp_vals = np.exp(-costs_adj / T)\n    probs = exp_vals / (exp_vals.sum() + 1e-12)\n\n    idx_choice = int(np.random.choice(m, p=probs))\n    f_sel, l_sel = pairs[idx_choice]\n\n    out = a.copy()\n    out[int(f_sel)] = int(l_sel)\n    return out.tolist()\n\n",
  "simulated_annealing_pair_choice_aug_261": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.where(a == -1)[0]\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.where(~used_locs)[0]\n\n    assigned = np.where(a != -1)[0]\n    locs_assigned = a[assigned]\n\n    pairs = [(int(f), int(l)) for f in unassigned for l in free_locs]\n    m = len(pairs)\n    costs = np.empty(m, dtype=float)\n\n    if assigned.size == 0:\n        costs.fill(0.0)\n    else:\n        for i, (f, l) in enumerate(pairs):\n            # Proxy approximation via dot product of flattened vectors\n            costs[i] = float(np.dot(flow_matrix[f, assigned].flatten(),\n                                    distance_matrix[l, locs_assigned].flatten()))\n\n    progress = 1.0 - (unassigned.size / max(1, n))\n    T = 0.5 * (1.0 - progress) + 0.2\n    T = np.clip(T, 1e-6, 2.0)\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.linspace(0, 1e-7, m)\n    costs_adj = costs + noise\n\n    # Top\u2011k candidates\n    top_k = 5\n    if top_k > m:\n        top_k = m\n    top_indices = np.argpartition(costs_adj, top_k - 1)[:top_k]\n\n    # Softmin over the top\u2011k\n    top_costs = costs_adj[top_indices]\n    exp_vals = np.exp(-top_costs / T)\n    probs = exp_vals / (exp_vals.sum() + 1e-12)\n\n    idx_within_top = int(np.random.choice(top_indices, p=probs))\n    f_sel, l_sel = pairs[idx_within_top]\n\n    out = a.copy()\n    out[int(f_sel)] = int(l_sel)\n    return out.tolist()\n\n",
  "upper_bound_completion_greedy_score_aug_262": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    # locate unassigned facilities\n    unassigned = np.flatnonzero(a0 == -1).astype(int)\n    if unassigned.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, bool)\n    if np.any(a0 != -1):\n        used[a0[a0 != -1]] = True\n    free_loc = np.flatnonzero(~used).astype(int)\n\n    # incremental cost of assigning f to l\n    def inc(a: np.ndarray, f: int, l: int) -> float:\n        ass = np.flatnonzero(a != -1).astype(int)\n        if ass.size == 0:\n            return 0.0\n        locs = a[ass].astype(int)\n        return float(np.sum(flow_mat[f, ass] * dist_mat[l, locs] +\n                            flow_mat[ass, f] * dist_mat[locs, l]))\n\n    # generate all candidate pairs using while loops\n    pairs = []\n    i = 0\n    while i < unassigned.size:\n        f = int(unassigned[i])\n        j = 0\n        while j < free_loc.size:\n            l = int(free_loc[j])\n            pairs.append((f, l))\n            j += 1\n        i += 1\n\n    best_score = np.inf\n    best_pair = pairs[0]\n    rng = np.random.default_rng(42)\n\n    for f, l in pairs:\n        a1 = a0.copy()\n        a1[int(f)] = int(l)\n        score = inc(a0, int(f), int(l))\n\n        un1 = np.flatnonzero(a1 == -1).astype(int)\n        used1 = np.zeros(n, bool)\n        used1[a1[a1 != -1]] = True\n        free1 = np.flatnonzero(~used1).astype(int)\n\n        if un1.size and free1.size:\n            best_next = np.inf\n            k = 0\n            while k < un1.size:\n                f2 = int(un1[k])\n                m = 0\n                while m < free1.size:\n                    l2 = int(free1[m])\n                    c2 = inc(a1, f2, l2)\n                    if c2 < best_next:\n                        best_next = c2\n                    m += 1\n                k += 1\n            score = score + 0.4 * best_next  # tuned weight\n\n        # deterministic noise for tie\u2011breaking\n        noise = (f * 31 + l * 17) * 1e-6\n        score += noise\n\n        if score < best_score:\n            best_score = score\n            best_pair = (f, l)\n\n    out = a0.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n\n",
  "upper_bound_completion_greedy_score_aug_263": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n\n    unassigned = np.flatnonzero(a0 == -1).astype(int)\n    if unassigned.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, bool)\n    if np.any(a0 != -1):\n        used[a0[a0 != -1]] = True\n    free_loc = np.flatnonzero(~used).astype(int)\n\n    # proxy incremental cost using dot product\n    def inc(a: np.ndarray, f: int, l: int) -> float:\n        ass = np.flatnonzero(a != -1).astype(int)\n        if ass.size == 0:\n            return 0.0\n        locs = a[ass].astype(int)\n        flow_slice = flow_mat[f, ass]\n        dist_slice = dist_mat[l, locs]\n        return float(np.dot(flow_slice, dist_slice))\n\n    pairs = [(int(f), int(l)) for f in unassigned for l in free_loc]\n    scores = []\n\n    for f, l in pairs:\n        a1 = a0.copy()\n        a1[int(f)] = int(l)\n        base = inc(a0, int(f), int(l))\n\n        un1 = np.flatnonzero(a1 == -1).astype(int)\n        used1 = np.zeros(n, bool)\n        used1[a1[a1 != -1]] = True\n        free1 = np.flatnonzero(~used1).astype(int)\n\n        if un1.size and free1.size:\n            next_vals = [inc(a1, int(f2), int(l2)) for f2 in un1 for l2 in free1]\n            max_next = np.max(next_vals)           # max aggregation\n            total = base + 0.5 * max_next\n        else:\n            total = base\n\n        # deterministic noise\n        noise = ((f * 37 + l * 23) % 1000) * 1e-8\n        total += noise\n        scores.append(total)\n\n    scores_np = np.array(scores)\n    # softmin selection\n    min_score = np.min(scores_np)\n    shifted = scores_np - min_score\n    exp_vals = np.exp(-shifted / 0.2)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    rng = np.random.default_rng(7)\n    chosen_idx = rng.choice(len(pairs), p=probs)\n    chosen_pair = pairs[chosen_idx]\n\n    out = a0.copy()\n    out[chosen_pair[0]] = chosen_pair[1]\n    return out.tolist()\n\n",
  "dual_potential_gap_minimization_aug_264": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorised selection with deterministic noise for tie\u2011breaking.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Candidates and free locations\n    cand = np.flatnonzero(a == -1)\n    if cand.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a.any():\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used)\n\n    # Normalised potentials\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n\n    assigned = np.flatnonzero(a != -1)\n    locs = a[assigned]\n\n    # Compute gap matrix\n    gap_mat = np.abs(pf[:, None] - cl[None, :])  # shape (cand, free)\n\n    # Incremental cost matrix\n    inc_mat = np.zeros_like(gap_mat)\n    for i, f in enumerate(cand):\n        for j, l in enumerate(free):\n            inc = np.sum(flow_matrix[f, assigned] *\n                         distance_matrix[l, locs] +\n                         flow_matrix[assigned, f] *\n                         distance_matrix[locs, l])\n            inc_mat[i, j] = inc\n\n    # Combine with weights and add tiny noise for deterministic tie\u2011breaking\n    score = gap_mat + 1e-6 * inc_mat\n    noise = np.random.uniform(-1e-8, 1e-8, size=score.shape)\n    score += noise\n\n    idx = np.unravel_index(np.argmin(score), score.shape)\n    best_f, best_l = cand[idx[0]], free[idx[1]]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "dual_potential_gap_minimization_aug_265": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"While\u2011loop implementation using median for incremental cost.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Find unvisited facilities\n    unvisited = np.where(a == -1)[0]\n    if unvisited.size == 0:\n        return a.tolist()\n\n    # Determine free locations\n    used = np.zeros(n, dtype=bool)\n    if a.any():\n        used[a[a != -1]] = True\n    free_locs = [i for i in range(n) if not used[i]]\n\n    # Normalise potentials\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    best_score = np.inf\n    best_f = int(unvisited[0])\n    best_l = int(free_locs[0])\n\n    f_idx = 0\n    while f_idx < unvisited.size:\n        f = unvisited[f_idx]\n        l_idx = 0\n        while l_idx < len(free_locs):\n            l = free_locs[l_idx]\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = np.median(\n                    flow_matrix[f, assigned] *\n                    distance_matrix[l, locs] +\n                    flow_matrix[assigned, f] *\n                    distance_matrix[locs, l]\n                )\n            score = 0.6 * abs(pf[f] - cl[l]) + 0.4 * inc\n            if score < best_score:\n                best_score, best_f, best_l = score, f, l\n            l_idx += 1\n        f_idx += 1\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "dual_potential_gap_minimization_aug_266": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Top\u2011k soft\u2011min selection with proxy cost approximation.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Candidates and free locations\n    cand = np.where(a == -1)[0]\n    if cand.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a.any():\n        used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    # Normalised potentials\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    # Compute scores\n    scores = np.full((cand.size, free.size), np.inf)\n    for i, f in enumerate(cand):\n        for j, l in enumerate(free):\n            # Proxy incremental cost using max instead of sum\n            inc = np.max(\n                flow_matrix[f, assigned] *\n                distance_matrix[l, locs] +\n                flow_matrix[assigned, f] *\n                distance_matrix[locs, l]\n            ) if assigned.size else 0.0\n            scores[i, j] = abs(pf[f] - cl[l]) + 0.5 * inc\n\n    # Soft\u2011min: keep top\u2011k (k=3) and choose smallest among them\n    k = min(3, scores.size)\n    flat = scores.ravel()\n    top_k_idx = np.argpartition(flat, k)[:k]\n    best_idx = top_k_idx[np.argmin(flat[top_k_idx])]\n\n    best_f = int(cand[best_idx // free.size])\n    best_l = int(free[best_idx % free.size])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "dual_potential_gap_minimization_aug_267": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Inverted conditionals and random tie\u2011breaking among top\u20113 scores.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Find unvisited facilities\n    unvisited = np.where(a == -1)[0]\n    if unvisited.size == 0:\n        return a.tolist()\n\n    # Determine free locations\n    used = np.zeros(n, dtype=bool)\n    if a.any():\n        used[a[a != -1]] = True\n    free_locs = np.where(~used)[0]\n\n    # Normalise potentials with clipping\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = np.clip((pf - pf.min()) / (pf.max() - pf.min() + 1e-12), 0, 1)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = np.clip((cl - cl.min()) / (cl.max() - cl.min() + 1e-12), 0, 1)\n\n    assigned = np.where(a != -1)[0]\n    locs = a[assigned]\n\n    # Compute all scores\n    scores = np.full((unvisited.size, free_locs.size), np.inf)\n    for i, f in enumerate(unvisited):\n        for j, l in enumerate(free_locs):\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = np.sum(\n                    flow_matrix[f, assigned] *\n                    distance_matrix[l, locs] +\n                    flow_matrix[assigned, f] *\n                    distance_matrix[locs, l]\n                )\n            scores[i, j] = abs(pf[f] - cl[l]) + 0.3 * inc\n\n    # Select top\u20113 minimal scores and pick one at random\n    flat_scores = scores.ravel()\n    top3_idx = np.argpartition(flat_scores, 3)[:3]\n    chosen = np.random.choice(top3_idx)\n    best_f = int(unvisited[chosen // free_locs.size])\n    best_l = int(free_locs[chosen % free_locs.size])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "median_interaction_cost_pair_aug_268": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Greedy selection using the mean of interaction costs.\n    Adds deterministic noise to break ties.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Indices of facilities not yet assigned\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Locations that are already used\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    # Facilities already placed\n    placed = np.flatnonzero(a != -1).astype(int)\n    placed_locs = a[placed].astype(int)\n\n    # Broadcast to compute all pairwise costs\n    F = candidates[:, None]          # shape (uf, 1)\n    L = free_locs[None, :]            # shape (1, lf)\n\n    # Compute interaction values\n    part1 = flow_matrix[F, placed][:, :, None] * distance_matrix[L, placed_locs][:, None, :]\n    part2 = flow_matrix[placed, F][:, None, :] * distance_matrix[placed_locs, L][:, :, None]\n    vals = part1 + part2              # shape (uf, lf, len(placed))\n\n    # Aggregate with mean (or zero if nothing is placed yet)\n    if placed.size == 0:\n        scores = np.zeros((candidates.size, free_locs.size))\n    else:\n        scores = np.mean(vals, axis=2)\n\n    # Add deterministic noise for stable tie\u2011breaking\n    noise = 1e-6 * np.arange(scores.size).reshape(scores.shape)\n    scores += noise\n\n    # Find the best pair\n    idx_flat = np.argmin(scores)\n    idx_f, idx_l = np.unravel_index(idx_flat, scores.shape)\n    best_f, best_l = int(candidates[idx_f]), int(free_locs[idx_l])\n\n    # Update assignment\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "median_interaction_cost_pair_aug_269": "import numpy as np\nimport random\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Weighted sum of sum and max of interaction costs.\n    Uses a softmin (temperature) to probabilistically select among the top\u2011k pairs.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Candidates and free locations\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    placed = np.flatnonzero(a != -1).astype(int)\n    placed_locs = a[placed].astype(int)\n\n    # Broadcast cost matrix\n    F = unassigned[:, None]\n    L = free[None, :]\n\n    part1 = flow_matrix[F, placed][:, :, None] * distance_matrix[L, placed_locs][:, None, :]\n    part2 = flow_matrix[placed, F][:, None, :] * distance_matrix[placed_locs, L][:, :, None]\n    vals = part1 + part2\n\n    if placed.size == 0:\n        scores = np.zeros((unassigned.size, free.size))\n    else:\n        # Weighted combination of sum and max\n        sum_part = np.sum(vals, axis=2)\n        max_part = np.max(vals, axis=2)\n        scores = 0.6 * sum_part + 0.4 * max_part\n\n    # Softmin selection with temperature\n    temperature = 0.5\n    # Prevent division by zero\n    eps = 1e-12\n    exp_vals = np.exp(-scores / (temperature + eps))\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n\n    # Sample one pair according to probabilities\n    flat_index = np.random.choice(scores.size, p=probs.ravel())\n    idx_f, idx_l = np.unravel_index(flat_index, scores.shape)\n    best_f, best_l = int(unassigned[idx_f]), int(free[idx_l])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "median_interaction_cost_pair_aug_270": "import numpy as np\nimport random\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Uses np.max aggregation and random choice among the top\u2011k candidates.\n    Implements the search loop with a while\u2011construct.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Identify unassigned facilities and free locations\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n    used_locs = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_locs[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_locs).astype(int)\n\n    placed = np.flatnonzero(a != -1).astype(int)\n    placed_locs = a[placed].astype(int)\n\n    # Compute all pairwise costs\n    F = unassigned[:, None]\n    L = free_locs[None, :]\n    part1 = flow_matrix[F, placed][:, :, None] * distance_matrix[L, placed_locs][:, None, :]\n    part2 = flow_matrix[placed, F][:, None, :] * distance_matrix[placed_locs, L][:, :, None]\n    vals = part1 + part2\n\n    if placed.size == 0:\n        scores = np.zeros((unassigned.size, free_locs.size))\n    else:\n        # Use maximum interaction as score\n        scores = np.max(vals, axis=2)\n\n    # Add small noise to break ties deterministically\n    noise = 1e-9 * np.arange(scores.size).reshape(scores.shape)\n    scores += noise\n\n    # Find top\u2011k lowest scores\n    top_k = 7\n    flat_scores = scores.ravel()\n    top_indices = np.argpartition(flat_scores, top_k)[:top_k]\n    # Randomly pick one of the top\u2011k\n    chosen_idx = random.choice(top_indices)\n    idx_f, idx_l = np.unravel_index(chosen_idx, scores.shape)\n    best_f, best_l = int(unassigned[idx_f]), int(free_locs[idx_l])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "median_interaction_cost_pair_aug_271": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Approximates the median with a trimmed mean and uses np.clip\n    to keep intermediate values bounded. Adds epsilon to avoid\n    division by zero in any future extensions.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Candidates and free locations\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    placed = np.flatnonzero(a != -1).astype(int)\n    placed_locs = a[placed].astype(int)\n\n    # Broadcast cost computation\n    F = candidates[:, None]\n    L = free[None, :]\n    part1 = flow_matrix[F, placed][:, :, None] * distance_matrix[L, placed_locs][:, None, :]\n    part2 = flow_matrix[placed, F][:, None, :] * distance_matrix[placed_locs, L][:, :, None]\n    vals = part1 + part2\n\n    if placed.size == 0:\n        scores = np.zeros((candidates.size, free.size))\n    else:\n        # Trimmed mean: keep middle 80% after sorting\n        sorted_vals = np.sort(vals, axis=2)\n        trim = int(0.1 * sorted_vals.shape[2])\n        trimmed = sorted_vals[:, :, trim:-trim] if trim > 0 else sorted_vals\n        scores = np.mean(trimmed, axis=2)\n\n    # Clip scores to avoid extreme values\n    scores = np.clip(scores, -1e9, 1e9)\n\n    # Deterministic tie\u2011breaker\n    noise = 1e-7 * np.arange(scores.size).reshape(scores.shape)\n    scores += noise\n\n    # Choose the pair with the minimal score\n    idx_flat = np.argmin(scores)\n    idx_f, idx_l = np.unravel_index(idx_flat, scores.shape)\n    best_f, best_l = int(candidates[idx_f]), int(free[idx_l])\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "minimax_incremental_worst_edge_aug_272": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Vectorised minimax assignment with clipping of extreme matrix values.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Facilities that are still unassigned\n    candidates = np.flatnonzero(a == -1)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Locations that are still free\n    occupied = a != -1\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[occupied]] = True\n    free_locs = np.flatnonzero(~used_locs)\n\n    # Already assigned facilities and their locations\n    assigned_fac = np.flatnonzero(occupied)\n    assigned_loc = a[assigned_fac]\n\n    # Clip matrices to avoid overflow/underflow\n    flow_clipped = np.clip(flow_matrix, 0, np.inf)\n    dist_clipped = np.clip(distance_matrix, 0, np.inf)\n\n    # Initialise score matrix with infinities\n    scores = np.full((candidates.size, free_locs.size), np.inf, dtype=float)\n\n    if assigned_fac.size > 0:\n        # Broadcast indices for vectorised computation\n        f_idx = candidates[:, None]\n        l_idx = free_locs[None, :]\n\n        # Forward and reverse interaction costs\n        v1 = flow_clipped[f_idx, assigned_fac] * dist_clipped[l_idx, assigned_loc]\n        v2 = flow_clipped[assigned_fac, f_idx] * dist_clipped[assigned_loc, l_idx]\n\n        # Maximise over both directions for each candidate pair\n        scores = np.max(np.stack([v1, v2], axis=2), axis=2)\n\n    # Pick the candidate pair with the smallest score\n    min_idx = np.unravel_index(np.argmin(scores), scores.shape)\n    best_f = candidates[min_idx[0]]\n    best_l = free_locs[min_idx[1]]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "minimax_incremental_worst_edge_aug_273": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Soft\u2011min selection with a random pick among the top\u2011k best candidates.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Unassigned facilities\n    candidates = np.flatnonzero(a == -1)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Free locations\n    occupied = a != -1\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[occupied]] = True\n    free_locs = np.flatnonzero(~used_locs)\n\n    # Already assigned facilities and locations\n    assigned_fac = np.flatnonzero(occupied)\n    assigned_loc = a[assigned_fac]\n\n    # Clip to keep values bounded\n    flow_clipped = np.clip(flow_matrix, 0, np.inf)\n    dist_clipped = np.clip(distance_matrix, 0, np.inf)\n\n    # Compute minimax scores\n    scores = np.full((candidates.size, free_locs.size), np.inf, dtype=float)\n    if assigned_fac.size > 0:\n        f_idx = candidates[:, None]\n        l_idx = free_locs[None, :]\n        v1 = flow_clipped[f_idx, assigned_fac] * dist_clipped[l_idx, assigned_loc]\n        v2 = flow_clipped[assigned_fac, f_idx] * dist_clipped[assigned_loc, l_idx]\n        scores = np.max(np.stack([v1, v2], axis=2), axis=2)\n\n    # Soft\u2011min probability distribution\n    T = 1.0\n    exp_vals = np.exp(-scores / (T + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # Randomly pick among the top\u2011k best candidates\n    top_k = 5\n    flat_indices = np.argsort(probs)[:top_k]\n    chosen = np.random.choice(flat_indices)\n\n    best_f = candidates[chosen // free_locs.size]\n    best_l = free_locs[chosen % free_locs.size]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "minimax_incremental_worst_edge_aug_274": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Deterministic tie\u2011breaking by adding a tiny noise term based on indices.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Candidate facilities\n    candidates = np.flatnonzero(a == -1)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Free locations\n    occupied = a != -1\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[occupied]] = True\n    free_locs = np.flatnonzero(~used_locs)\n\n    # Already assigned facilities and locations\n    assigned_fac = np.flatnonzero(occupied)\n    assigned_loc = a[assigned_fac]\n\n    # Clip matrices\n    flow_clipped = np.clip(flow_matrix, 0, np.inf)\n    dist_clipped = np.clip(distance_matrix, 0, np.inf)\n\n    best_score = np.inf\n    best_f = int(candidates[0])\n    best_l = int(free_locs[0])\n    noise_eps = 1e-8\n\n    for f in candidates:\n        for l in free_locs:\n            if assigned_fac.size == 0:\n                score = 0.0\n            else:\n                v1 = flow_clipped[f, assigned_fac] * dist_clipped[l, assigned_loc]\n                v2 = flow_clipped[assigned_fac, f] * dist_clipped[assigned_loc, l]\n                score = float(np.max(np.concatenate((v1, v2))))\n            # Deterministic noise for tie\u2011breaking\n            score += noise_eps * (f * 1000 + l)\n            if score < best_score:\n                best_score = score\n                best_f = int(f)\n                best_l = int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "minimax_incremental_worst_edge_aug_275": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Weighted combination of max and mean interaction costs.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Unassigned facilities\n    candidates = np.flatnonzero(a == -1)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Free locations\n    occupied = a != -1\n    used_locs = np.zeros(n, dtype=bool)\n    used_locs[a[occupied]] = True\n    free_locs = np.flatnonzero(~used_locs)\n\n    # Assigned facilities and their locations\n    assigned_fac = np.flatnonzero(occupied)\n    assigned_loc = a[assigned_fac]\n\n    # Clip to keep values bounded\n    flow_clipped = np.clip(flow_matrix, 0, np.inf)\n    dist_clipped = np.clip(distance_matrix, 0, np.inf)\n\n    best_score = np.inf\n    best_f = int(candidates[0])\n    best_l = int(free_locs[0])\n\n    w_max = 0.6\n    w_mean = 0.4\n\n    for f in candidates:\n        for l in free_locs:\n            if assigned_fac.size == 0:\n                score = 0.0\n            else:\n                v1 = flow_clipped[f, assigned_fac] * dist_clipped[l, assigned_loc]\n                v2 = flow_clipped[assigned_fac, f] * dist_clipped[assigned_loc, l]\n                interactions = np.concatenate((v1, v2))\n                score = w_max * float(np.max(interactions)) + w_mean * float(np.mean(interactions))\n            if score < best_score:\n                best_score = score\n                best_f = int(f)\n                best_l = int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "maximin_alignment_score_aug_276": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorised implementation that selects the facility\u2013location pair\n    with the maximal conservative score (min of normalised potential and\n    centrality), adding a tiny random noise to break ties.\"\"\"\n    assignment = np.asarray(current_assignment, dtype=int)\n    n = assignment.size\n\n    # Facilities that are still unassigned\n    unassigned = np.where(assignment == -1)[0]\n    if unassigned.size == 0:\n        return assignment.tolist()\n\n    # Locations that are still free\n    used_loc = np.zeros(n, dtype=bool)\n    used_loc[assignment[assignment != -1]] = True\n    free_loc = np.where(~used_loc)[0]\n\n    # Normalised facility potential (flow)\n    pf_raw = flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)\n    pf_min, pf_max = pf_raw.min(), pf_raw.max()\n    pf = (pf_raw - pf_min) / (pf_max - pf_min + 1e-12)\n    pf = np.clip(pf, 0.0, 1.0)\n\n    # Normalised location centrality (inverse of distance sum)\n    cl_raw = 1.0 / (distance_matrix.sum(axis=1) + 1e-12)\n    cl_min, cl_max = cl_raw.min(), cl_raw.max()\n    cl = (cl_raw - cl_min) / (cl_max - cl_min + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)\n\n    # Conservative score matrix (min of pf and cl)\n    scores = np.minimum.outer(pf, cl)\n\n    # Add a tiny deterministic noise to break ties\n    noise = np.random.uniform(0, 1e-6, scores.shape)\n    scores += noise\n\n    # Restrict to unassigned facilities and free locations\n    sub_scores = scores[np.ix_(unassigned, free_loc)]\n    idx = np.unravel_index(np.argmax(sub_scores), sub_scores.shape)\n    best_fac = unassigned[idx[0]]\n    best_loc = free_loc[idx[1]]\n\n    assignment[best_fac] = best_loc\n    return assignment.tolist()\n\n",
  "maximin_alignment_score_aug_277": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Greedy weighted\u2011sum heuristic that picks among the top\u2011k best pairs\n    using a random choice to diversify the search.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # Unassigned facilities\n    facs = np.where(assign == -1)[0]\n    if facs.size == 0:\n        return assign.tolist()\n\n    # Free locations\n    used = np.zeros(n, dtype=bool)\n    used[assign[assign != -1]] = True\n    locs = np.where(~used)[0]\n\n    # Normalise flow potential\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n    pf = np.clip(pf, 0.0, 1.0)\n\n    # Normalise location centrality (inverse of mean distance)\n    cl = 1.0 / (distance_matrix.mean(axis=1) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)\n\n    # Weighted sum of pf and cl\n    weight_f, weight_l = 0.6, 0.4\n    best_score = -float('inf')\n    best_pair = (facs[0], locs[0])\n\n    for f in facs:\n        for l in locs:\n            score = weight_f * pf[f] + weight_l * cl[l]\n            if score > best_score:\n                best_score = score\n                best_pair = (f, l)\n\n    # Top\u2011k selection\n    top_k = 5\n    scores = []\n    for f in facs:\n        for l in locs:\n            s = weight_f * pf[f] + weight_l * cl[l]\n            scores.append((s, f, l))\n    scores.sort(key=lambda x: x[0], reverse=True)\n    top_pairs = scores[:top_k]\n    chosen = np.random.choice(len(top_pairs), 1)[0]\n    f_best, l_best = top_pairs[chosen][1], top_pairs[chosen][2]\n\n    assign[f_best] = l_best\n    return assign.tolist()\n\n",
  "maximin_alignment_score_aug_278": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Median\u2011based normalisation and random selection among the best\n    pairs, with a soft\u2011max style weighting.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Identify candidates\n    cand_fac = np.where(a == -1)[0]\n    if cand_fac.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    used_loc[a[a != -1]] = True\n    cand_loc = np.where(~used_loc)[0]\n\n    # Median\u2011normalised flow potential\n    pf_raw = flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)\n    pf = (pf_raw - np.median(pf_raw)) / (np.ptp(pf_raw) + 1e-12)\n    pf = np.clip(pf, 0.0, 1.0)\n\n    # Centrality based on mean distance, median normalisation\n    cl_raw = 1.0 / (np.mean(distance_matrix, axis=1) + 1e-12)\n    cl = (cl_raw - np.median(cl_raw)) / (np.ptp(cl_raw) + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)\n\n    # Soft\u2011max weighting with temperature\n    beta = 5.0\n    scores = []\n    for f in cand_fac:\n        for l in cand_loc:\n            raw = pf[f] + cl[l]\n            scores.append((raw, f, l))\n    # Compute probabilities\n    raw_vals = np.array([s[0] for s in scores])\n    exp_vals = np.exp(beta * raw_vals)\n    probs = exp_vals / exp_vals.sum()\n\n    # Randomly choose a pair weighted by soft\u2011max probabilities\n    idx = np.random.choice(len(scores), p=probs)\n    f_sel, l_sel = scores[idx][1], scores[idx][2]\n\n    a[f_sel] = l_sel\n    return a.tolist()\n\n",
  "maximin_alignment_score_aug_279": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Inverted logic with squared distance centrality and deterministic\n    tie\u2011breaking via a small noise term.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # If all facilities are already placed, return unchanged\n    if np.all(assign != -1):\n        return assign.tolist()\n\n    # Candidates and free locations\n    facs = np.where(assign == -1)[0]\n    used = np.zeros(n, dtype=bool)\n    used[assign[assign != -1]] = True\n    locs = np.where(~used)[0]\n\n    # Flow potential (raw)\n    pf_raw = flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)\n    pf_min, pf_max = pf_raw.min(), pf_raw.max()\n    pf = (pf_raw - pf_min) / (pf_max - pf_min + 1e-12)\n    pf = np.clip(pf, 0.0, 1.0)\n\n    # Centrality using squared distances\n    dist_sq = np.square(distance_matrix)\n    cl_raw = 1.0 / (dist_sq.sum(axis=1) + 1e-12)\n    cl_min, cl_max = cl_raw.min(), cl_raw.max()\n    cl = (cl_raw - cl_min) / (cl_max - cl_min + 1e-12)\n    cl = np.clip(cl, 0.0, 1.0)\n\n    # Compute conservative score (min) with deterministic noise\n    best_score = -float('inf')\n    best_f, best_l = facs[0], locs[0]\n    for f in facs:\n        for l in locs:\n            score = min(pf[f], cl[l]) + np.random.uniform(0, 1e-6)\n            if score > best_score:\n                best_score = score\n                best_f, best_l = f, l\n\n    assign[best_f] = best_l\n    return assign.tolist()\n\n",
  "farthest_point_flow_clustering_representative_aug_280": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Farthest\u2011point selection in flow\u2011space with vectorised operations.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Unassigned facilities\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return a.tolist()\n\n    # Free locations\n    used = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    # Symmetric flow (prevent division by zero)\n    sym = np.clip(flow_matrix + flow_matrix.T, 1e-12, None)\n\n    # Choose up to three farthest centers\n    k = min(3, max(1, un.size))\n    centers = [int(un[0])]\n    for _ in range(1, k):\n        # distance to existing centers\n        dists = np.sum(1.0 / (sym[np.ix_(un, centers)] + 1e-12), axis=1)\n        idx = np.argmax(dists)\n        centers.append(int(un[idx]))\n\n    # Densest center among the candidates\n    center_scores = np.sum(sym[centers][:, un], axis=1)\n    f = int(centers[int(np.argmax(center_scores))])\n\n    # Existing assignments\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    # Incremental cost for each free location\n    incs = np.empty(free.size, dtype=float)\n    for i, l in enumerate(free):\n        if ass.size == 0:\n            incs[i] = 0.0\n        else:\n            incs[i] = np.sum(\n                flow_matrix[f, ass] * distance_matrix[l, locs] +\n                flow_matrix[ass, f] * distance_matrix[locs, l]\n            )\n\n    best_l = int(free[np.argmin(incs)])\n    out = a.copy()\n    out[int(f)] = int(best_l)\n    return out.tolist()\n\n",
  "farthest_point_flow_clustering_representative_aug_281": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Weighted cost and softmin selection.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    sym = np.clip(flow_matrix + flow_matrix.T, 1e-8, None)\n\n    k = min(5, max(1, un.size))\n    centers = [int(un[0])]\n    for _ in range(1, k):\n        dists = np.sum(1.0 / (sym[np.ix_(un, centers)] + 1e-8), axis=1)\n        idx = np.argmax(dists)\n        centers.append(int(un[idx]))\n\n    center_scores = np.mean(sym[centers][:, un], axis=1)\n    f = int(centers[int(np.argmax(center_scores))])\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    # Weighted incremental cost\n    w_flow, w_dist = 0.6, 0.4\n    incs = np.empty(free.size, dtype=float)\n    for i, l in enumerate(free):\n        if ass.size == 0:\n            incs[i] = 0.0\n        else:\n            incs[i] = np.sum(\n                w_flow * flow_matrix[f, ass] * distance_matrix[l, locs] +\n                w_dist * flow_matrix[ass, f] * distance_matrix[locs, l]\n            )\n\n    # Softmin selection\n    temp = 0.5\n    probs = np.exp(-incs / temp)\n    best_l = int(free[np.argmax(probs)])\n    out = a.copy()\n    out[int(f)] = int(best_l)\n    return out.tolist()\n\n",
  "farthest_point_flow_clustering_representative_aug_282": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Deterministic tie\u2011breaking with noise, median aggregation.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    sym = np.clip(flow_matrix + flow_matrix.T, 1e-12, None)\n\n    k = min(3, max(1, un.size))\n    centers = [int(un[0])]\n    for _ in range(1, k):\n        dists = np.sum(1.0 / (sym[np.ix_(un, centers)] + 1e-12), axis=1)\n        idx = np.argmax(dists)\n        centers.append(int(un[idx]))\n\n    center_scores = np.median(sym[centers][:, un], axis=1)\n    f = int(centers[int(np.argmax(center_scores))])\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    incs = np.empty(free.size, dtype=float)\n    for i, l in enumerate(free):\n        if ass.size == 0:\n            incs[i] = 0.0\n        else:\n            incs[i] = np.sum(\n                flow_matrix[f, ass] * distance_matrix[l, locs] +\n                flow_matrix[ass, f] * distance_matrix[locs, l]\n            )\n\n    # Add deterministic noise for tie\u2011breaking\n    noise = np.arange(free.size) * 1e-9\n    incs += noise\n\n    best_l = int(free[np.argmin(incs)])\n    out = a.copy()\n    out[int(f)] = int(best_l)\n    return out.tolist()\n\n",
  "farthest_point_flow_clustering_representative_aug_283": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    While\u2011loop structure with mean cost aggregation.\n    \"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Identify unassigned facilities\n    un = np.where(a == -1)[0]\n    if un.size == 0:\n        return a.tolist()\n\n    # Determine free locations\n    used = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used[a[a != -1]] = True\n    free = np.where(~used)[0]\n\n    sym = np.clip(flow_matrix + flow_matrix.T, 1e-6, None)\n\n    # Farthest\u2011point traversal using a while loop\n    k = min(3, max(1, un.size))\n    centers = [int(un[0])]\n    idx = 1\n    while idx < k:\n        dists = np.sum(1.0 / (sym[np.ix_(un, centers)] + 1e-6), axis=1)\n        best = np.argmax(dists)\n        centers.append(int(un[best]))\n        idx += 1\n\n    # Densest center via mean flow\n    center_scores = np.mean(sym[centers][:, un], axis=1)\n    f = int(centers[int(np.argmax(center_scores))])\n\n    ass = np.where(a != -1)[0]\n    locs = a[ass]\n\n    # Incremental cost computed with mean aggregation\n    incs = np.empty(free.size, dtype=float)\n    i = 0\n    while i < free.size:\n        l = free[i]\n        if ass.size == 0:\n            incs[i] = 0.0\n        else:\n            incs[i] = np.mean(\n                flow_matrix[f, ass] * distance_matrix[l, locs] +\n                flow_matrix[ass, f] * distance_matrix[locs, l]\n            )\n        i += 1\n\n    best_l = int(free[np.argmin(incs)])\n    out = a.copy()\n    out[int(f)] = int(best_l)\n    return out.tolist()\n\n",
  "free_location_degree_centrality_then_best_facility_aug_284": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur_assign = np.asarray(current_assignment, dtype=int)\n    n = cur_assign.size\n    eps = 1e-12\n\n    # facilities that are not yet placed\n    unassigned = np.flatnonzero(cur_assign == -1).astype(int)\n    if unassigned.size == 0:\n        return cur_assign.tolist()\n\n    # locations that are already used\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(cur_assign != -1):\n        used_loc[cur_assign[cur_assign != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    # similarity graph on locations (inverse distances)\n    inv_dist = 1.0 / (distance_matrix.astype(float) + eps)\n    degrees = np.clip(inv_dist[free_locs].sum(axis=1), 0, 1e6)\n\n    # pick location with the highest similarity-degree\n    loc_idx = free_locs[int(np.argmax(degrees))]\n\n    # currently placed facilities and their locations\n    assigned_fac = np.flatnonzero(cur_assign != -1).astype(int)\n    assigned_locs = cur_assign[assigned_fac].astype(int)\n\n    best_fac = unassigned[0]\n    best_inc = np.inf\n\n    for f in unassigned:\n        if assigned_fac.size == 0:\n            inc = 0.0\n        else:\n            inc = float(np.sum(flow_matrix[f, assigned_fac] * distance_matrix[loc_idx, assigned_locs] +\n                               flow_matrix[assigned_fac, f] * distance_matrix[assigned_locs, loc_idx]))\n        if inc < best_inc:\n            best_inc = inc\n            best_fac = f\n\n    result = cur_assign.copy()\n    result[best_fac] = loc_idx\n    return result.tolist()\n\n",
  "free_location_degree_centrality_then_best_facility_aug_285": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n    eps = 1e-12\n\n    unassigned = np.flatnonzero(cur == -1).astype(int)\n    if unassigned.size == 0:\n        return cur.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(cur != -1):\n        used[cur[cur != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    inv_dist = 1.0 / (distance_matrix.astype(float) + eps)\n    degrees = np.clip(inv_dist[free_locs].sum(axis=1), 0, 1e6)\n\n    # weighted soft\u2011max over degrees (temperature controls spread)\n    temp = 0.5\n    exp_scores = np.exp(degrees / temp)\n    probs = exp_scores / exp_scores.sum()\n    chosen_loc = free_locs[np.argmax(probs)]\n\n    assigned_fac = np.flatnonzero(cur != -1).astype(int)\n    assigned_locs = cur[assigned_fac].astype(int)\n\n    # incremental costs for each unassigned facility at the chosen location\n    incs = np.empty(unassigned.size, dtype=float)\n    for idx, f in enumerate(unassigned):\n        if assigned_fac.size == 0:\n            incs[idx] = 0.0\n        else:\n            incs[idx] = np.sum(flow_matrix[f, assigned_fac] * distance_matrix[chosen_loc, assigned_locs] +\n                               flow_matrix[assigned_fac, f] * distance_matrix[assigned_locs, chosen_loc])\n\n    # soft\u2011min over incremental costs with deterministic noise for ties\n    noise = 1e-6 * np.arange(unassigned.size)\n    incs += noise\n    softmin = np.exp(-incs / temp)\n    soft_probs = softmin / softmin.sum()\n\n    # pick among the top\u20113 lowest costs\n    top_k = min(3, incs.size)\n    top_indices = np.argpartition(soft_probs, -top_k)[-top_k:]\n    chosen_fac = unassigned[top_indices[np.argmax(soft_probs[top_indices])]]\n\n    result = cur.copy()\n    result[chosen_fac] = chosen_loc\n    return result.tolist()\n\n",
  "free_location_degree_centrality_then_best_facility_aug_286": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n    eps = 1e-12\n\n    unassigned = np.flatnonzero(cur == -1).astype(int)\n    if unassigned.size == 0:\n        return cur.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(cur != -1):\n        used[cur[cur != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    inv_dist = 1.0 / (distance_matrix.astype(float) + eps)\n    # use median of similarities instead of sum\n    degrees = np.median(inv_dist[free_locs], axis=1)\n    degrees = np.clip(degrees, 0, 1e6)\n    loc = free_locs[int(np.argmax(degrees))]\n\n    assigned_fac = np.flatnonzero(cur != -1).astype(int)\n    assigned_locs = cur[assigned_fac].astype(int)\n\n    best_fac = unassigned[0]\n    best_inc = np.inf\n\n    for f in unassigned:\n        if assigned_fac.size == 0:\n            inc = 0.0\n        else:\n            # proxy: use maximum weighted distance rather than sum\n            inc = float(np.max(flow_matrix[f, assigned_fac] * distance_matrix[loc, assigned_locs] +\n                               flow_matrix[assigned_fac, f] * distance_matrix[assigned_locs, loc]))\n        # deterministic tie\u2011breaking noise\n        inc += 1e-6 * (f % 7)\n        if inc < best_inc:\n            best_inc = inc\n            best_fac = f\n\n    result = cur.copy()\n    result[best_fac] = loc\n    return result.tolist()\n\n",
  "free_location_degree_centrality_then_best_facility_aug_287": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    cur = np.asarray(current_assignment, dtype=int)\n    n = cur.size\n    eps = 1e-12\n\n    unassigned = np.flatnonzero(cur == -1).astype(int)\n    if unassigned.size == 0:\n        return cur.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(cur != -1):\n        used[cur[cur != -1]] = True\n    free_locs = np.flatnonzero(~used).astype(int)\n\n    inv_dist = 1.0 / (distance_matrix.astype(float) + eps)\n    degrees = np.clip(inv_dist[free_locs].sum(axis=1), 0, 1e6)\n\n    # softmax to select a location\n    temp = 0.3\n    soft = np.exp(degrees / temp)\n    probs = soft / soft.sum()\n    loc = free_locs[np.argmax(probs)]\n\n    assigned_fac = np.flatnonzero(cur != -1).astype(int)\n    assigned_locs = cur[assigned_fac].astype(int)\n\n    # compute incremental costs with a while loop\n    incs = np.empty(unassigned.size, dtype=float)\n    idx = 0\n    while idx < unassigned.size:\n        f = unassigned[idx]\n        if assigned_fac.size == 0:\n            incs[idx] = 0.0\n        else:\n            incs[idx] = np.sum(flow_matrix[f, assigned_fac] * distance_matrix[loc, assigned_locs] +\n                               flow_matrix[assigned_fac, f] * distance_matrix[assigned_locs, loc])\n        idx += 1\n\n    # soft\u2011min and random choice among the two best\n    softmin = np.exp(-incs / temp)\n    probs_fac = softmin / softmin.sum()\n    top_k = min(2, incs.size)\n    top_indices = np.argpartition(probs_fac, -top_k)[-top_k:]\n    chosen_fac = unassigned[top_indices[np.argmax(probs_fac[top_indices])]]\n\n    result = cur.copy()\n    result[chosen_fac] = loc\n    return result.tolist()\n\n",
  "maximize_entropy_of_location_costs_aug_288": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Pick facility whose incremental costs over locations have highest entropy,\n    then choose its best location.\"\"\"\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # Facilities that are still unassigned\n    unplaced = np.where(assign == -1)[0]\n    if unplaced.size == 0:\n        return assign.tolist()\n\n    # Locations already taken\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    free_locs = np.where(~used_loc)[0]\n\n    # Already placed facilities and their locations\n    placed_fac = np.where(assign != -1)[0]\n    placed_loc = assign[placed_fac]\n\n    def _costs_for_fac(f: int) -> np.ndarray:\n        if placed_fac.size == 0:\n            return np.zeros(free_locs.size, dtype=float)\n        f_flow = flow_matrix[f, placed_fac]\n        f_rev_flow = flow_matrix[placed_fac, f]\n        dist_to = distance_matrix[free_locs[:, None], placed_loc[None, :]]\n        cost_vec = (f_flow[None, :] * dist_to).sum(axis=1) + (f_rev_flow[None, :] * dist_to).sum(axis=1)\n        return cost_vec\n\n    best_entropy = -np.inf\n    best_fac = unplaced[0]\n    best_loc = free_locs[0]\n\n    idx = 0\n    while idx < unplaced.size:\n        f = unplaced[idx]\n        costs = _costs_for_fac(int(f))\n        # Softmax of negative costs\n        temp = -(costs - costs.min())\n        exp_vals = np.exp(temp - temp.max())\n        probs = exp_vals / (exp_vals.sum() + 1e-12)\n        entropy = -np.sum(probs * np.log(probs + 1e-12))\n        loc_choice = free_locs[np.argmin(costs)]\n        if entropy > best_entropy:\n            best_entropy = entropy\n            best_fac = f\n            best_loc = loc_choice\n        idx += 1\n\n    out = assign.copy()\n    out[best_fac] = best_loc\n    return out.tolist()\n\n",
  "maximize_entropy_of_location_costs_aug_289": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    unplaced = np.where(assign == -1)[0]\n    if unplaced.size == 0:\n        return assign.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    free_locs = np.where(~used_loc)[0]\n\n    placed_fac = np.where(assign != -1)[0]\n    placed_loc = assign[placed_fac]\n\n    def _costs_for_fac(f: int) -> np.ndarray:\n        if placed_fac.size == 0:\n            return np.zeros(free_locs.size, dtype=float)\n        f_flow = flow_matrix[f, placed_fac]\n        f_rev_flow = flow_matrix[placed_fac, f]\n        dist_to = distance_matrix[free_locs[:, None], placed_loc[None, :]]\n        cost_vec = (f_flow[None, :] * dist_to).sum(axis=1) + (f_rev_flow[None, :] * dist_to).sum(axis=1)\n        return cost_vec\n\n    best_entropy = -np.inf\n    best_fac = unplaced[0]\n    best_loc = free_locs[0]\n\n    for f in unplaced:\n        costs = _costs_for_fac(int(f))\n        # deterministic noise to break ties\n        noise = np.linspace(-1e-6, 1e-6, costs.size)\n        costs = costs + noise\n        # Softmax with temperature 0.5\n        temp = -(costs - costs.min()) / 0.5\n        exp_vals = np.exp(temp - temp.max())\n        probs = exp_vals / (exp_vals.sum() + 1e-12)\n        entropy = -np.sum(probs * np.log(probs + 1e-12))\n        # Choose among top\u20113 cheapest locations with weighted random selection\n        top_k = 3\n        top_idx = np.argsort(costs)[:top_k]\n        top_probs = probs[top_idx]\n        top_probs = top_probs / (top_probs.sum() + 1e-12)\n        loc_choice = free_locs[np.random.choice(top_idx, p=top_probs)]\n        if entropy > best_entropy:\n            best_entropy = entropy\n            best_fac = f\n            best_loc = loc_choice\n\n    out = assign.copy()\n    out[best_fac] = best_loc\n    return out.tolist()\n\n",
  "maximize_entropy_of_location_costs_aug_290": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    unplaced = np.where(assign == -1)[0]\n    if unplaced.size == 0:\n        return assign.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    free_locs = np.where(~used_loc)[0]\n\n    placed_fac = np.where(assign != -1)[0]\n    placed_loc = assign[placed_fac]\n\n    def _costs_for_fac(f: int) -> np.ndarray:\n        if placed_fac.size == 0:\n            return np.zeros(free_locs.size, dtype=float)\n        f_flow = flow_matrix[f, placed_fac]\n        f_rev_flow = flow_matrix[placed_fac, f]\n        dist_to = distance_matrix[free_locs[:, None], placed_loc[None, :]]\n        # Use median instead of sum for aggregation\n        cost_vec = np.median(f_flow[None, :] * dist_to, axis=1) + np.median(f_rev_flow[None, :] * dist_to, axis=1)\n        return cost_vec\n\n    best_entropy = -np.inf\n    best_fac = unplaced[0]\n    best_loc = free_locs[0]\n\n    for f in unplaced:\n        costs = _costs_for_fac(int(f))\n        # Softmin probabilities\n        min_cost = costs.min()\n        exp_vals = np.exp(-(costs - min_cost))\n        probs = exp_vals / (exp_vals.sum() + 1e-12)\n        entropy = -np.sum(probs * np.log(probs + 1e-12))\n        # Random choice weighted by softmin over all locations\n        loc_choice = free_locs[np.random.choice(free_locs.size, p=probs)]\n        if entropy > best_entropy:\n            best_entropy = entropy\n            best_fac = f\n            best_loc = loc_choice\n\n    out = assign.copy()\n    out[best_fac] = best_loc\n    return out.tolist()\n\n",
  "maximize_entropy_of_location_costs_aug_291": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    unplaced = np.where(assign == -1)[0]\n    if unplaced.size == 0:\n        return assign.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    free_locs = np.where(~used_loc)[0]\n\n    placed_fac = np.where(assign != -1)[0]\n    placed_loc = assign[placed_fac]\n\n    def _costs_for_fac(f: int) -> np.ndarray:\n        if placed_fac.size == 0:\n            return np.zeros(free_locs.size, dtype=float)\n        f_flow = flow_matrix[f, placed_fac]\n        f_rev_flow = flow_matrix[placed_fac, f]\n        dist_to = distance_matrix[free_locs[:, None], placed_loc[None, :]]\n        # Use max aggregation for a conservative estimate\n        cost_vec = np.max(f_flow[None, :] * dist_to, axis=1) + np.max(f_rev_flow[None, :] * dist_to, axis=1)\n        return cost_vec\n\n    best_entropy = -np.inf\n    best_fac = unplaced[0]\n    best_loc = free_locs[0]\n\n    idx = 0\n    while idx < unplaced.size:\n        f = unplaced[idx]\n        costs = _costs_for_fac(int(f))\n        # Deterministic noise for tie\u2011breaking\n        noise = np.linspace(-1e-7, 1e-7, costs.size)\n        costs = costs + noise\n        # Softmax with temperature 1.5\n        temp = -(costs - costs.min()) / 1.5\n        exp_vals = np.exp(temp - temp.max())\n        probs = exp_vals / (exp_vals.sum() + 1e-12)\n        probs = np.clip(probs, 1e-12, 1.0)  # ensure valid probabilities\n        entropy = -np.sum(probs * np.log(probs + 1e-12))\n        # Select among top\u20115 cheapest locations\n        top_k = 5\n        top_idx = np.argsort(costs)[:top_k]\n        top_probs = probs[top_idx]\n        top_probs = top_probs / (top_probs.sum() + 1e-12)\n        loc_choice = free_locs[np.random.choice(top_idx, p=top_probs)]\n        if entropy > best_entropy:\n            best_entropy = entropy\n            best_fac = f\n            best_loc = loc_choice\n        idx += 1\n\n    out = assign.copy()\n    out[best_fac] = best_loc\n    return out.tolist()\n\n",
  "diversify_by_flow_distance_from_assigned_aug_292": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # find unassigned facilities and free locations\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    # already assigned facilities and their locations\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    # incremental cost for every candidate pair\n    incs = []\n    pairs = []\n    for f in unassigned:\n        for l in free_locs:\n            if assigned_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(\n                    np.sum(flow_mat[f, assigned_fac] * dist_mat[l, assigned_loc] +\n                           flow_mat[assigned_fac, f] * dist_mat[assigned_loc, l])\n                )\n            pairs.append((int(f), int(l)))\n            incs.append(float(inc))\n    incs = np.asarray(incs, dtype=float)\n\n    # top\u2011k candidates by incremental cost\n    k = max(1, int(np.ceil(0.08 * incs.size)))\n    top_idx = np.argsort(incs)[:k]\n\n    # flow dissimilarity (mean of assigned facilities)\n    if assigned_fac.size:\n        mu = flow_mat[assigned_fac].mean(axis=0).astype(float)\n    else:\n        mu = flow_mat.mean(axis=0).astype(float)\n\n    # soft\u2011min weighting over the top\u2011k candidates\n    beta = 5.0\n    weights = np.exp(-beta * incs[top_idx])\n    weights /= (weights.sum() + 1e-12)  # epsilon to avoid division by zero\n\n    # deterministic RNG seeded from the current assignment\n    rng = np.random.default_rng(seed=int(abs(hash(tuple(current_assignment))) & 0xffffffff))\n\n    chosen = rng.choice(len(top_idx), p=weights)\n    f_best, l_best = pairs[top_idx[chosen]]\n\n    out = a.copy()\n    out[f_best] = l_best\n    return out.tolist()\n\n",
  "diversify_by_flow_distance_from_assigned_aug_293": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    # generate all candidate pairs\n    pairs = [(int(f), int(l)) for f in unassigned for l in free_locs]\n\n    # incremental cost for each pair\n    if assigned_fac.size == 0:\n        incs = np.zeros(len(pairs), dtype=float)\n    else:\n        incs = np.array([\n            float(\n                np.sum(flow_mat[f, assigned_fac] * dist_mat[l, assigned_loc] +\n                       flow_mat[assigned_fac, f] * dist_mat[assigned_loc, l])\n            )\n            for f, l in pairs\n        ])\n\n    incs = np.clip(incs, 0.0, 1e6)  # bound to avoid overflow\n\n    top_k = 7\n    top_idx = np.argsort(incs)[:top_k]\n\n    # median\u2011based mean vector\n    if assigned_fac.size:\n        mu = np.median(flow_mat[assigned_fac], axis=0).astype(float)\n    else:\n        mu = np.median(flow_mat, axis=0).astype(float)\n\n    rng = np.random.default_rng(seed=int(abs(hash(tuple(current_assignment))) & 0xffffffff))\n\n    best_score = -float('inf')\n    best_pair = pairs[top_idx[0]]\n    for idx in top_idx:\n        f, l = pairs[idx]\n        d = float(np.linalg.norm(flow_mat[f].astype(float) - mu))\n        inc = incs[idx]\n        noise = rng.random() * 1e-6  # deterministic small noise\n        score = 0.6 * d + 0.4 * inc + noise\n        if score > best_score:\n            best_score = score\n            best_pair = (f, l)\n\n    out = a.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n\n",
  "diversify_by_flow_distance_from_assigned_aug_294": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    # gather all candidate pairs and their incremental costs\n    pairs = []\n    incs = []\n    for f in unassigned:\n        for l in free_locs:\n            if assigned_fac.size == 0:\n                inc = 0.0\n            else:\n                inc = float(\n                    np.sum(flow_mat[f, assigned_fac] * dist_mat[l, assigned_loc] +\n                           flow_mat[assigned_fac, f] * dist_mat[assigned_loc, l])\n                )\n            pairs.append((int(f), int(l)))\n            incs.append(float(inc))\n    incs = np.asarray(incs, dtype=float)\n\n    top_k = 5\n    top_idx = np.argsort(incs)[:top_k]\n\n    if assigned_fac.size:\n        mu = np.median(flow_mat[assigned_fac], axis=0).astype(float)\n    else:\n        mu = np.median(flow_mat, axis=0).astype(float)\n\n    rng = np.random.default_rng(seed=int(abs(hash(tuple(current_assignment))) & 0xffffffff))\n\n    # softmax weighting over the top\u2011k candidates\n    beta = 10.0\n    logits = np.exp(-beta * incs[top_idx])\n    probs = logits / (logits.sum() + 1e-12)  # epsilon guard\n\n    chosen = rng.choice(len(top_idx), p=probs)\n    f_best, l_best = pairs[top_idx[chosen]]\n\n    out = a.copy()\n    out[f_best] = l_best\n    return out.tolist()\n\n",
  "diversify_by_flow_distance_from_assigned_aug_295": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    flow_mat = flow_matrix\n    dist_mat = distance_matrix\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_locs = np.flatnonzero(~used_loc).astype(int)\n\n    assigned_fac = np.flatnonzero(a != -1).astype(int)\n    assigned_loc = a[assigned_fac].astype(int)\n\n    # candidate pairs\n    pairs = [(int(f), int(l)) for f in unassigned for l in free_locs]\n\n    # approximate incremental cost by max contribution per assigned pair\n    if assigned_fac.size == 0:\n        incs = np.zeros(len(pairs), dtype=float)\n    else:\n        incs = np.array([\n            float(\n                np.max(flow_mat[f, assigned_fac] * dist_mat[l, assigned_loc] +\n                       flow_mat[assigned_fac, f] * dist_mat[assigned_loc, l])\n            )\n            for f, l in pairs\n        ])\n\n    incs = np.clip(incs, 1e-12, 1e6)  # avoid division by zero later\n\n    top_k = 6\n    top_idx = np.argsort(incs)[:top_k]\n\n    if assigned_fac.size:\n        mu = flow_mat[assigned_fac].mean(axis=0).astype(float)\n    else:\n        mu = flow_mat.mean(axis=0).astype(float)\n\n    rng = np.random.default_rng(seed=int(abs(hash(tuple(current_assignment))) & 0xffffffff))\n\n    best_pair = pairs[top_idx[0]]\n    best_score = -float('inf')\n    for idx in top_idx:\n        f, l = pairs[idx]\n        d = float(np.linalg.norm(flow_mat[f].astype(float) - mu))\n        inc = incs[idx]\n        score = 0.8 * d + 0.2 * (1.0 / (1.0 + inc + 1e-12)) + rng.random() * 1e-6\n        if score > best_score:\n            best_score = score\n            best_pair = (f, l)\n\n    out = a.copy()\n    out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n\n",
  "bilinear_flow_distance_tradeoff_aug_296": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Vectorised incremental computation with soft\u2011min tie breaking.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # candidate facilities and free locations\n    cand_f = np.flatnonzero(a == -1).astype(int)\n    used_loc = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used_loc[a[a != -1]] = True\n    cand_l = np.flatnonzero(~used_loc).astype(int)\n\n    if cand_f.size == 0:\n        return a.tolist()\n\n    # Normalised facility potentials\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    # Normalised location centrality\n    cent = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cent = (cent - cent.min()) / (cent.max() - cent.min() + 1e-12)\n\n    # already assigned facilities and locations\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (cand_f.size / max(1, n))\n    alpha = 0.3 + 0.6 * progress          # weight for incremental part\n\n    best_score = np.inf\n    best_f, best_l = cand_f[0], cand_l[0]\n\n    # iterate over all candidate pairs\n    for f in cand_f:\n        for l in cand_l:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.dot(flow_matrix[f, ass], distance_matrix[l, locs]) +\n                            np.dot(flow_matrix[ass, f], distance_matrix[locs, l]))\n            penalty = pf[f] * (1.0 - cent[l])\n            penalty = np.clip(penalty, 0.0, 1.0)\n            score = alpha * inc + (1.0 - alpha) * penalty * (abs(inc) + 1.0)\n\n            # deterministic noise to break ties\n            noise = 1e-6 * ((f + 1) * (l + 1))\n            if score + noise < best_score:\n                best_score = score + noise\n                best_f, best_l = f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "bilinear_flow_distance_tradeoff_aug_297": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Median\u2011based incremental score with random top\u2011k selection.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # facilities yet to be assigned and free locations\n    cand_f = np.flatnonzero(a == -1).astype(int)\n    used_loc = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used_loc[a[a != -1]] = True\n    cand_l = np.flatnonzero(~used_loc).astype(int)\n\n    if cand_f.size == 0:\n        return a.tolist()\n\n    # normalised potentials\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    cent = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cent = (cent - cent.min()) / (cent.max() - cent.min() + 1e-12)\n\n    # current assignments\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (cand_f.size / max(1, n))\n    alpha = 0.6 + 0.2 * progress          # heavier weight on incremental part\n\n    scores = []\n    pairs = []\n\n    for f in cand_f:\n        for l in cand_l:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = np.median(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                flow_matrix[ass, f] * distance_matrix[locs, l])\n            penalty = pf[f] * (1.0 - cent[l])\n            penalty = np.clip(penalty, 0.0, 1.0)\n            score = alpha * inc + (1.0 - alpha) * penalty * (abs(inc) + 1.0)\n\n            # deterministic noise based on tuple hash\n            noise = 1e-6 * ((f * 31 + l) % 10007)\n            scores.append(score + noise)\n            pairs.append((f, l))\n\n    # choose among top\u2011k candidates\n    k = 5\n    idx_sorted = np.argsort(scores)\n    top_idx = idx_sorted[:k]\n    chosen = np.random.choice(top_idx)\n    best_f, best_l = pairs[chosen]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "bilinear_flow_distance_tradeoff_aug_298": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Broadcasted max\u2011based incremental evaluation with deterministic noise.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # unassigned facilities and free locations\n    cand_f = np.flatnonzero(a == -1).astype(int)\n    used_loc = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used_loc[a[a != -1]] = True\n    cand_l = np.flatnonzero(~used_loc).astype(int)\n\n    if cand_f.size == 0:\n        return a.tolist()\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    cent = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cent = (cent - cent.min()) / (cent.max() - cent.min() + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (cand_f.size / max(1, n))\n    alpha = 0.4 + 0.5 * progress\n\n    best_score = np.inf\n    best_f, best_l = cand_f[0], cand_l[0]\n\n    for f in cand_f:\n        for l in cand_l:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.max(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                   flow_matrix[ass, f] * distance_matrix[locs, l]))\n            penalty = pf[f] * (1.0 - cent[l])\n            penalty = np.clip(penalty, 0.0, 1.0)\n            score = alpha * inc + (1.0 - alpha) * penalty * (abs(inc) + 1.0)\n\n            # deterministic noise\n            noise = 1e-7 * ((f + 1) * (l + 1) % 1009)\n            if score + noise < best_score:\n                best_score = score + noise\n                best_f, best_l = f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "bilinear_flow_distance_tradeoff_aug_299": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Soft\u2011min probabilistic selection with top\u2011k random choice.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # candidates\n    cand_f = np.flatnonzero(a == -1).astype(int)\n    used_loc = np.zeros(n, dtype=bool)\n    if a.any() != -1:\n        used_loc[a[a != -1]] = True\n    cand_l = np.flatnonzero(~used_loc).astype(int)\n\n    if cand_f.size == 0:\n        return a.tolist()\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    cent = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cent = (cent - cent.min()) / (cent.max() - cent.min() + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (cand_f.size / max(1, n))\n    alpha = 0.2 + 0.5 * progress\n\n    scores = []\n    pairs = []\n\n    for f in cand_f:\n        for l in cand_l:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                   flow_matrix[ass, f] * distance_matrix[locs, l]))\n            penalty = pf[f] * (1.0 - cent[l])\n            penalty = np.clip(penalty, 0.0, 1.0)\n            score = alpha * inc + (1.0 - alpha) * penalty * (abs(inc) + 1.0)\n            scores.append(score)\n            pairs.append((f, l))\n\n    # convert scores to probabilities using softmin\n    min_score = min(scores)\n    exp_vals = np.exp(-(np.array(scores) - min_score))\n    probs = exp_vals / exp_vals.sum()\n\n    # select top\u2011k indices\n    k = 3\n    top_k_idx = np.argsort(probs)[-k:]\n    chosen = np.random.choice(top_k_idx)\n    best_f, best_l = pairs[chosen]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "randomized_rounding_softmax_pairs_aug_300": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Incremental assignment using a softmax over negative costs.\n    The function has been rewritten to use while\u2011loops and\n    explicit pair indexing.  Variable names have been shortened\n    and temperature is clipped to avoid division by zero.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_pos = np.zeros(n, dtype=bool)\n    if a.any() and (a != -1).any():\n        used_pos[a[a != -1]] = True\n    free_pos = np.flatnonzero(~used_pos).astype(int)\n\n    assigned_idx = np.flatnonzero(a != -1).astype(int)\n    assigned_pos = a[assigned_idx].astype(int)\n\n    m = unassigned.size * free_pos.size\n    pair_indices = np.empty((m, 2), dtype=int)\n    idx = 0\n    for f in unassigned:\n        for l in free_pos:\n            pair_indices[idx, 0] = f\n            pair_indices[idx, 1] = l\n            idx += 1\n\n    costs = np.empty(m, dtype=float)\n    if assigned_idx.size == 0:\n        costs.fill(0.0)\n    else:\n        for i in range(m):\n            f, l = pair_indices[i]\n            costs[i] = float(\n                np.sum(flow_matrix[f, assigned_idx] * distance_matrix[l, assigned_pos] +\n                       flow_matrix[assigned_idx, f] * distance_matrix[assigned_pos, l])\n            )\n\n    x = -(costs - costs.min())\n    T = np.clip(np.std(costs) + 1e-6, 1e-6, None)\n    p = np.exp((x - x.max()) / T)\n    p = p / (p.sum() + 1e-12)\n\n    choice = int(np.random.choice(m, p=p))\n    f, l = pair_indices[choice]\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "randomized_rounding_softmax_pairs_aug_301": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Weighted cost calculation and a top\u2011k softmax selection.\n    The weights, threshold, and temperature scaling have been tuned\n    to explore different parameter regimes.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_pos = np.zeros(n, dtype=bool)\n    if a.any() and (a != -1).any():\n        used_pos[a[a != -1]] = True\n    free_pos = np.flatnonzero(~used_pos).astype(int)\n\n    assigned_idx = np.flatnonzero(a != -1).astype(int)\n    assigned_pos = a[assigned_idx].astype(int)\n\n    m = unassigned.size * free_pos.size\n    pair_indices = np.empty((m, 2), dtype=int)\n    idx = 0\n    for f in unassigned:\n        for l in free_pos:\n            pair_indices[idx, 0] = f\n            pair_indices[idx, 1] = l\n            idx += 1\n\n    costs = np.empty(m, dtype=float)\n    weight_fwd = 0.6\n    weight_rev = 0.4\n    if assigned_idx.size == 0:\n        costs.fill(0.0)\n    else:\n        for i in range(m):\n            f, l = pair_indices[i]\n            forward = np.sum(flow_matrix[f, assigned_idx] * distance_matrix[l, assigned_pos])\n            backward = np.sum(flow_matrix[assigned_idx, f] * distance_matrix[assigned_pos, l])\n            costs[i] = weight_fwd * forward + weight_rev * backward\n\n    # Top\u2011k selection\n    top_k = min(7, m)\n    top_indices = np.argpartition(costs, top_k)[:top_k]\n    top_costs = costs[top_indices]\n\n    T = np.clip(np.mean(top_costs) * 0.5 + 1e-6, 1e-6, None)\n    exp_vals = np.exp(-(top_costs - top_costs.min()) / T)\n    probs = exp_vals / (exp_vals.sum() + 1e-12)\n\n    choice = int(np.random.choice(top_k, p=probs))\n    f, l = pair_indices[top_indices[choice]]\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "randomized_rounding_softmax_pairs_aug_302": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Behavioral diversity: deterministic noise, median dispersion,\n    softmin over a small top\u2011k set.  The noise ensures unique tie\u2011breaking.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_pos = np.zeros(n, dtype=bool)\n    if a.any() and (a != -1).any():\n        used_pos[a[a != -1]] = True\n    free_pos = np.flatnonzero(~used_pos).astype(int)\n\n    assigned_idx = np.flatnonzero(a != -1).astype(int)\n    assigned_pos = a[assigned_idx].astype(int)\n\n    m = unassigned.size * free_pos.size\n    pair_indices = np.empty((m, 2), dtype=int)\n    idx = 0\n    for f in unassigned:\n        for l in free_pos:\n            pair_indices[idx, 0] = f\n            pair_indices[idx, 1] = l\n            idx += 1\n\n    costs = np.empty(m, dtype=float)\n    if assigned_idx.size == 0:\n        costs.fill(0.0)\n    else:\n        for i in range(m):\n            f, l = pair_indices[i]\n            costs[i] = float(\n                np.sum(flow_matrix[f, assigned_idx] * distance_matrix[l, assigned_pos] +\n                       flow_matrix[assigned_idx, f] * distance_matrix[assigned_pos, l])\n            )\n\n    # Deterministic tie\u2011breaking noise\n    noise = np.arange(m, dtype=float) * 1e-8\n    costs_noisy = costs + noise\n\n    median_disp = np.median(costs_noisy)\n    T = np.clip(median_disp + 1e-6, 1e-6, None)\n\n    top_k = min(5, m)\n    top_indices = np.argpartition(costs_noisy, top_k)[:top_k]\n    top_costs = costs_noisy[top_indices]\n\n    exp_vals = np.exp(-(top_costs - top_costs.min()) / T)\n    probs = exp_vals / (exp_vals.sum() + 1e-12)\n\n    choice = int(np.random.choice(top_k, p=probs))\n    f, l = pair_indices[top_indices[choice]]\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "randomized_rounding_softmax_pairs_aug_303": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Semantic preservation with a proxy cost and deterministic argmin.\n    If multiple assignments share the minimal cost, a random one is chosen.\"\"\"\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n\n    unassigned = np.flatnonzero(a == -1).astype(int)\n    if unassigned.size == 0:\n        return a.tolist()\n\n    used_pos = np.zeros(n, dtype=bool)\n    if a.any() and (a != -1).any():\n        used_pos[a[a != -1]] = True\n    free_pos = np.flatnonzero(~used_pos).astype(int)\n\n    assigned_idx = np.flatnonzero(a != -1).astype(int)\n    assigned_pos = a[assigned_idx].astype(int)\n\n    m = unassigned.size * free_pos.size\n    pair_indices = np.empty((m, 2), dtype=int)\n    idx = 0\n    for f in unassigned:\n        for l in free_pos:\n            pair_indices[idx, 0] = f\n            pair_indices[idx, 1] = l\n            idx += 1\n\n    costs = np.empty(m, dtype=float)\n    if assigned_idx.size == 0:\n        costs.fill(0.0)\n    else:\n        for i in range(m):\n            f, l = pair_indices[i]\n            # Proxy approximation: absolute difference between flow and distance\n            costs[i] = float(\n                np.sum(np.abs(flow_matrix[f, assigned_idx] - distance_matrix[l, assigned_pos]) +\n                       np.abs(flow_matrix[assigned_idx, f] - distance_matrix[assigned_pos, l]))\n            )\n\n    min_cost = costs.min()\n    eps = 1e-8\n    best_indices = np.flatnonzero(np.abs(costs - min_cost) <= eps)\n    if best_indices.size > 1:\n        choice_idx = int(np.random.choice(best_indices))\n    else:\n        choice_idx = int(best_indices[0])\n\n    f, l = pair_indices[choice_idx]\n    out = a.copy()\n    out[f] = l\n    return out.tolist()\n\n",
  "pairwise_conflict_penalty_flow_similarity_aug_304": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 1 \u2013 vectorised scoring with deterministic noise.\n    \"\"\"\n    # rename for readability\n    flow_mat = flow_matrix.astype(float)\n    dist_mat = distance_matrix.astype(float)\n    n = len(current_assignment)\n\n    a = np.array(current_assignment, dtype=int)\n    # facilities yet to be placed\n    cand_f = np.where(a == -1)[0]\n    if cand_f.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_l = np.where(~used_loc)[0]\n\n    # already assigned facilities and their locations\n    ass_f = np.where(a != -1)[0]\n    ass_l = a[ass_f]\n\n    # normalised flow rows (cosine similarity)\n    norms = np.linalg.norm(flow_mat, axis=1) + 1e-12\n    fnorm = flow_mat / norms[:, None]\n\n    # penalty weight\n    lam = 0.25\n\n    best_score = float('inf')\n    best_f, best_l = cand_f[0], free_l[0]\n\n    # deterministic tie\u2011breaking noise\n    noise_factor = 1e-6\n\n    for f in cand_f:\n        # vectorised distances from candidate location to all assigned locations\n        d_to_locs = dist_mat[free_l[:, None], ass_l]          # shape (len(free_l), len(ass_f))\n        # flow from candidate to assigned\n        flow_to_ass = flow_mat[f, ass_f]                     # shape (len(ass_f),)\n        inc_vec = flow_to_ass @ d_to_locs.T + flow_mat[ass_f, f] @ d_to_locs\n        # penalty part\n        cos_sim = fnorm[f, ass_f] @ fnorm[ass_f, f]           # scalar\n        near = np.exp(-d_to_locs)                            # shape (len(free_l), len(ass_f))\n        pen_vec = cos_sim * near.sum(axis=1)                 # shape (len(free_l),)\n\n        for idx, l in enumerate(free_l):\n            inc = inc_vec[idx]\n            pen = pen_vec[idx]\n            score = inc + lam * pen * (abs(inc) + 1.0)\n            # add deterministic noise to break ties\n            score += noise_factor * (f + l)\n            if score < best_score:\n                best_score = score\n                best_f, best_l = f, l\n\n    a[best_f] = best_l\n    return a.tolist()\n\n",
  "pairwise_conflict_penalty_flow_similarity_aug_305": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 2 \u2013 while\u2011loop, max\u2011penalty aggregation, top\u2011k random choice.\n    \"\"\"\n    flow_mat = flow_matrix.astype(float)\n    dist_mat = distance_matrix.astype(float)\n    n = len(current_assignment)\n\n    a = np.array(current_assignment, dtype=int)\n    # facilities to assign\n    cand_f = np.where(a == -1)[0]\n    if cand_f.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_l = np.where(~used_loc)[0]\n\n    ass_f = np.where(a != -1)[0]\n    ass_l = a[ass_f]\n\n    norms = np.linalg.norm(flow_mat, axis=1) + 1e-12\n    fnorm = flow_mat / norms[:, None]\n\n    lam = 0.35\n    top_k = 7\n    eps = 1e-12\n    noise = 1e-5\n\n    # collect scores\n    scores = []\n    pairs = []\n\n    i = 0\n    while i < cand_f.size:\n        f = cand_f[i]\n        # distances from each free location to all assigned locations\n        d_to_locs = dist_mat[free_l[:, None], ass_l]\n        flow_to_ass = flow_mat[f, ass_f]\n        inc_vec = flow_to_ass @ d_to_locs.T + flow_mat[ass_f, f] @ d_to_locs\n        cos_sim = fnorm[f, ass_f] @ fnorm[ass_f, f]\n        near = np.exp(-d_to_locs)\n        pen_vec = cos_sim * near.max(axis=1)  # use max instead of sum\n        for idx, l in enumerate(free_l):\n            inc = inc_vec[idx]\n            pen = pen_vec[idx]\n            score = inc + lam * pen * (abs(inc) + 1.0)\n            score += noise * (f - l)  # small bias\n            scores.append(score)\n            pairs.append((f, l))\n        i += 1\n\n    # select top_k best scores\n    scores_np = np.array(scores)\n    top_indices = np.argpartition(scores_np, top_k)[:top_k]\n    chosen = pairs[np.random.choice(top_indices)]\n    a[chosen[0]] = chosen[1]\n    return a.tolist()\n\n",
  "pairwise_conflict_penalty_flow_similarity_aug_306": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 3 \u2013 list\u2011comprehension, median inc, softmax scoring.\n    \"\"\"\n    flow_mat = flow_matrix.astype(float)\n    dist_mat = distance_matrix.astype(float)\n    n = len(current_assignment)\n\n    a = np.array(current_assignment, dtype=int)\n    cand_f = np.where(a == -1)[0]\n    if cand_f.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_l = np.where(~used_loc)[0]\n\n    ass_f = np.where(a != -1)[0]\n    ass_l = a[ass_f]\n\n    norms = np.linalg.norm(flow_mat, axis=1) + 1e-12\n    fnorm = flow_mat / norms[:, None]\n\n    lam = 0.4\n    temp = 0.5\n    noise = 1e-7\n\n    candidates = [(f, l) for f in cand_f for l in free_l]\n\n    scores = []\n    for f, l in candidates:\n        d_to_locs = dist_mat[l, ass_l]\n        inc = np.median(flow_mat[f, ass_f] * d_to_locs + flow_mat[ass_f, f] * d_to_locs)\n        cos_sim = fnorm[f, ass_f] @ fnorm[ass_f, f]\n        near = np.exp(-d_to_locs)\n        pen = np.median(cos_sim * near)\n        score = inc + lam * pen * (abs(inc) + 1.0)\n        score += noise * (f + l)  # deterministic tie\u2011breaker\n        scores.append(score)\n\n    # softmax (negative scores for minimisation)\n    logits = -np.array(scores) / temp\n    probs = np.exp(logits - np.max(logits))\n    probs /= probs.sum()\n    chosen_idx = np.random.choice(len(candidates), p=probs)\n    f_chosen, l_chosen = candidates[chosen_idx]\n    a[f_chosen] = l_chosen\n    return a.tolist()\n\n",
  "pairwise_conflict_penalty_flow_similarity_aug_307": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"\n    Variant 4 \u2013 full vectorisation, sqrt\u2011norm, deterministic noise.\n    \"\"\"\n    flow_mat = flow_matrix.astype(float)\n    dist_mat = distance_matrix.astype(float)\n    n = len(current_assignment)\n\n    a = np.array(current_assignment, dtype=int)\n    cand_f = np.where(a == -1)[0]\n    if cand_f.size == 0:\n        return a.tolist()\n\n    used_loc = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used_loc[a[a != -1]] = True\n    free_l = np.where(~used_loc)[0]\n\n    ass_f = np.where(a != -1)[0]\n    ass_l = a[ass_f]\n\n    # sqrt\u2011norm for flow rows\n    norms = np.sqrt(np.sum(flow_mat ** 2, axis=1)) + 1e-12\n    fnorm = flow_mat / norms[:, None]\n\n    lam = 0.3\n    eps = 1e-12\n    noise = 1e-6\n\n    # pre\u2011compute all pair distances\n    d_mat = dist_mat[free_l[:, None], ass_l]  # shape (len(free_l), len(ass_f))\n\n    # compute inc for all (f, l) pairs\n    inc_mat = np.empty((cand_f.size, free_l.size))\n    for i, f in enumerate(cand_f):\n        inc_mat[i] = (flow_mat[f, ass_f] @ d_mat.T) + (flow_mat[ass_f, f] @ d_mat)\n\n    # penalty: max cosine similarity weighted by nearest distance\n    cos_mat = fnorm[cand_f[:, None], ass_f] @ fnorm[ass_f, cand_f[None, :]]\n    near_mat = np.exp(-d_mat)\n    pen_mat = np.max(cos_mat[:, :, None] * near_mat[None, :, :], axis=1)\n\n    score_mat = inc_mat + lam * pen_mat * (np.abs(inc_mat) + 1.0)\n\n    # add deterministic noise to avoid ties\n    noise_grid = noise * (cand_f[:, None] + free_l[None, :])\n    score_mat += noise_grid\n\n    # pick minimal score\n    idx_f, idx_l = np.unravel_index(score_mat.argmin(), score_mat.shape)\n    a[cand_f[idx_f]] = free_l[idx_l]\n    return a.tolist()\n\n",
  "facility_max_stddev_then_best_location_aug_308": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Choose the facility with the highest standard deviation of incremental costs\n    and assign it to its best free location. Uses while\u2011loop control flow\n    and vectorized cost computation.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # Facilities that have not yet been assigned\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    # Determine which locations are already used\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    free_locs = np.flatnonzero(~occupied).astype(int)\n\n    # Already assigned facilities and their locations\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    best_f = None\n    best_std = -np.inf\n\n    # Evaluate each candidate facility\n    while candidates.size > 0:   # single iteration, keeps the while\u2011loop form\n        for f in candidates:\n            if assigned.size == 0:\n                costs = np.zeros(free_locs.size, dtype=float)\n            else:\n                # Vectorised incremental cost for all free locations\n                costs = np.sum(\n                    flow_matrix[f, assigned][:, None] * distance_matrix[free_locs, locs][None, :] +\n                    flow_matrix[assigned, f][:, None] * distance_matrix[locs, free_locs][None, :],\n                    axis=0\n                )\n            costs = np.clip(costs, 0, None)               # safety clipping\n            std_val = np.std(costs) + 1e-12               # epsilon to avoid zero division\n            if std_val > best_std:\n                best_std = std_val\n                best_f = f\n        break\n\n    # Choose the best location for the selected facility\n    if assigned.size == 0:\n        best_l = free_locs[0]\n    else:\n        costs_best = np.sum(\n            flow_matrix[best_f, assigned][:, None] * distance_matrix[free_locs, locs][None, :] +\n            flow_matrix[assigned, best_f][:, None] * distance_matrix[locs, free_locs][None, :],\n            axis=0\n        )\n        costs_best = np.clip(costs_best, 0, None)\n        best_l = free_locs[np.argmin(costs_best)]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "facility_max_stddev_then_best_location_aug_309": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Select facility based on weighted std\u2011mean score and assign to minimal cost location.\n    Uses a top\u2011k strategy and weighted scoring.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    free_locs = np.flatnonzero(~occupied).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # Compute standard deviations for all candidate facilities\n    stds = np.empty(candidates.size, dtype=float)\n    for idx, f in enumerate(candidates):\n        if assigned.size == 0:\n            costs = np.zeros(free_locs.size, dtype=float)\n        else:\n            costs = np.sum(\n                flow_matrix[f, assigned][:, None] * distance_matrix[free_locs, locs][None, :] +\n                flow_matrix[assigned, f][:, None] * distance_matrix[locs, free_locs][None, :],\n                axis=0\n            )\n        costs = np.clip(costs, 0, None)\n        stds[idx] = np.std(costs) + 1e-12\n\n    # Top\u2011k facilities with highest std\n    top_k = min(7, candidates.size)\n    top_idx = np.argsort(-stds)[:top_k]\n    top_facs = candidates[top_idx]\n\n    # Compute weighted score for each top facility\n    scores = np.empty(top_k, dtype=float)\n    for i, f in enumerate(top_facs):\n        if assigned.size == 0:\n            costs = np.zeros(free_locs.size, dtype=float)\n        else:\n            costs = np.sum(\n                flow_matrix[f, assigned][:, None] * distance_matrix[free_locs, locs][None, :] +\n                flow_matrix[assigned, f][:, None] * distance_matrix[locs, free_locs][None, :],\n                axis=0\n            )\n        costs = np.clip(costs, 0, None)\n        mean_cost = np.mean(costs) + 1e-12\n        scores[i] = 0.7 * stds[top_idx[i]] - 0.3 * mean_cost  # weighted score\n\n    best_f = top_facs[np.argmax(scores)]\n\n    # Assign best location to the chosen facility\n    if assigned.size == 0:\n        best_l = free_locs[0]\n    else:\n        costs_best = np.sum(\n            flow_matrix[best_f, assigned][:, None] * distance_matrix[free_locs, locs][None, :] +\n            flow_matrix[assigned, best_f][:, None] * distance_matrix[locs, free_locs][None, :],\n            axis=0\n        )\n        costs_best = np.clip(costs_best, 0, None)\n        best_l = free_locs[np.argmin(costs_best)]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "facility_max_stddev_then_best_location_aug_310": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Select facility via weighted std\u2011mean score, then choose location using softmin.\n    Adds tiny deterministic noise for tie\u2011breaking and random choice among top\u2011k facilities.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    free_locs = np.flatnonzero(~occupied).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # Compute std for all candidates\n    stds = np.empty(candidates.size, dtype=float)\n    for idx, f in enumerate(candidates):\n        if assigned.size == 0:\n            costs = np.zeros(free_locs.size, dtype=float)\n        else:\n            costs = np.sum(\n                flow_matrix[f, assigned][:, None] * distance_matrix[free_locs, locs][None, :] +\n                flow_matrix[assigned, f][:, None] * distance_matrix[locs, free_locs][None, :],\n                axis=0\n            )\n        costs = np.clip(costs, 0, None)\n        stds[idx] = np.std(costs) + 1e-12\n\n    # Pick a facility among top\u2011k by weighted probability\n    top_k = min(3, candidates.size)\n    top_idx = np.argsort(-stds)[:top_k]\n    probs = stds[top_idx] + 1e-12\n    probs /= np.sum(probs)\n    best_f = candidates[top_idx[np.random.choice(top_k, p=probs)]]\n\n    # Add tiny noise to costs for deterministic tie\u2011breaking\n    if assigned.size == 0:\n        costs_best = np.zeros(free_locs.size, dtype=float)\n    else:\n        costs_best = np.sum(\n            flow_matrix[best_f, assigned][:, None] * distance_matrix[free_locs, locs][None, :] +\n            flow_matrix[assigned, best_f][:, None] * distance_matrix[locs, free_locs][None, :],\n            axis=0\n        )\n    noise = np.random.uniform(0, 1e-6, size=costs_best.shape)\n    costs_best = np.clip(costs_best + noise, 0, None)\n\n    # Softmin selection\n    beta = 10.0\n    exp_vals = np.exp(-beta * costs_best)\n    probs_l = exp_vals / (np.sum(exp_vals) + 1e-12)  # epsilon on denominator\n    best_l = free_locs[np.random.choice(free_locs.size, p=probs_l)]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "facility_max_stddev_then_best_location_aug_311": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    \"\"\"Use proxy approximations: median instead of std, max instead of sum.\n    Applies clipping and a top\u2011k strategy.\"\"\"\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    candidates = np.flatnonzero(a == -1).astype(int)\n    if candidates.size == 0:\n        return a.tolist()\n\n    occupied = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        occupied[a[a != -1]] = True\n    free_locs = np.flatnonzero(~occupied).astype(int)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    # Compute proxy \u201cstd\u201d (median) for all candidates\n    medians = np.empty(candidates.size, dtype=float)\n    for idx, f in enumerate(candidates):\n        if assigned.size == 0:\n            costs = np.zeros(free_locs.size, dtype=float)\n        else:\n            costs = np.sum(\n                flow_matrix[f, assigned][:, None] * distance_matrix[free_locs, locs][None, :] +\n                flow_matrix[assigned, f][:, None] * distance_matrix[locs, free_locs][None, :],\n                axis=0\n            )\n        costs = np.clip(costs, 0, None)\n        medians[idx] = np.median(costs) + 1e-12\n\n    # Top\u2011k facilities with largest median\n    top_k = min(5, candidates.size)\n    top_idx = np.argsort(-medians)[:top_k]\n    top_facs = candidates[top_idx]\n\n    # Score: median minus mean cost (mean approximated by max for proxy)\n    scores = np.empty(top_k, dtype=float)\n    for i, f in enumerate(top_facs):\n        if assigned.size == 0:\n            costs = np.zeros(free_locs.size, dtype=float)\n        else:\n            costs = np.sum(\n                flow_matrix[f, assigned][:, None] * distance_matrix[free_locs, locs][None, :] +\n                flow_matrix[assigned, f][:, None] * distance_matrix[locs, free_locs][None, :],\n                axis=0\n            )\n        costs = np.clip(costs, 0, None)\n        max_cost = np.max(costs) + 1e-12\n        scores[i] = medians[top_idx[i]] - 0.5 * max_cost\n\n    best_f = top_facs[np.argmax(scores)]\n\n    # Assign best location using max\u2011cost proxy\n    if assigned.size == 0:\n        best_l = free_locs[0]\n    else:\n        costs_best = np.sum(\n            flow_matrix[best_f, assigned][:, None] * distance_matrix[free_locs, locs][None, :] +\n            flow_matrix[assigned, best_f][:, None] * distance_matrix[locs, free_locs][None, :],\n            axis=0\n        )\n        costs_best = np.clip(costs_best, 0, None)\n        best_l = free_locs[np.argmin(costs_best)]\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "location_max_stddev_then_best_facility_aug_312": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    eps = 1e-12\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    # candidates (unassigned facilities)\n    cand = np.flatnonzero(assign == -1).astype(int)\n    if cand.size == 0:\n        return assign.tolist()\n\n    # free locations\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # already assigned facilities and their locations\n    ass = np.flatnonzero(assign != -1).astype(int)\n    locs = assign[ass].astype(int)\n\n    best_loc = int(free[0])\n    best_std = -1.0\n    best_fac = int(cand[0])\n\n    for l in free.astype(int):\n        if ass.size == 0:\n            costs = np.zeros(cand.size, dtype=float)\n        else:\n            # vectorised incremental cost for all candidates at location l\n            flow_to_ass = flow_matrix[cand[:, None], ass]          # (c,a)\n            dist_l_to_locs = distance_matrix[l, locs]              # (a,)\n            flow_ass_to_cand = flow_matrix[ass[:, None], cand]    # (a,c)\n            dist_locs_to_l = distance_matrix[locs[:, None], l]    # (a,)\n\n            costs = (flow_to_ass @ dist_l_to_locs + flow_ass_to_cand @ dist_locs_to_l).astype(float)\n\n        # clip to avoid extreme values\n        costs = np.clip(costs, None, 1e12)\n\n        std_val = float(np.std(costs, ddof=0))\n        # deterministic tie\u2011breaking noise\n        noise = np.random.uniform(0, 1e-8, size=costs.shape)\n        if std_val + noise[0] > best_std:\n            best_std = std_val\n            best_loc = int(l)\n            best_fac = int(cand[np.argmin(costs + noise)])\n\n    out = assign.copy()\n    out[best_fac] = best_loc\n    return out.tolist()\n\n",
  "location_max_stddev_then_best_facility_aug_313": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    eps = 1e-12\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    cand = np.flatnonzero(assign == -1).astype(int)\n    if cand.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(assign != -1).astype(int)\n    locs = assign[ass].astype(int)\n\n    best_loc = int(free[0])\n    best_score = -np.inf\n    best_fac = int(cand[0])\n\n    idx = 0\n    while idx < free.size:\n        l = int(free[idx])\n\n        if ass.size == 0:\n            costs = np.zeros(cand.size, dtype=float)\n            avg_dist = 0.0\n        else:\n            flow_to_ass = flow_matrix[cand[:, None], ass]\n            dist_l_to_locs = distance_matrix[l, locs]\n            flow_ass_to_cand = flow_matrix[ass[:, None], cand]\n            dist_locs_to_l = distance_matrix[locs[:, None], l]\n\n            costs = (flow_to_ass @ dist_l_to_locs + flow_ass_to_cand @ dist_locs_to_l).astype(float)\n            avg_dist = np.mean(distance_matrix[l, locs])\n\n        # clip to keep values bounded\n        avg_dist = np.clip(avg_dist, 0, 1e12)\n\n        # weighted score: 0.6 * normalized cost + 0.4 * normalized distance\n        norm_cost = costs / (costs.sum() + eps)\n        norm_dist = avg_dist / (avg_dist + eps)\n        score = 0.6 * norm_cost.mean() + 0.4 * norm_dist\n\n        if score > best_score:\n            best_score = score\n            best_loc = int(l)\n            # random choice among the 3 cheapest facilities\n            top_k = 3\n            sorted_idx = np.argsort(costs)\n            top_indices = sorted_idx[:top_k]\n            best_fac = int(cand[np.random.choice(top_indices)])\n\n        idx += 1\n\n    out = assign.copy()\n    out[best_fac] = best_loc\n    return out.tolist()\n\n",
  "location_max_stddev_then_best_facility_aug_314": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    eps = 1e-12\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    cand = np.flatnonzero(assign == -1).astype(int)\n    if cand.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(assign != -1).astype(int)\n    locs = assign[ass].astype(int)\n\n    best_loc = int(free[0])\n    best_mean = np.inf\n    best_fac = int(cand[0])\n\n    idx = 0\n    while idx < free.size:\n        l = int(free[idx])\n\n        if ass.size == 0:\n            costs = np.zeros(cand.size, dtype=float)\n        else:\n            flow_to_ass = flow_matrix[cand[:, None], ass]\n            dist_l_to_locs = distance_matrix[l, locs]\n            flow_ass_to_cand = flow_matrix[ass[:, None], cand]\n            dist_locs_to_l = distance_matrix[locs[:, None], l]\n\n            costs = (flow_to_ass @ dist_l_to_locs + flow_ass_to_cand @ dist_locs_to_l).astype(float)\n\n        # clip to keep values bounded\n        costs = np.clip(costs, None, 1e12)\n\n        # softmin weighting\n        denom = costs.mean() + eps\n        weights = np.exp(-costs / denom)\n        softmin = np.sum(costs * weights) / (np.sum(weights) + eps)\n\n        # deterministic noise for tie\u2011breaking\n        noise = np.arange(costs.size) * 1e-9\n        if softmin + noise[0] < best_mean:\n            best_mean = softmin\n            best_loc = int(l)\n            best_fac = int(cand[np.argmin(costs + noise)])\n\n        idx += 1\n\n    out = assign.copy()\n    out[best_fac] = best_loc\n    return out.tolist()\n\n",
  "location_max_stddev_then_best_facility_aug_315": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    eps = 1e-12\n    assign = np.asarray(current_assignment, dtype=int)\n    n = assign.size\n\n    cand = np.flatnonzero(assign == -1).astype(int)\n    if cand.size == 0:\n        return assign.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(assign != -1):\n        used[assign[assign != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(assign != -1).astype(int)\n    locs = assign[ass].astype(int)\n\n    # Incremental cost matrix (facilities \u00d7 locations)\n    if ass.size == 0:\n        inc_cost = np.zeros((cand.size, free.size), dtype=float)\n    else:\n        flow_cand_ass = flow_matrix[cand[:, None], ass]          # (c,a)\n        dist_locs_free = distance_matrix[locs[:, None], free]    # (a,l)\n        flow_ass_cand = flow_matrix[ass[:, None], cand]          # (a,c)\n        dist_free_locs = distance_matrix[free[:, None], locs]    # (l,a)\n\n        inc_cost = (flow_cand_ass @ dist_locs_free + flow_ass_cand.T @ dist_free_locs.T).astype(float)\n\n    # choose location with largest stddev across facilities\n    stds = np.std(inc_cost, axis=0, ddof=0)\n    best_l_idx = int(np.argmax(stds))\n    best_l = int(free[best_l_idx])\n\n    # facility selection via softmax on costs for the chosen location\n    costs_at_loc = inc_cost[:, best_l_idx]\n    denom = costs_at_loc.mean() + eps\n    probs = np.exp(-costs_at_loc / denom)\n    probs = probs / (probs.sum() + eps)\n    probs = np.clip(probs, 0, 1)  # keep probabilities bounded\n\n    best_fac = int(cand[np.argmax(probs)])\n\n    out = assign.copy()\n    out[best_fac] = best_l\n    return out.tolist()\n\n",
  "hotspot_hubs_penalize_consuming_central_locations_aug_316": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    # candidates for assignment\n    cand = np.flatnonzero(a == -1).astype(int)\n    if cand.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # hubness among all facilities\n    hub = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    hub_cand = hub[cand]\n    thr = np.quantile(hub_cand, 0.75) if hub_cand.size else 0.0\n    # use median instead of mean\n    hub_frac = float(np.median(hub_cand >= thr)) if hub_cand.size else 0.0\n\n    # centrality of locations (avoid division by zero)\n    cent = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cent = (cent - cent.min()) / (cent.max() - cent.min() + 1e-12)\n\n    assigned = np.flatnonzero(a != -1).astype(int)\n    locs = a[assigned].astype(int)\n\n    progress = 1.0 - (cand.size / max(1, n))\n    lam = (1.0 - progress) * hub_frac * 0.75\n\n    best_score = np.inf\n    best_f = int(cand[0])\n    best_l = int(free[0])\n\n    # deterministic noise for tie\u2011breaking\n    noise = np.arange(free.size) * 1e-6\n\n    for fi in cand:\n        for li_idx, l in enumerate(free):\n            if assigned.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[fi, assigned] *\n                                   distance_matrix[l, locs] +\n                                   flow_matrix[assigned, fi] *\n                                   distance_matrix[locs, l]))\n            score = inc + lam * float(cent[l]) * (abs(inc) + 1.0) + noise[li_idx]\n            if score < best_score:\n                best_score, best_f, best_l = score, int(fi), int(l)\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n",
  "hotspot_hubs_penalize_consuming_central_locations_aug_317": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    assign = np.asarray(current_assignment, dtype=int)\n    size = assign.size\n\n    # unassigned facilities\n    un_fac = np.flatnonzero(assign == -1).astype(int)\n    if un_fac.size == 0:\n        return assign.tolist()\n\n    used_loc = np.zeros(size, dtype=bool)\n    if np.any(assign != -1):\n        used_loc[assign[assign != -1]] = True\n    free_loc = np.flatnonzero(~used_loc).astype(int)\n\n    hub = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    hub_un = hub[un_fac]\n    thr = np.quantile(hub_un, 0.85) if hub_un.size else 0.0\n    hub_frac = float(np.max(hub_un >= thr)) if hub_un.size else 0.0\n\n    cent = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cent = (cent - cent.min()) / (cent.max() - cent.min() + 1e-12)\n    cent_scalar = np.median(cent)  # use median as scalar\n\n    assigned_idx = np.flatnonzero(assign != -1).astype(int)\n    locs_assigned = assign[assigned_idx].astype(int)\n\n    progress = 1.0 - (un_fac.size / max(1, size))\n    lam = (1.0 - progress) * hub_frac * 0.5\n\n    best_score = np.inf\n    best_f = int(un_fac[0])\n    best_l = int(free_loc[0])\n\n    i = 0\n    while i < un_fac.size:\n        f = int(un_fac[i])\n        j = 0\n        while j < free_loc.size:\n            l = int(free_loc[j])\n            if assigned_idx.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, assigned_idx] *\n                                   distance_matrix[l, locs_assigned] +\n                                   flow_matrix[assigned_idx, f] *\n                                   distance_matrix[locs_assigned, l]))\n            score = lam * inc + cent_scalar * (abs(inc) + 0.5)\n            if score < best_score:\n                best_score, best_f, best_l = score, f, l\n            j += 1\n        i += 1\n\n    out = assign.copy()\n    out[best_f] = best_l\n    return out.tolist()\n\n"
}