{
  "min_incremental_cost_global": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose the (facility, location) pair with minimum incremental cost vs already-assigned facilities.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            d = delta(int(f), int(l))\n            if d < best:\n                best, best_f, best_l = d, int(f), int(l)\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "max_flow_to_assigned_best_location": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility with largest interaction to already-placed facilities; place it in its best free location.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    if ass.size:\n        w = (flow_matrix[np.ix_(un, ass)].sum(axis=1) + flow_matrix[np.ix_(ass, un)].sum(axis=0)).astype(float)\n    else:\n        w = (flow_matrix[un].sum(axis=1) + flow_matrix[:, un].sum(axis=0)).astype(float)\n\n    f = int(un[int(np.argmax(w))])\n\n    def delta(l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_l = int(free[int(np.argmin([delta(int(l)) for l in free]))])\n    out = list(current_assignment)\n    out[f] = best_l\n    return out\n",
  "max_total_flow_best_location": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick the globally highest-flow facility remaining; place in the best free location (incremental).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    f = int(un[int(np.argmax(tot[un]))])\n\n    if ass.size == 0:\n        l = int(free[int(np.argmin(distance_matrix[free].sum(axis=1)))])\n    else:\n        inc = []\n        for loc in free:\n            d = np.sum(flow_matrix[f, ass] * distance_matrix[loc, locs] +\n                       flow_matrix[ass, f] * distance_matrix[locs, loc])\n            inc.append(float(d))\n        l = int(free[int(np.argmin(inc))])\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n",
  "central_location_best_facility": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose a 'central' free location first, then choose the facility that best fits there (incremental).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    # centrality by sum-distance to all locations (smaller is more central)\n    loc_c = distance_matrix[free].sum(axis=1).astype(float)\n    l = int(free[int(np.argmin(loc_c))])\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def delta(f):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_f = int(un[int(np.argmin([delta(int(f)) for f in un]))])\n    out = list(current_assignment)\n    out[best_f] = l\n    return out\n",
  "max_regret_2_insertion": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Regret-2: for each facility compute (2nd best - best) over free locations; assign max-regret facility to its best.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_f, best_l, best_reg = int(un[0]), int(free[0]), -1.0\n    for f in un:\n        costs = np.array([delta(int(f), int(l)) for l in free], dtype=float)\n        if costs.size == 1:\n            reg, lbest = float(\"inf\"), int(free[0])\n        else:\n            idx = np.argsort(costs)\n            reg, lbest = float(costs[idx[1]] - costs[idx[0]]), int(free[int(idx[0])])\n        if reg > best_reg:\n            best_reg, best_f, best_l = reg, int(f), lbest\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "flow_weighted_regret": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Regret-2 weighted by interaction strength (flow to assigned / total flow).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_f, best_l, best_score = int(un[0]), int(free[0]), -1.0\n    for f in un:\n        costs = np.array([delta(int(f), int(l)) for l in free], dtype=float)\n        idx = np.argsort(costs)\n        best = float(costs[idx[0]])\n        second = float(costs[idx[1]]) if costs.size > 1 else best + 1.0\n        regret = second - best\n        strength = float(tot[int(f)]) if tot[int(f)] > 0 else 1.0\n        score = regret * strength\n        if score > best_score:\n            best_score, best_f, best_l = score, int(f), int(free[int(idx[0])])\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "minimax_interaction": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Minimax: pick assignment that minimizes the worst single interaction cost to any already-assigned facility.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def worst(f, l):\n        if ass.size == 0:\n            return 0.0\n        c1 = flow_matrix[f, ass] * distance_matrix[l, locs]\n        c2 = flow_matrix[ass, f] * distance_matrix[locs, l]\n        return float(np.max(c1 + c2))\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            w = worst(int(f), int(l))\n            if w < best:\n                best, best_f, best_l = w, int(f), int(l)\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "annealed_softmax_pair_sampling": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Sample a good (facility, location) pair with a temperature that cools as the assignment fills.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    T = max(1e-6, 2.0 * (1.0 - progress) + 0.05)\n\n    pairs = []\n    costs = []\n    for f in un:\n        for l in free:\n            if ass.size == 0:\n                d = 0.0\n            else:\n                d = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                 flow_matrix[ass, f] * distance_matrix[locs, l]))\n            pairs.append((int(f), int(l)))\n            costs.append(d)\n\n    c = np.array(costs, dtype=float)\n    c = c - c.min()  # stabilize\n    p = np.exp(-c / T)\n    p = p / (p.sum() + 1e-12)\n    idx = int(np.random.choice(len(pairs), p=p))\n    f, l = pairs[idx]\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n",
  "randomized_greedy_topk_pairs": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Compute all incremental costs; pick randomly among the top-k best pairs (GRASP-style constructive step).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = []\n    costs = []\n    for f in un:\n        for l in free:\n            if ass.size == 0:\n                d = 0.0\n            else:\n                d = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                 flow_matrix[ass, f] * distance_matrix[locs, l]))\n            pairs.append((int(f), int(l)))\n            costs.append(d)\n\n    c = np.array(costs, dtype=float)\n    k = max(1, int(np.ceil(0.10 * len(pairs))))\n    idxs = np.argsort(c)[:k]\n    pick = int(np.random.choice(idxs))\n    f, l = pairs[pick]\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n",
  "one_step_lookahead_mean_future": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Greedy incremental + cheap future estimate using remaining-flow * mean distance of remaining locations.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    # Precompute remaining facility \"mass\"\n    sym_flow = flow_matrix + flow_matrix.T\n    rem_flow_mass = sym_flow[np.ix_(un, un)].sum(axis=1).astype(float)\n\n    # Meanf: mean distance among remaining free locations\n    if free.size > 1:\n        Dff = distance_matrix[np.ix_(free, free)].astype(float)\n        mean_d = float(Dff.mean())\n    else:\n        mean_d = 0.0\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for idx_f, f in enumerate(un):\n        for l in free:\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                   flow_matrix[ass, f] * distance_matrix[locs, l]))\n            future = rem_flow_mass[idx_f] * mean_d\n            score = inc + 0.15 * future\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "linearized_potential_matching": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Match high-flow facilities to low-distance-sum locations using a linearized scalar potential.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    # potentials\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    ql = distance_matrix.sum(axis=1).astype(float)\n    # normalize to comparable scale\n    pf_n = (pf - pf.mean()) / (pf.std() + 1e-12)\n    ql_n = (ql - ql.mean()) / (ql.std() + 1e-12)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc + 0.40 * (pf_n[int(f)] * ql_n[int(l)])\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment)\n    out[best_f] = best_l\n    return out\n",
  "spectral_rank_quantile_match": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Rank facilities by leading eigenvector of symmetrized flow; rank locations by closeness; match quantiles.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    # leading eigenvector (symmetric => eigh)\n    vals, vecs = np.linalg.eigh(F)\n    vf = np.abs(vecs[:, int(np.argmax(vals))])\n    vf = (vf - vf.min()) / (vf.max() - vf.min() + 1e-12)\n\n    # location rank: smaller sum-distance => higher rank\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n\n    # pick facility with highest rank among unassigned\n    f = int(un[int(np.argmax(vf[un]))])\n    target = float(vf[f])\n\n    # pick free location with closest centrality rank (quantile match)\n    idx = int(np.argmin(np.abs(cl[free] - target)))\n    l = int(free[idx])\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n",
  "strong_neighbor_attraction": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose facility that most strongly connects to an already-placed facility; place near that facility's location.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    if ass.size == 0:\n        # fall back: high-flow facility to central free location\n        tot = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(tot[un]))])\n        l = int(free[int(np.argmin(distance_matrix[free].sum(axis=1)))])\n        out = list(current_assignment); out[f] = l\n        return out\n\n    locs = a[ass].astype(int)\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # facility selection by max connection to any assigned facility\n    conn = sym_flow[np.ix_(un, ass)].max(axis=1)\n    f = int(un[int(np.argmax(conn))])\n\n    # choose anchor assigned facility with strongest link\n    j = int(ass[int(np.argmax(sym_flow[f, ass]))])\n    anchor_loc = int(a[j])\n\n    # place in free location closest to anchor_loc\n    l = int(free[int(np.argmin(distance_matrix[free, anchor_loc]))])\n\n    out = list(current_assignment)\n    out[f] = l\n    return out\n",
  "vogel_penalty_allocation": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Vogel-style penalties on the incremental cost matrix to choose a high-penalty row/col then allocate its min.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    # Build cost matrix C (rows=unassigned facilities, cols=free locations)\n    C = np.zeros((un.size, free.size), dtype=float)\n    if ass.size:\n        for i, f in enumerate(un):\n            for j, l in enumerate(free):\n                C[i, j] = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                       flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # Row/column penalties = (2nd best - best)\n    row_pen = np.full(un.size, float(\"inf\"))\n    for i in range(un.size):\n        r = np.sort(C[i])\n        row_pen[i] = float(r[1] - r[0]) if r.size > 1 else float(\"inf\")\n\n    col_pen = np.full(free.size, float(\"inf\"))\n    for j in range(free.size):\n        c = np.sort(C[:, j])\n        col_pen[j] = float(c[1] - c[0]) if c.size > 1 else float(\"inf\")\n\n    if float(row_pen.max()) >= float(col_pen.max()):\n        i = int(np.argmax(row_pen))\n        j = int(np.argmin(C[i]))\n    else:\n        j = int(np.argmax(col_pen))\n        i = int(np.argmin(C[:, j]))\n\n    f = int(un[i]); l = int(free[j])\n    out = list(current_assignment); out[f] = l\n    return out\n",
  "adaptive_candidate_sampling": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Speed/quality tradeoff: sample candidates by facility flow and location centrality, then pick best incremental.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    # sample sizes adapt with progress\n    kf = max(2, int(np.ceil((0.25 + 0.50 * (1.0 - progress)) * un.size)))\n    kl = max(2, int(np.ceil((0.25 + 0.50 * (1.0 - progress)) * free.size)))\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    top_f = un[np.argsort(-pf[un])[:min(kf, un.size)]]\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    top_l = free[np.argsort(-cl[free])[:min(kl, free.size)]]\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l, best = int(top_f[0]), int(top_l[0]), float(\"inf\")\n    for f in top_f:\n        for l in top_l:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best, best_f, best_l = inc, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "entropy_uncertainty_then_best": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick the facility with highest placement-entropy over free locations, then place it at its best location.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def deltas_for_f(f):\n        if ass.size == 0:\n            return np.zeros(free.size, dtype=float)\n        return np.array([np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                flow_matrix[ass, f] * distance_matrix[locs, l]) for l in free], dtype=float)\n\n    best_f, best_l, best_H = int(un[0]), int(free[0]), -1.0\n    for f in un:\n        c = deltas_for_f(int(f))\n        c = c - c.min()\n        p = np.exp(-c / (c.std() + 1e-6))\n        p = p / (p.sum() + 1e-12)\n        H = float(-np.sum(p * np.log(p + 1e-12)))\n        if H > best_H:\n            best_H, best_f = H, int(f)\n            best_l = int(free[int(np.argmin(c))])\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "zscore_blended_scoring": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Compute all incremental costs, z-score them, then blend with facility-flow and location-centrality z-scores.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf_z = (pf - pf.mean()) / (pf.std() + 1e-12)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl_z = (cl - cl.mean()) / (cl.std() + 1e-12)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = []\n    incs = []\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            pairs.append((int(f), int(l)))\n            incs.append(inc)\n\n    incs = np.array(incs, dtype=float)\n    inc_z = (incs - incs.mean()) / (incs.std() + 1e-12)\n\n    # Want: low incremental (small inc_z), high flow (large pf_z), central location (large cl_z)\n    score = inc_z - 0.25 * pf_z[[p[0] for p in pairs]] - 0.25 * cl_z[[p[1] for p in pairs]]\n\n    idx = int(np.argmin(score))\n    f, l = pairs[idx]\n\n    out = list(current_assignment); out[f] = l\n    return out\n",
  "potential_balance_gap": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Minimize incremental cost + penalty for mismatch between facility flow-potential and location centrality.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n    cl = (cl - cl.min()) / (cl.max() - cl.min() + 1e-12)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n    lam = 0.35\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc + lam * abs(pf[int(f)] - cl[int(l)]) * (abs(inc) + 1.0)\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "deterministic_hash_tiebreak_min_inc": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Greedy min incremental; break close ties deterministically using a hash of the partial assignment.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    # simple stable hash\n    h = int(np.sum((np.arange(n) + 1) * (a + 2)))\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            # small deterministic noise in [0,1)\n            noise = ((h ^ (int(f) * 1315423911) ^ (int(l) * 2654435761)) & 0xffffffff) / 2**32\n            score = inc + 1e-6 * noise\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "two_swap_improvement_if_complete": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''If incomplete: greedy min incremental. If complete: perform best improving 2-swap (local search step).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n\n    def total_cost(arr):\n        idx = np.arange(n)\n        L = arr.astype(int)\n        return float(np.sum(flow_matrix[np.ix_(idx, idx)] * distance_matrix[np.ix_(L, L)]))\n\n    if un.size == 0:\n        best = total_cost(a)\n        best_arr = a.copy()\n        for i in range(n):\n            for j in range(i + 1, n):\n                b = a.copy()\n                b[i], b[j] = b[j], b[i]\n                c = total_cost(b)\n                if c < best:\n                    best, best_arr = c, b\n        return best_arr.astype(int).tolist()\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best, best_f, best_l = inc, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "sampled_three_cycle_if_complete": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''If complete: try sampled 3-cycle improvements. If incomplete: max-regret insertion.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n\n    def total_cost(arr):\n        idx = np.arange(n)\n        L = arr.astype(int)\n        return float(np.sum(flow_matrix[np.ix_(idx, idx)] * distance_matrix[np.ix_(L, L)]))\n\n    if un.size == 0:\n        base = total_cost(a)\n        best = base\n        best_arr = a.copy()\n        # sample up to 200 random triples\n        m = min(200, n * (n - 1) * (n - 2) // 6)\n        for _ in range(m):\n            i, j, k = np.random.choice(n, size=3, replace=False)\n            b = a.copy()\n            b[i], b[j], b[k] = a[k], a[i], a[j]  # 3-cycle\n            c = total_cost(b)\n            if c < best:\n                best, best_arr = c, b\n        return best_arr.astype(int).tolist()\n\n    # Otherwise: regret-2 insertion\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_f, best_l, best_reg = int(un[0]), int(free[0]), -1.0\n    for f in un:\n        costs = np.array([delta(int(f), int(l)) for l in free], dtype=float)\n        idx = np.argsort(costs)\n        reg = float(costs[idx[1]] - costs[idx[0]]) if costs.size > 1 else float(\"inf\")\n        if reg > best_reg:\n            best_reg, best_f, best_l = reg, int(f), int(free[int(idx[0])])\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "future_pairwise_top_neighbor_flow": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Incremental cost + future estimate based on strongest unassigned neighbor flows (top-k).'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    sym_flow = (flow_matrix + flow_matrix.T).astype(float)\n\n    # mean distance among free locations for future approximation\n    mean_d = float(distance_matrix[np.ix_(free, free)].mean()) if free.size > 1 else 0.0\n\n    k = min(5, un.size)  # neighbors\n    best_f, best_l, best = int(un[0]), int(free[0]), float(\"inf\")\n    for f in un:\n        # strongest remaining interactions for f\n        nbrs = un[np.argsort(-sym_flow[f, un])[:k]]\n        future_mass = float(sym_flow[f, nbrs].sum())\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc + 0.10 * future_mass * mean_d\n            if score < best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "robust_median_centrality_assignment": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Use robust (median-based) location centrality and facility flow to pick the next placement.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    f = int(un[int(np.argmax(pf[un]))])\n\n    # robust centrality: median distance to all locations (smaller => more central)\n    med = np.median(distance_matrix[free], axis=1).astype(float)\n    l0 = int(free[int(np.argmin(med))])\n\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    if ass.size == 0:\n        l = l0\n    else:\n        # choose between a few most-central free locations by true incremental cost\n        cand = free[np.argsort(med)[:min(6, free.size)]]\n        best, l = float(\"inf\"), int(cand[0])\n        for loc in cand:\n            inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[loc, locs] +\n                               flow_matrix[ass, f] * distance_matrix[locs, loc]))\n            if inc < best:\n                best, l = inc, int(loc)\n\n    out = list(current_assignment); out[f] = l\n    return out\n",
  "facility_diversity_then_greedy": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Early diversify facility types: pick facility farthest (in flow space) from already assigned; then greedy place.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    ass = np.where(a != -1)[0].astype(int)\n    progress = 1.0 - (un.size / max(1, n))\n\n    # \"flow feature\" = row+col vector\n    F = (flow_matrix + flow_matrix.T).astype(float)\n\n    if ass.size and progress < 0.6:\n        # choose unassigned facility with largest distance to mean assigned flow-profile\n        mu = F[ass].mean(axis=0)\n        d = np.linalg.norm(F[un] - mu[None, :], axis=1)\n        f = int(un[int(np.argmax(d))])\n    else:\n        tot = F.sum(axis=1)\n        f = int(un[int(np.argmax(tot[un]))])\n\n    locs = a[ass].astype(int)\n\n    best, l = float(\"inf\"), int(free[0])\n    for loc in free:\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[loc, locs] +\n                                                    flow_matrix[ass, f] * distance_matrix[locs, loc]))\n        if inc < best:\n            best, l = inc, int(loc)\n\n    out = list(current_assignment); out[f] = l\n    return out\n",
  "flow_distance_cosine_alignment": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Align facility interaction profile with location distance profile using cosine similarity, then greedily place.'''\n    a = np.array(current_assignment, dtype=int)\n    n = a.size\n    un = np.where(a == -1)[0].astype(int)\n    if un.size == 0:\n        return list(current_assignment)\n\n    used = np.zeros(n, dtype=bool)\n    used[a[a != -1]] = True\n    free = np.where(~used)[0].astype(int)\n\n    # facility profile: sym flow row\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    # location profile: inverse distances (closer = larger)\n    G = 1.0 / (distance_matrix.astype(float) + 1e-6)\n\n    # normalize profiles\n    Fz = F / (np.linalg.norm(F, axis=1, keepdims=True) + 1e-12)\n    Gz = G / (np.linalg.norm(G, axis=1, keepdims=True) + 1e-12)\n\n    # pick facility and location pair maximizing alignment minus incremental cost proxy\n    ass = np.where(a != -1)[0].astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l, best = int(un[0]), int(free[0]), -float(\"inf\")\n    for f in un:\n        for l in free:\n            align = float(np.dot(Fz[int(f)], Gz[int(l)]))\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = align - 0.001 * inc\n            if score > best:\n                best, best_f, best_l = score, int(f), int(l)\n\n    out = list(current_assignment); out[best_f] = best_l\n    return out\n",
  "min_incremental_cost_pair_cached": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Min incremental cost over all (facility, location) pairs (straight, cache-friendly loops).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l = int(un[0]), int(free[0])\n    best = float('inf')\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            if ass.size == 0:\n                inc = 0.0\n            else:\n                inc = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                   flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best = inc\n                best_f, best_l = f, l\n\n    out = a.copy()\n    out[best_f] = best_l\n    return out.tolist()\n",
  "min_incremental_cost_lexicographic": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Min incremental; tie-break by (facility total flow desc, location centrality desc).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best_f, best_l = int(un[0]), int(free[0])\n    best = float('inf')\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best - 1e-12:\n                best = inc\n                best_f, best_l = f, l\n            elif abs(inc - best) <= 1e-12:\n                if (pf[f], cl[l]) > (pf[best_f], cl[best_l]):\n                    best_f, best_l = f, l\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "min_weighted_inc_by_free_dispersion": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Incremental cost weighted by how dispersed the remaining locations are (penalize early mistakes).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used)\n\n    # dispersion among free locations\n    if free.size > 1:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        disp = float(D.std())\n    else:\n        disp = 0.0\n\n    w = 1.0 + 0.35 * (disp / (float(distance_matrix.std()) + 1e-12))\n\n    ass = np.flatnonzero(a != -1)\n    locs = a[ass].astype(int)\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = w * inc\n            if score < best:\n                best = score\n                best_f, best_l = int(f), int(l)\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "max_flow_to_free_then_place": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility with largest total flow to still-unassigned facilities; then place by min incremental to assigned.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n    mass = sym[np.ix_(un, un)].sum(axis=1)\n    f = int(un[int(np.argmax(mass))])\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best_l = int(free[0])\n    best = float('inf')\n    for l in free:\n        l = int(l)\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc\n            best_l = l\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "min_incremental_plus_quadratic_penalty": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Minimize incremental + quadratic penalty for placing high-flow facility far from currently used locations.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    pf = (pf - pf.min()) / (pf.max() - pf.min() + 1e-12)\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if ass.size == 0:\n                far = float(distance_matrix[l].mean())\n            else:\n                far = float(distance_matrix[l, locs].mean())\n            score = inc + 0.20 * pf[f] * (far ** 2)\n            if score < best:\n                best = score\n                best_f, best_l = f, l\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "max_regret_3_insertion": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Regret-3 insertion: (3rd best - best) chooses the facility; assign it to its best location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_score = -1.0\n    best_f = int(un[0])\n    best_l = int(free[0])\n\n    for f in un:\n        costs = np.array([delta(int(f), int(l)) for l in free], dtype=float)\n        idx = np.argsort(costs)\n        best = float(costs[idx[0]])\n        third = float(costs[idx[2]]) if costs.size >= 3 else float(costs[idx[-1]])\n        score = third - best\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[int(idx[0])])\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "max_regret_ratio_insertion": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Regret ratio: (2nd-best / (best+eps)) picks facility; assign to best location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    eps = 1e-9\n\n    def delta(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    best_score = -1.0\n    best_f = int(un[0])\n    best_l = int(free[0])\n\n    for f in un:\n        costs = np.array([delta(int(f), int(l)) for l in free], dtype=float)\n        idx = np.argsort(costs)\n        b = float(costs[idx[0]])\n        s = float(costs[idx[1]]) if costs.size > 1 else (b + 1.0)\n        score = s / (b + eps)\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[int(idx[0])])\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "facility_pair_seed_then_place_one": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''If nothing assigned: seed by max-flow facility pair to closest location pair; else add min-incremental pair.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    if ass.size == 0 and un.size >= 2 and free.size >= 2:\n        # pick facility pair with max sym flow\n        sym = (flow_matrix + flow_matrix.T).astype(float)\n        sub = sym[np.ix_(un, un)]\n        iu, ju = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        f1 = int(un[iu]); f2 = int(un[ju])\n        # pick location pair with min distance\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        il, jl = np.unravel_index(int(np.argmin(D + np.eye(D.shape[0]) * 1e12)), D.shape)\n        l1 = int(free[il]); l2 = int(free[jl])\n        # assign one of them now (the heuristic is single-step)\n        out = a.copy(); out[f1] = l1\n        return out.tolist()\n\n    # fallback: min incremental pair\n    locs = a[ass].astype(int)\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best = inc\n                best_f, best_l = f, l\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "location_pair_seed_then_best_facility": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''If nothing assigned: pick closest location pair; place highest-flow facility on one of them.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    if ass.size == 0 and free.size >= 2:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        i, j = np.unravel_index(int(np.argmin(D + np.eye(D.shape[0]) * 1e12)), D.shape)\n        l = int(free[int(i)])\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(pf[un]))])\n        out = a.copy(); out[f] = l\n        return out.tolist()\n\n    # otherwise: greedy min incremental pair\n    locs = a[ass].astype(int)\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un:\n        for l in free:\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[int(f), ass] * distance_matrix[int(l), locs] +\n                                                         flow_matrix[ass, int(f)] * distance_matrix[locs, int(l)]))\n            if inc < best:\n                best = inc; best_f = int(f); best_l = int(l)\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "anti_greedy_outlier_location_first": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Early: assign to most isolated free location to reduce later corner-cases; late: min incremental.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used)\n\n    progress = 1.0 - (un.size / max(1, n))\n\n    ass = np.flatnonzero(a != -1)\n    locs = a[ass].astype(int)\n\n    if progress < 0.5:\n        # pick most isolated free location by mean distance to other free locations\n        if free.size > 1:\n            D = distance_matrix[np.ix_(free, free)].astype(float)\n            iso = D.mean(axis=1)\n            l = int(free[int(np.argmax(iso))])\n        else:\n            l = int(free[0])\n        # place facility that best fits there\n        best = float('inf'); best_f = int(un[0])\n        for f in un.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best = inc; best_f = f\n        out = a.copy(); out[best_f] = l\n        return out.tolist()\n\n    # late: min incremental pair\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best = inc; best_f = f; best_l = l\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "late_stage_minimax_blend": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Blend min incremental early with minimax interaction late (progress-adaptive).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    lam = max(0.0, min(1.0, (progress - 0.55) / 0.45))  # 0 until ~55%, then ramps to 1\n\n    best = float('inf')\n    best_f, best_l = int(un[0]), int(free[0])\n\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            if ass.size == 0:\n                inc = 0.0\n                worst = 0.0\n            else:\n                c1 = flow_matrix[f, ass] * distance_matrix[l, locs]\n                c2 = flow_matrix[ass, f] * distance_matrix[locs, l]\n                worst = float(np.max(c1 + c2))\n                inc = float(np.sum(c1 + c2))\n            score = (1.0 - lam) * inc + lam * worst\n            if score < best:\n                best = score\n                best_f, best_l = f, l\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "balanced_bipartite_greedy_step": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Constructive step that targets balance: choose facility and location ranks (high-flow vs central) then refine by cost.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n\n    # pick percentile index based on progress\n    progress = 1.0 - (un.size / max(1, n))\n    q = 0.15 + 0.70 * progress\n\n    uf_sorted = un[np.argsort(-pf[un])]\n    lf_sorted = free[np.argsort(-cl[free])]\n\n    f = int(uf_sorted[min(len(uf_sorted)-1, int(q * (len(uf_sorted)-1) + 0.5))])\n    l0 = int(lf_sorted[min(len(lf_sorted)-1, int(q * (len(lf_sorted)-1) + 0.5))])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # refine: among a small location neighborhood around l0, pick best for f\n    if free.size > 1:\n        k = min(8, free.size)\n        near = free[np.argsort(distance_matrix[free, l0])[:k]]\n    else:\n        near = np.array([l0], dtype=int)\n\n    best = float('inf'); best_l = int(near[0])\n    for l in near.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "stochastic_rcl_facility_then_location": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Two-stage GRASP: pick facility from restricted candidate list (flow); then pick location from RCL (incremental).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # facility RCL (top 20%)\n    kf = max(1, int(np.ceil(0.20 * un.size)))\n    f_cand = un[np.argsort(-pf[un])[:kf]]\n    f = int(np.random.choice(f_cand))\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # location RCL by incremental cost\n    costs = []\n    for l in free.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        costs.append(inc)\n    costs = np.asarray(costs, dtype=float)\n    kl = max(1, int(np.ceil(0.20 * free.size)))\n    idx = np.argsort(costs)[:kl]\n    l = int(free[int(np.random.choice(idx))])\n\n    out = a.copy(); out[f] = l\n    return out.tolist()\n",
  "adaptive_rcl_by_progress": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''RCL size shrinks as progress increases; choose among best pairs with probability proportional to exp(-cost/T).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    frac = 0.25 * (1.0 - progress) + 0.05  # from 30% early down to ~5% late\n\n    pairs = []\n    costs = []\n    for f in un:\n        f = int(f)\n        for l in free:\n            l = int(l)\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                         flow_matrix[ass, f] * distance_matrix[locs, l]))\n            pairs.append((f, l))\n            costs.append(inc)\n\n    costs = np.asarray(costs, dtype=float)\n    k = max(1, int(np.ceil(frac * costs.size)))\n    idx = np.argsort(costs)[:k]\n\n    c = costs[idx]\n    c = c - c.min()\n    T = max(1e-6, 1.5 * (1.0 - progress) + 0.05)\n    p = np.exp(-c / T)\n    p = p / (p.sum() + 1e-12)\n\n    pick = int(np.random.choice(idx, p=p))\n    f, l = pairs[pick]\n\n    out = a.copy(); out[int(f)] = int(l)\n    return out.tolist()\n",
  "heavy_edge_match_then_place": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick unassigned facility pair with max sym flow; place one facility near the other's best-fit anchor among assigned.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    if un.size >= 2:\n        sub = sym[np.ix_(un, un)].copy()\n        np.fill_diagonal(sub, -np.inf)\n        i, j = np.unravel_index(int(np.argmax(sub)), sub.shape)\n        f = int(un[i])\n    else:\n        f = int(un[0])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    # choose location minimizing incremental; if assigned exists, add bias to be near the \"strongest\" assigned neighbor\n    best = float('inf'); best_l = int(free[0])\n    if ass.size:\n        anchor_fac = int(ass[int(np.argmax(sym[f, ass]))])\n        anchor_loc = int(a[anchor_fac])\n    else:\n        anchor_loc = None\n\n    for l in free.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        bias = 0.0 if anchor_loc is None else 0.10 * float(distance_matrix[l, anchor_loc])\n        score = inc + bias\n        if score < best:\n            best = score; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "min_inc_with_location_crowding": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Incremental cost + crowding penalty if chosen location is far from the centroid of already-used locations.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    locs = a[ass].astype(int)\n\n    if ass.size:\n        # centroid in distance space via medoid: location minimizing sum to used locations\n        medoid_idx = int(np.argmin(distance_matrix[locs][:, locs].sum(axis=1)))\n        center_loc = int(locs[medoid_idx])\n    else:\n        center_loc = None\n\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            crowd = 0.0 if center_loc is None else 0.08 * float(distance_matrix[l, center_loc])\n            score = inc + crowd\n            if score < best:\n                best = score; best_f = int(f); best_l = int(l)\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "min_inc_with_flow_centrality_facility": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Select facility by eigenvector centrality of flow graph (approx via power iteration), then best location by incremental.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    # power iteration (few steps)\n    v = np.ones(n, dtype=float) / n\n    for _ in range(12):\n        v = F @ v\n        v = v / (np.linalg.norm(v) + 1e-12)\n    v = np.abs(v)\n\n    f = int(un[int(np.argmax(v[un]))])\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf'); best_l = int(free[0])\n    for l in free.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "min_inc_with_location_pagerank": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Bias toward high PageRank locations on the inverse-distance graph; choose best pair under biased score.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # build stochastic matrix from inverse distances\n    W = 1.0 / (distance_matrix.astype(float) + 1e-6)\n    np.fill_diagonal(W, 0.0)\n    P = W / (W.sum(axis=1, keepdims=True) + 1e-12)\n\n    d = 0.85\n    pr = np.ones(n, dtype=float) / n\n    for _ in range(20):\n        pr = d * (P.T @ pr) + (1.0 - d) / n\n    pr = (pr - pr.min()) / (pr.max() - pr.min() + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc - 0.25 * pr[l]  # prefer higher-pr locations\n            if score < best:\n                best = score; best_f = f; best_l = l\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "directional_flow_asymmetry_priority": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Prioritize facilities with high flow asymmetry to already assigned; place to minimize asymmetric incremental.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    locs = a[ass].astype(int)\n\n    if ass.size:\n        asym = np.abs(flow_matrix[np.ix_(un, ass)].sum(axis=1) - flow_matrix[np.ix_(ass, un)].sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(asym))])\n    else:\n        # if no assigned, just pick high total flow\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(pf[un]))])\n\n    best = float('inf'); best_l = int(free[0])\n    for l in free.astype(int):\n        if ass.size == 0:\n            inc = 0.0\n        else:\n            out_cost = np.sum(flow_matrix[f, ass] * distance_matrix[l, locs])\n            in_cost = np.sum(flow_matrix[ass, f] * distance_matrix[locs, l])\n            inc = float(out_cost + in_cost)\n        if inc < best:\n            best = inc; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "min_inc_with_rank_sum": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Score = rank(inc) + rank(-facility_flow) + rank(-location_centrality), pick min.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = []\n    incs = []\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            pairs.append((f, l))\n            incs.append(inc)\n\n    incs = np.asarray(incs, dtype=float)\n    inc_rank = np.argsort(np.argsort(incs))\n\n    f_vals = np.array([pf[f] for f, _ in pairs], dtype=float)\n    l_vals = np.array([cl[l] for _, l in pairs], dtype=float)\n\n    f_rank = np.argsort(np.argsort(-f_vals))\n    l_rank = np.argsort(np.argsort(-l_vals))\n\n    score = inc_rank + 0.35 * f_rank + 0.35 * l_rank\n    idx = int(np.argmin(score))\n    f, l = pairs[idx]\n\n    out = a.copy(); out[int(f)] = int(l)\n    return out.tolist()\n",
  "min_inc_with_small_k_medoids_locations": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Cluster free locations into k medoids (k small), pick a medoid location, then choose best facility for it.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    # pick k medoids as the k most central free locations\n    k = min(5, max(1, free.size // 5))\n    cent = distance_matrix[free].sum(axis=1).astype(float)\n    medoids = free[np.argsort(cent)[:k]].astype(int)\n\n    # choose one medoid to fill now: the one farthest from already-used locations (covers space)\n    ass = np.flatnonzero(a != -1).astype(int)\n    if ass.size:\n        locs = a[ass].astype(int)\n        spread = np.array([distance_matrix[m, locs].mean() for m in medoids], dtype=float)\n        l = int(medoids[int(np.argmax(spread))])\n    else:\n        l = int(medoids[0])\n\n    locs = a[ass].astype(int)\n\n    best = float('inf'); best_f = int(un[0])\n    for f in un.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_f = int(f)\n\n    out = a.copy(); out[best_f] = l\n    return out.tolist()\n",
  "min_inc_with_facility_hubs_first": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Early: place hub facilities (top flow) onto central locations; later: pure min incremental.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n\n    pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n    cl = 1.0 / (distance_matrix.sum(axis=1).astype(float) + 1e-12)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    if progress < 0.45:\n        # choose among top hub facilities\n        kf = max(1, int(np.ceil(0.20 * un.size)))\n        hubs = un[np.argsort(-pf[un])[:kf]]\n        f = int(hubs[0])\n        # choose among top central locations\n        kl = max(1, int(np.ceil(0.20 * free.size)))\n        cents = free[np.argsort(-cl[free])[:kl]]\n        # pick best hub-central pair by incremental\n        best = float('inf'); best_f = int(f); best_l = int(cents[0])\n        for f2 in hubs.astype(int):\n            for l2 in cents.astype(int):\n                inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f2, ass] * distance_matrix[l2, locs] +\n                                                            flow_matrix[ass, f2] * distance_matrix[locs, l2]))\n                if inc < best:\n                    best = inc; best_f = int(f2); best_l = int(l2)\n        out = a.copy(); out[best_f] = best_l\n        return out.tolist()\n\n    # later: pure min incremental pair\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if inc < best:\n                best = inc; best_f = int(f); best_l = int(l)\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "least_constrained_location_first": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick the location with most similar distances to other free locations (least constrained), then best facility for it.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    if free.size > 1:\n        D = distance_matrix[np.ix_(free, free)].astype(float)\n        # \"least constrained\" = minimal variance of its distances to other free locations\n        v = D.var(axis=1)\n        l = int(free[int(np.argmin(v))])\n    else:\n        l = int(free[0])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf'); best_f = int(un[0])\n    for f in un.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_f = int(f)\n\n    out = a.copy(); out[best_f] = l\n    return out.tolist()\n",
  "most_constrained_location_first": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick the most extreme free location (highest distance-sum), then best facility for it (avoid dead-ends).'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    s = distance_matrix[free].sum(axis=1).astype(float)\n    l = int(free[int(np.argmax(s))])\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    best = float('inf'); best_f = int(un[0])\n    for f in un.astype(int):\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_f = int(f)\n\n    out = a.copy(); out[best_f] = l\n    return out.tolist()\n",
  "facility_similarity_bundle": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Pick facility that is most similar (cosine) to already-assigned flow profile; place near centroid of used locations.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    F = (flow_matrix + flow_matrix.T).astype(float)\n    Fn = F / (np.linalg.norm(F, axis=1, keepdims=True) + 1e-12)\n\n    if ass.size:\n        mu = Fn[ass].mean(axis=0)\n        mu = mu / (np.linalg.norm(mu) + 1e-12)\n        sims = Fn[un] @ mu\n        f = int(un[int(np.argmax(sims))])\n    else:\n        pf = F.sum(axis=1)\n        f = int(un[int(np.argmax(pf[un]))])\n\n    if ass.size:\n        locs = a[ass].astype(int)\n        # choose free location closest to used-set medoid\n        medoid_idx = int(np.argmin(distance_matrix[locs][:, locs].sum(axis=1)))\n        center = int(locs[medoid_idx])\n        l0 = int(free[int(np.argmin(distance_matrix[free, center]))])\n    else:\n        l0 = int(free[int(np.argmin(distance_matrix[free].sum(axis=1)))])\n\n    # local refinement by incremental among nearest few\n    k = min(8, free.size)\n    cand = free[np.argsort(distance_matrix[free, l0])[:k]].astype(int)\n\n    locs = a[ass].astype(int)\n    best = float('inf'); best_l = int(cand[0])\n    for l in cand:\n        inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                     flow_matrix[ass, f] * distance_matrix[locs, l]))\n        if inc < best:\n            best = inc; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n",
  "opportunity_cost_facility_choice": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Choose facility with highest opportunity cost: avg(inc) - min(inc); assign to its min(inc) location.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    def inc_costs(f):\n        if ass.size == 0:\n            return np.zeros(free.size, dtype=float)\n        return np.array([np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                flow_matrix[ass, f] * distance_matrix[locs, l]) for l in free], dtype=float)\n\n    best_score = -1.0\n    best_f = int(un[0])\n    best_l = int(free[0])\n\n    for f in un.astype(int):\n        c = inc_costs(int(f))\n        score = float(c.mean() - c.min())\n        if score > best_score:\n            best_score = score\n            best_f = int(f)\n            best_l = int(free[int(np.argmin(c))])\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "mean_plus_std_risk_averse": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Risk-averse: score(l)=mean interaction cost + k*std interaction cost vs assigned; choose min across pairs.'''\n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    k = 0.25 + 0.75 * progress  # more risk-averse late\n\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n\n    for f in un.astype(int):\n        for l in free.astype(int):\n            if ass.size == 0:\n                score = 0.0\n            else:\n                c = flow_matrix[f, ass] * distance_matrix[l, locs] + flow_matrix[ass, f] * distance_matrix[locs, l]\n                score = float(c.mean() + k * c.std())\n            if score < best:\n                best = score; best_f = int(f); best_l = int(l)\n\n    out = a.copy(); out[best_f] = best_l\n    return out.tolist()\n",
  "min_inc_with_soft_conflicts": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Penalize placing a facility at a location whose distance profile poorly matches already-assigned interactions.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    locs = a[ass].astype(int)\n\n    # interaction mass between candidate f and assigned facilities\n    sym = (flow_matrix + flow_matrix.T).astype(float)\n\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        w = sym[f, ass].astype(float) if ass.size else None\n        wsum = float(w.sum()) if ass.size else 1.0\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            if ass.size == 0:\n                penalty = 0.0\n            else:\n                # compare location distances to assigned locs against inverse of interaction weights (soft match)\n                d = distance_matrix[l, locs].astype(float)\n                d = (d - d.mean()) / (d.std() + 1e-12)\n                ww = (w - w.mean()) / (w.std() + 1e-12)\n                penalty = float(np.sum((d - (-ww))**2) / (ass.size + 1e-12))\n            score = inc + 0.05 * penalty * (abs(inc) + 1.0)\n            if score < best:\n                best = score; best_f = f; best_l = l\n\n    out = a.copy(); out[int(best_f)] = int(best_l)\n    return out.tolist()\n",
  "short_horizon_rollout_sample": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Sample a few candidate pairs; for each, simulate a short greedy rollout (h steps) and pick best simulated outcome.''' \n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n\n    un0 = np.flatnonzero(a0 == -1).astype(int)\n    if un0.size == 0:\n        return a0.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a0 != -1):\n        used[a0[a0 != -1]] = True\n    free0 = np.flatnonzero(~used).astype(int)\n\n    ass0 = np.flatnonzero(a0 != -1).astype(int)\n    locs0 = a0[ass0].astype(int)\n\n    # build all pairs costs (incremental)\n    pairs = []\n    costs = []\n    for f in un0.astype(int):\n        for l in free0.astype(int):\n            inc = 0.0 if ass0.size == 0 else float(np.sum(flow_matrix[f, ass0] * distance_matrix[l, locs0] +\n                                                         flow_matrix[ass0, f] * distance_matrix[locs0, l]))\n            pairs.append((f, l))\n            costs.append(inc)\n\n    costs = np.asarray(costs, dtype=float)\n    k = min(20, max(3, int(0.08 * len(pairs))))\n    cand_idx = np.argsort(costs)[:k]\n\n    def total_cost(arr):\n        idx = np.arange(n)\n        L = arr.astype(int)\n        return float(np.sum(flow_matrix[np.ix_(idx, idx)] * distance_matrix[np.ix_(L, L)]))\n\n    h = min(3, un0.size)  # rollout depth\n    best_total = float('inf')\n    best_pair = pairs[int(cand_idx[0])]\n\n    for idxp in cand_idx:\n        f, l = pairs[int(idxp)]\n        a = a0.copy()\n        a[int(f)] = int(l)\n        # greedy fill h-1 steps using min incremental\n        for _ in range(h - 1):\n            un = np.flatnonzero(a == -1).astype(int)\n            if un.size == 0:\n                break\n            used = np.zeros(n, dtype=bool)\n            used[a[a != -1]] = True\n            free = np.flatnonzero(~used).astype(int)\n            ass = np.flatnonzero(a != -1).astype(int)\n            locs = a[ass].astype(int)\n            bf, bl, b = int(un[0]), int(free[0]), float('inf')\n            for f2 in un.astype(int):\n                for l2 in free.astype(int):\n                    inc = float(np.sum(flow_matrix[f2, ass] * distance_matrix[l2, locs] +\n                                       flow_matrix[ass, f2] * distance_matrix[locs, l2]))\n                    if inc < b:\n                        b = inc; bf = int(f2); bl = int(l2)\n            a[bf] = bl\n        # if still incomplete, just evaluate partial by incremental proxy\n        if np.any(a == -1):\n            # proxy: sum current incremental contributions only\n            ass = np.flatnonzero(a != -1).astype(int)\n            locs = a[ass].astype(int)\n            proxy = 0.0\n            for i in range(ass.size):\n                for j in range(ass.size):\n                    proxy += float(flow_matrix[ass[i], ass[j]] * distance_matrix[locs[i], locs[j]])\n            tot = proxy\n        else:\n            tot = total_cost(a)\n        if tot < best_total:\n            best_total = tot\n            best_pair = (int(f), int(l))\n\n    out = a0.copy(); out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n",
  "beam_search_width3_one_step": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''One-step beam: expand best few partial assignments by one move, keep top-B, return the first move of best branch.''' \n    a0 = np.asarray(current_assignment, dtype=int)\n    n = a0.size\n\n    un0 = np.flatnonzero(a0 == -1).astype(int)\n    if un0.size == 0:\n        return a0.tolist()\n\n    def inc_pair(a, f, l):\n        ass = np.flatnonzero(a != -1).astype(int)\n        if ass.size == 0:\n            return 0.0\n        locs = a[ass].astype(int)\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # enumerate candidate moves and seed beam by best K\n    used0 = np.zeros(n, dtype=bool)\n    if np.any(a0 != -1):\n        used0[a0[a0 != -1]] = True\n    free0 = np.flatnonzero(~used0).astype(int)\n\n    moves = []\n    costs = []\n    for f in un0.astype(int):\n        for l in free0.astype(int):\n            moves.append((f, l))\n            costs.append(inc_pair(a0, int(f), int(l)))\n\n    costs = np.asarray(costs, dtype=float)\n    K = min(12, len(moves))\n    seed = np.argsort(costs)[:K]\n\n    B = 3\n    beam = []\n    for idx in seed:\n        f, l = moves[int(idx)]\n        a = a0.copy(); a[int(f)] = int(l)\n        beam.append((float(costs[int(idx)]), a, (int(f), int(l))))\n    beam.sort(key=lambda x: x[0])\n    beam = beam[:B]\n\n    # one additional expansion layer\n    new_beam = []\n    for base_cost, a, first_move in beam:\n        un = np.flatnonzero(a == -1).astype(int)\n        if un.size == 0:\n            new_beam.append((base_cost, a, first_move))\n            continue\n        used = np.zeros(n, dtype=bool)\n        used[a[a != -1]] = True\n        free = np.flatnonzero(~used).astype(int)\n        for f2 in un.astype(int):\n            for l2 in free.astype(int):\n                c = inc_pair(a, int(f2), int(l2))\n                b = a.copy(); b[int(f2)] = int(l2)\n                new_beam.append((base_cost + c, b, first_move))\n\n    new_beam.sort(key=lambda x: x[0])\n    best_first = new_beam[0][2]\n\n    out = a0.copy(); out[best_first[0]] = best_first[1]\n    return out.tolist()\n",
  "cross_entropy_pair_selection": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Cross-entropy style: sample pairs from a distribution, keep elites, update logits once, then pick MAP pair.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    pairs = [(int(f), int(l)) for f in un for l in free]\n    m = len(pairs)\n\n    # initial logits from negative incremental cost\n    base = np.zeros(m, dtype=float)\n    for i, (f, l) in enumerate(pairs):\n        if ass.size == 0:\n            base[i] = 0.0\n        else:\n            base[i] = -float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # normalize\n    logits = (base - base.mean()) / (base.std() + 1e-6)\n\n    # sample\n    S = min(200, max(40, 3 * m))\n    p = np.exp(logits - logits.max())\n    p = p / (p.sum() + 1e-12)\n    samp = np.random.choice(m, size=S, replace=True, p=p)\n\n    # evaluate sampled costs\n    costs = np.zeros(S, dtype=float)\n    for k, idx in enumerate(samp):\n        f, l = pairs[int(idx)]\n        if ass.size == 0:\n            costs[k] = 0.0\n        else:\n            costs[k] = float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                    flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # elite set\n    elite_frac = 0.15\n    E = max(5, int(elite_frac * S))\n    elite_idx = samp[np.argsort(costs)[:E]]\n\n    # update logits toward elites\n    alpha = 0.6\n    counts = np.bincount(elite_idx, minlength=m).astype(float)\n    counts = counts / (counts.sum() + 1e-12)\n    logits = (1 - alpha) * logits + alpha * (np.log(counts + 1e-12) - np.log(1.0 / m))\n\n    # pick MAP\n    pick = int(np.argmax(logits))\n    f, l = pairs[pick]\n\n    out = a.copy(); out[f] = l\n    return out.tolist()\n",
  "incremental_cost_with_symmetry_breaking": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Min incremental but add tiny symmetry-breaking bias favoring smaller location indices early (stabilizes runs).''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    progress = 1.0 - (un.size / max(1, n))\n    eps = 1e-6 * (1.0 - progress)\n\n    best = float('inf'); best_f = int(un[0]); best_l = int(free[0])\n    for f in un.astype(int):\n        for l in free.astype(int):\n            inc = 0.0 if ass.size == 0 else float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                                                        flow_matrix[ass, f] * distance_matrix[locs, l]))\n            score = inc + eps * (l / max(1, n - 1))\n            if score < best:\n                best = score; best_f = f; best_l = l\n\n    out = a.copy(); out[int(best_f)] = int(best_l)\n    return out.tolist()\n",
  "dual_greedy_facility_and_location": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Compute best location for each facility and best facility for each location; pick the most mutually consistent pair.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    used = np.zeros(n, dtype=bool)\n    if np.any(a != -1):\n        used[a[a != -1]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    ass = np.flatnonzero(a != -1).astype(int)\n    locs = a[ass].astype(int)\n\n    def inc(f, l):\n        if ass.size == 0:\n            return 0.0\n        return float(np.sum(flow_matrix[f, ass] * distance_matrix[l, locs] +\n                            flow_matrix[ass, f] * distance_matrix[locs, l]))\n\n    # best location per facility\n    f_best_l = {}\n    f_best_c = {}\n    for f in un.astype(int):\n        cs = np.array([inc(int(f), int(l)) for l in free], dtype=float)\n        j = int(np.argmin(cs))\n        f_best_l[int(f)] = int(free[j])\n        f_best_c[int(f)] = float(cs[j])\n\n    # best facility per location\n    l_best_f = {}\n    l_best_c = {}\n    for l in free.astype(int):\n        cs = np.array([inc(int(f), int(l)) for f in un], dtype=float)\n        i = int(np.argmin(cs))\n        l_best_f[int(l)] = int(un[i])\n        l_best_c[int(l)] = float(cs[i])\n\n    # pick pair with maximum mutuality score\n    best_score = -float('inf'); best_pair = (int(un[0]), int(free[0]))\n    for f in un.astype(int):\n        l = f_best_l[int(f)]\n        mutual = 1 if l_best_f[int(l)] == int(f) else 0\n        score = 2.0 * mutual - f_best_c[int(f)] - l_best_c[int(l)]\n        if score > best_score:\n            best_score = score\n            best_pair = (int(f), int(l))\n\n    out = a.copy(); out[best_pair[0]] = best_pair[1]\n    return out.tolist()\n",
  "partial_cost_gradient_descent_step": "import numpy as np\nfrom typing import List\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    '''Treat each facility's location as variable; approximate a gradient via swapping benefit and commit one assignment.''' \n    a = np.asarray(current_assignment, dtype=int)\n    n = a.size\n\n    un = np.flatnonzero(a == -1).astype(int)\n    if un.size == 0:\n        return a.tolist()\n\n    ass = np.flatnonzero(a != -1).astype(int)\n\n    used = np.zeros(n, dtype=bool)\n    if ass.size:\n        used[a[ass]] = True\n    free = np.flatnonzero(~used).astype(int)\n\n    locs = a[ass].astype(int)\n\n    # pick a facility with largest partial \"force\" from assigned facilities\n    if ass.size:\n        force = (flow_matrix[np.ix_(un, ass)].sum(axis=1) + flow_matrix[np.ix_(ass, un)].sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(force))])\n    else:\n        pf = (flow_matrix.sum(axis=1) + flow_matrix.sum(axis=0)).astype(float)\n        f = int(un[int(np.argmax(pf[un]))])\n\n    # choose location that minimizes a quadratic form distance^2 weighted by interaction\n    best = float('inf'); best_l = int(free[0])\n    for l in free.astype(int):\n        if ass.size == 0:\n            score = float((distance_matrix[l].astype(float) ** 2).mean())\n        else:\n            w_out = flow_matrix[f, ass].astype(float)\n            w_in = flow_matrix[ass, f].astype(float)\n            w = w_out + w_in\n            wsum = float(w.sum()) + 1e-12\n            d = distance_matrix[l, locs].astype(float)\n            score = float(np.sum(w * (d ** 2)) / wsum)\n        if score < best:\n            best = score; best_l = int(l)\n\n    out = a.copy(); out[f] = best_l\n    return out.tolist()\n"
}
