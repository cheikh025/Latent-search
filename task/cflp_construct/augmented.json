{
  "greedy_lowest_cost_first_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Baseline: iterate customers in given order, pick cheapest feasible facility for the first feasible customer.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(costs[feas, c])])\n        return int(c), f\n\n    return None, None\n",
  "global_best_pair_min_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick the globally cheapest feasible (customer, facility) pair.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        j = int(feas[np.argmin(costs[feas, c])])\n        val = float(costs[j, c])\n        if val < best[0]:\n            best = (val, int(c), int(j))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "min_regret_2_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Choose customer with maximum regret (2nd best - best) among feasible facilities; assign to best facility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_regret = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            regret = 1e12\n            f = int(feas[0])\n        else:\n            order = np.argsort(c_costs)\n            regret = float(c_costs[order[1]] - c_costs[order[0]])\n            f = int(feas[order[0]])\n        if regret > best_regret:\n            best_regret = regret\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "max_savings_vs_second_best": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick customer where choosing best facility yields the largest savings vs the next best feasible facility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    pick_c = None\n    pick_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            savings = 1e12\n            f = int(feas[0])\n        else:\n            order = np.argsort(c_costs)\n            savings = float(c_costs[order[1]] - c_costs[order[0]])\n            f = int(feas[order[0]])\n        if savings > best_score:\n            best_score = savings\n            pick_c = int(c)\n            pick_f = int(f)\n\n    return (pick_c, pick_f) if pick_c is not None else (None, None)\n",
  "most_constrained_customer_fewest_facilities": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Serve the most constrained customer first (fewest feasible facilities); tie-break by cheapest feasible cost.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_key = None\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        k = int(feas.size)\n        if k == 0:\n            continue\n        j = int(feas[np.argmin(costs[feas, c])])\n        key = (k, float(costs[j, c]))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(j)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "largest_demand_then_cheapest": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Prioritize largest-demand customers (harder to place later), assign to cheapest feasible facility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    order = sorted(remaining_customers, key=lambda c: (-dem[c], c))\n    for c in order:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(costs[feas, c])])\n        return int(c), f\n\n    return None, None\n",
  "smallest_demand_greedy_fill": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pack many small customers early: smallest demand first, assign to cheapest feasible facility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    order = sorted(remaining_customers, key=lambda c: (dem[c], c))\n    for c in order:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(costs[feas, c])])\n        return int(c), f\n\n    return None, None\n",
  "min_cost_per_demand": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Choose assignment minimizing (cost / demand) to favor cost-effective service for large demands.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-9\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        j = int(feas[np.argmin(costs[feas, c])])\n        score = float(costs[j, c]) / (d + eps)\n        if score < best[0]:\n            best = (score, int(c), int(j))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "tightest_fit_then_min_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick a customer and facility that leaves the smallest nonnegative slack (best fit); tie-break by cost.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (slack, cost, c, f)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slacks = caps[feas] - d\n        min_slack = float(np.min(slacks))\n        cand_fs = feas[np.where(slacks == min_slack)[0]]\n        j = int(cand_fs[np.argmin(costs[cand_fs, c])])\n        key = (min_slack, float(costs[j, c]), int(c), int(j))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "slack_weighted_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Minimize cost plus a penalty for consuming scarce capacity: cost + lambda/(slack+1).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 10.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        score = costs[feas, c] + lam / (slack + 1.0)\n        idx = int(np.argmin(score))\n        j = int(feas[idx])\n        val = float(score[idx])\n        if val < best[0]:\n            best = (val, int(c), int(j))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "load_balance_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Prefer balanced utilization: cost + alpha * utilization_after, where utilization_after = used/capacity_total.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    alpha = 5.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    used = np.zeros_like(caps)\n    for f, custs in enumerate(assignments):\n        s = 0.0\n        for c in custs:\n            s += float(dem[c])\n        used[f] = s\n    total_cap = used + caps\n    total_cap = np.maximum(total_cap, 1e-9)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        util_after = (used[feas] + d) / total_cap[feas]\n        score = costs[feas, c] + alpha * util_after\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_fill_first_then_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Push to fill already-heavily-used facilities: prefer facilities with low remaining capacity fraction, then cost.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    used = np.zeros_like(caps)\n    for f, custs in enumerate(assignments):\n        used[f] = sum(float(dem[c]) for c in custs)\n    total_cap = np.maximum(used + caps, 1e-9)\n    rem_frac = caps / total_cap\n\n    best = (np.inf, np.inf, None, None)  # (rem_frac_after, cost, c, f)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        rem_after = (caps[feas] - d) / total_cap[feas]\n        k = int(np.argmin(rem_after))\n        f = int(feas[k])\n        key = (float(rem_after[k]), float(costs[f, c]), int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "k_best_pairs_random_pick": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Build list of feasible pairs, pick randomly among the K cheapest (diversification).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    K = 10\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            pairs.append((float(costs[f, c]), int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    top = pairs[: min(K, len(pairs))]\n    pick = top[int(rng.integers(0, len(top)))]\n    return pick[1], pick[2]\n",
  "epsilon_greedy_global_pair": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"With probability epsilon pick a random feasible pair; otherwise pick the best-cost feasible pair.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    epsilon = 0.15\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    feasible_pairs = []\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            val = float(costs[f, c])\n            feasible_pairs.append((int(c), int(f)))\n            if val < best[0]:\n                best = (val, int(c), int(f))\n\n    if not feasible_pairs:\n        return None, None\n\n    if float(rng.random()) < epsilon:\n        c, f = feasible_pairs[int(rng.integers(0, len(feasible_pairs)))]\n        return int(c), int(f)\n\n    return best[1], best[2]\n",
  "softmax_sampling_over_pairs": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Sample a feasible pair using softmax over negative cost (more likely for cheaper pairs).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    tau = 20.0  # temperature; higher -> flatter\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    pair_c = []\n    pair_f = []\n    pair_cost = []\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            pair_c.append(int(c))\n            pair_f.append(int(f))\n            pair_cost.append(float(costs[f, c]))\n\n    if not pair_cost:\n        return None, None\n\n    x = np.asarray(pair_cost, dtype=float)\n    m = float(np.min(x))\n    w = np.exp(-(x - m) / max(1e-9, tau))\n    w = w / np.sum(w)\n    idx = int(rng.choice(len(w), p=w))\n    return pair_c[idx], pair_f[idx]\n",
  "progressive_explore_then_exploit": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Early: diversify by sampling among top-K; Late: deterministic best pair as remaining shrinks.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    n_rem = len(remaining_customers)\n    n_fac = len(remaining_capacities)\n    progress = 1.0 - (n_rem / max(1, n_rem + sum(len(a) for a in assignments)))\n\n    K = int(np.clip(np.ceil((1.0 - progress) * 20), 3, 20))\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            pairs.append((float(costs[f, c]), int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    if n_rem <= max(2, n_fac // 2):\n        _, c, f = pairs[0]\n        return c, f\n\n    top = pairs[: min(K, len(pairs))]\n    _, c, f = top[int(rng.integers(0, len(top)))]\n    return c, f\n",
  "lookahead_scarcity_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Penalize using facilities that are 'scarce' for big demands: cost + beta * expected_future_loss.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 2.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_dem = np.asarray([float(dem[c]) for c in remaining_customers], dtype=float)\n    if rem_dem.size == 0:\n        return None, None\n\n    # scarcity of facility f: fraction of remaining customers it could still serve\n    feas_frac = []\n    for f in range(len(caps)):\n        feas_frac.append(float(np.mean(caps[f] >= rem_dem)))\n    feas_frac = np.asarray(feas_frac, dtype=float)\n    scarcity = 1.0 - feas_frac  # higher = more scarce\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        # If facility is scarce, consuming capacity is riskier\n        slack = caps[feas] - d\n        risk = scarcity[feas] * (d / np.maximum(1.0, slack + 1.0))\n        score = costs[feas, c] + beta * risk\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_first_pick_best_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick a facility to act on (most remaining capacity), then assign the cheapest feasible customer to it.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Choose facility with most remaining capacity to reduce risk of fragmentation.\n    f_order = np.argsort(-caps)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    for f in f_order:\n        feas_c_mask = dem[rem] <= caps[f]\n        if not np.any(feas_c_mask):\n            continue\n        feas_customers = rem[np.where(feas_c_mask)[0]]\n        j = int(feas_customers[np.argmin(costs[int(f), feas_customers])])\n        return int(j), int(f)\n\n    return None, None\n",
  "facility_most_constrained_then_best_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick the facility that can serve the fewest remaining customers, then assign its cheapest feasible customer.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    feas_counts = []\n    for f in range(len(caps)):\n        feas_counts.append(int(np.sum(dem[rem] <= caps[f])))\n    feas_counts = np.asarray(feas_counts, dtype=int)\n\n    # Most constrained = smallest positive count\n    cand_fs = np.where(feas_counts > 0)[0]\n    if cand_fs.size == 0:\n        return None, None\n    f = int(cand_fs[np.argmin(feas_counts[cand_fs])])\n\n    feas_customers = rem[np.where(dem[rem] <= caps[f])[0]]\n    c = int(feas_customers[np.argmin(costs[f, feas_customers])])\n    return c, f\n",
  "two_step_lookahead_best_remaining_min": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"One-step lookahead: choose pair minimizing (current cost + best cost for a second customer after update).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = list(remaining_customers)\n\n    best = (np.inf, None, None)\n\n    for c in rem:\n        d = float(dem[c])\n        feas_fs = np.where(caps0 >= d)[0]\n        if feas_fs.size == 0:\n            continue\n        for f in feas_fs:\n            caps = caps0.copy()\n            caps[f] -= d\n            base = float(costs[f, c])\n\n            # find best next assignment cost (no penalties) among remaining\\{c}\n            best2 = np.inf\n            for c2 in rem:\n                if c2 == c:\n                    continue\n                d2 = float(dem[c2])\n                feas2 = np.where(caps >= d2)[0]\n                if feas2.size == 0:\n                    continue\n                best2 = min(best2, float(np.min(costs[feas2, c2])))\n            if not np.isfinite(best2):\n                best2 = 0.0\n\n            score = base + 0.5 * best2\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "cheapest_with_capacity_reserve_for_large": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Reserve capacity for large demands by penalizing assignments that reduce ability to serve top-quantile demands.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    gamma = 8.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_full = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    rem_dem = dem_full[rem]\n    if rem_dem.size == 0:\n        return None, None\n\n    q = float(np.quantile(rem_dem, 0.75))\n    big = rem_dem[rem_dem >= q]\n    big = big if big.size > 0 else rem_dem\n\n    best = (np.inf, None, None)\n    for c in rem:\n        d = float(dem_full[c])\n        feas_fs = np.where(caps >= d)[0]\n        if feas_fs.size == 0:\n            continue\n        for f in feas_fs:\n            cap_after = caps[f] - d\n            # how many big demands would still fit in this facility after assignment\n            able_after = float(np.mean(cap_after >= big))\n            penalty = gamma * (1.0 - able_after)\n            score = float(costs[f, c]) + penalty\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "demand_weighted_regret": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Maximize (regret * demand): prioritize high-demand customers where second-best is much worse.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            regret = 1e12\n            f = int(feas[0])\n        else:\n            order = np.argsort(c_costs)\n            regret = float(c_costs[order[1]] - c_costs[order[0]])\n            f = int(feas[order[0]])\n        score = regret * float(dem[c])\n        if score > best_score:\n            best_score = score\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "median_cost_customer_priority": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Choose customer with smallest median feasible cost (overall easy/cheap to serve), assign to best facility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (median_cost, best_cost, c, f)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        med = float(np.median(c_costs))\n        f = int(feas[np.argmin(c_costs)])\n        key = (med, float(costs[f, c]), int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "min_average_cost_facility_bias": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Prefer facilities that are generally cheap: score = cost + eta * mean_cost_of_facility_over_remaining.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    eta = 0.3\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    mean_fac = np.mean(costs[:, rem], axis=1) if rem.size > 0 else np.mean(costs, axis=1)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        score = costs[feas, c] + eta * mean_fac[feas]\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "max_compatibility_margin": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick customer whose demand is closest to max capacity (harder later): maximize demand / max_capacity among feasible.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    max_cap = float(np.max(caps)) if caps.size > 0 else 0.0\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (-np.inf, np.inf, None, None)  # (ratio, cost, c, f)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0 or max_cap <= 0:\n            continue\n        ratio = float(dem[c] / max_cap)\n        f = int(feas[np.argmin(costs[feas, c])])\n        key = (ratio, float(costs[f, c]), int(c), int(f))\n        if key[0] > best[0] or (key[0] == best[0] and key[1] < best[1]):\n            best = (key[0], key[1], key[2], key[3])\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "min_cost_plus_quadratic_demand": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Penalize assigning big customers unless truly cheap: score = cost + alpha * demand^2.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    alpha = 0.05\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        d2 = float(dem[c] ** 2)\n        score = costs[feas, c] + alpha * d2\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "min_cost_plus_demand_over_slack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Score = cost + alpha * demand/(slack+1): avoids using tight capacity for large demands.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    alpha = 6.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        score = costs[feas, c] + alpha * (d / (slack + 1.0))\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_popularity_then_assign": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Compute 'popularity' of facilities as how often they appear in customers' top-2 feasible; act on most popular.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    pop = np.zeros(len(caps), dtype=float)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        k = min(2, int(feas.size))\n        topk = feas[np.argsort(c_costs)[:k]]\n        pop[topk] += 1.0\n\n    cand_fs = np.where(pop > 0)[0]\n    if cand_fs.size == 0:\n        return None, None\n\n    f = int(cand_fs[np.argmax(pop[cand_fs])])\n\n    # Assign the cheapest feasible customer to this popular facility\n    rem = np.asarray(remaining_customers, dtype=int)\n    feas_customers = rem[np.where(dem[rem] <= caps[f])[0]]\n    if feas_customers.size == 0:\n        return None, None\n    c = int(feas_customers[np.argmin(costs[f, feas_customers])])\n    return c, f\n",
  "customer_priority_by_gap_to_capacity": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick customer whose demand is close to the smallest capacity that can still fit it (risk of blocking).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (gap, cost, c, f)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        # pick the tightest facility that still fits\n        gaps = caps[feas] - d\n        t = int(feas[np.argmin(gaps)])\n        gap = float(np.min(gaps))\n        # assign to cheapest feasible (not necessarily tightest) but use gap for priority\n        f = int(feas[np.argmin(costs[feas, c])])\n        key = (gap, float(costs[f, c]), int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "cheapest_customer_per_facility_round_robin": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Round-robin by facility index derived from assignments size: pick that facility, assign its cheapest feasible customer.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # choose facility with currently smallest number of assigned customers (fairness)\n    loads = np.asarray([len(a) for a in assignments], dtype=int)\n    f_order = np.argsort(loads)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    for f in f_order:\n        feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n        if feas_c.size == 0:\n            continue\n        c = int(feas_c[np.argmin(costs[int(f), feas_c])])\n        return c, int(f)\n\n    return None, None\n",
  "cheapest_pair_with_tie_break_by_remaining_capacity": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Min cost pair; tie-break by preferring larger remaining capacity after assignment.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, -np.inf, None, None)  # (cost, rem_after, c, f) where rem_after higher is better\n\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            cost = float(costs[f, c])\n            rem_after = float(caps[f] - d)\n            key = (cost, rem_after)\n            if (cost < best[0]) or (cost == best[0] and rem_after > best[1]):\n                best = (cost, rem_after, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "adaptive_alpha_cost_plus_slack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Adaptive tradeoff: score = cost + alpha*1/(slack+1); alpha increases as fewer customers remain.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    n_assigned = sum(len(a) for a in assignments)\n    n_rem = len(remaining_customers)\n    progress = n_assigned / max(1, n_assigned + n_rem)\n    alpha = 1.0 + 12.0 * progress\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        score = costs[feas, c] + alpha * (1.0 / (slack + 1.0))\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "randomized_customer_order_cheapest": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Shuffle customer order each step; pick first feasible customer and its cheapest feasible facility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    perm = list(remaining_customers)\n    rng.shuffle(perm)\n\n    for c in perm:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(costs[feas, c])])\n        return int(c), f\n\n    return None, None\n",
  "customer_best_cost_then_high_demand_tiebreak": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick customer with smallest best feasible cost; tie-break by larger demand; assign to best facility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, -np.inf, None, None)  # (best_cost, demand, c, f) where higher demand wins tie\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        k = int(np.argmin(costs[feas, c]))\n        f = int(feas[k])\n        bc = float(costs[f, c])\n        key = (bc, float(dem[c]))\n        if (bc < best[0]) or (bc == best[0] and key[1] > best[1]):\n            best = (bc, key[1], int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "greedy_with_facility_risk_of_starvation": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Avoid starving small-capacity facilities: penalize assigning away from small facilities when they have unique cheap customers.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    delta = 1.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # identify, for each customer, its best feasible facility\n    best_fac = {}\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        best_fac[int(c)] = int(feas[np.argmin(costs[feas, c])])\n\n    # count how many customers \"belong\" to each facility as their best\n    belong = np.zeros(len(caps), dtype=float)\n    for c, f in best_fac.items():\n        belong[f] += 1.0\n\n    # facility fragility: small capacity + many dependents\n    frag = (belong + 1.0) / (caps + 1.0)\n\n    best = (np.inf, None, None)\n    for c in rem:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        # score each feasible facility: cost + delta*fragility(f)\n        score = costs[feas, int(c)] + delta * frag[feas]\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "max_avg_cost_customer_then_best_facility": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Hard-first: pick customer with highest mean feasible cost; assign to its cheapest feasible facility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_key = None\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        mean_cost = float(np.mean(costs[feas, c]))\n        f = int(feas[np.argmin(costs[feas, c])])\n        key = (-mean_cost, float(costs[f, c]))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "thresholded_options_count_priority": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Count 'good' feasible options below a cost threshold; serve customers with fewest good options first.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    # Threshold = 30th percentile over all currently feasible pairs (fallback to global percentile)\n    feas_vals = []\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size:\n            feas_vals.extend(C[feas, c].tolist())\n    if len(feas_vals) == 0:\n        return None, None\n    thr = float(np.quantile(np.asarray(feas_vals, dtype=float), 0.30))\n\n    best_key = None\n    best_c = None\n    best_f = None\n\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        good = int(np.sum(C[feas, c] <= thr))\n        f = int(feas[np.argmin(C[feas, c])])\n        key = (good, float(C[f, c]))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "minimize_variance_of_remaining_capacities": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Choose pair that minimizes variance of remaining capacities after assignment; tie-break by cost.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (var_after, cost, c, f)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            var_after = float(np.var(caps))\n            cost = float(C[int(f), int(c)])\n            key = (var_after, cost)\n            if key < best[:2]:\n                best = (var_after, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "gini_balance_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef _gini(x: np.ndarray) -> float:\n    x = np.asarray(x, dtype=float)\n    x = np.clip(x, 0.0, None)\n    if x.size == 0:\n        return 0.0\n    s = float(np.sum(x))\n    if s <= 1e-12:\n        return 0.0\n    xs = np.sort(x)\n    n = xs.size\n    idx = np.arange(1, n + 1, dtype=float)\n    return float((2.0 * np.sum(idx * xs) / (n * s)) - (n + 1.0) / n)\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Cost + lambda * Gini(remaining capacities) after assignment (encourages equitable capacity distribution).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 10.0\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            score = float(C[int(f), int(c)]) + lam * _gini(caps)\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "entropy_utilization_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef _entropy(p: np.ndarray) -> float:\n    p = np.asarray(p, dtype=float)\n    p = np.clip(p, 1e-12, None)\n    p = p / float(np.sum(p))\n    return float(-np.sum(p * np.log(p)))\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Encourage spreading usage: score = cost - beta * entropy(remaining capacities after assignment).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 3.0\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            ent = _entropy(caps + 1e-9)\n            score = float(C[int(f), int(c)]) - beta * ent\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "zscore_facility_preference": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Use facility-normalized costs: pick pair with minimum z-score within facility among remaining customers.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Facility stats over remaining customers\n    mu = np.mean(C[:, rem], axis=1)\n    sd = np.std(C[:, rem], axis=1)\n    sd = np.maximum(sd, 1e-9)\n\n    best = (np.inf, None, None)\n    for c in rem:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        z = (C[feas, int(c)] - mu[feas]) / sd[feas]\n        k = int(np.argmin(z))\n        f = int(feas[k])\n        val = float(z[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "rank_sum_cost_and_slack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Multi-criteria ranking: minimize rank(cost) + rank(slack) among feasible pairs.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            slack = float(caps0[int(f)] - d)\n            pairs.append((float(C[int(f), int(c)]), slack, int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    costs = np.asarray([p[0] for p in pairs], dtype=float)\n    slacks = np.asarray([p[1] for p in pairs], dtype=float)\n\n    cost_rank = np.argsort(np.argsort(costs))\n    slack_rank = np.argsort(np.argsort(slacks))  # smaller slack => smaller rank\n\n    score = cost_rank + slack_rank\n    idx = int(np.argmin(score))\n    return pairs[idx][2], pairs[idx][3]\n",
  "pareto_front_weighted_pick": "import numpy as np\nfrom typing import List, Tuple\n\ndef _pareto_mask(vals: np.ndarray) -> np.ndarray:\n    # vals shape (n,2) where we minimize both columns\n    n = vals.shape[0]\n    mask = np.ones(n, dtype=bool)\n    for i in range(n):\n        if not mask[i]:\n            continue\n        dominated = np.all(vals <= vals[i], axis=1) & np.any(vals < vals[i], axis=1)\n        mask[dominated] = False\n    return mask\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Build feasible pairs, keep Pareto front on (cost, -slack) => (cost, slack_small). Pick min weighted sum.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    w_cost = 1.0\n    w_slack = 0.5\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    crit = []\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            cost = float(C[int(f), int(c)])\n            slack = float(caps0[int(f)] - d)\n            pairs.append((int(c), int(f), cost, slack))\n            crit.append((cost, slack))\n\n    if not pairs:\n        return None, None\n\n    crit = np.asarray(crit, dtype=float)\n    # We want low cost AND low slack (tighter fits) on Pareto front\n    mask = _pareto_mask(crit)\n    idxs = np.where(mask)[0]\n\n    best = (np.inf, None)\n    for i in idxs:\n        c, f, cost, slack = pairs[int(i)]\n        score = w_cost * cost + w_slack * slack\n        if score < best[0]:\n            best = (score, (c, f))\n\n    return best[1] if best[1] is not None else (None, None)\n",
  "log_barrier_utilization": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Barrier on exhausting capacity: score = cost - mu * log(slack+eps).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    mu = 4.0\n    eps = 1e-9\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            slack = float(caps0[int(f)] - d)\n            score = float(C[int(f), int(c)]) - mu * float(np.log(slack + eps + 1.0))\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "roulette_customer_by_demand_then_best_facility": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Sample customer proportional to demand among those with at least one feasible facility; then assign to cheapest.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    candidates = []\n    weights = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size:\n            candidates.append(int(c))\n            weights.append(float(dem[c]))\n\n    if not candidates:\n        return None, None\n\n    w = np.asarray(weights, dtype=float)\n    w = w / float(np.sum(w))\n    c = int(rng.choice(np.asarray(candidates, dtype=int), p=w))\n\n    feas = np.where(caps >= dem[c])[0]\n    f = int(feas[np.argmin(C[feas, c])])\n    return c, f\n",
  "roulette_facility_by_capacity_then_best_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Sample facility proportional to remaining capacity; assign its cheapest feasible customer.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # filter facilities that can serve at least one remaining customer\n    feasible_fac = []\n    weights = []\n    for f in range(len(caps)):\n        if np.any(dem[rem] <= caps[f]):\n            feasible_fac.append(int(f))\n            weights.append(float(caps[f]))\n\n    if not feasible_fac:\n        return None, None\n\n    w = np.asarray(weights, dtype=float)\n    w = w / float(np.sum(w))\n    f = int(rng.choice(np.asarray(feasible_fac, dtype=int), p=w))\n\n    feas_customers = rem[np.where(dem[rem] <= caps[f])[0]]\n    if feas_customers.size == 0:\n        return None, None\n    c = int(feas_customers[np.argmin(C[f, feas_customers])])\n    return c, f\n",
  "top_quantile_demand_focus": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Focus on big customers: restrict to top 25% demand (if any feasible), choose globally best cost pair within.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    q = float(np.quantile(dem_all[rem], 0.75))\n    subset = rem[dem_all[rem] >= q]\n    subset = subset if subset.size else rem\n\n    best = (np.inf, None, None)\n    for c in subset:\n        feas = np.where(caps >= dem_all[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        val = float(C[f, int(c)])\n        if val < best[0]:\n            best = (val, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "bottom_quantile_demand_pack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pack small customers: restrict to bottom 25% demand (if any feasible), then pick cheapest feasible pair.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    q = float(np.quantile(dem_all[rem], 0.25))\n    subset = rem[dem_all[rem] <= q]\n    subset = subset if subset.size else rem\n\n    best = (np.inf, None, None)\n    for c in subset:\n        feas = np.where(caps >= dem_all[int(c)])[0]\n        for f in feas:\n            val = float(C[int(f), int(c)])\n            if val < best[0]:\n                best = (val, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "mini_batch_top_demand_best_pair": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Consider only top-M demand customers each step, then pick globally cheapest feasible pair among them.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    M = 8\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    order = rem[np.argsort(-dem[rem])]\n    batch = order[: min(M, order.size)]\n\n    best = (np.inf, None, None)\n    for c in batch:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            val = float(C[int(f), int(c)])\n            if val < best[0]:\n                best = (val, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "maximize_future_feasibility_count": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Choose pair that maximizes total number of feasible facility options remaining after assignment; tie-break by cost.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = list(remaining_customers)\n\n    best = (-np.inf, np.inf, None, None)  # (feas_count_after, cost, c, f)\n\n    for c in rem:\n        d = float(dem_all[c])\n        feas_fs = np.where(caps0 >= d)[0]\n        for f in feas_fs:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            # count feasible options for remaining customers (excluding c)\n            cnt = 0\n            for c2 in rem:\n                if c2 == c:\n                    continue\n                cnt += int(np.sum(caps >= dem_all[int(c2)]))\n            cost = float(C[int(f), int(c)])\n            if (cnt > best[0]) or (cnt == best[0] and cost < best[1]):\n                best = (float(cnt), cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "minimize_feasibility_loss": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Minimize the number of (customer,facility) feasibility edges removed by consuming capacity; tie-break by cost.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = list(remaining_customers)\n\n    # baseline feasible edges count\n    base_edges = 0\n    for c in rem:\n        base_edges += int(np.sum(caps0 >= dem_all[int(c)]))\n\n    best = (np.inf, np.inf, None, None)  # (loss, cost, c, f)\n\n    for c in rem:\n        d = float(dem_all[int(c)])\n        feas_fs = np.where(caps0 >= d)[0]\n        for f in feas_fs:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            edges = 0\n            for c2 in rem:\n                if c2 == c:\n                    continue\n                edges += int(np.sum(caps >= dem_all[int(c2)]))\n            loss = float(base_edges - edges)\n            cost = float(C[int(f), int(c)])\n            key = (loss, cost)\n            if key < best[:2]:\n                best = (loss, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "facility_opportunity_cost_customer_choice": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"For each facility, find its best and second-best feasible customer costs; act where opportunity cost is largest.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    best_gap = -np.inf\n    best_pair = (None, None)\n\n    for f in range(len(caps)):\n        feas_customers = rem[np.where(dem[rem] <= caps[f])[0]]\n        if feas_customers.size == 0:\n            continue\n        vals = C[int(f), feas_customers]\n        if vals.size == 1:\n            gap = 1e12\n            c = int(feas_customers[0])\n        else:\n            order = np.argsort(vals)\n            gap = float(vals[order[1]] - vals[order[0]])\n            c = int(feas_customers[order[0]])\n        if gap > best_gap:\n            best_gap = gap\n            best_pair = (c, int(f))\n\n    return best_pair if best_pair[0] is not None else (None, None)\n",
  "shadow_price_capacity_scarcity": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Approximate shadow price for capacity: score = cost + pi_f * demand, where pi_f increases as capacity shrinks.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Shadow price: inverse of remaining capacity (scarcer => higher)\n    pi = 1.0 / (caps + 1.0)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        score = C[feas, int(c)] + pi[feas] * d\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "cost_minus_capacity_bonus": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Prefer roomy facilities: score = cost - kappa * remaining_capacity_after (small bonus for more slack).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    kappa = 0.2\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            rem_after = float(caps0[int(f)] - d)\n            score = float(C[int(f), int(c)]) - kappa * rem_after\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "balanced_used_capacity_increment": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Cost + penalty for increasing max utilization across facilities (minimize peak load growth).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 8.0\n    caps_rem = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    used = np.zeros_like(caps_rem)\n    for f, custs in enumerate(assignments):\n        used[f] = sum(float(dem[int(c)]) for c in custs)\n    total = np.maximum(used + caps_rem, 1e-9)\n    util0 = used / total\n    peak0 = float(np.max(util0)) if util0.size else 0.0\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps_rem >= d)[0]\n        for f in feas:\n            used2 = used.copy()\n            used2[int(f)] += d\n            util2 = used2 / total\n            peak2 = float(np.max(util2))\n            score = float(C[int(f), int(c)]) + lam * (peak2 - peak0)\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_cheapest_customer_with_best_fit": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"For each facility, find its cheapest feasible customer; among those pairs, pick the one with tightest fit then cost.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    best = (np.inf, np.inf, None, None)  # (slack, cost, c, f)\n\n    for f in range(len(caps)):\n        feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n        if feas_c.size == 0:\n            continue\n        c = int(feas_c[np.argmin(C[int(f), feas_c])])\n        slack = float(caps[int(f)] - dem[int(c)])\n        cost = float(C[int(f), int(c)])\n        key = (slack, cost, int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "customer_cheapest_facility_with_best_fit": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"For each customer, take its cheapest feasible facility; pick customer whose chosen facility yields tightest fit then cost.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (slack, cost, c, f)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        slack = float(caps[int(f)] - dem[int(c)])\n        cost = float(C[int(f), int(c)])\n        key = (slack, cost, int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "quantile_clipped_cost_selection": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Robust against outliers: clip costs at 90th percentile of feasible costs, then pick best feasible pair.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    feas_vals = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size:\n            feas_vals.extend(C[feas, int(c)].tolist())\n    if len(feas_vals) == 0:\n        return None, None\n\n    clip = float(np.quantile(np.asarray(feas_vals, dtype=float), 0.90))\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            val = float(min(C[int(f), int(c)], clip))\n            if val < best[0]:\n                best = (val, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "stochastic_ranking_cost_vs_slack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Stochastic ranking between cost and slack: with prob p compare by cost else by slack (diversifies selection).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    p = 0.7\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            pairs.append((int(c), int(f), float(C[int(f), int(c)]), float(caps[int(f)] - d)))\n\n    if not pairs:\n        return None, None\n\n    # Perform a few bubble-like passes\n    pairs = list(pairs)\n    for _ in range(8):\n        swapped = False\n        for i in range(len(pairs) - 1):\n            a = pairs[i]\n            b = pairs[i + 1]\n            if float(rng.random()) < p:\n                better = a[2] <= b[2]\n            else:\n                better = a[3] <= b[3]\n            if not better:\n                pairs[i], pairs[i + 1] = pairs[i + 1], pairs[i]\n                swapped = True\n        if not swapped:\n            break\n\n    c, f, _, _ = pairs[0]\n    return c, f\n",
  "min_cost_under_capacity_fraction_rule": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Avoid fragmenting tiny remainders: prefer assignments keeping remaining capacity above a fraction of avg demand.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    frac = 0.40\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    avg_d = float(np.mean(dem_all[rem])) if rem.size else float(np.mean(dem_all))\n    target = frac * max(1e-9, avg_d)\n\n    best = (np.inf, np.inf, None, None)  # (viol, cost, c, f)\n\n    for c in rem:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            rem_after = float(caps[int(f)] - d)\n            viol = 0.0 if rem_after >= target else (target - rem_after)\n            cost = float(C[int(f), int(c)])\n            key = (viol, cost)\n            if key < best[:2]:\n                best = (viol, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "most_dependent_on_single_facility": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick customers whose cheapest feasible facility is uniquely cheapest by a margin; serve those first.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best_margin = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        if vals.size == 1:\n            margin = 1e12\n            f = int(feas[0])\n        else:\n            order = np.argsort(vals)\n            margin = float(vals[order[1]] - vals[order[0]])\n            f = int(feas[order[0]])\n        if margin > best_margin:\n            best_margin = margin\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "favor_underutilized_facilities_cost_adjusted": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Discount costs on underutilized facilities: adjusted_cost = cost * (1 - rho*(1-util)).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rho = 0.35\n    caps_rem = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    used = np.zeros_like(caps_rem)\n    for f, custs in enumerate(assignments):\n        used[f] = sum(float(dem[int(c)]) for c in custs)\n    total = np.maximum(used + caps_rem, 1e-9)\n    util = used / total\n    discount = 1.0 - rho * (1.0 - util)\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps_rem >= d)[0]\n        if feas.size == 0:\n            continue\n        adj = C[feas, int(c)] * discount[feas]\n        k = int(np.argmin(adj))\n        f = int(feas[k])\n        val = float(adj[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "min_cost_with_facility_quota_pressure": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Introduce soft quota: encourage each facility to get a similar number of customers (count-based pressure).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 0.8\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    counts = np.asarray([len(a) for a in assignments], dtype=float)\n    target = float(np.mean(counts)) if counts.size else 0.0\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        pressure = np.abs((counts[feas] + 1.0) - target)\n        score = C[feas, int(c)] + lam * pressure\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "bottleneck_facility_capacity_protection": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Protect smallest-capacity facilities: add penalty when consuming capacity from already-small facilities.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 5.0\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Smaller capacity => larger penalty coefficient\n    cap_scale = (np.max(caps0) + 1.0) / (caps0 + 1.0)\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            penalty = lam * float(cap_scale[int(f)]) * (d / (caps0[int(f)] + 1.0))\n            score = float(C[int(f), int(c)]) + penalty\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "two_stage_customer_cluster_by_cost_profile": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Cluster-ish: pick customer with lowest std-dev of feasible costs (clear preference structure), then assign cheapest.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (std, best_cost, c, f)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        s = float(np.std(vals))\n        f = int(feas[np.argmin(vals)])\n        key = (s, float(C[int(f), int(c)]), int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "max_cost_spread_customer_priority": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Choose customer with largest feasible cost spread (max-min), assign to cheapest feasible facility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best_spread = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        spread = float(np.max(vals) - np.min(vals))\n        f = int(feas[np.argmin(vals)])\n        if spread > best_spread:\n            best_spread = spread\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "min_cost_with_demand_percentile_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Penalty based on demand percentile among remaining: score = cost + alpha * percentile(demand).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    alpha = 2.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    dvals = dem_all[rem]\n    if dvals.size == 0:\n        return None, None\n\n    # compute percentile rank per customer\n    order = np.argsort(dvals)\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.linspace(0.0, 1.0, num=order.size)\n    pct = {int(rem[i]): float(ranks[i]) for i in range(rem.size)}\n\n    best = (np.inf, None, None)\n\n    for c in rem:\n        feas = np.where(caps >= dem_all[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        score = float(C[int(f), int(c)]) + alpha * pct[int(c)]\n        if score < best[0]:\n            best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "adaptive_topk_by_remaining_density": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Adaptive candidate set: choose among top-K cheapest feasible pairs, where K grows when many remain.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    n_rem = len(remaining_customers)\n    K = int(np.clip(np.ceil(0.15 * n_rem), 3, 25))\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            pairs.append((float(C[int(f), int(c)]), int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    top = pairs[: min(K, len(pairs))]\n\n    # Pick the median-cost option in top-K to avoid always extreme greediness\n    idx = int(len(top) // 2)\n    _, c, f = top[idx]\n    # small chance to randomize within top\n    if float(rng.random()) < 0.10:\n        _, c, f = top[int(rng.integers(0, len(top)))]\n\n    return c, f\n",
  "min_cost_with_customer_degrees_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Penalize assigning customers that still have many options (save them): score = cost + beta*deg(customer).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.6\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    deg = {}\n    for c in remaining_customers:\n        deg[int(c)] = int(np.sum(caps >= dem_all[int(c)]))\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem_all[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        score = float(C[int(f), int(c)]) + beta * float(deg[int(c)])\n        if score < best[0]:\n            best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "min_cost_with_facility_degree_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Penalize using facilities that can serve many customers (save versatile facilities): cost + beta*deg(facility).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.4\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    deg_f = np.zeros(len(caps), dtype=float)\n    for f in range(len(caps)):\n        deg_f[f] = float(np.sum(dem_all[rem] <= caps[f]))\n\n    best = (np.inf, None, None)\n\n    for c in rem:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        score = C[feas, int(c)] + beta * deg_f[feas]\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "max_demand_to_cost_ratio": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Efficiency: maximize demand served per unit cost using best feasible facility (demand / cost).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-9\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (-np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        cost = float(C[int(f), int(c)])\n        ratio = d / (cost + eps)\n        if ratio > best[0]:\n            best = (ratio, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "minimax_customer_best_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick the hardest customer: highest (best feasible cost), assign to its best facility\n    if not remaining_customers:\n        return None, None\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best_c = None\n    best_f = None\n    worst_best = -np.inf\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        j = int(feas[np.argmin(vals)])\n        bb = float(C[j, int(c)])\n        if bb > worst_best:\n            worst_best = bb\n            best_c, best_f = int(c), int(j)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "minimax_pair_cost_then_slack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Choose pair minimizing max(cost, normalized_slack_penalty); tie-break by cost\n    if not remaining_customers:\n        return None, None\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    cmax = float(np.max(C)) if C.size else 1.0\n    cmax = max(cmax, 1e-9)\n\n    best = (np.inf, np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            slack = float(caps[int(f)] - d)\n            cost = float(C[int(f), int(c)])\n            crit = max(cost / cmax, 1.0 / (slack + 1.0))\n            key = (crit, cost)\n            if key < best[:2]:\n                best = (crit, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "annealed_softmax_pairs": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Softmax sampling over feasible pairs with temperature decreasing as progress increases\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    n_assigned = sum(len(a) for a in assignments)\n    n_rem = len(remaining_customers)\n    progress = n_assigned / max(1, n_assigned + n_rem)\n    tau = 40.0 * (1.0 - progress) + 2.0\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    cs, fs, vals = [], [], []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            cs.append(int(c))\n            fs.append(int(f))\n            vals.append(float(C[int(f), int(c)]))\n\n    if not vals:\n        return None, None\n\n    x = np.asarray(vals, float)\n    m = float(np.min(x))\n    w = np.exp(-(x - m) / max(1e-9, tau))\n    w = w / float(np.sum(w))\n\n    idx = int(rng.choice(len(w), p=w))\n    return cs[idx], fs[idx]\n",
  "grasp_rcl_pairs": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # GRASP-style: build restricted candidate list (RCL) and pick randomly from it\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    alpha = 0.20  # top 20% cheapest feasible pairs\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            pairs.append((float(C[int(f), int(c)]), int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    k = max(1, int(np.ceil(alpha * len(pairs))))\n    rcl = pairs[:k]\n    _, c, f = rcl[int(rng.integers(0, len(rcl)))]\n    return c, f\n",
  "demand_bin_round_robin": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Round-robin across demand bins (high/medium/low) based on step count\n    if not remaining_customers:\n        return None, None\n\n    step = sum(len(a) for a in assignments)\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    rem = np.asarray(remaining_customers, int)\n    dvals = dem[rem]\n    if dvals.size == 0:\n        return None, None\n\n    q1 = float(np.quantile(dvals, 0.33))\n    q2 = float(np.quantile(dvals, 0.66))\n\n    mode = step % 3\n    if mode == 0:\n        subset = rem[dvals >= q2]\n    elif mode == 1:\n        subset = rem[(dvals >= q1) & (dvals < q2)]\n    else:\n        subset = rem[dvals < q1]\n    if subset.size == 0:\n        subset = rem\n\n    best = (np.inf, None, None)\n    for c in subset:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        val = float(C[int(f), int(c)])\n        if val < best[0]:\n            best = (val, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_median_capacity_then_best_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick facility with median remaining capacity; assign its cheapest feasible customer\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    order = np.argsort(caps)\n    f = int(order[len(order) // 2]) if order.size else None\n    if f is None:\n        return None, None\n\n    feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n    if feas_c.size == 0:\n        # fallback: choose any facility that can serve someone\n        for ff in order:\n            feas_c = rem[np.where(dem[rem] <= caps[int(ff)])[0]]\n            if feas_c.size:\n                f = int(ff)\n                break\n        if feas_c.size == 0:\n            return None, None\n\n    c = int(feas_c[np.argmin(C[f, feas_c])])\n    return c, int(f)\n",
  "cost_with_utilization_cap_threshold": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Prefer assignments that keep utilization <= u_max when possible; otherwise fallback to cheapest feasible\n    if not remaining_customers:\n        return None, None\n\n    u_max = 0.85\n    caps_rem = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    used = np.zeros_like(caps_rem)\n    for f, custs in enumerate(assignments):\n        used[f] = sum(float(dem[int(c)]) for c in custs)\n    total = np.maximum(used + caps_rem, 1e-9)\n\n    best_good = (np.inf, None, None)\n    best_any = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps_rem >= d)[0]\n        if feas.size == 0:\n            continue\n        for f in feas:\n            util_after = float((used[int(f)] + d) / total[int(f)])\n            val = float(C[int(f), int(c)])\n            if val < best_any[0]:\n                best_any = (val, int(c), int(f))\n            if util_after <= u_max and val < best_good[0]:\n                best_good = (val, int(c), int(f))\n\n    if best_good[1] is not None:\n        return best_good[1], best_good[2]\n    return (best_any[1], best_any[2]) if best_any[1] is not None else (None, None)\n",
  "harmonic_cost_slack_score": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Score = cost * (1 + w/(slack+1)) (harmonic-style penalty for tight slack)\n    if not remaining_customers:\n        return None, None\n\n    w = 3.5\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            slack = float(caps[int(f)] - d)\n            score = float(C[int(f), int(c)]) * (1.0 + w / (slack + 1.0))\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "customer_high_cv_cost_priority": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick customer with highest coefficient of variation of feasible costs; assign cheapest feasible facility\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best_cv = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        mu = float(np.mean(vals))\n        sd = float(np.std(vals))\n        cv = sd / max(1e-9, mu)\n        f = int(feas[np.argmin(vals)])\n        if cv > best_cv:\n            best_cv, best_c, best_f = cv, int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "facility_low_cost_variance_prefer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Prefer facilities with low variance of costs over remaining customers, then assign its cheapest feasible customer\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    var_f = np.var(C[:, rem], axis=1) if rem.size else np.var(C, axis=1)\n    order = np.argsort(var_f)\n\n    for f in order:\n        feas_c = rem[np.where(dem[rem] <= caps[int(f)])[0]]\n        if feas_c.size == 0:\n            continue\n        c = int(feas_c[np.argmin(C[int(f), feas_c])])\n        return c, int(f)\n\n    return None, None\n",
  "top_regret_pool_then_best_fit": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Take top-P customers by regret, then choose pair with tightest fit among them (tie by cost)\n    if not remaining_customers:\n        return None, None\n\n    P = 7\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    reg = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = np.sort(C[feas, int(c)])\n        r = float(vals[1] - vals[0]) if vals.size >= 2 else 1e12\n        reg.append((r, int(c)))\n\n    if not reg:\n        return None, None\n\n    reg.sort(key=lambda x: -x[0])\n    pool = [c for _, c in reg[: min(P, len(reg))]]\n\n    best = (np.inf, np.inf, None, None)  # (slack, cost, c, f)\n    for c in pool:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slacks = caps[feas] - d\n        k = int(np.argmin(slacks))\n        f_tight = int(feas[k])\n        # among tightest slack facilities, pick cheapest\n        min_slack = float(slacks[k])\n        cand = feas[np.where(slacks == min_slack)[0]]\n        f = int(cand[np.argmin(C[cand, int(c)])])\n        key = (min_slack, float(C[int(f), int(c)]), int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "boost_new_facilities_first": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Encourage using facilities with zero assignments: score = cost - bonus_if_unused\n    if not remaining_customers:\n        return None, None\n\n    bonus = 5.0\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    used_flag = np.asarray([1.0 if len(a) > 0 else 0.0 for a in assignments], float)\n    adj_bonus = (1.0 - used_flag) * bonus\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            score = float(C[int(f), int(c)]) - float(adj_bonus[int(f)])\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "penalize_overused_facilities": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Penalize facilities with many assigned customers: score = cost + lam*count\n    if not remaining_customers:\n        return None, None\n\n    lam = 0.9\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    cnt = np.asarray([len(a) for a in assignments], float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        score = C[feas, int(c)] + lam * cnt[feas]\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "max_improvement_over_mean_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick customer with biggest improvement: mean feasible cost - best feasible cost\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best_imp = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        j = int(feas[np.argmin(vals)])\n        imp = float(np.mean(vals) - float(C[j, int(c)]))\n        if imp > best_imp:\n            best_imp, best_c, best_f = imp, int(c), int(j)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "facility_mean_normalized_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Normalize cost by facility mean over remaining customers: score = cost / (mean_f + eps)\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-9\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    mean_f = np.mean(C[:, rem], axis=1) if rem.size else np.mean(C, axis=1)\n\n    best = (np.inf, None, None)\n    for c in rem:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            score = float(C[int(f), int(c)]) / (float(mean_f[int(f)]) + eps)\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "customer_mean_normalized_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Normalize by customer mean feasible cost: score = cost / (mean_c + eps), pick best pair\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-9\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        mean_c = float(np.mean(C[feas, int(c)]))\n        for f in feas:\n            score = float(C[int(f), int(c)]) / (mean_c + eps)\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_capacity_percentile_gate": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Prefer using high-capacity facilities early: gate to top-capacity percentile when progress is low\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    n_assigned = sum(len(a) for a in assignments)\n    n_rem = len(remaining_customers)\n    progress = n_assigned / max(1, n_assigned + n_rem)\n\n    pct = 0.70 if progress < 0.5 else 0.0\n    thr = float(np.quantile(caps, pct)) if caps.size else 0.0\n\n    best_primary = (np.inf, None, None)\n    best_any = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            val = float(C[int(f), int(c)])\n            if val < best_any[0]:\n                best_any = (val, int(c), int(f))\n            if caps[int(f)] >= thr and val < best_primary[0]:\n                best_primary = (val, int(c), int(f))\n\n    if best_primary[1] is not None:\n        return best_primary[1], best_primary[2]\n    return (best_any[1], best_any[2]) if best_any[1] is not None else (None, None)\n",
  "smallest_capacity_facility_first": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick smallest remaining-capacity facility that can serve someone; assign its cheapest feasible customer\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    order = np.argsort(caps)\n    for f in order:\n        feas_c = rem[np.where(dem[rem] <= caps[int(f)])[0]]\n        if feas_c.size == 0:\n            continue\n        c = int(feas_c[np.argmin(C[int(f), feas_c])])\n        return c, int(f)\n\n    return None, None\n",
  "remaining_capacity_to_median_target": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Choose pair whose facility remaining capacity after assignment is closest to the median remaining capacity\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    med = float(np.median(caps0)) if caps0.size else 0.0\n\n    best = (np.inf, np.inf, None, None)  # (dist_to_med, cost, c, f)\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            rem_after = float(caps0[int(f)] - d)\n            dist = abs(rem_after - med)\n            cost = float(C[int(f), int(c)])\n            key = (dist, cost)\n            if key < best[:2]:\n                best = (dist, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "lookahead_for_biggest_customer_next": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # One-step lookahead focused on the biggest remaining customer: preserve its feasibility/cost\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    rem = list(map(int, remaining_customers))\n    big = max(rem, key=lambda c: dem[c])\n\n    best = (np.inf, None, None)\n\n    for c in rem:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            base = float(C[int(f), int(c)])\n\n            # After this assignment, estimate best achievable cost for biggest customer\n            if c == big:\n                penalty = 0.0\n            else:\n                feas_big = np.where(caps >= dem[int(big)])[0]\n                if feas_big.size == 0:\n                    penalty = 1e9\n                else:\n                    penalty = float(np.min(C[feas_big, int(big)]))\n\n            score = base + 0.4 * penalty\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "maximize_demand_per_total_capacity": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Choose customer maximizing demand / (facility_total_capacity) using cheapest feasible facility\n    if not remaining_customers:\n        return None, None\n\n    caps_rem = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    used = np.zeros_like(caps_rem)\n    for f, custs in enumerate(assignments):\n        used[f] = sum(float(dem[int(c)]) for c in custs)\n    total = np.maximum(used + caps_rem, 1e-9)\n\n    best_ratio = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps_rem >= d)[0]\n        if feas.size == 0:\n            continue\n        # cheapest facility for cost, but ratio uses total capacity of that facility\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        ratio = d / float(total[int(f)])\n        if ratio > best_ratio:\n            best_ratio, best_c, best_f = ratio, int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "rank_based_sampling_pairs": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Sample feasible pair by rank: probability proportional to 1/rank(cost)\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            pairs.append((float(C[int(f), int(c)]), int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    n = len(pairs)\n    ranks = np.arange(1, n + 1, dtype=float)\n    w = 1.0 / ranks\n    w = w / float(np.sum(w))\n\n    idx = int(rng.choice(n, p=w))\n    _, c, f = pairs[idx]\n    return c, f\n",
  "facility_best_mean_cost_then_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Choose facility with lowest mean cost to remaining customers, then assign its cheapest feasible customer\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    mean_f = np.mean(C[:, rem], axis=1) if rem.size else np.mean(C, axis=1)\n    for f in np.argsort(mean_f):\n        feas_c = rem[np.where(dem[rem] <= caps[int(f)])[0]]\n        if feas_c.size == 0:\n            continue\n        c = int(feas_c[np.argmin(C[int(f), feas_c])])\n        return c, int(f)\n\n    return None, None\n",
  "risk_averse_customer_cvar": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick customer with highest CVaR (tail mean) of feasible costs; assign cheapest feasible facility\n    if not remaining_customers:\n        return None, None\n\n    alpha = 0.8  # tail starts at 80th percentile\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best_tail = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = np.sort(C[feas, int(c)].astype(float))\n        k = int(np.ceil(alpha * vals.size))\n        k = min(max(k, 0), vals.size)\n        tail = vals[k:] if k < vals.size else vals[-1:]\n        cvar = float(np.mean(tail))\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        if cvar > best_tail:\n            best_tail, best_c, best_f = cvar, int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "maximize_min_slack_after_pair": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Choose pair maximizing the minimum remaining capacity across facilities after assignment; tie-break by cost\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best = (-np.inf, np.inf, None, None)  # (min_cap_after, cost, c, f)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            min_after = float(np.min(caps)) if caps.size else 0.0\n            cost = float(C[int(f), int(c)])\n            if (min_after > best[0]) or (min_after == best[0] and cost < best[1]):\n                best = (min_after, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "probabilistic_customer_then_pair_bestofm": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Sample M customers uniformly (with replacement), pick best feasible assignment among them\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    M = 6\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    rem = np.asarray(remaining_customers, int)\n    if rem.size == 0:\n        return None, None\n\n    sample = rem[int(rng.integers(0, rem.size, size=M))]\n\n    best = (np.inf, None, None)\n    for c in sample:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        val = float(C[int(f), int(c)])\n        if val < best[0]:\n            best = (val, int(c), int(f))\n\n    if best[1] is not None:\n        return best[1], best[2]\n\n    # fallback: deterministic cheapest feasible pair\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size:\n            f = int(feas[np.argmin(C[feas, int(c)])])\n            return int(c), int(f)\n\n    return None, None\n",
  "capacity_fragmentation_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Penalize leaving small unusable fragments: score = cost + lam * exp(-rem_after/scale)\n    if not remaining_customers:\n        return None, None\n\n    lam = 3.0\n    caps = np.asarray(remaining_capacities, float)\n    dem_all = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    rem = np.asarray(remaining_customers, int)\n    scale = float(np.median(dem_all[rem])) if rem.size else 1.0\n    scale = max(scale, 1e-9)\n\n    best = (np.inf, None, None)\n    for c in rem:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            rem_after = float(caps[int(f)] - d)\n            frag = float(np.exp(-rem_after / scale))\n            score = float(C[int(f), int(c)]) + lam * frag\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "customer_near_capacity_90pct_risk": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Prioritize customers whose demand is near the 90th percentile of remaining capacities (risk of becoming infeasible)\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    cap90 = float(np.quantile(caps, 0.90)) if caps.size else 0.0\n\n    best = (np.inf, np.inf, None, None)  # (distance_to_cap90, cost, c, f)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        dist = abs(float(dem[int(c)]) - cap90)\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        cost = float(C[int(f), int(c)])\n        key = (dist, cost, int(c), int(f))\n        if key[:2] < best[:2]:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "greedy_lowest_cost_first_customer_aug_0": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    for cust in remaining_customers:\n        feas_idx = np.where(caps_arr >= dem_arr[cust])[0]\n        if feas_idx.size == 0:\n            continue\n        # clip costs to avoid extreme values and keep them bounded\n        clipped_costs = np.clip(cost_arr[feas_idx, cust], 0, np.max(cost_arr) + 1e-12)\n        chosen_fac = feas_idx[np.argmin(clipped_costs)]\n        return int(cust), int(chosen_fac)\n\n    return None, None\n\n",
  "greedy_lowest_cost_first_customer_aug_1": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    rng = np.random.default_rng()\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    top_k = 5\n    for cust in remaining_customers:\n        feas_idx = np.where(caps >= dem[cust])[0]\n        if feas_idx.size == 0:\n            continue\n\n        cust_costs = costs[feas_idx, cust]\n        if feas_idx.size <= top_k:\n            chosen_fac = feas_idx[np.argmin(cust_costs)]\n        else:\n            top_idx = np.argpartition(cust_costs, top_k)[:top_k]\n            chosen_fac = feas_idx[top_idx[rng.integers(0, top_k)]]\n\n        return int(cust), int(chosen_fac)\n\n    return None, None\n\n",
  "greedy_lowest_cost_first_customer_aug_2": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    beta = 5.0\n    for cust in remaining_customers:\n        feas_idx = np.where(caps >= dem[cust])[0]\n        if feas_idx.size == 0:\n            continue\n\n        cust_costs = costs[feas_idx, cust]\n        exp_vals = np.exp(-beta * cust_costs)\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)  # epsilon to avoid div\u2011by\u2011zero\n        chosen_fac = feas_idx[np.argmax(probs)]\n        return int(cust), int(chosen_fac)\n\n    return None, None\n\n",
  "greedy_lowest_cost_first_customer_aug_3": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    alpha = 0.7\n    for cust in remaining_customers:\n        feas_idx = np.where(caps >= dem[cust])[0]\n        if feas_idx.size == 0:\n            continue\n\n        cust_costs = costs[feas_idx, cust]\n        slack = caps[feas_idx] - dem[cust]\n        slack_ratio = slack / (caps[feas_idx] + 1e-12)   # epsilon added\n        slack_ratio = np.clip(slack_ratio, 0, 1)         # bounding\n        score = alpha * cust_costs + (1 - alpha) * (1 - slack_ratio)\n        chosen_fac = feas_idx[np.argmin(score)]\n        return int(cust), int(chosen_fac)\n\n    return None, None\n\n",
  "greedy_lowest_cost_first_customer_aug_4": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    for cust in remaining_customers:\n        feas_idx = np.where(caps >= dem[cust])[0]\n        if feas_idx.size == 0:\n            continue\n\n        cust_costs = costs[feas_idx, cust]\n        # deterministic noise for tie\u2011breaking\n        noise = 1e-6 * np.arange(feas_idx.size)\n        noisy_costs = cust_costs + noise\n        median_val = np.median(noisy_costs)\n        candidates = feas_idx[noisy_costs <= median_val + 1e-12]  # epsilon added\n        if candidates.size == 0:\n            chosen_fac = feas_idx[np.argmin(noisy_costs)]\n        else:\n            chosen_fac = candidates[0]  # first candidate after median filter\n        return int(cust), int(chosen_fac)\n\n    return None, None\n\n",
  "global_best_pair_min_cost_aug_5": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick the globally cheapest feasible (customer, facility) pair,\n    with deterministic noise added to break ties.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_cost = np.inf\n    best_cust = None\n    best_fac = None\n\n    # small deterministic noise for tie\u2011breaking\n    noise = np.random.uniform(0, 1e-6, size=costs.shape)\n\n    for cust in remaining_customers:\n        feas_mask = caps >= dem[cust]\n        if not np.any(feas_mask):\n            continue\n        feas_idx = np.where(feas_mask)[0]\n        # add noise to break ties deterministically\n        candidate_costs = costs[feas_idx, cust] + noise[feas_idx, cust]\n        min_idx = feas_idx[np.argmin(candidate_costs)]\n        val = costs[min_idx, cust]\n        if val < best_cost:\n            best_cost = val\n            best_cust = cust\n            best_fac = min_idx\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "global_best_pair_min_cost_aug_6": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Use a while\u2011loop and softmin probabilities to choose the next assignment.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_val = np.inf\n    best_cust = None\n    best_fac = None\n\n    idx = 0\n    while idx < len(remaining_customers):\n        cust = remaining_customers[idx]\n        feas_mask = caps >= dem[cust]\n        if np.any(feas_mask):\n            feas_idx = np.where(feas_mask)[0]\n            temp = 1.0\n            # softmin probabilities\n            exp_vals = np.exp(-(costs[feas_idx, cust] + 1e-12) / temp)\n            probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n            chosen = feas_idx[np.argmax(probs)]\n            val = costs[chosen, cust]\n            if val < best_val:\n                best_val = val\n                best_cust = cust\n                best_fac = chosen\n        idx += 1\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "global_best_pair_min_cost_aug_7": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Use median\u2011based scoring and clipped demand/capacity ratios.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_cost = np.inf\n    best_cust = None\n    best_fac = None\n\n    for cust in remaining_customers:\n        feas_mask = caps >= dem[cust]\n        if not np.any(feas_mask):\n            continue\n        feas_idx = np.where(feas_mask)[0]\n        # ratio of demand to capacity, clipped to [0,1]\n        ratios = dem[cust] / (caps[feas_idx] + 1e-12)\n        ratios = np.clip(ratios, 0, 1)\n        # weighted score: cost + alpha * ratio\n        scores = costs[feas_idx, cust] + 0.5 * ratios\n        min_idx = feas_idx[np.argmin(scores)]\n        val = costs[min_idx, cust]\n        if val < best_cost:\n            best_cost = val\n            best_cust = cust\n            best_fac = min_idx\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "global_best_pair_min_cost_aug_8": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Randomly choose among the top\u2011k cheapest facilities using softmax weights.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_val = np.inf\n    best_cust = None\n    best_fac = None\n\n    temp = 1.0\n    for cust in remaining_customers:\n        feas_mask = caps >= dem[cust]\n        if not np.any(feas_mask):\n            continue\n        feas_idx = np.where(feas_mask)[0]\n        cost_slice = costs[feas_idx, cust]\n        exp_vals = np.exp(-(cost_slice + 1e-12) / temp)\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n        # top\u2011k facilities\n        if feas_idx.size <= 3:\n            top_idx = feas_idx\n        else:\n            top_k = np.argpartition(cost_slice, 3)[:3]\n            top_idx = feas_idx[top_k]\n\n        # probabilities for the top\u2011k\n        mask = np.isin(feas_idx, top_idx)\n        top_probs = probs[mask]\n        top_probs = top_probs / (np.sum(top_probs) + 1e-12)\n\n        chosen = np.random.choice(top_idx, p=top_probs)\n        val = costs[chosen, cust]\n        if val < best_val:\n            best_val = val\n            best_cust = cust\n            best_fac = chosen\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "min_regret_2_customer_aug_9": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection with deterministic noise for tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_c = None\n    best_f = None\n    best_regret = -np.inf\n\n    customers = remaining_customers[:]  # copy to modify\n    while customers:\n        c = customers.pop()\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            regret = 1e12\n            f = int(feas[0])\n        else:\n            order = np.argsort(c_costs)\n            # deterministic noise proportional to customer id\n            noise = (c % 1000) * 1e-6\n            regret = float(c_costs[order[1]] - c_costs[order[0]]) + noise\n            f = int(feas[order[0]])\n\n        regret = np.clip(regret, 0, 1e12)\n        if regret > best_regret:\n            best_regret = regret\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "min_regret_2_customer_aug_10": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min based facility choice among top\u2011k cheapest options.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_c = None\n    best_f = None\n    best_regret = -np.inf\n    top_k = 5\n    temp = 10.0\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            f = int(feas[0])\n            regret = 1e12\n        else:\n            # rank facilities by cost\n            sorted_idx = np.argsort(c_costs)\n            top_idx = feas[sorted_idx[:top_k]]\n            top_costs = costs[top_idx, c]\n            # softmin probability\n            probs = np.exp(-top_costs / temp)\n            probs /= np.sum(probs) + 1e-12  # epsilon\n            chosen = np.random.choice(top_idx, p=probs)\n            f = int(chosen)\n            # regret as difference between best and second best\n            best_cost = top_costs[np.argmin(probs)]\n            second_cost = top_costs[np.argsort(probs)[1]]\n            regret = float(second_cost - best_cost)\n\n        # deterministic tie\u2011breaking\n        regret += (c % 1000) * 1e-6\n        regret = np.clip(regret, 0, 1e12)\n        if regret > best_regret:\n            best_regret = regret\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "min_regret_2_customer_aug_11": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Regret weighted by demand/capacity ratio and soft\u2011min facility choice.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_c = None\n    best_f = None\n    best_score = -np.inf\n    temp = 5.0\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            f = int(feas[0])\n            score = 1e12\n        else:\n            # compute weighted regret\n            ratio = (dem[c] + 1e-12) / (caps[feas] + 1e-12)\n            order = np.argsort(c_costs)\n            diff = c_costs[order[1]] - c_costs[order[0]]\n            score = float(diff) * np.mean(ratio[order[:2]])\n            # soft\u2011min facility selection\n            probs = np.exp(-c_costs / temp)\n            probs /= np.sum(probs) + 1e-12\n            f = int(np.random.choice(feas, p=probs))\n\n        score += (c % 1000) * 1e-6\n        score = np.clip(score, 0, 1e12)\n        if score > best_score:\n            best_score = score\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "min_regret_2_customer_aug_12": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised regret computation with deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # build feasibility mask\n    feas_mask = caps[:, None] >= dem[None, :]\n    feas_costs = np.where(feas_mask, costs, np.inf)\n\n    # compute best and second best costs per customer\n    best_costs = np.min(feas_costs, axis=0)\n    mask_best = feas_costs == best_costs\n    second_mask = (feas_costs != np.inf) & (~mask_best)\n    second_costs = np.where(second_mask, feas_costs, np.inf)\n    second_best = np.min(second_costs, axis=0)\n\n    regret = np.where(np.isfinite(best_costs) & np.isfinite(second_best),\n                      second_best - best_costs, 0.0)\n    # deterministic noise\n    regret += np.arange(len(remaining_customers)) * 1e-6\n    regret = np.clip(regret, 0, 1e12)\n\n    # choose customer with maximum regret\n    idx = np.argmax(regret)\n    if regret[idx] == 0.0:\n        return None, None\n\n    c = remaining_customers[idx]\n    # facility with minimal cost for chosen customer\n    f = int(np.argmin(feas_costs[:, c]))\n    return (c, f)\n\n",
  "min_regret_2_customer_aug_13": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Deterministic random choice among top\u20113 cheapest facilities.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_c = None\n    best_f = None\n    best_regret = -np.inf\n    top_k = 3\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            f = int(feas[0])\n            regret = 1e12\n        else:\n            # deterministic RNG seeded by customer id\n            rng = np.random.default_rng(seed=c)\n            sorted_idx = np.argsort(c_costs)\n            top_idx = feas[sorted_idx[:top_k]]\n            f = int(rng.choice(top_idx))\n            regret = float(c_costs[sorted_idx[1]] - c_costs[sorted_idx[0]])\n\n        regret += (c % 1000) * 1e-6\n        regret = np.clip(regret, 0, 1e12)\n        if regret > best_regret:\n            best_regret = regret\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "max_savings_vs_second_best_aug_14": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that evaluates all customers at once.\n    Uses a deterministic noise term to break ties.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Ensure arrays are float for numerical stability\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Clip capacities to avoid negative values\n    caps = np.clip(caps, a_min=0.0, a_max=None)\n\n    # Feasibility mask: shape (n_facilities, n_customers)\n    feas_mask = caps[:, None] >= dem[None, :]\n    # If a customer has no feasible facility, set its mask to False for all facilities\n    feas_mask[:, remaining_customers] = feas_mask[:, remaining_customers] & True\n\n    # Broadcast costs with mask: set infeasible costs to a large number\n    INF = 1e12\n    masked_costs = np.where(feas_mask, costs, INF)\n\n    # Get two smallest costs per customer using np.partition\n    first_min = np.partition(masked_costs, 1, axis=0)[0, remaining_customers]\n    second_min = np.partition(masked_costs, 1, axis=0)[1, remaining_customers]\n\n    # Compute savings; if only one feasible, treat savings as large\n    savings = np.where(second_min < INF,\n                       second_min - first_min,\n                       INF)\n\n    # Add deterministic noise to break ties\n    noise = 1e-9 * np.array(remaining_customers, dtype=float)\n    savings += noise\n\n    # Identify customer with maximum savings\n    best_idx = np.argmax(savings)\n    best_c = remaining_customers[best_idx]\n\n    # Recompute feasible facilities for the chosen customer\n    feas = np.where(caps >= dem[best_c])[0]\n    if feas.size == 0:\n        return None, None\n\n    # Facility with minimal cost\n    f_costs = costs[feas, best_c]\n    best_f = int(feas[np.argmin(f_costs)])\n    return best_c, best_f\n\n",
  "max_savings_vs_second_best_aug_15": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a while-loop and soft\u2011min selection with deterministic tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng(seed=42)\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    pick_c = None\n    pick_f = None\n\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size > 0:\n            c_costs = costs[feas, c]\n            # Soft\u2011min with temperature tau\n            tau = 0.5\n            exp_vals = np.exp(-tau * c_costs)\n            denom = exp_vals.sum() + 1e-12  # epsilon to avoid div\u2011by\u2011zero\n            probs = exp_vals / denom\n            probs = np.clip(probs, 0.0, 1.0)\n            # Sample facility according to probabilities\n            f = int(rng.choice(feas, p=probs))\n            # Compute savings as difference to next best\n            sorted_costs = np.sort(c_costs)\n            if sorted_costs.size == 1:\n                savings = 1e12\n            else:\n                savings = float(sorted_costs[1] - sorted_costs[0])\n            # Deterministic noise for tie\u2011breaking\n            savings += 1e-6 * c\n            if savings > best_score:\n                best_score = savings\n                pick_c = int(c)\n                pick_f = int(f)\n        idx += 1\n\n    return (pick_c, pick_f) if pick_c is not None else (None, None)\n\n",
  "max_savings_vs_second_best_aug_16": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Aggregates costs using a weighted combination and median of top\u20113 costs.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Weight for cost component\n    weight = 0.8\n    best_score = -np.inf\n    pick_c = None\n    pick_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        # Weighted cost (here just cost itself, weight kept for future extension)\n        weighted = weight * c_costs\n        # Median of top\u20113 costs as surrogate for second best\n        top3 = np.partition(weighted, -3)[-3:]\n        median_top3 = np.median(top3)\n        min_cost = weighted.min()\n        savings = median_top3 - min_cost\n        # Clip savings to avoid negative values\n        savings = np.clip(savings, 0.0, None)\n        # Add small noise for deterministic tie\u2011breaking\n        savings += 1e-7 * c\n        if savings > best_score:\n            best_score = savings\n            pick_c = int(c)\n            pick_f = int(feas[np.argmin(weighted)])\n\n    return (pick_c, pick_f) if pick_c is not None else (None, None)\n\n",
  "max_savings_vs_second_best_aug_17": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a capacity/demand ratio threshold as a proxy for feasibility\n    and randomly selects among the top\u2011k cheapest facilities.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng(seed=99)\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    pick_c = None\n    pick_f = None\n\n    for c in remaining_customers:\n        ratio = caps / (dem[c] + 1e-12)  # epsilon to avoid div\u2011by\u2011zero\n        feas = np.where(ratio >= 0.8)[0]  # threshold proxy\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        # Randomly pick among top\u20113 cheapest facilities\n        top_k = 3\n        idxs = np.argpartition(c_costs, top_k)[:top_k]\n        chosen = int(feas[rng.choice(idxs)])\n        # Savings as difference between chosen cost and next cheapest\n        sorted_costs = np.sort(c_costs)\n        if sorted_costs.size == 1:\n            savings = 1e12\n        else:\n            savings = float(sorted_costs[1] - sorted_costs[0])\n        savings += 1e-8 * c  # deterministic noise\n        if savings > best_score:\n            best_score = savings\n            pick_c = int(c)\n            pick_f = int(chosen)\n\n    return (pick_c, pick_f) if pick_c is not None else (None, None)\n\n",
  "max_savings_vs_second_best_aug_18": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Computes savings as a relative ratio, clips to a reasonable range,\n    and selects the customer with the maximum ratio.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_ratio = -np.inf\n    pick_c = None\n    pick_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        sorted_costs = np.sort(c_costs)\n        if sorted_costs.size == 1:\n            ratio = 1e12\n        else:\n            # Ratio of second best to best, plus epsilon\n            ratio = (sorted_costs[1] + 1e-12) / (sorted_costs[0] + 1e-12)\n        # Clip ratio to avoid extreme values\n        ratio = np.clip(ratio, 0.0, 10.0)\n        # Add deterministic noise\n        ratio += 1e-9 * c\n        if ratio > best_ratio:\n            best_ratio = ratio\n            pick_c = int(c)\n            pick_f = int(feas[np.argmin(c_costs)])\n\n    return (pick_c, pick_f) if pick_c is not None else (None, None)\n\n",
  "most_constrained_customer_fewest_facilities_aug_19": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Clip costs to keep them in a safe range\n    costs = np.clip(costs, 0, 1e9)\n\n    best_key = None\n    best_c = None\n    best_f = None\n\n    # Iterate over customers with a while loop\n    cust_list = list(remaining_customers)\n    while cust_list:\n        c = cust_list.pop(0)\n        feas_idx = np.where(caps >= dem[c])[0]\n        k = int(feas_idx.size)\n        if k == 0:\n            continue\n\n        # Deterministic noise for tie\u2011breaking\n        noise = np.arange(k, dtype=float) * 1e-9\n        j_idx = feas_idx[np.argmin(costs[feas_idx, c] + noise)]\n        key = (k, float(costs[j_idx, c] + 1e-12))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(j_idx)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "most_constrained_customer_fewest_facilities_aug_20": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Keep costs in a safe interval\n    costs = np.clip(costs, 0, 1e9)\n\n    # Feasibility matrix (facilities \u00d7 customers)\n    feas_mat = caps[:, None] >= dem[None, :]\n    k_arr = np.sum(feas_mat, axis=0)\n\n    # Customers with at least one feasible facility\n    valid = k_arr > 0\n    if not np.any(valid):\n        return (None, None)\n\n    # Replace infeasible costs with a large sentinel\n    large = 1e12\n    masked_costs = np.where(feas_mat, costs, large)\n\n    # Deterministic noise to break ties\n    noise = np.arange(masked_costs.shape[0])[:, None] * 1e-9\n    masked_costs += noise\n\n    # Minimum feasible cost per customer\n    min_costs = np.min(masked_costs, axis=0)\n    min_costs = np.where(valid, min_costs, large)\n\n    # Lexicographic selection: first by k, then by cost\n    valid_indices = np.where(valid)[0]\n    k_valid = k_arr[valid_indices]\n    cost_valid = min_costs[valid_indices]\n    lex_order = np.lexsort((cost_valid, k_valid))\n    best_idx = valid_indices[lex_order[0]]\n    c = int(remaining_customers[best_idx])\n\n    # Pick the cheapest facility for the chosen customer\n    feas_idx = np.where(caps >= dem[c])[0]\n    j = int(feas_idx[np.argmin(costs[feas_idx, c] + 1e-12)])\n    return (c, j)\n\n",
  "most_constrained_customer_fewest_facilities_aug_21": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Clip costs to avoid overflow in the exponential\n    costs = np.clip(costs, 0, 1e9)\n\n    best_key = None\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas_idx = np.where(caps >= dem[c])[0]\n        k = int(feas_idx.size)\n        if k == 0:\n            continue\n\n        # Soft\u2011min probabilities (beta controls greediness)\n        beta = 10.0\n        feasible_costs = costs[feas_idx, c]\n        exp_vals = np.exp(-beta * feasible_costs)\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n        # Random facility according to soft\u2011min distribution\n        j = int(np.random.choice(feas_idx, p=probs))\n\n        key = (k, float(costs[j, c] + 1e-12))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(j)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "most_constrained_customer_fewest_facilities_aug_22": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Build candidate tuples: (k, cost, customer, facility)\n    candidates = []\n    for c in remaining_customers:\n        feas_idx = np.where(caps >= dem[c])[0]\n        k = int(feas_idx.size)\n        if k == 0:\n            continue\n        j = int(feas_idx[np.argmin(costs[feas_idx, c] + 1e-12)])\n        candidates.append((k, float(costs[j, c] + 1e-12), c, j))\n\n    if not candidates:\n        return (None, None)\n\n    # Invert comparison: pick largest k (most constrained), then smallest cost\n    best = max(candidates, key=lambda x: (-x[0], x[1]))\n    return (int(best[2]), int(best[3]))\n\n",
  "largest_demand_then_cheapest_aug_23": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Greedy assignment that prefers the largest\u2011demand customer first and\n    breaks ties with a tiny deterministic noise added to the cost.\n    \"\"\"\n    # --- rename variables for clarity ------------------------------------\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    # --- order customers by decreasing demand --------------------------------\n    custs = remaining_customers\n    if not custs:\n        return None, None\n\n    order = sorted(custs, key=lambda c: (-dem_arr[c], c))\n\n    # --- iterate using a while loop ------------------------------------------\n    idx = 0\n    while idx < len(order):\n        cust = order[idx]\n        idx += 1\n\n        # feasible facilities for this customer\n        feas = np.where(cap_arr >= dem_arr[cust])[0]\n        if feas.size == 0:\n            continue\n\n        # deterministic noise for tie\u2011breaking\n        noise = 1e-6 * cust\n        # choose facility with minimal (cost + noise)\n        best_fac = feas[np.argmin(cost_arr[feas, cust] + noise)]\n        return int(cust), int(best_fac)\n\n    return None, None\n\n",
  "largest_demand_then_cheapest_aug_24": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised selection using a weighted score that mixes cost and\n    remaining capacity.  A soft\u2011min (exponential) is applied to pick\n    the facility with the lowest score while keeping numerical safety.\n    \"\"\"\n    # --- rename and cast ----------------------------------------------------\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    custs = remaining_customers\n    if not custs:\n        return None, None\n\n    # --- feasibility mask and weighted score --------------------------------\n    # Broadcast customer demands to compare with each facility\n    feas_mask = cap_arr[np.newaxis, :] >= dem_arr[custs][:, np.newaxis]\n    # Avoid division by zero with epsilon\n    cap_eps = cap_arr + 1e-12\n    # Weighted score: 0.6*cost + 0.4*(remaining-capacity)/capacity\n    score = 0.6 * cost_arr[custs][:, np.newaxis] + \\\n            0.4 * (cap_eps - dem_arr[custs][:, np.newaxis]) / cap_eps\n    # Clip to keep scores within a reasonable range\n    score = np.clip(score, 0, 1e6)\n\n    # --- soft\u2011min selection --------------------------------------------------\n    # Turn infeasible entries into large positive values\n    score = np.where(feas_mask, score, np.inf)\n\n    # For each customer, compute soft\u2011min probabilities\n    lambda_factor = 1.0\n    probs = np.exp(-lambda_factor * score)\n    probs = np.where(feas_mask, probs, 0.0)\n\n    # Normalise probabilities, add epsilon to denominator\n    probs_sum = np.sum(probs, axis=1, keepdims=True) + 1e-12\n    probs /= probs_sum\n\n    # Choose facility with highest probability for the first feasible customer\n    for idx, cust in enumerate(custs):\n        if feas_mask[idx].any():\n            best_fac = int(np.argmax(probs[idx]))\n            return int(cust), best_fac\n\n    return None, None\n\n",
  "largest_demand_then_cheapest_aug_25": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Selects the largest\u2011demand customer, finds the top\u2011k cheapest feasible\n    facilities, and then deterministically picks one using a seeded RNG.\n    \"\"\"\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    custs = remaining_customers\n    if not custs:\n        return None, None\n\n    # Sort customers by demand descending\n    order = sorted(custs, key=lambda c: (-dem_arr[c], c))\n\n    top_k = 5  # hyper\u2011parameter\n    for cust in order:\n        feas = np.where(cap_arr >= dem_arr[cust])[0]\n        if feas.size == 0:\n            continue\n        # Costs for feasible facilities\n        feas_costs = cost_arr[feas, cust]\n        # Indices of k cheapest facilities\n        k_idx = np.argsort(feas_costs)[:top_k]\n        k_facs = feas[k_idx]\n\n        # Deterministic RNG seeded by customer id\n        rng = np.random.default_rng(seed=cust)\n        chosen_fac = int(rng.choice(k_facs))\n        return int(cust), chosen_fac\n\n    return None, None\n\n",
  "largest_demand_then_cheapest_aug_26": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses the median remaining capacity of feasible facilities as a proxy\n    for suitability and applies a softmax weighting to choose a facility.\n    \"\"\"\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    custs = remaining_customers\n    if not custs:\n        return None, None\n\n    # Sort by demand (largest first)\n    order = sorted(custs, key=lambda c: (-dem_arr[c], c))\n\n    # Softmax scaling factor\n    alpha = 0.5\n\n    for cust in order:\n        feas = np.where(cap_arr >= dem_arr[cust])[0]\n        if feas.size == 0:\n            continue\n\n        # Median capacity among feasible facilities\n        med_cap = np.median(cap_arr[feas])\n        # Score: higher median capacity minus cost (higher is better)\n        scores = med_cap - cost_arr[feas, cust]\n        # Clip to avoid extreme values\n        scores = np.clip(scores, -1e6, 1e6)\n\n        # Convert to probabilities via softmax\n        exp_scores = np.exp(alpha * scores)\n        probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n\n        # Pick facility with highest probability\n        best_fac = int(feas[np.argmax(probs)])\n        return int(cust), best_fac\n\n    return None, None\n\n",
  "smallest_demand_greedy_fill_aug_27": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorized selection with deterministic noise and cost\u2011per\u2011unit demand.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Order customers by ascending demand\n    cust_order = sorted(remaining_customers, key=lambda idx: (dem[idx], idx))\n    for cust in cust_order:\n        feas = np.where(caps >= dem[cust])[0]\n        if feas.size == 0:\n            continue\n\n        # Cost per unit demand with epsilon to avoid division by zero\n        unit_cost = costs[feas, cust] / (dem[cust] + 1e-12)\n        unit_cost = np.clip(unit_cost, 0, 1e6)\n\n        # Small deterministic noise for tie\u2011breaking\n        noise = np.linspace(0, 1e-6, feas.size)\n        score = unit_cost + noise\n        chosen = feas[np.argmin(score)]\n\n        return int(cust), int(chosen)\n\n    return None, None\n\n",
  "smallest_demand_greedy_fill_aug_28": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    While\u2011loop with list comprehensions, weighted score (cost + capacity slack).\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    custs = sorted(remaining_customers, key=lambda idx: dem[idx])\n    pos = 0\n    while pos < len(custs):\n        cust = custs[pos]\n        feas = [f for f, cap in enumerate(caps) if cap >= dem[cust]]\n        if not feas:\n            pos += 1\n            continue\n\n        # Weighted score: 0.6 * cost per unit + 0.4 * (1 - capacity slack ratio)\n        cost_part = costs[feas, cust] / (dem[cust] + 1e-12)\n        slack = (caps[feas] - dem[cust]) / (caps[feas] + 1e-12)\n        slack = np.clip(slack, 0, 1)\n        score = 0.6 * cost_part + 0.4 * (1 - slack)\n\n        chosen = feas[int(np.argmin(score))]\n        return int(cust), int(chosen)\n\n        pos += 1\n\n    return None, None\n\n",
  "smallest_demand_greedy_fill_aug_29": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Soft\u2011min probabilistic assignment with random choice among all feasible facilities.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    for cust in sorted(remaining_customers, key=lambda idx: dem[idx]):\n        feas = np.where(caps >= dem[cust])[0]\n        if feas.size == 0:\n            continue\n\n        # Soft\u2011min probabilities\n        temp = 1.0\n        probs = np.exp(-costs[feas, cust] / (temp + 1e-12))\n        probs_sum = np.sum(probs) + 1e-12\n        probs /= probs_sum\n\n        chosen = np.random.choice(feas, p=probs)\n        return int(cust), int(chosen)\n\n    return None, None\n\n",
  "smallest_demand_greedy_fill_aug_30": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Median\u2011cost based selection: choose facility whose cost is closest to the median.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    for cust in sorted(remaining_customers, key=lambda idx: dem[idx]):\n        feas = np.where(caps >= dem[cust])[0]\n        if feas.size == 0:\n            continue\n\n        median_cost = np.median(costs[feas, cust])\n        diff = np.abs(costs[feas, cust] - median_cost) / (median_cost + 1e-12)\n        diff = np.clip(diff, 0, 1e6)\n\n        chosen = feas[np.argmin(diff)]\n        return int(cust), int(chosen)\n\n    return None, None\n\n",
  "min_cost_per_demand_aug_31": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection with deterministic tie\u2011breaking noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-12\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, None)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = np.inf\n    best_c, best_j = None, None\n    rng = np.random.RandomState(42)          # deterministic noise source\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        # facility with minimal cost among feasible ones\n        j = feas[np.argmin(costs[feas, c])]\n        # score = cost / demand + tiny deterministic noise\n        score = costs[j, c] / (d + eps) + 1e-9 * rng.rand()\n\n        if score < best_score:\n            best_score = score\n            best_c, best_j = c, j\n\n    return (best_c, best_j) if best_c is not None else (None, None)\n\n",
  "min_cost_per_demand_aug_32": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Random choice among the top\u2011k cheapest assignments.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-12\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, None)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = np.inf\n    best_c, best_j = None, None\n    rng = np.random.RandomState(123)\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        ratios = costs[feas, c] / (d + eps)\n        top_k = min(7, feas.size)           # hyper\u2011parameter\n        idx_top = np.argpartition(ratios, top_k - 1)[:top_k]\n        chosen = feas[idx_top]\n        j = chosen[rng.randint(0, chosen.size)]  # random pick among top\u2011k\n\n        score = np.median(ratios[idx_top])  # median aggregation\n        if score < best_score:\n            best_score = score\n            best_c, best_j = c, j\n\n    return (best_c, best_j) if best_c is not None else (None, None)\n\n",
  "min_cost_per_demand_aug_33": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Select based on inverse cost/demand ratio with squared cost penalty.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-12\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, None)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_val = -np.inf\n    best_c, best_j = None, None\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        # inverse ratio with squared cost to penalise high cost heavily\n        vals = (d + eps) / (np.square(costs[feas, c]) + eps)\n        j = feas[np.argmax(vals)]\n        val = np.max(vals)\n\n        if val > best_val:\n            best_val = val\n            best_c, best_j = c, j\n\n    return (best_c, best_j) if best_c is not None else (None, None)\n\n",
  "tightest_fit_then_min_cost_aug_34": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    demand_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    best_tuple = (np.inf, np.inf, None, None)  # (slack, cost, customer, facility)\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        d = float(demand_arr[c])\n        feas_idx = np.where(cap_arr >= d)[0]\n        if feas_idx.size:\n            slacks = np.clip(cap_arr[feas_idx] - d, 0, np.inf)\n            min_slack = float(np.min(slacks))\n            cand_fs = feas_idx[np.where(slacks == min_slack)[0]]\n\n            # deterministic noise for tie\u2011breaking\n            noise = np.random.uniform(0, 1e-9, size=cost_arr.shape[0])\n            cost_vals = cost_arr[cand_fs, c] + noise[cand_fs]\n            j = int(cand_fs[np.argmin(cost_vals)])\n\n            candidate = (min_slack, float(cost_arr[j, c]), int(c), int(j))\n            if candidate < best_tuple:\n                best_tuple = candidate\n        idx += 1\n\n    return (best_tuple[2], best_tuple[3]) if best_tuple[2] is not None else (None, None)\n\n",
  "tightest_fit_then_min_cost_aug_35": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    demand_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    best_tuple = (np.inf, np.inf, None, None)\n    w_slack, w_cost = 0.4, 0.6           # tuned weights\n    top_k = 7                            # tuned threshold\n\n    for c in remaining_customers:\n        d = float(demand_arr[c])\n        feas_idx = np.where(cap_arr >= d)[0]\n        if feas_idx.size == 0:\n            continue\n\n        slacks = np.clip(cap_arr[feas_idx] - d, 0, np.inf)\n        costs_vals = cost_arr[feas_idx, c]\n        scores = w_slack * slacks + w_cost * costs_vals\n\n        if scores.size <= top_k:\n            chosen = np.argmin(scores)\n        else:\n            top = np.argpartition(scores, top_k)[:top_k]\n            chosen = top[np.argmin(scores[top])]\n\n        min_score = float(scores[chosen])\n        ties = np.where(np.isclose(scores, min_score, atol=1e-12))[0]\n        if ties.size > 1:\n            chosen = int(np.random.choice(ties))\n\n        j = int(feas_idx[chosen])\n        candidate = (float(slacks[chosen]), float(cost_arr[j, c]), int(c), int(j))\n        if candidate < best_tuple:\n            best_tuple = candidate\n\n    return (best_tuple[2], best_tuple[3]) if best_tuple[2] is not None else (None, None)\n\n",
  "tightest_fit_then_min_cost_aug_36": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    demand_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    best_tuple = (np.inf, np.inf, None, None)\n    temp = 0.5  # temperature for softmin\n\n    for c in remaining_customers:\n        d = float(demand_arr[c])\n        feas_idx = np.where(cap_arr >= d)[0]\n        if feas_idx.size == 0:\n            continue\n\n        slacks = np.clip(cap_arr[feas_idx] - d, 0, np.inf)\n        costs_vals = cost_arr[feas_idx, c]\n        scores = slacks + costs_vals\n\n        # softmin probabilities with numerical stability\n        min_score = np.min(scores)\n        shifted = scores - min_score\n        exp_vals = np.exp(-shifted / (temp + 1e-12))\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n        j = int(np.random.choice(feas_idx, p=probs))\n        idx_in_feas = feas_idx.tolist().index(j)\n        candidate = (float(slacks[idx_in_feas]), float(cost_arr[j, c]), int(c), int(j))\n        if candidate < best_tuple:\n            best_tuple = candidate\n\n    return (best_tuple[2], best_tuple[3]) if best_tuple[2] is not None else (None, None)\n\n",
  "tightest_fit_then_min_cost_aug_37": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    demand_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    best_tuple = (np.inf, np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(demand_arr[c])\n        feas_idx = [i for i in range(cap_arr.size) if cap_arr[i] >= d]\n        if not feas_idx:\n            continue\n\n        slacks = np.clip(cap_arr[feas_idx] - d, 0, np.inf)\n        min_slack = float(np.min(slacks))\n        candidate_fs = np.array([feas_idx[i] for i, s in enumerate(slacks) if s == min_slack], dtype=int)\n\n        costs_vals = cost_arr[candidate_fs, c]\n        # deterministic noise to break ties\n        noise = np.arange(candidate_fs.size, dtype=float) * 1e-10\n        j = int(candidate_fs[np.argmin(costs_vals + noise)])\n\n        candidate = (min_slack, float(cost_arr[j, c]), int(c), int(j))\n        if candidate < best_tuple:\n            best_tuple = candidate\n\n    return (best_tuple[2], best_tuple[3]) if best_tuple[2] is not None else (None, None)\n\n",
  "slack_weighted_cost_aug_38": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that selects the cheapest feasible assignment\n    while penalising scarce capacity. Uses deterministic noise for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Convert inputs to NumPy arrays\n    caps   = np.asarray(remaining_capacities, dtype=float)\n    dem    = np.asarray(customer_demands, dtype=float)\n    costs  = np.asarray(assignment_costs, dtype=float)\n\n    # Build a feasibility mask and compute slack\n    feas_mask = caps[None, :] >= dem[:, None]          # (n_customers, n_facilities)\n    slack     = caps[None, :] - dem[:, None]           # same shape\n    slack     = np.where(feas_mask, slack, np.inf)    # inf where infeasible\n\n    # Scoring: cost + lambda/(slack+1)\n    lam       = 10.0\n    penalty   = lam / (slack + 1.0 + 1e-12)            # epsilon to avoid div0\n    score     = costs[None, :] + penalty\n\n    # Deterministic tie\u2011breaking noise\n    cust_idx  = np.arange(len(remaining_customers))\n    fac_idx   = np.arange(len(caps))\n    noise     = 1e-9 * (cust_idx[:, None] * 1e-4 + fac_idx[None, :] * 1e-5)\n    score    += noise\n\n    # If no feasible assignments exist\n    if not np.isfinite(score).any():\n        return None, None\n\n    # Find global minimum\n    flat_idx  = np.argmin(score)\n    c_pos, j_pos = np.unravel_index(flat_idx, score.shape)\n    c = remaining_customers[c_pos]\n    j = j_pos\n    return c, j\n\n",
  "slack_weighted_cost_aug_39": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Iteratively evaluates each customer, using the average slack of\n    all feasible facilities as the capacity penalty. The score is a\n    weighted combination of cost and penalty.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps   = np.asarray(remaining_capacities, dtype=float)\n    dem    = np.asarray(customer_demands, dtype=float)\n    costs  = np.asarray(assignment_costs, dtype=float)\n\n    lam       = 8.0\n    best_val  = np.inf\n    best_c    = None\n    best_j    = None\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        slack_vals = caps[feas] - d\n        avg_slack  = np.mean(slack_vals)\n        penalty    = lam / (avg_slack + 1.0 + 1e-12)\n\n        scores = 0.7 * costs[feas, c] + 0.3 * penalty\n        noise  = 1e-9 * (feas * 1e-4 + c * 1e-5)\n        scores += noise\n\n        idx = int(np.argmin(scores))\n        val = scores[idx]\n        if val < best_val:\n            best_val = val\n            best_c   = int(c)\n            best_j   = int(feas[idx])\n\n    return (best_c, best_j) if best_c is not None else (None, None)\n\n",
  "slack_weighted_cost_aug_40": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Generates a list of all feasible assignments, computes a penalty based\n    on the median slack, and selects the cheapest one with deterministic\n    tie\u2011breaking. Capacities are clipped to avoid negative values.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps   = np.clip(np.asarray(remaining_capacities, dtype=float), 0, np.inf)\n    dem    = np.asarray(customer_demands, dtype=float)\n    costs  = np.asarray(assignment_costs, dtype=float)\n\n    lam = 12.0\n    feasible = [(c, j) for c in remaining_customers\n                for j in range(len(caps)) if caps[j] >= dem[c]]\n\n    if not feasible:\n        return None, None\n\n    scores = []\n    for c, j in feasible:\n        slack = caps[j] - dem[c]\n        penalty = lam / (slack + 1.0 + 1e-12)\n        score = costs[j, c] + penalty\n        noise = 1e-9 * (j * 1e-4 + c * 1e-5)\n        scores.append(score + noise)\n\n    best_idx = int(np.argmin(scores))\n    c, j = feasible[best_idx]\n    return c, j\n\n",
  "load_balance_penalty_aug_41": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection with deterministic tie\u2011breaking and epsilon safety.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    alpha = 5.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # compute current usage per facility with a list comprehension\n    used = np.array([sum(dem[c] for c in custs) for custs in assignments], dtype=float)\n\n    # total capacity after assignment\n    total_cap = used + caps\n    total_cap = np.clip(total_cap, 1e-12, None)          # epsilon to avoid div0\n\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        # utilization after adding this customer\n        util_after = (used[feas] + d) / total_cap[feas]\n        score = costs[feas, c] + alpha * util_after\n        # deterministic tie\u2011breaking by adding a tiny noise\n        noise = np.arange(score.size) * 1e-8\n        score += noise\n        idx = int(np.argmin(score))\n        f = int(feas[idx])\n        val = float(score[idx])\n        if val < best_score:\n            best_score = val\n            best_cust = int(c)\n            best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "load_balance_penalty_aug_42": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Top\u2011k soft\u2011min selection with random tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    alpha = 5.0\n    top_k = 7\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    used = np.array([sum(dem[c] for c in custs) for custs in assignments], dtype=float)\n    total_cap = used + caps\n    total_cap = np.clip(total_cap, 1e-12, None)\n\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        util_after = (used[feas] + d) / total_cap[feas]\n        score = costs[feas, c] + alpha * util_after\n\n        # soft\u2011min via exponential weighting\n        weights = np.exp(-score)\n        weights /= weights.sum()\n        # sample from top_k facilities\n        idxs = np.argsort(score)[:top_k]\n        probs = weights[idxs]\n        probs /= probs.sum()\n        chosen = np.random.choice(idxs, p=probs)\n        f = int(feas[chosen])\n        val = float(score[chosen])\n\n        if val < best_score:\n            best_score = val\n            best_cust = int(c)\n            best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "load_balance_penalty_aug_43": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Uses maximum post\u2011assignment utilization in the score.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    alpha = 5.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    used = np.array([sum(dem[c] for c in custs) for custs in assignments], dtype=float)\n    total_cap = used + caps\n    total_cap = np.clip(total_cap, 1e-12, None)\n\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        # max utilization after adding the customer\n        util_after = (used[feas] + d) / total_cap[feas]\n        max_util = np.max(util_after)\n        score = costs[feas, c] + alpha * max_util\n\n        idx = int(np.argmin(score))\n        f = int(feas[idx])\n        val = float(score[idx])\n\n        if val < best_score:\n            best_score = val\n            best_cust = int(c)\n            best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "load_balance_penalty_aug_44": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Uses logarithmic cost proxy, clipping, and random top\u2011k selection.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    alpha = 3.0\n    top_k = 5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # log\u2011cost proxy to dampen large values\n    log_costs = np.log1p(costs)\n\n    used = np.array([sum(dem[c] for c in custs) for custs in assignments], dtype=float)\n    total_cap = used + caps\n    total_cap = np.clip(total_cap, 1e-12, None)\n\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        util_after = (used[feas] + d) / total_cap[feas]\n        score = log_costs[feas, c] + alpha * util_after\n\n        # random choice among top_k lowest scores\n        idxs = np.argpartition(score, top_k)[:top_k]\n        chosen = int(np.random.choice(idxs))\n        f = int(feas[chosen])\n        val = float(score[chosen])\n\n        if val < best_score:\n            best_score = val\n            best_cust = int(c)\n            best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "facility_fill_first_then_cost_aug_45": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    fac_caps = np.asarray(remaining_capacities, dtype=float)\n    cust_dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    # Current usage of each facility\n    used = np.zeros_like(fac_caps)\n    for f, custs in enumerate(assignments):\n        if custs:\n            used[f] = np.sum(cust_dem[custs])\n    total_cap = used + fac_caps + 1e-12                     # avoid div\u2011by\u2011zero\n    rem_frac = np.clip(fac_caps / total_cap, 0.0, 1.0)     # keep fraction in [0,1]\n\n    best_key = (np.inf, np.inf, None, None)\n    cust_arr = np.asarray(remaining_customers, dtype=int)\n\n    for f in range(len(fac_caps)):\n        feasible_cust = cust_arr[fac_caps[f] >= cust_dem[cust_arr]]\n        if feasible_cust.size == 0:\n            continue\n        d = cust_dem[feasible_cust]\n        rem_after = (fac_caps[f] - d) / (total_cap[f] + 1e-12)\n        idx = np.argmin(rem_after)\n        c = feasible_cust[idx]\n        key = (rem_after[idx], cost_mat[f, c], int(c), int(f))\n        if key < best_key:\n            best_key = key\n\n    return (best_key[2], best_key[3]) if best_key[2] is not None else (None, None)\n\n",
  "k_best_pairs_random_pick_aug_46": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised construction with random choice among the cheapest K pairs.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    top_k = 7\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Clip costs to avoid extreme values\n    costs = np.clip(costs, 0, 1e6)\n\n    # Feasible facility\u2011customer matrix\n    feasible = caps[:, None] >= dem[remaining_customers]\n    fac_idx, cust_idx = np.where(feasible)\n\n    # Corresponding costs and a tiny noise for deterministic tie\u2011breaking\n    pair_costs = costs[fac_idx, cust_idx] + rng.uniform(0, 1e-6, size=fac_idx.shape)\n\n    # Sort and pick among the top\u2011k cheapest\n    sorted_idx = np.argsort(pair_costs)\n    top_indices = sorted_idx[: min(top_k, len(sorted_idx))]\n\n    if not top_indices.size:\n        return None, None\n\n    chosen = top_indices[rng.integers(0, len(top_indices))]\n    facility = fac_idx[chosen]\n    customer = remaining_customers[cust_idx[chosen]]\n    return customer, facility\n\n",
  "k_best_pairs_random_pick_aug_47": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy construction with softmin weighting and division\u2011aware scoring.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    temperature = 5.0\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    caps = np.clip(caps, 0, 1e6)\n    costs = np.clip(costs, 0, 1e6)\n\n    pairs = []\n    cust_iter = iter(remaining_customers)\n    while True:\n        try:\n            c = next(cust_iter)\n        except StopIteration:\n            break\n        for f, cap in enumerate(caps):\n            if cap + 1e-12 >= dem[c]:\n                ratio = (cap - dem[c]) / (dem[c] + 1e-12)\n                score = costs[f, c] + 0.2 * ratio\n                pairs.append((score, c, f))\n\n    if not pairs:\n        return None, None\n\n    scores = np.array([p[0] for p in pairs]) + rng.uniform(0, 1e-6, size=len(pairs))\n    exp_vals = np.exp(-scores / (temperature + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n\n    chosen_idx = rng.choice(len(pairs), p=probs)\n    _, customer, facility = pairs[chosen_idx]\n    return customer, facility\n\n",
  "k_best_pairs_random_pick_aug_48": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"List\u2011comprehension based construction with a small top\u2011k selection.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    top_k = 5\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    caps = np.clip(caps, 0, 1e6)\n    costs = np.clip(costs, 0, 1e6)\n\n    pairs = [(costs[f, c], c, f)\n             for c in remaining_customers\n             for f in range(len(caps))\n             if caps[f] >= dem[c]]\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    top_pairs = pairs[: min(top_k, len(pairs))]\n\n    chosen = rng.choice(top_pairs)\n    customer, facility = chosen[1], chosen[2]\n    return customer, facility\n\n",
  "k_best_pairs_random_pick_aug_49": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"While\u2011loop construction using a proxy feasibility ratio and random tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    top_k = 10\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    caps = np.clip(caps, 0, 1e6)\n    costs = np.clip(costs, 0, 1e6)\n\n    pairs = []\n    cust_iter = iter(remaining_customers)\n    while True:\n        try:\n            c = next(cust_iter)\n        except StopIteration:\n            break\n        for f, cap in enumerate(caps):\n            ratio = (cap + 1e-12) / (dem[c] + 1e-12)\n            if ratio > 1.0:\n                pairs.append((costs[f, c] + rng.uniform(0, 1e-6), c, f))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    top_pairs = pairs[: min(top_k, len(pairs))]\n\n    chosen = rng.choice(top_pairs)\n    return chosen[1], chosen[2]\n\n",
  "epsilon_greedy_global_pair_aug_50": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Variation 1 \u2013 while\u2011loops, softmin, epsilon tuning, deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    eps = 0.10  # exploration probability\n\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, np.inf)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    feasible_pairs = []\n    best_val = np.inf\n    best_pair = (None, None)\n\n    # while\u2011loop over customers\n    cust_idx = 0\n    while cust_idx < len(remaining_customers):\n        c = remaining_customers[cust_idx]\n        feas = np.where(caps >= dem[c])[0]\n        f_idx = 0\n        while f_idx < len(feas):\n            f = feas[f_idx]\n            val = costs[f, c]\n            # deterministic noise to break ties\n            val_noisy = val + 1e-9 * rng.random()\n            feasible_pairs.append((c, f))\n            if val_noisy < best_val:\n                best_val = val_noisy\n                best_pair = (c, f)\n            f_idx += 1\n        cust_idx += 1\n\n    if not feasible_pairs:\n        return None, None\n\n    # Random exploration\n    if rng.random() < eps:\n        return feasible_pairs[rng.integers(len(feasible_pairs))]\n\n    # Softmin selection using exponential weights\n    costs_arr = np.array([costs[p[1], p[0]] for p in feasible_pairs], dtype=float)\n    weights = np.exp(-costs_arr / (1e-12 + 1.0))\n    weights = np.clip(weights, 0, None)\n    weights += 1e-12 * rng.random(size=weights.shape)\n    idx = np.argmax(weights)\n    return feasible_pairs[idx]\n\n",
  "epsilon_greedy_global_pair_aug_51": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Variation 2 \u2013 vectorised feasibility, top\u2011k selection, deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    eps = 0.20\n    top_k = 5\n\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, np.inf)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float), 0, np.inf)\n\n    feas_matrix = caps[:, None] >= dem[None, :]\n    feas_idx = np.argwhere(feas_matrix)\n\n    if feas_idx.size == 0:\n        return None, None\n\n    pair_costs = costs[feas_idx[:, 0], feas_idx[:, 1]]\n    pair_costs += 1e-9 * rng.random(size=pair_costs.shape)\n\n    # choose top\u2011k cheapest pairs\n    if feas_idx.shape[0] <= top_k:\n        top_idx = np.arange(feas_idx.shape[0])\n    else:\n        top_idx = np.argpartition(pair_costs, top_k)[:top_k]\n        top_idx = top_idx[np.argsort(pair_costs[top_idx])]\n\n    chosen = rng.choice(top_idx)\n    c = int(feas_idx[chosen, 1])\n    f = int(feas_idx[chosen, 0])\n    return c, f\n\n",
  "epsilon_greedy_global_pair_aug_52": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Variation 3 \u2013 log\u2011sum\u2011exp softmin, epsilon tuning, deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    eps = 0.05\n    temp = 1.0\n\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, np.inf)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    feas_matrix = caps[:, None] >= dem[None, :]\n    feas_idx = np.argwhere(feas_matrix)\n\n    if feas_idx.size == 0:\n        return None, None\n\n    pair_costs = costs[feas_idx[:, 0], feas_idx[:, 1]]\n    pair_costs += 1e-9 * rng.random(size=pair_costs.shape)\n\n    logits = -pair_costs / (temp + 1e-12)\n    max_logit = np.max(logits)\n    exp_logits = np.exp(logits - max_logit)\n    probs = exp_logits / (np.sum(exp_logits) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n\n    probs += 1e-12 * rng.random(size=probs.shape)\n    probs /= np.sum(probs) + 1e-12\n\n    chosen = rng.choice(len(probs), p=probs)\n    c = int(feas_idx[chosen, 1])\n    f = int(feas_idx[chosen, 0])\n    return c, f\n\n",
  "epsilon_greedy_global_pair_aug_53": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Variation 4 \u2013 weighted random choice on inverse costs, top\u20113, epsilon tuning.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    eps = 0.15\n    top_k = 3\n\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, np.inf)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float), 0, np.inf)\n\n    feas_matrix = caps[:, None] >= dem[None, :]\n    feas_idx = np.argwhere(feas_matrix)\n\n    if feas_idx.size == 0:\n        return None, None\n\n    pair_costs = costs[feas_idx[:, 0], feas_idx[:, 1]]\n    pair_costs += 1e-9 * rng.random(size=pair_costs.shape)\n\n    weights = 1.0 / (pair_costs + 1e-12)\n    weights = np.clip(weights, 0, None)\n\n    if feas_idx.shape[0] > top_k:\n        top_idx = np.argpartition(weights, -top_k)[-top_k:]\n        weights = weights[top_idx]\n        feas_idx = feas_idx[top_idx]\n    # else keep all pairs\n\n    probs = weights / (np.sum(weights) + 1e-12)\n    probs += 1e-12 * rng.random(size=probs.shape)\n    probs /= np.sum(probs) + 1e-12\n\n    chosen = rng.choice(len(probs), p=probs)\n    c = int(feas_idx[chosen, 1])\n    f = int(feas_idx[chosen, 0])\n    return c, f\n\n",
  "softmax_sampling_over_pairs_aug_54": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised soft\u2011max selection with temperature tuning.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    tau = 15.0  # temperature\n\n    # Convert lists to numpy arrays\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    fac_indices = np.arange(len(remaining_capacities))\n    custs = np.asarray(remaining_customers, dtype=int)\n\n    # Feasibility mask: facility capacity >= customer demand\n    feas_mask = caps[:, None] >= dem[custs]\n    if not feas_mask.any():\n        return None, None\n\n    # Gather feasible pairs\n    idxs = np.where(feas_mask)\n    pair_f = fac_indices[idxs[0]]\n    pair_c = custs[idxs[1]]\n    pair_cost = costs[idxs[0], idxs[1]]\n\n    # Soft\u2011max over negative cost\n    m = np.min(pair_cost)\n    w = np.exp(-(pair_cost - m) / (tau + 1e-12))\n    w /= np.sum(w) + 1e-12\n\n    idx = int(rng.choice(len(w), p=w))\n    return int(pair_c[idx]), int(pair_f[idx])\n\n",
  "softmax_sampling_over_pairs_aug_55": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011max with deterministic tie\u2011breaking, median baseline and top\u2011k selection.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    tau = 10.0\n    top_k = 7\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    fac_indices = np.arange(len(remaining_capacities))\n    custs = np.asarray(remaining_customers, dtype=int)\n\n    feas_mask = caps[:, None] >= dem[custs]\n    if not feas_mask.any():\n        return None, None\n\n    idxs = np.where(feas_mask)\n    pair_f = fac_indices[idxs[0]]\n    pair_c = custs[idxs[1]]\n    pair_cost = costs[idxs[0], idxs[1]]\n\n    # Deterministic noise for tie\u2011breaking\n    noise = rng.normal(scale=1e-6, size=pair_cost.shape)\n    pair_cost_noisy = pair_cost + noise\n\n    # Median baseline instead of minimum\n    m = np.median(pair_cost_noisy)\n    w = np.exp(-(pair_cost_noisy - m) / (tau + 1e-12))\n    w /= np.sum(w) + 1e-12\n\n    # Keep only the top\u2011k cheapest (largest weights)\n    top_idx = np.argsort(-w)[:top_k]\n    top_w = w[top_idx]\n    top_w /= np.sum(top_w) + 1e-12\n\n    chosen = rng.choice(len(top_w), p=top_w)\n    return int(pair_c[top_idx[chosen]]), int(pair_f[top_idx[chosen]])\n\n",
  "softmax_sampling_over_pairs_aug_56": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"While\u2011loop construction, mean baseline and deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    tau = 12.0\n\n    caps_arr = np.clip(np.asarray(remaining_capacities, dtype=float), 0, None)\n    dem_arr  = np.clip(np.asarray(customer_demands, dtype=float), 0, None)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    custs = np.asarray(remaining_customers, dtype=int)\n    pair_c, pair_f, pair_cost = [], [], []\n\n    idx = 0\n    while idx < len(custs):\n        c = custs[idx]\n        feas = np.where(caps_arr >= dem_arr[c])[0]\n        if feas.size > 0:\n            for f in feas:\n                pair_c.append(int(c))\n                pair_f.append(int(f))\n                pair_cost.append(float(cost_arr[f, c]))\n        idx += 1\n\n    if not pair_cost:\n        return None, None\n\n    # Deterministic noise for tie\u2011breaking\n    noise = rng.normal(scale=1e-7, size=len(pair_cost))\n    pair_cost = np.array(pair_cost) + noise\n\n    # Mean baseline for soft\u2011max\n    m = np.mean(pair_cost)\n    w = np.exp(-(pair_cost - m) / (tau + 1e-12))\n    w /= np.sum(w) + 1e-12\n\n    chosen = int(rng.choice(len(w), p=w))\n    return pair_c[chosen], pair_f[chosen]\n\n",
  "softmax_sampling_over_pairs_aug_57": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Inverse\u2011cost proxy weighting with top\u2011k random choice and deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    epsilon = 1e-12\n    top_k = 5\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    fac_indices = np.arange(len(remaining_capacities))\n    custs = np.asarray(remaining_customers, dtype=int)\n\n    feas_mask = caps[:, None] >= dem[custs]\n    if not feas_mask.any():\n        return None, None\n\n    idxs = np.where(feas_mask)\n    pair_f = fac_indices[idxs[0]]\n    pair_c = custs[idxs[1]]\n    pair_cost = costs[idxs[0], idxs[1]]\n\n    # Deterministic noise for tie\u2011breaking\n    noise = rng.normal(scale=1e-7, size=pair_cost.shape)\n    pair_cost_noisy = pair_cost + noise\n\n    # Inverse\u2011cost proxy weighting\n    w = 1.0 / (pair_cost_noisy + epsilon)\n    w /= np.sum(w) + epsilon\n\n    # Random choice among the top\u2011k cheapest pairs\n    top_idx = np.argsort(pair_cost_noisy)[:top_k]\n    top_w = w[top_idx]\n    top_w /= np.sum(top_w) + epsilon\n\n    chosen = rng.choice(len(top_w), p=top_w)\n    return int(pair_c[top_idx[chosen]]), int(pair_f[top_idx[chosen]])\n\n",
  "progressive_explore_then_exploit_aug_58": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorized feasibility check with soft\u2011min sampling and noise\u2011based tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    n_rem = len(remaining_customers)\n    n_fac = len(remaining_capacities)\n\n    # Progress metric with epsilon to avoid division by zero\n    denom = max(1, n_rem + sum(len(a) for a in assignments) + 1e-12)\n    progress = 1.0 - (n_rem / denom)\n\n    # Dynamically set K using np.clip\n    K = int(np.clip(np.ceil((1.0 - progress) * 15), 3, 15))\n\n    # Feasibility mask: facilities that can serve each remaining customer\n    feas_mask = caps[:, None] >= dem[remaining_customers]  # shape (n_fac, n_rem)\n\n    # Flatten indices of feasible pairs\n    f_idx, c_idx = np.where(feas_mask)\n    if f_idx.size == 0:\n        return None, None\n\n    # Corresponding costs and add tiny noise for deterministic tie\u2011breaking\n    pair_costs = costs[f_idx, c_idx] + 1e-6 * rng.random(f_idx.size)\n\n    # Soft\u2011min sampling: higher probability for lower cost\n    temperature = 1.0\n    probs = np.exp(-pair_costs / temperature)\n    probs /= probs.sum()\n\n    # Sample one pair\n    chosen = rng.choice(f_idx.size, p=probs)\n    chosen_f = f_idx[chosen]\n    chosen_c = remaining_customers[c_idx[chosen]]\n    return chosen_c, chosen_f\n\n",
  "progressive_explore_then_exploit_aug_59": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"While\u2011loop construction with deterministic best pair for small problem size.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    n_rem = len(remaining_customers)\n    n_fac = len(remaining_capacities)\n\n    denom = max(1, n_rem + sum(len(a) for a in assignments) + 1e-12)\n    progress = 1.0 - (n_rem / denom)\n\n    # K with a higher upper bound\n    K = int(np.clip(np.ceil((1.0 - progress) * 12), 4, 12))\n\n    # Build list of feasible pairs using while loop\n    pairs = []\n    idx_c = 0\n    while idx_c < n_rem:\n        c = remaining_customers[idx_c]\n        idx_f = 0\n        while idx_f < n_fac:\n            if caps[idx_f] >= dem[c]:\n                pairs.append((float(costs[idx_f, c]), int(c), int(idx_f)))\n            idx_f += 1\n        idx_c += 1\n\n    if not pairs:\n        return None, None\n\n    # Sort and decide strategy\n    pairs.sort(key=lambda x: x[0])\n    if n_rem <= max(2, n_fac // 2):\n        _, c, f = pairs[0]\n        return c, f\n\n    # Random choice among top\u2011K with deterministic noise\n    top = pairs[:min(K, len(pairs))]\n    _, c, f = top[int(rng.integers(0, len(top)))]\n    return c, f\n\n",
  "progressive_explore_then_exploit_aug_60": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"List\u2011comprehension based pair extraction with soft\u2011min selection and capacity penalty.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    n_rem = len(remaining_customers)\n    n_fac = len(remaining_capacities)\n\n    denom = max(1, n_rem + sum(len(a) for a in assignments) + 1e-12)\n    progress = 1.0 - (n_rem / denom)\n\n    # Use median\u2011based progress to alter K computation\n    K = int(np.clip(np.ceil((1.0 - progress) * 20), 5, 20))\n\n    # Create feasible pairs via comprehension\n    pairs = [(float(costs[f, c]), int(c), int(f))\n             for c in remaining_customers\n             for f in range(n_fac)\n             if caps[f] >= dem[c]]\n\n    if not pairs:\n        return None, None\n\n    # Add small deterministic noise to costs for tie\u2011breaking\n    noise = 1e-8 * np.arange(len(pairs))\n    costs_arr = np.array([p[0] for p in pairs]) + noise\n\n    # Soft\u2011min sampling with temperature\n    temperature = 0.8\n    probs = np.exp(-costs_arr / temperature)\n    probs /= probs.sum()\n\n    chosen_idx = rng.choice(len(pairs), p=probs)\n    _, c, f = pairs[chosen_idx]\n    return c, f\n\n",
  "progressive_explore_then_exploit_aug_61": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Broadcasting approach with large\u2011cost masking and random top\u2011K selection.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    n_rem = len(remaining_customers)\n    n_fac = len(remaining_capacities)\n\n    denom = max(1, n_rem + sum(len(a) for a in assignments) + 1e-12)\n    progress = 1.0 - (n_rem / denom)\n\n    # Compute feasibility mask via broadcasting\n    feas = caps[:, None] >= dem[remaining_customers]  # (n_fac, n_rem)\n\n    # Mask infeasible entries with a huge cost\n    masked_costs = np.where(feas, costs[:, remaining_customers], 1e9)\n\n    # Find global minimum pair\n    min_idx = np.unravel_index(np.argmin(masked_costs), masked_costs.shape)\n    if masked_costs[min_idx] >= 1e9:\n        # No feasible pair\n        return None, None\n\n    # If problem is small, return deterministic best\n    if n_rem <= max(2, n_fac // 2):\n        f = min_idx[0]\n        c = remaining_customers[min_idx[1]]\n        return c, f\n\n    # Otherwise sample among top\u2011K lowest costs\n    flat = masked_costs.flatten()\n    sorted_idx = np.argsort(flat)\n    K = int(np.clip(np.ceil((1.0 - progress) * 10), 3, 10))\n    top_idx = sorted_idx[:min(K, len(sorted_idx))]\n    chosen_flat = rng.choice(top_idx)\n    f, c_idx = divmod(chosen_flat, n_rem)\n    c = remaining_customers[c_idx]\n    return c, f\n\n",
  "lookahead_scarcity_penalty_aug_62": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    beta = 2.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_dem = np.asarray([dem[c] for c in remaining_customers], dtype=float)\n    if rem_dem.size == 0:\n        return None, None\n\n    # use median instead of mean for feasibility fraction\n    feas_frac = np.array([np.median(caps[f] >= rem_dem) for f in range(len(caps))],\n                         dtype=float)\n    scarcity = np.clip(1.0 - feas_frac, 0.0, 1.0)\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        risk = scarcity[feas] * (d / np.maximum(1.0, slack + 1e-12))\n        score = costs[feas, c] + beta * risk\n        k = np.argmin(score)\n        f = feas[k]\n        val = score[k]\n        if val < best_val:\n            best_val, best_c, best_f = val, c, f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "lookahead_scarcity_penalty_aug_63": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    beta = 1.8\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_dem = np.asarray([dem[c] for c in remaining_customers], dtype=float)\n    if rem_dem.size == 0:\n        return None, None\n\n    feas_frac = np.array([np.mean(caps[f] >= rem_dem) for f in range(len(caps))],\n                         dtype=float)\n    scarcity = np.clip(1.0 - feas_frac, 0.0, 1.0)\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        risk = scarcity[feas] * (d / np.maximum(1.0, slack + 1e-12))\n        score = costs[feas, c] + beta * risk\n\n        # tiny random noise for deterministic tie\u2011breaking\n        noise = np.random.uniform(0, 1e-6, size=score.shape)\n        score_noisy = score + noise\n\n        # choose randomly among the top\u2011k smallest scores\n        top_k = min(5, score_noisy.size)\n        top_indices = np.argpartition(score_noisy, top_k)[:top_k]\n        chosen = np.random.choice(top_indices)\n\n        f = feas[chosen]\n        val = score_noisy[chosen]\n        if val < best_val:\n            best_val, best_c, best_f = val, c, f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "lookahead_scarcity_penalty_aug_64": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    beta = 1.5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_dem = np.asarray([dem[c] for c in remaining_customers], dtype=float)\n    if rem_dem.size == 0:\n        return None, None\n\n    feas_frac = np.array([np.median(caps[f] >= rem_dem) for f in range(len(caps))],\n                         dtype=float)\n    scarcity = np.clip(1.0 - feas_frac, 0.0, 1.0)\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size > 0:\n            slack = caps[feas] - d\n            # use sum of risk components\n            risk = np.sum(scarcity[feas] * (d / (slack + 1e-12)))\n            score = costs[feas, c] + beta * risk\n            # deterministic noise that grows with index\n            noise = 1e-9 * np.arange(score.size)\n            score_noisy = score + noise\n            k = np.argmin(score_noisy)\n            f = feas[k]\n            val = score_noisy[k]\n            if val < best_val:\n                best_val, best_c, best_f = val, c, f\n        idx += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "lookahead_scarcity_penalty_aug_65": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    beta = 1.3\n    rem_cap = np.asarray(remaining_capacities, dtype=float)\n    cust_dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    rem_dem = np.asarray([cust_dem[c] for c in remaining_customers], dtype=float)\n    if rem_dem.size == 0:\n        return None, None\n\n    feas_frac = np.array([np.mean(rem_cap[f] >= rem_dem) for f in range(len(rem_cap))],\n                         dtype=float)\n    scarcity = np.clip(1.0 - feas_frac, 0.0, 1.0)\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n    i = 0\n    while i < len(remaining_customers):\n        c = remaining_customers[i]\n        d = cust_dem[c]\n        feas = np.where(rem_cap >= d)[0]\n        if feas.size > 0:\n            slack = rem_cap[feas] - d\n            risk = scarcity[feas] * (d / (slack + 1e-12))\n            score = cost_mat[feas, c] + beta * risk\n            # deterministic noise\n            score += 1e-9 * np.arange(score.size)\n            k = np.argmin(score)\n            f = feas[k]\n            val = score[k]\n            if val < best_val:\n                best_val, best_c, best_f = val, c, f\n        i += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "facility_first_pick_best_customer_aug_66": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Choose a facility with the largest remaining capacity and assign the cheapest feasible customer,\n    adding a tiny deterministic noise for tie\u2011breaking.  Uses list comprehensions and a while\u2011style loop.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Order facilities by descending remaining capacity\n    f_order = np.argsort(-caps)\n\n    # Iterate over facilities\n    for f in f_order:\n        # Find customers that fit in facility f\n        feas_mask = dem[remaining_customers] <= caps[f]\n        if not np.any(feas_mask):\n            continue\n        feas_customers = [c for c, m in zip(remaining_customers, feas_mask) if m]\n\n        # Compute a score that penalises using up capacity too fast\n        eps = 1e-12\n        scores = []\n        for j in feas_customers:\n            ratio = (caps[f] - dem[j]) / (caps[f] + eps)\n            ratio = np.clip(ratio, 0, 1)\n            # heavier penalty for small remaining capacity\n            score = costs[f, j] + (1 - ratio) * 10.0\n            # tiny deterministic noise for reproducible tie\u2011breaking\n            noise = (j + f) * 1e-7\n            scores.append(score + noise)\n\n        # Pick the customer with the lowest score\n        best_idx = int(np.argmin(scores))\n        return int(feas_customers[best_idx]), int(f)\n\n    return None, None\n\n",
  "facility_first_pick_best_customer_aug_67": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised selection: compute a global score matrix, pick the top\u2011k cheapest pairs\n    and randomly choose among them.  Weighting parameters are tuned for higher cost emphasis.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Broadcast capacities and demands to form a feasibility mask\n    feas = dem[remaining_customers] <= caps[:, None]\n    if not np.any(feas):\n        return None, None\n\n    eps = 1e-12\n    # Compute a score: higher weight on cost (0.7) and lower weight on capacity usage (0.3)\n    ratio = np.clip((caps[:, None] - dem[remaining_customers]) / (caps[:, None] + eps), 0, 1)\n    score_matrix = 0.7 * costs[:, remaining_customers] + 0.3 * (1 - ratio) * 10.0\n\n    # Mask infeasible entries\n    score_matrix = np.where(feas, score_matrix, np.inf)\n\n    # Flatten and find indices of the top_k cheapest feasible pairs\n    flat_idx = np.argsort(score_matrix.ravel())[:7]   # top_k = 7\n    f_idx, c_idx = np.unravel_index(flat_idx, score_matrix.shape)\n    # Randomly pick one of the top_k candidates\n    choice = np.random.choice(len(flat_idx))\n    return int(remaining_customers[c_idx[choice]]), int(f_idx[choice])\n\n",
  "facility_first_pick_best_customer_aug_68": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection with softmin weighting: compute a temperature\u2011scaled softmin over\n    feasible pairs and pick a customer proportionally to the softmin probability.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Build feasibility mask\n    feas = dem[remaining_customers] <= caps[:, None]\n    if not np.any(feas):\n        return None, None\n\n    eps = 1e-12\n    # Median\u2011based capacity penalty\n    ratio = np.clip((caps[:, None] - dem[remaining_customers]) / (caps[:, None] + eps), 0, 1)\n    penalty = np.median((1 - ratio) * 10.0, axis=1, keepdims=True)\n    score_matrix = costs[:, remaining_customers] + penalty\n\n    # Apply softmin with temperature tau\n    tau = 5.0\n    softmin_weights = np.exp(-score_matrix / (tau + eps))\n    softmin_weights = np.where(feas, softmin_weights, 0.0)\n\n    # Normalize to get probabilities\n    prob_matrix = softmin_weights / (softmin_weights.sum() + eps)\n\n    # Flatten and sample a pair according to the probabilities\n    flat_prob = prob_matrix.ravel()\n    idx = np.random.choice(len(flat_prob), p=flat_prob)\n    f_idx, c_idx = np.unravel_index(idx, prob_matrix.shape)\n    return int(remaining_customers[c_idx]), int(f_idx)\n\n",
  "facility_first_pick_best_customer_aug_69": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Recursively pick a facility\u2011customer pair by sampling with probability inversely\n    proportional to the cost, while ensuring capacity constraints.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Feasibility mask\n    feas = dem[remaining_customers] <= caps[:, None]\n    if not np.any(feas):\n        return None, None\n\n    eps = 1e-12\n    # Compute inverse\u2011cost weights (higher weight for lower cost)\n    inv_cost = 1.0 / (costs[:, remaining_customers] + eps)\n    inv_cost = np.where(feas, inv_cost, 0.0)\n\n    # Normalize to get sampling probabilities\n    probs = inv_cost / (inv_cost.sum() + eps)\n    flat_probs = probs.ravel()\n\n    # Sample a pair\n    idx = np.random.choice(len(flat_probs), p=flat_probs)\n    f_idx, c_idx = np.unravel_index(idx, probs.shape)\n\n    return int(remaining_customers[c_idx]), int(f_idx)\n\n",
  "facility_most_constrained_then_best_customer_aug_70": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Pick the facility that can serve the fewest remaining customers,\n    then assign its cheapest feasible customer. Deterministic tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n    rem_arr = np.asarray(remaining_customers, dtype=int)\n\n    # Vectorised feasibility counts\n    feas_counts = np.array([np.sum(dem_arr[rem_arr] <= cap) for cap in cap_arr],\n                           dtype=int)\n\n    # Facilities that can serve at least one customer\n    valid_fs = np.where(feas_counts > 0)[0]\n    if valid_fs.size == 0:\n        return None, None\n\n    # Deterministic tie\u2011breaking using tiny index\u2011based noise\n    noise = 1e-12 * np.arange(len(feas_counts))\n    f = int(valid_fs[np.argmin(feas_counts[valid_fs] + noise[valid_fs])])\n\n    # Feasible customers for the chosen facility\n    feas_cust_mask = dem_arr[rem_arr] <= cap_arr[f]\n    feas_cust = rem_arr[feas_cust_mask]\n\n    # Deterministic tie\u2011breaking for customer selection\n    cust_noise = 1e-12 * np.arange(len(feas_cust))\n    c = int(feas_cust[np.argmin(cost_arr[f, feas_cust] + cust_noise)])\n\n    return c, f\n\n",
  "facility_most_constrained_then_best_customer_aug_71": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Random tie\u2011breaking for facility selection; deterministic top\u20113 customer choice.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng(123)\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n    rem_arr = np.asarray(remaining_customers, dtype=int)\n\n    feas_counts = np.array([np.sum(dem_arr[rem_arr] <= cap) for cap in cap_arr], dtype=int)\n\n    valid_fs = np.where(feas_counts > 0)[0]\n    if valid_fs.size == 0:\n        return None, None\n\n    # Facility with fewest customers; random among ties\n    min_count = np.min(feas_counts[valid_fs])\n    candidates = valid_fs[feas_counts[valid_fs] == min_count]\n    f = int(rng.choice(candidates))\n\n    feas_cust_mask = dem_arr[rem_arr] <= cap_arr[f]\n    feas_cust = rem_arr[feas_cust_mask]\n    if feas_cust.size == 0:\n        return None, None\n\n    # Top\u20113 cheapest customers\n    k = min(3, len(feas_cust))\n    costs_f = cost_arr[f, feas_cust]\n    topk_idx = np.argpartition(costs_f, k - 1)[:k]\n    topk_customers = feas_cust[topk_idx]\n\n    # Deterministically pick the cheapest among the top\u20113\n    c = int(topk_customers[np.argmin(cost_arr[f, topk_customers])])\n\n    return c, f\n\n",
  "two_step_lookahead_best_remaining_min_aug_72": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy look\u2011ahead with a 0.6 weight on the second\u2011step cost and deterministic tie\u2011breaking.\"\"\"\n    # Vectorise inputs\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    cust_indices = list(remaining_customers)\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    i = 0\n    while i < len(cust_indices):\n        c = cust_indices[i]\n        d = dem_arr[c]\n        # facilities that can still serve customer c\n        feas_f = np.where(caps_arr >= d)[0]\n        if feas_f.size > 0:\n            for f in feas_f:\n                caps_tmp = caps_arr.copy()\n                caps_tmp[f] -= d\n                base_cost = float(cost_arr[f, c])\n\n                # best next assignment cost (ignoring penalties)\n                best_next = np.inf\n                for c2 in cust_indices:\n                    if c2 == c:\n                        continue\n                    d2 = dem_arr[c2]\n                    feas_f2 = np.where(caps_tmp >= d2)[0]\n                    if feas_f2.size > 0:\n                        best_next = min(best_next,\n                                        float(np.min(cost_arr[feas_f2, c2])))\n                if not np.isfinite(best_next):\n                    best_next = 0.0\n                best_next = np.clip(best_next, 0, np.inf)\n\n                score = base_cost + 0.6 * best_next\n                # deterministic tie\u2011breaking noise\n                score += np.random.rand() * 1e-6\n                if score < best_score:\n                    best_score = score\n                    best_cust = c\n                    best_fac = f\n        i += 1\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "two_step_lookahead_best_remaining_min_aug_73": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Mean\u2011based look\u2011ahead with a 0.4 weight and random choice among top\u20113 candidates.\"\"\"\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    # Work only with the first 7 customers (top_k = 7)\n    cust_indices = remaining_customers[:7]\n    scores = []\n\n    for c in cust_indices:\n        d = dem_arr[c]\n        feas_f = np.where(caps_arr >= d)[0]\n        if feas_f.size == 0:\n            continue\n        for f in feas_f:\n            caps_tmp = caps_arr.copy()\n            caps_tmp[f] -= d\n            base_cost = float(cost_arr[f, c])\n\n            # approximate next\u2011step cost by the mean over all feasible facilities\n            best_next = np.inf\n            for c2 in cust_indices:\n                if c2 == c:\n                    continue\n                d2 = dem_arr[c2]\n                feas_f2 = np.where(caps_tmp >= d2)[0]\n                if feas_f2.size > 0:\n                    # mean cost with epsilon to avoid division by zero\n                    mean_cost = float(np.mean(cost_arr[feas_f2, c2]))\n                    best_next = min(best_next, mean_cost)\n            if not np.isfinite(best_next):\n                best_next = 0.0\n            best_next = np.clip(best_next, 0, np.inf)\n\n            score = base_cost + 0.4 * best_next\n            scores.append((score, c, f))\n\n    if not scores:\n        return (None, None)\n\n    # sort and pick the three best candidates\n    scores.sort(key=lambda x: x[0])\n    top3 = scores[:3]\n    # random choice among the top\u20113\n    chosen = np.random.choice(len(top3))\n    _, chosen_c, chosen_f = top3[chosen]\n    return (chosen_c, chosen_f)\n\n",
  "two_step_lookahead_best_remaining_min_aug_74": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min weighted selection with random sampling among the best three.\"\"\"\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    candidates = []\n    alpha = 1.0  # soft\u2011min temperature\n\n    for c in remaining_customers:\n        d = dem_arr[c]\n        feas_f = np.where(caps_arr >= d)[0]\n        if feas_f.size == 0:\n            continue\n        for f in feas_f:\n            caps_tmp = caps_arr.copy()\n            caps_tmp[f] -= d\n            base_cost = float(cost_arr[f, c])\n\n            best_next = np.inf\n            for c2 in remaining_customers:\n                if c2 == c:\n                    continue\n                d2 = dem_arr[c2]\n                feas_f2 = np.where(caps_tmp >= d2)[0]\n                if feas_f2.size > 0:\n                    best_next = min(best_next,\n                                    float(np.min(cost_arr[feas_f2, c2])))\n            if not np.isfinite(best_next):\n                best_next = 0.0\n            best_next = np.clip(best_next, 0, np.inf)\n\n            score = base_cost + 0.4 * best_next\n            candidates.append((score, c, f))\n\n    if not candidates:\n        return (None, None)\n\n    # take the three best scores\n    candidates.sort(key=lambda x: x[0])\n    top3 = candidates[:3]\n    scores = np.array([s for s, _, _ in top3], dtype=float)\n\n    # soft\u2011min weights\n    exp_vals = np.exp(-alpha * scores / (scores.max() + 1e-12))\n    probs = exp_vals / (exp_vals.sum() + 1e-12)\n\n    chosen_idx = np.random.choice(len(top3), p=probs)\n    _, chosen_c, chosen_f = top3[chosen_idx]\n    return (chosen_c, chosen_f)\n\n",
  "two_step_lookahead_best_remaining_min_aug_75": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised median\u2011based look\u2011ahead with a 0.3 weight and deterministic tie\u2011breaking.\"\"\"\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    # median of all assignment costs (proxy for best_next)\n    median_cost = np.median(cost_arr)\n    median_cost = np.clip(median_cost, 0, np.inf)\n\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    for c in remaining_customers:\n        d = dem_arr[c]\n        feas_f = np.where(caps_arr >= d)[0]\n        if feas_f.size == 0:\n            continue\n        for f in feas_f:\n            base_cost = float(cost_arr[f, c])\n            score = base_cost + 0.3 * median_cost\n            # deterministic tie\u2011breaking noise\n            score += np.random.rand() * 1e-6\n            if score < best_score:\n                best_score = score\n                best_cust = c\n                best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "cheapest_with_capacity_reserve_for_large_aug_76": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    gamma = 9.0  # tuned weight for capacity penalty\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_ids = np.asarray(remaining_customers, dtype=int)\n    rem_demands = demands[rem_ids]\n    if rem_demands.size == 0:\n        return None, None\n\n    q75 = float(np.quantile(rem_demands, 0.75))\n    big_demands = rem_demands[rem_demands >= q75]\n    if big_demands.size == 0:\n        big_demands = rem_demands\n\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    for c in rem_ids:\n        d = float(demands[c])\n        feas_facs = np.where(caps >= d)[0]\n        if feas_facs.size == 0:\n            continue\n        for f in feas_facs:\n            cap_left = caps[f] - d\n            able = float(np.median(cap_left >= big_demands))\n            able = np.clip(able, 0.0, 1.0)\n            penalty = gamma * (1.0 - able)\n            score = float(costs[f, c]) + penalty\n            # deterministic tie\u2011breaking noise\n            score += 1e-6 * (c + f)\n            if score < best_score:\n                best_score = score\n                best_cust, best_fac = int(c), int(f)\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "cheapest_with_capacity_reserve_for_large_aug_77": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    gamma = 7.5\n    tau = 0.5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_ids = np.asarray(remaining_customers, dtype=int)\n    rem_demands = demands[rem_ids]\n    if rem_demands.size == 0:\n        return None, None\n\n    q75 = float(np.quantile(rem_demands, 0.75))\n    big_demands = rem_demands[rem_demands >= q75]\n    if big_demands.size == 0:\n        big_demands = rem_demands\n\n    best_cust = None\n    best_fac = None\n    best_weight = -np.inf\n\n    idx = 0\n    while idx < rem_ids.size:\n        c = rem_ids[idx]\n        d = float(demands[c])\n        feas_facs = np.where(caps >= d)[0]\n        if feas_facs.size > 0:\n            fac_idx = 0\n            while fac_idx < feas_facs.size:\n                f = feas_facs[fac_idx]\n                cap_left = caps[f] - d\n                able = float(np.max(cap_left >= big_demands))\n                able = np.clip(able, 0.0, 1.0)\n                penalty = gamma * (1.0 - able)\n                score = float(costs[f, c]) + penalty\n                weight = np.exp(-score / tau)\n                if weight > best_weight:\n                    best_weight = weight\n                    best_cust, best_fac = int(c), int(f)\n                fac_idx += 1\n        idx += 1\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "demand_weighted_regret_aug_78": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assigns: List[List[int]], custs: List[int], caps_list: List[int], demands: List[int], cost_mat: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection using a while\u2011loop and vectorised feasibility checks.\"\"\"\n    if not custs:\n        return None, None\n\n    caps = np.asarray(caps_list, dtype=float)\n    dem = np.asarray(demands, dtype=float)\n    costs = np.asarray(cost_mat, dtype=float)\n\n    best_score = -np.inf\n    best_c = None\n    best_f = None\n\n    idx = 0\n    while idx < len(custs):\n        c = custs[idx]\n        idx += 1\n\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            regret = 1e12\n            f = int(feas[0])\n        else:\n            order = np.argsort(c_costs)\n            regret = float(c_costs[order[1]] - c_costs[order[0]])\n            f = int(feas[order[0]])\n\n        score = regret * float(dem[c])\n        if score > best_score:\n            best_score = score\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "demand_weighted_regret_aug_79": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Weighted scoring with tuned constants and clipping.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            regret = 1e9  # tuned constant\n            f = int(feas[0])\n        else:\n            order = np.argsort(c_costs)\n            regret = float(c_costs[order[1]] - c_costs[order[0]])\n            f = int(feas[order[0]])\n\n        # weighted score: 60\u202f% regret\u202f\u00d7\u202fdemand, 40\u202f% regret\n        dem_c = dem[c] + 1e-12\n        score = 0.6 * regret * dem_c + 0.4 * regret\n        score = np.clip(score, -1e12, 1e12)\n\n        if score > best_score:\n            best_score = score\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "demand_weighted_regret_aug_80": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Deterministic noise and random tie\u2011breaking among top\u2011k cheapest facilities.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            regret = 1e12\n            chosen_f = int(feas[0])\n        else:\n            sorted_idx = np.argsort(c_costs)\n            regret = float(c_costs[sorted_idx[1]] - c_costs[sorted_idx[0]])\n            # Randomly pick among the 3 cheapest facilities\n            top_k = min(3, feas.size)\n            chosen_f = int(feas[sorted_idx[np.random.randint(top_k)]])\n\n        # Deterministic noise based on customer id\n        noise = ((c + 1) % 100) * 1e-6\n        score = regret * dem[c] + noise\n\n        if score > best_score:\n            best_score = score\n            best_c = int(c)\n            best_f = chosen_f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "demand_weighted_regret_aug_81": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Fully vectorised selection with soft\u2011min facility choice and deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Feasibility mask: facilities \u00d7 customers\n    feas_mask = caps[:, None] >= dem[None, :]\n\n    # Keep only remaining customers\n    cust_mask = np.zeros(dem.shape[0], dtype=bool)\n    cust_mask[remaining_customers] = True\n    feas_mask = feas_mask[:, cust_mask]\n\n    large_val = 1e12\n    masked_costs = np.where(feas_mask, costs[:, cust_mask], large_val)\n\n    # Minimum and second\u2011minimum costs per customer\n    min_cost = np.min(masked_costs, axis=0)\n    second_min = np.partition(masked_costs, 1, axis=0)[1]\n    second_min = np.where(min_cost == large_val, large_val, second_min)\n\n    regret = second_min - min_cost\n    regret = np.clip(regret, 0, 1e9)\n\n    # Scoring: 50\u202f% regret\u202f\u00d7\u202fdemand + 50\u202f% regret\n    score = 0.5 * regret * dem[remaining_customers] + 0.5 * regret\n\n    # Deterministic noise\n    noise = ((np.array(remaining_customers) + 1) % 100) * 1e-6\n    score += noise\n\n    best_idx = np.argmax(score)\n    best_customer = remaining_customers[best_idx]\n\n    # Facility with minimal cost for the chosen customer\n    feas_facs = np.where(caps >= dem[best_customer])[0]\n    if feas_facs.size == 0:\n        return None, None\n    best_facility = int(feas_facs[np.argmin(costs[feas_facs, best_customer])])\n\n    return best_customer, best_facility\n\n",
  "median_cost_customer_priority_aug_82": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Ensure capacities are non\u2011negative\n    caps = np.clip(caps, 0, None)\n\n    scores = []\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size == 0:\n            scores.append(np.inf)\n        else:\n            mean_cost = np.mean(costs[feasible, c])\n            # deterministic tie\u2011breaking noise\n            scores.append(mean_cost + 1e-4 * c)\n        idx += 1\n\n    best_cust = remaining_customers[int(np.argmin(scores))]\n\n    feasible = np.where(caps >= dem[best_cust])[0]\n    if feasible.size == 0:\n        return None, None\n\n    cust_costs = costs[feasible, best_cust]\n    temp = 0.5 + 1e-12\n    exp_vals = np.exp(-cust_costs / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    best_fac = int(feasible[np.argmax(probs)])\n\n    return best_cust, best_fac\n\n",
  "median_cost_customer_priority_aug_83": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    caps = np.clip(caps, 0, None)\n\n    feas_mask = caps[:, None] >= dem[None, :]\n    masked_costs = np.where(feas_mask, costs, np.nan)\n\n    medians = np.nanmedian(masked_costs, axis=0)\n    min_costs = np.nanmin(masked_costs, axis=0)\n\n    combined = 0.6 * medians + 0.4 * min_costs\n    combined += 1e-6 * np.arange(len(combined))  # deterministic noise\n\n    scores = np.full_like(combined, np.inf, dtype=float)\n    scores[remaining_customers] = combined[remaining_customers]\n    best_cust = int(np.argmin(scores))\n\n    feasible = np.where(caps >= dem[best_cust])[0]\n    if feasible.size == 0:\n        return None, None\n    cust_costs = costs[feasible, best_cust]\n    best_fac = int(feasible[np.argmin(cust_costs)])\n\n    return best_cust, best_fac\n\n",
  "median_cost_customer_priority_aug_84": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    caps = np.clip(caps, 0, None)\n\n    feas_mask = caps[:, None] >= dem[None, :]\n    masked_costs = np.where(feas_mask, costs, np.nan)\n    medians = np.nanmedian(masked_costs, axis=0)\n\n    remaining_arr = np.array(remaining_customers)\n    medians_rem = medians[remaining_arr]\n\n    k = 5\n    if k > len(remaining_arr):\n        k = len(remaining_arr)\n    top_k_idx = np.argsort(medians_rem)[:k]\n    chosen = np.random.choice(top_k_idx)\n    best_cust = int(remaining_arr[chosen])\n\n    feasible = np.where(caps >= dem[best_cust])[0]\n    if feasible.size == 0:\n        return None, None\n    cust_costs = costs[feasible, best_cust]\n    best_fac = int(feasible[np.argmin(cust_costs)])\n\n    return best_cust, best_fac\n\n",
  "median_cost_customer_priority_aug_85": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    caps = np.clip(caps, 0, None)\n\n    feas_mask = caps[:, None] >= dem[None, :]\n    masked_costs = np.where(feas_mask, costs, np.nan)\n    medians = np.nanmedian(masked_costs, axis=0)\n\n    remaining_arr = np.array(remaining_customers)\n    medians_rem = medians[remaining_arr]\n\n    best_cust = int(remaining_arr[np.argmax(medians_rem)])\n\n    feasible = np.where(caps >= dem[best_cust])[0]\n    if feasible.size == 0:\n        return None, None\n    cust_costs = costs[feasible, best_cust]\n\n    temp = 1.0 + 1e-12\n    exp_vals = np.exp(-cust_costs / (temp + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    best_fac = int(feasible[np.argmax(probs)])\n\n    return best_cust, best_fac\n\n",
  "min_average_cost_facility_bias_aug_86": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 1 \u2013 Vectorised soft\u2011minimum selection with median aggregation.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Parameters\n    eta = 0.3\n    temperature = 1.0\n    epsilon = 1e-12\n\n    # Convert to numpy arrays\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Median cost of each facility over the remaining customers\n    mean_fac = np.median(costs[:, rem], axis=1) if rem.size > 0 else np.median(costs, axis=1)\n\n    best = (np.inf, None, None)\n\n    for c in rem:\n        # Facilities that can still accommodate this customer\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        # Score = direct cost + eta * median cost + deterministic noise\n        noise = (c * 1e-6 + feas * 1e-6).sum()\n        score = costs[feas, c] + eta * mean_fac[feas] + noise\n\n        # Soft\u2011minimum probability\n        logits = -score / (temperature + epsilon)\n        probs = np.exp(logits)\n        probs = probs / (probs.sum() + epsilon)\n        probs = np.clip(probs, 0.0, 1.0)\n\n        # Facility with highest soft\u2011min probability\n        f = int(feas[np.argmax(probs)])\n\n        if score < best[0]:\n            best = (float(score), int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n\n",
  "min_average_cost_facility_bias_aug_87": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 2 \u2013 While\u2011loop, max\u2011aggregation, adjusted eta and top\u2011k.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Parameters\n    eta = 0.6          # heavier weight on facility mean cost\n    top_k = 7\n    epsilon = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Max cost of each facility over the remaining customers\n    mean_fac = np.max(costs[:, rem], axis=1) if rem.size > 0 else np.max(costs, axis=1)\n\n    best = (np.inf, None, None)\n    idx = 0\n    while idx < rem.size:\n        c = int(rem[idx])\n        idx += 1\n\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size != 0:          # inverted conditional logic\n            # Score with deterministic noise\n            noise = (c + feas.sum()) * 1e-6\n            score = costs[feas, c] + eta * mean_fac[feas] + noise\n            # Choose among top\u2011k cheapest facilities\n            k = np.argpartition(score, top_k - 1)[:top_k]\n            f = int(feas[k[np.argmin(score[k])]])\n            if score[k[0]] < best[0]:\n                best = (float(score[k[0]]), c, f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n\n",
  "min_average_cost_facility_bias_aug_88": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 3 \u2013 List\u2011comprehension, sum aggregation, random top\u2011k choice.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Parameters\n    eta = 0.4\n    top_k = 5\n    rng = np.random.default_rng(12345)\n    epsilon = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Sum cost of each facility over remaining customers\n    mean_fac = np.sum(costs[:, rem], axis=1) / (rem.size + epsilon)\n\n    best = (np.inf, None, None)\n\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        # Score with deterministic noise\n        noise = ((c + feas) * 1e-6).sum()\n        score = costs[feas, c] + eta * mean_fac[feas] + noise\n\n        # Randomly pick among top\u2011k cheapest facilities\n        idxs = np.argpartition(score, top_k - 1)[:top_k]\n        chosen = rng.choice(idxs)\n        f = int(feas[chosen])\n\n        if score[chosen] < best[0]:\n            best = (float(score[chosen]), int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n\n",
  "min_average_cost_facility_bias_aug_89": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 4 \u2013 While\u2011loop, softmax selection, median aggregation, clipping.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Parameters\n    eta = 0.5\n    temperature = 0.8\n    epsilon = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Median cost per facility over remaining customers\n    mean_fac = np.median(costs[:, rem], axis=1) if rem.size > 0 else np.median(costs, axis=1)\n\n    best = (np.inf, None, None)\n    i = 0\n    while i < rem.size:\n        c = int(rem[i])\n        i += 1\n\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        # Score with deterministic noise\n        noise = ((c + feas) * 1e-6).sum()\n        score = costs[feas, c] + eta * mean_fac[feas] + noise\n\n        # Softmax probabilities\n        logits = -score / (temperature + epsilon)\n        logits = np.clip(logits, -1e3, 1e3)          # prevent overflow\n        exp_vals = np.exp(logits - np.max(logits))   # stable exp\n        probs = exp_vals / (exp_vals.sum() + epsilon)\n        probs = np.clip(probs, 0.0, 1.0)\n\n        f = int(feas[np.argmax(probs)])\n\n        if score.min() < best[0]:\n            best = (float(score.min()), int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n\n",
  "max_compatibility_margin_aug_90": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised selection with deterministic noise for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Convert inputs to float arrays for numeric safety\n    caps = np.asarray(remaining_capacities, dtype=float)\n    max_cap = float(np.max(caps)) if caps.size > 0 else 0.0\n    max_cap = max_cap + 1e-12  # epsilon to avoid division by zero\n\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Feasibility mask: which facilities can serve each candidate customer\n    feas_mask = caps[:, None] >= dem[remaining_customers]  # shape (facilities, customers)\n\n    # Ratio of demand to the largest capacity (clipped to [0,1])\n    ratios = dem[remaining_customers] / (max_cap + 1e-12)\n    ratios = np.clip(ratios, 0.0, 1.0)\n\n    # Small deterministic noise to break ties in a reproducible way\n    noise = np.arange(len(remaining_customers)) * 1e-6\n    ratios_noisy = ratios + noise\n\n    # For each customer find the cheapest feasible facility\n    min_costs = np.full(len(remaining_customers), np.inf)\n    best_fac = np.full(len(remaining_customers), -1, dtype=int)\n    for idx, cust in enumerate(remaining_customers):\n        feas_fac = np.where(feas_mask[idx])[0]\n        if feas_fac.size > 0:\n            f_idx = feas_fac[np.argmin(costs[feas_fac, cust])]\n            min_costs[idx] = costs[f_idx, cust]\n            best_fac[idx] = f_idx\n\n    # Combine ratio and cost into a single score (larger is better)\n    scores = ratios_noisy - 1e-6 * min_costs\n    best_idx = np.argmax(scores)\n\n    if best_fac[best_idx] == -1:\n        return None, None\n    return int(remaining_customers[best_idx]), int(best_fac[best_idx])\n\n",
  "max_compatibility_margin_aug_91": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    While\u2011loop version with weighted score (ratio 0.6, cost 0.4).\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    max_cap = float(np.max(caps)) if caps.size > 0 else 0.0\n    max_cap = max_cap + 1e-12\n\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    best_cost = np.inf\n    best_c = None\n    best_f = None\n\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size > 0:\n            ratio = dem[c] / (max_cap + 1e-12)\n            ratio = np.clip(ratio, 0.0, 1.0)\n            f = int(feas[np.argmin(costs[feas, c])])\n            score = 0.6 * ratio - 0.4 * costs[f, c]  # higher ratio, lower cost\n            if score > best_score or (score == best_score and costs[f, c] < best_cost):\n                best_score = score\n                best_cost = costs[f, c]\n                best_c = c\n                best_f = f\n        idx += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "max_compatibility_margin_aug_92": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Top\u2011k (k=5) deterministic selection based on demand ratio.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    max_cap = float(np.max(caps)) if caps.size > 0 else 0.0\n    max_cap = max_cap + 1e-12\n\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    ratios = dem[remaining_customers] / (max_cap + 1e-12)\n    ratios = np.clip(ratios, 0.0, 1.0)\n\n    top_k = 5\n    if len(ratios) <= top_k:\n        top_idx = np.arange(len(ratios))\n    else:\n        top_idx = np.argpartition(-ratios, top_k - 1)[:top_k]\n        top_idx = top_idx[np.argsort(-ratios[top_idx])]\n\n    best_c = None\n    best_f = None\n    best_cost = np.inf\n\n    for idx in top_idx:\n        c = remaining_customers[idx]\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(costs[feas, c])])\n        if costs[f, c] < best_cost:\n            best_cost = costs[f, c]\n            best_c = c\n            best_f = f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "min_cost_plus_quadratic_demand_aug_93": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    alpha = 0.05\n    # clip capacities to avoid negative values\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, np.inf)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        # use epsilon in denominator to avoid division by zero\n        d2 = float((dem[c] ** 2) / (1 + 1e-12))\n        score = costs[feas, c] + alpha * d2\n\n        # deterministic tie\u2011breaking noise\n        noise = (feas.astype(float) + 1) * 1e-8\n        score += noise\n\n        idx = int(np.argmin(score))\n        f = int(feas[idx])\n        val = float(score[idx])\n\n        if val < best_val:\n            best_val = val\n            best_c = c\n            best_f = f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "min_cost_plus_quadratic_demand_aug_94": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    alpha = 0.06\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # feasibility mask (facilities \u00d7 customers)\n    feas_mask = caps[:, None] >= dem[None, :]\n    large = 1e12\n\n    # compute score matrix; infeasible entries get a large penalty\n    score_mat = np.where(\n        feas_mask,\n        costs + alpha * (dem[None, :] ** 2) / (1 + 1e-12),\n        large\n    )\n\n    # deterministic noise for tie\u2011breaking\n    noise = (\n        np.arange(costs.shape[0])[:, None] * 1e-8 +\n        np.arange(costs.shape[1])[None, :] * 1e-9\n    )\n    score_mat += noise\n\n    flat_idx = int(np.argmin(score_mat))\n    f, c = divmod(flat_idx, costs.shape[1])\n\n    return (int(c), int(f)) if feas_mask[f, c] else (None, None)\n\n",
  "min_cost_plus_quadratic_demand_aug_95": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    alpha = 0.03\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        d2 = float((dem[c] ** 2) / (1 + 1e-12))\n        score = costs[feas, c] + alpha * d2\n\n        # clip scores to keep them bounded\n        score = np.clip(score, 0, 1e6)\n\n        # select the top\u2011k cheapest facilities\n        top_k = int(np.clip(np.round(0.25 * feas.size), 1, feas.size))\n        top_idx = np.argpartition(score, top_k - 1)[:top_k]\n\n        # random choice among the top\u2011k\n        rand_pos = np.random.randint(0, top_k)\n        chosen = feas[top_idx[rand_pos]]\n        val = float(score[top_idx[rand_pos]])\n\n        if val < best_val:\n            best_val = val\n            best_c = c\n            best_f = int(chosen)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "min_cost_plus_demand_over_slack_aug_96": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection with a simple scoring function.\n    Score = cost + alpha * demand / (slack + 1e\u201112).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    alpha = 5.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    best_score, best_c, best_f = np.inf, None, None\n\n    for c in remaining_customers:\n        d = dem[c]\n        # facilities that can serve customer c\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        # avoid division by zero\n        denom = slack + 1e-12\n        scores = cost[feas, c] + alpha * (d / denom)\n        idx = np.argmin(scores)\n        f = feas[idx]\n        val = scores[idx]\n        if val < best_score:\n            best_score, best_c, best_f = val, c, f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "min_cost_plus_demand_over_slack_aug_97": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Top\u2011k deterministic choice with median slack weighting.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    alpha = 3.5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    best_score, best_c, best_f = np.inf, None, None\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        denom = slack + 1e-12\n        scores = cost[feas, c] + alpha * (d / denom)\n\n        # choose top\u2011k (k=3) candidates\n        k = min(3, scores.size)\n        top_idx = np.argpartition(scores, k - 1)[:k]\n        top_scores = scores[top_idx]\n        top_facilities = feas[top_idx]\n\n        # deterministic tie\u2011breaking with small noise\n        noise = np.random.default_rng().random(top_scores.shape) * 1e-6\n        top_scores += noise\n        chosen_idx = np.argmin(top_scores)\n        f = top_facilities[chosen_idx]\n        val = top_scores[chosen_idx]\n\n        if val < best_score:\n            best_score, best_c, best_f = val, c, f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "min_cost_plus_demand_over_slack_aug_98": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customes: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Uses squared slack penalty and np.max aggregation for robustness.\"\"\"\n    if not remaining_customes:\n        return None, None\n\n    alpha = 6.5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    best_score, best_c, best_f = np.inf, None, None\n\n    for c in remaining_customes:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        # clip slack to avoid negative values and add epsilon\n        slack = np.clip(slack, 0, None)\n        denom = slack + 1e-12\n        # square slack to penalise large slack\n        scores = cost[feas, c] + alpha * (d / denom) + 0.1 * np.square(slack)\n\n        # use np.max of negative scores as proxy for best\n        neg_scores = -scores\n        f = feas[np.argmax(neg_scores)]\n        val = scores[np.argmax(neg_scores)]\n\n        if val < best_score:\n            best_score, best_c, best_f = val, c, f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "facility_popularity_then_assign_aug_99": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Popularity\u2011based selection with inverse\u2011capacity weighting.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    demands_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    eps = 1e-12\n    popularity = np.zeros_like(caps_arr)\n\n    # Iterate over customers using a while loop\n    idx = 0\n    custs = remaining_customers\n    while idx < len(custs):\n        c = custs[idx]\n        feas = np.where(caps_arr >= demands_arr[c])[0]\n        if feas.size:\n            c_costs = cost_arr[feas, c]\n            k = min(2, feas.size)\n            topk = feas[np.argsort(c_costs)[:k]]\n            popularity[topk] += 1.0\n        idx += 1\n\n    # Weight popularity by inverse capacity to avoid over\u2011selecting huge facilities\n    popularity = popularity / (caps_arr + eps)\n    popularity = np.clip(popularity, 0, 1)\n\n    cand_fs = np.where(popularity > 0)[0]\n    if cand_fs.size == 0:\n        return None, None\n\n    f = int(cand_fs[np.argmax(popularity[cand_fs])])\n\n    rem_customers = np.asarray(remaining_customers, dtype=int)\n    feas_customers = rem_customers[demands_arr[rem_customers] <= caps_arr[f]]\n    if feas_customers.size == 0:\n        return None, None\n\n    c = int(feas_customers[np.argmin(cost_arr[f, feas_customers])])\n    return c, f\n\n",
  "facility_popularity_then_assign_aug_100": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Weighted popularity with capacity ratio and a larger top\u2011k.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    demands_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    eps = 1e-12\n    max_cap = np.max(caps_arr) + eps\n    popularity = np.zeros_like(caps_arr)\n\n    for c in remaining_customers:\n        feas = np.where(caps_arr >= demands_arr[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = cost_arr[feas, c]\n        k = min(5, feas.size)\n        topk = feas[np.argsort(c_costs)[:k]]\n        popularity[topk] += 1.0\n\n    # Add a capacity\u2011ratio component to the popularity score\n    cap_ratio = caps_arr / max_cap\n    popularity = popularity + 0.4 * cap_ratio\n\n    cand_fs = np.where(popularity > 0)[0]\n    if cand_fs.size == 0:\n        return None, None\n\n    f = int(cand_fs[np.argmax(popularity[cand_fs])])\n\n    rem_customers = np.asarray(remaining_customers, dtype=int)\n    feas_customers = rem_customers[demands_arr[rem_customers] <= caps_arr[f]]\n    if feas_customers.size == 0:\n        return None, None\n\n    c = int(feas_customers[np.argmin(cost_arr[f, feas_customers])])\n    return c, f\n\n",
  "facility_popularity_then_assign_aug_101": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Deterministic tie\u2011breaking with noise and random choice among top\u2011k cheapest.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    demands_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    eps = 1e-12\n    popularity = np.zeros_like(caps_arr)\n\n    for c in remaining_customers:\n        feas = np.where(caps_arr >= demands_arr[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = cost_arr[feas, c]\n        k = min(2, feas.size)\n        topk = feas[np.argsort(c_costs)[:k]]\n        popularity[topk] += 1.0\n\n    cand_fs = np.where(popularity > 0)[0]\n    if cand_fs.size == 0:\n        return None, None\n\n    f = int(cand_fs[np.argmax(popularity[cand_fs])])\n\n    rem_customers = np.asarray(remaining_customers, dtype=int)\n    feas_customers = rem_customers[demands_arr[rem_customers] <= caps_arr[f]]\n    if feas_customers.size == 0:\n        return None, None\n\n    costs_f = cost_arr[f, feas_customers]\n    # Deterministic noise to break ties\n    noise = 1e-6 * np.arange(costs_f.size)\n    noisy_costs = costs_f + noise\n\n    # Pick a random customer among the top\u20113 cheapest\n    top_k = min(3, costs_f.size)\n    top_idx = np.argsort(noisy_costs)[:top_k]\n    chosen_idx = np.random.choice(top_idx)\n    c = int(feas_customers[chosen_idx])\n    return c, f\n\n",
  "facility_popularity_then_assign_aug_102": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Proxy\u2011cost approximation, median popularity, and softmax selection.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    demands_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    eps = 1e-12\n    max_cost = np.max(cost_arr) + eps\n\n    # Approximate cost with a small bias toward the global maximum\n    approx_cost = 0.9 * cost_arr + 0.1 * max_cost\n\n    popularity = np.zeros_like(caps_arr)\n\n    for c in remaining_customers:\n        feas = np.where(caps_arr >= demands_arr[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = approx_cost[feas, c]\n        k = min(3, feas.size)\n        topk = feas[np.argsort(c_costs)[:k]]\n        popularity[topk] += 1.0\n\n    # Use the median popularity to filter facilities\n    median_pop = np.median(popularity)\n    cand_fs = np.where(popularity >= median_pop)[0]\n    if cand_fs.size == 0:\n        return None, None\n\n    f = int(cand_fs[np.argmax(popularity[cand_fs])])\n\n    rem_customers = np.asarray(remaining_customers, dtype=int)\n    feas_customers = rem_customers[demands_arr[rem_customers] <= caps_arr[f]]\n    if feas_customers.size == 0:\n        return None, None\n\n    costs_f = approx_cost[f, feas_customers]\n    # Softmax (softmin) selection with numerical safety\n    exp_vals = np.exp(-costs_f / (np.max(costs_f) + eps))\n    exp_vals = np.clip(exp_vals, 0, 1e6)\n    probs = exp_vals / (np.sum(exp_vals) + eps)\n\n    rng = np.random.default_rng()\n    chosen = rng.choice(feas_customers.size, p=probs)\n    c = int(feas_customers[chosen])\n    return c, f\n\n",
  "customer_priority_by_gap_to_capacity_aug_103": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised search with a while\u2011loop and explicit clipping of gaps.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)          # (gap, cost, customer, facility)\n    i = 0\n    while i < len(remaining_customers):\n        c = remaining_customers[i]\n        d = dem[c]\n        feasible = np.where(caps >= d)[0]\n        if feasible.size:\n            gaps = np.clip(caps[feasible] - d, 0, None)\n            tightest = feasible[np.argmin(gaps)]\n            gap = gaps.min()\n            cheapest = feasible[np.argmin(costs[feasible, c])]\n            key = (gap, float(costs[cheapest, c]), c, cheapest)\n            if key < best:\n                best = key\n        i += 1\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "customer_priority_by_gap_to_capacity_aug_104": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Weighted score with top\u2011k pruning and a minimum gap threshold.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    weighted_best = (np.inf, None, None)          # (score, customer, facility)\n    top_k = 7\n    min_gap = 1e-3\n\n    for c in remaining_customers:\n        d = dem[c]\n        feasible = np.where(caps >= d)[0]\n        if not feasible.size:\n            continue\n        gaps = np.clip(caps[feasible] - d, 0, None)\n        if gaps.min() < min_gap:\n            continue\n        # weighted score: 0.55*gap + 0.45*cost\n        scores = 0.55 * gaps + 0.45 * costs[feasible, c]\n        idxs = np.argsort(gaps)[:top_k]            # choose facilities with tightest gaps\n        for idx in idxs:\n            f = feasible[idx]\n            score = scores[idx]\n            if score < weighted_best[0]:\n                weighted_best = (score, c, f)\n\n    return (weighted_best[1], weighted_best[2]) if weighted_best[1] is not None else (None, None)\n\n",
  "customer_priority_by_gap_to_capacity_aug_105": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Randomised top\u20113 selection with deterministic noise and clipping.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rng = np.random.default_rng(42)\n    candidates = []\n\n    for c in remaining_customers:\n        d = dem[c]\n        feasible = np.where(caps >= d)[0]\n        if not feasible.size:\n            continue\n        gaps = np.clip(caps[feasible] - d, 0, None)\n        for f in feasible:\n            idx = np.where(feasible == f)[0][0]\n            gap = gaps[idx]\n            score = gap + costs[f, c]\n            # deterministic tie\u2011breaking noise\n            noise = 1e-8 * ((c + 1) * (f + 1))\n            candidates.append((score + noise, c, f))\n\n    if not candidates:\n        return None, None\n\n    # keep only the 3 best candidates\n    top_k = 3\n    candidates.sort(key=lambda x: x[0])\n    top_candidates = candidates[:top_k]\n\n    # random choice among the top 3\n    chosen = rng.choice(top_candidates, replace=False)[0]\n    return (chosen[1], chosen[2])\n\n",
  "cheapest_customer_per_facility_round_robin_aug_106": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    loads = np.asarray([len(a) for a in assignments], dtype=int)\n    f_order = np.argsort(loads)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    for f in f_order:\n        feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n        if feas_c.size == 0:\n            continue\n        # deterministic noise for tie\u2011breaking\n        noise = 1e-6 * np.arange(feas_c.size)\n        cost_vals = costs[f, feas_c] + noise\n        # soft\u2011min with temperature 0.5\n        temp = 0.5\n        exp_vals = np.exp(-cost_vals / (temp + 1e-12))\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n        idx = np.argmax(probs)\n        return int(feas_c[idx]), int(f)\n\n    return None, None\n\n",
  "cheapest_customer_per_facility_round_robin_aug_107": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    loads = np.asarray([len(a) for a in assignments], dtype=int)\n    f_order = np.argsort(loads)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    idx_f = 0\n    while idx_f < len(f_order):\n        f = f_order[idx_f]\n        feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n        if feas_c.size > 0:\n            # deterministic noise\n            noise = 1e-6 * np.arange(feas_c.size)\n            cost_vals = costs[f, feas_c] + noise\n            # pick among top\u2011k cheapest\n            top_k = 7\n            sorted_idx = np.argsort(cost_vals)\n            top_idx = sorted_idx[:min(top_k, feas_c.size)]\n            chosen = np.random.choice(top_idx)\n            return int(feas_c[chosen]), int(f)\n        idx_f += 1\n\n    return None, None\n\n",
  "cheapest_customer_per_facility_round_robin_aug_108": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # use squared loads and mean for load measurement\n    loads = np.mean(np.square(np.asarray([len(a) for a in assignments], dtype=int)), dtype=float)\n    _ = loads  # value retained for readability\n\n    f_order = np.argsort(np.square(np.asarray([len(a) for a in assignments], dtype=int)))\n\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    for f in f_order:\n        feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n        if feas_c.size == 0:\n            continue\n        # clip costs to avoid extreme values\n        cost_vals = np.clip(costs[f, feas_c], 0, 1e6)\n        # deterministic noise for tie\u2011breaking\n        noise = 1e-6 * np.arange(feas_c.size)\n        cost_vals += noise\n        idx = np.argmin(cost_vals)\n        return int(feas_c[idx]), int(f)\n\n    return None, None\n\n",
  "cheapest_customer_per_facility_round_robin_aug_109": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    loads = np.asarray([len(a) for a in assignments], dtype=int)\n    # pick facility with maximum load first\n    max_load = np.max(loads)\n    candidate_facs = np.where(loads == max_load)[0]\n    if candidate_facs.size == 0:\n        candidate_facs = np.arange(len(loads))\n    f = np.random.choice(candidate_facs)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n    if feas_c.size == 0:\n        # fallback to any facility\n        f_order = np.argsort(loads)[::-1]\n        for f in f_order:\n            feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n            if feas_c.size > 0:\n                break\n        else:\n            return None, None\n\n    # weighted score: capacity slack + inverse cost\n    slack = (caps[f] - dem[feas_c]) / (caps[f] + 1e-12)\n    inv_cost = 1.0 / (costs[f, feas_c] + 1e-12)\n    score = 0.6 * slack + 0.4 * inv_cost\n    score = np.clip(score, 0, 1e6)\n    idx = np.argmax(score)\n    return int(feas_c[idx]), int(f)\n\n",
  "cheapest_pair_with_tie_break_by_remaining_capacity_aug_110": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection with a weighted tie\u2011break based on remaining capacity.\n    Uses list comprehensions and a small deterministic noise term for reproducibility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands,   dtype=float)\n    costs = np.asarray(assignment_costs,  dtype=float)\n\n    # Build list of all feasible (customer, facility) pairs\n    feas_pairs = [(c, f) for c in remaining_customers\n                         for f in range(caps.size)\n                         if caps[f] >= dem[c]]\n\n    if not feas_pairs:\n        return None, None\n\n    # Compute cost and remaining capacity after assignment\n    cost_arr = np.array([costs[f, c] for c, f in feas_pairs], dtype=float)\n    rem_arr  = np.array([caps[f] - dem[c] for c, f in feas_pairs], dtype=float)\n\n    # Small weight that favours larger remaining capacity\n    weight = 0.01\n    score = cost_arr - weight * rem_arr\n\n    # Deterministic noise to break ties\n    noise = np.arange(len(score)) * 1e-9\n    score += noise\n\n    best_idx = np.argmin(score)\n    chosen_c, chosen_f = feas_pairs[best_idx]\n    return chosen_c, chosen_f\n\n",
  "cheapest_pair_with_tie_break_by_remaining_capacity_aug_111": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Randomised top\u2011k selection with a while\u2011loop and deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands,   dtype=float)\n    costs = np.asarray(assignment_costs,  dtype=float)\n\n    feas_pairs = []\n    idx = 0\n    # while\u2011loop to collect feasible pairs\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            feas_pairs.append((c, f))\n        idx += 1\n\n    if not feas_pairs:\n        return None, None\n\n    # Cost array with small random noise for tie\u2011breaking\n    cost_arr = np.array([costs[f, c] for c, f in feas_pairs], dtype=float)\n    noise = np.random.uniform(0, 1e-6, size=cost_arr.shape)\n    cost_noisy = cost_arr + noise\n\n    # Top\u2011k minimal costs (k=5)\n    top_k = 5\n    if cost_noisy.size <= top_k:\n        top_indices = np.arange(cost_noisy.size)\n    else:\n        top_indices = np.argpartition(cost_noisy, top_k)[:top_k]\n\n    # Randomly choose among the top\u2011k\n    chosen_idx = np.random.choice(top_indices)\n    chosen_c, chosen_f = feas_pairs[chosen_idx]\n    return chosen_c, chosen_f\n\n",
  "cheapest_pair_with_tie_break_by_remaining_capacity_aug_112": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Fully vectorised selection with np.clip for safety and deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps   = np.asarray(remaining_capacities, dtype=float)\n    dem    = np.asarray(customer_demands,   dtype=float)\n    costs  = np.asarray(assignment_costs,  dtype=float)\n\n    # Feasibility mask (facilities x customers)\n    feas_mask = caps[:, None] >= dem[None, :]\n    # Masked costs and remaining capacities\n    masked_costs = np.where(feas_mask, costs, np.inf)\n    rem_after    = np.where(feas_mask, caps[:, None] - dem[None, :], -np.inf)\n\n    # Clip negative remaining capacities to zero (just in case)\n    rem_after = np.clip(rem_after, 0, None)\n\n    # Weighted score: lower cost better, higher remaining capacity better\n    weight = 0.02\n    score = masked_costs - weight * rem_after\n\n    # Add deterministic noise to break ties\n    noise = np.arange(score.size) * 1e-9\n    score += noise\n\n    flat_idx = np.argmin(score)\n    fac_idx, cust_idx = np.unravel_index(flat_idx, score.shape)\n\n    if np.isinf(score[fac_idx, cust_idx]):\n        return None, None\n    return int(cust_idx), int(fac_idx)\n\n",
  "cheapest_pair_with_tie_break_by_remaining_capacity_aug_113": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min probabilistic selection with temperature scaling and epsilon safety.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps   = np.asarray(remaining_capacities, dtype=float)\n    dem    = np.asarray(customer_demands,   dtype=float)\n    costs  = np.asarray(assignment_costs,  dtype=float)\n\n    # Feasibility mask\n    feas_mask = caps[:, None] >= dem[None, :]\n    # Replace infeasible costs with a large value\n    masked_costs = np.where(feas_mask, costs, 1e9)\n\n    # Temperature\u2011scaled softmin probabilities\n    temperature = 10.0\n    # Avoid overflow by subtracting min\n    min_cost = np.min(masked_costs)\n    exp_vals = np.exp(-(masked_costs - min_cost) / temperature)\n    exp_vals = np.where(feas_mask, exp_vals, 0.0)\n\n    # Normalise with epsilon to avoid division by zero\n    prob_sum = np.sum(exp_vals) + 1e-12\n    probs = exp_vals / prob_sum\n\n    # Flatten and sample\n    flat_idx = np.random.choice(probs.size, p=probs.ravel())\n    fac_idx, cust_idx = np.unravel_index(flat_idx, probs.shape)\n\n    # If the chosen pair is infeasible (should not happen), return None\n    if not feas_mask[fac_idx, cust_idx]:\n        return None, None\n    return int(cust_idx), int(fac_idx)\n\n",
  "adaptive_alpha_cost_plus_slack_aug_114": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 1 \u2013 Uses a while\u2011loop, soft\u2011min selection, and a slightly different alpha.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Local random generator for deterministic noise\n    rng = np.random.default_rng(42)\n\n    # Convert to numpy arrays for vectorised operations\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Progress\u2011dependent trade\u2011off parameter\n    total_assigned = sum(len(a) for a in assignments)\n    total_rem = len(remaining_customers)\n    progress = total_assigned / max(1, total_assigned + total_rem)\n    alpha = 1.0 + 8.0 * progress   # tuned coefficient\n\n    best_cost, best_cust, best_fac = np.inf, None, None\n\n    # Iterate over customers using a while loop\n    customers = list(remaining_customers)          # copy to allow pop\n    while customers:\n        cust = customers.pop()\n        d = float(dem[cust])\n\n        # Facilities that can serve this customer\n        feas_idx = np.where(caps >= d)[0]\n        if feas_idx.size == 0:\n            continue\n\n        slack = caps[feas_idx] - d\n        # Add epsilon to avoid division by zero\n        inv_slack = 1.0 / (slack + 1.0 + 1e-12)\n\n        # Compute score and apply soft\u2011min weighting\n        score = costs[feas_idx, cust] + alpha * inv_slack\n        probs = np.exp(-score)\n        probs /= probs.sum()\n        chosen = rng.choice(feas_idx, p=probs)\n\n        val = score[np.where(feas_idx == chosen)[0][0]]\n        if val < best_cost:\n            best_cost, best_cust, best_fac = val, cust, int(chosen)\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "adaptive_alpha_cost_plus_slack_aug_115": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 2 \u2013 List\u2011comprehension based feasibility, median slack, and deterministic noise.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng(123)\n\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, None)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    total_assigned = sum(len(a) for a in assignments)\n    total_rem = len(remaining_customers)\n    progress = total_assigned / max(1, total_assigned + total_rem)\n    alpha = 1.5 + 10.0 * progress   # tuned coefficient\n\n    best_val, best_c, best_f = np.inf, None, None\n\n    for cust in remaining_customers:\n        d = float(dem[cust])\n        feas = [f for f, cap in enumerate(caps) if cap >= d]\n        if not feas:\n            continue\n\n        slack = np.asarray([caps[f] - d for f in feas], dtype=float)\n        inv_slack = 1.0 / (slack + 1.0 + 1e-12)\n        # Use median of slack for robustness\n        median_slack = np.median(slack)\n        score = costs[feas, cust] + alpha * (1.0 / (median_slack + 1.0 + 1e-12))\n        # Add tiny deterministic noise for tie\u2011breaking\n        noise = rng.uniform(0, 1e-6, size=score.shape)\n        score += noise\n        idx = np.argmin(score)\n        chosen_fac = int(feas[idx])\n        val = float(score[idx])\n\n        if val < best_val:\n            best_val, best_c, best_f = val, cust, chosen_fac\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "adaptive_alpha_cost_plus_slack_aug_116": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 3 \u2013 Fully vectorised selection with random choice among top\u20113 ties.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng(7)\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    total_assigned = sum(len(a) for a in assignments)\n    total_rem = len(remaining_customers)\n    progress = total_assigned / max(1, total_assigned + total_rem)\n    alpha = 1.2 + 9.0 * progress   # tuned coefficient\n\n    # Broadcast capacities and demands to create feasibility matrix\n    feas = caps[:, None] >= dem[None, :]\n    # Large negative for infeasible to avoid affecting min\n    slack = np.where(feas, caps[:, None] - dem[None, :], -1e9)\n    inv_slack = 1.0 / (slack + 1.0 + 1e-12)\n\n    # Weighted score: cost + alpha * inv_slack\n    score = costs + alpha * inv_slack\n\n    # Find global minimum across all customer\u2011facility pairs\n    min_idx = np.unravel_index(np.argmin(score), score.shape)\n    min_val = score[min_idx]\n    best_c, best_f = int(min_idx[1]), int(min_idx[0])\n\n    # Resolve ties: find all indices with the same minimal score\n    tie_mask = np.isclose(score, min_val, atol=1e-12)\n    tie_indices = np.argwhere(tie_mask)\n    if tie_indices.shape[0] > 3:\n        chosen = rng.choice(tie_indices.shape[0], size=3, replace=False)\n        tie_indices = tie_indices[chosen]\n    # Pick the first of the remaining ties\n    best_f, best_c = int(tie_indices[0, 0]), int(tie_indices[0, 1])\n\n    return (best_c, best_f)\n\n",
  "adaptive_alpha_cost_plus_slack_aug_117": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 4 \u2013 While loop with max\u2011slack and mean\u2011based scoring, plus deterministic noise.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng(99)\n\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, None)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    total_assigned = sum(len(a) for a in assignments)\n    total_rem = len(remaining_customers)\n    progress = total_assigned / max(1, total_assigned + total_rem)\n    alpha = 1.8 + 11.0 * progress   # tuned coefficient\n\n    best_val, best_cust, best_fac = np.inf, None, None\n\n    customers = list(remaining_customers)\n    while customers:\n        cust = customers.pop()\n        d = float(dem[cust])\n\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        slack = caps[feas] - d\n        # Use max slack to favour facilities with more spare capacity\n        max_slack = np.max(slack)\n        inv_slack = 1.0 / (max_slack + 1.0 + 1e-12)\n\n        # Mean of costs as a proxy for average performance\n        mean_cost = np.mean(costs[feas, cust])\n        score = mean_cost + alpha * inv_slack\n\n        # Deterministic noise for tie\u2011breaking\n        noise = rng.uniform(0, 1e-6, size=feas.shape)\n        score += noise\n        idx = np.argmin(score)\n        chosen_fac = int(feas[idx])\n        val = float(score[idx])\n\n        if val < best_val:\n            best_val, best_cust, best_fac = val, cust, chosen_fac\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "randomized_customer_order_cheapest_aug_118": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Randomly shuffle the customers each call\n    customers = remaining_customers.copy()\n    rng.shuffle(customers)\n\n    for c in customers:\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size == 0:\n            continue\n        # Deterministic tie\u2011breaking noise\n        noise = np.arange(feasible.size, dtype=float) * 1e-9\n        idx = np.argmin(costs[feasible, c] + noise)\n        f = int(feasible[idx])\n        return int(c), f\n\n    return None, None\n\n",
  "randomized_customer_order_cheapest_aug_119": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    customers = remaining_customers.copy()\n    rng.shuffle(customers)\n\n    idx = 0\n    while idx < len(customers):\n        c = customers[idx]\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size == 0:\n            idx += 1\n            continue\n\n        eps = 1e-12\n        load_factor = dem[c] / (caps[feasible] + eps)\n        scores = costs[feasible, c] + 0.5 * load_factor\n\n        # Soft\u2011min selection\n        beta = 5.0\n        exp_scores = np.exp(-beta * scores)\n        probs = exp_scores / np.maximum(np.sum(exp_scores), 1e-12)\n\n        f = int(rng.choice(feasible, p=probs))\n        return int(c), f\n\n    return None, None\n\n",
  "randomized_customer_order_cheapest_aug_120": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    customers = remaining_customers.copy()\n    rng.shuffle(customers)\n\n    for c in customers:\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size == 0:\n            continue\n\n        # Average cost per customer (unused in the final choice but kept for semantic diversity)\n        avg_cost = np.mean(costs[feasible, c])\n\n        # Pick the k cheapest facilities\n        k = 3\n        sorted_idx = np.argsort(costs[feasible, c])\n        top_k = feasible[sorted_idx[:k]]\n\n        noise = np.arange(len(top_k), dtype=float) * 1e-8\n        best_idx = np.argmin(costs[top_k, c] + noise)\n        f = int(top_k[best_idx])\n\n        return int(c), f\n\n    return None, None\n\n",
  "randomized_customer_order_cheapest_aug_121": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Build all feasible (customer, facility) pairs\n    pairs = [(c, f) for c in remaining_customers\n             for f in np.where(caps >= dem[c])[0]]\n\n    if not pairs:\n        return None, None\n\n    # Score each pair with a soft\u2011max probability\n    scores = []\n    for c, f in pairs:\n        cap_ratio = (caps[f] - dem[c]) / (caps[f] + 1e-12)\n        scores.append(costs[f, c] - 0.3 * cap_ratio)\n\n    scores = np.asarray(scores, dtype=float)\n    beta = 3.0\n    exp_scores = np.exp(-beta * scores)\n    probs = exp_scores / np.maximum(np.sum(exp_scores), 1e-12)\n\n    idx = int(rng.choice(len(pairs), p=probs))\n    c, f = pairs[idx]\n    return int(c), int(f)\n\n",
  "customer_best_cost_then_high_demand_tiebreak_aug_122": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection with deterministic noise and while\u2011loop control flow.\"\"\"\n    # Rename for clarity\n    assign_grid = assignments\n    cust_pool   = remaining_customers\n    cap_pool    = remaining_capacities\n    dem         = customer_demands\n    cost_mat    = assignment_costs\n\n    if not cust_pool:\n        return None, None\n\n    caps_arr  = np.asarray(cap_pool, dtype=float)\n    dem_arr   = np.asarray(dem, dtype=float)\n    cost_arr  = np.clip(np.asarray(cost_mat, dtype=float), 0, np.inf)\n\n    # Small deterministic noise to break ties\n    noise = 1e-6 * np.arange(len(cust_pool))\n\n    best = (np.inf, -np.inf, None, None)  # (best_cost, demand, customer, facility)\n\n    idx = 0\n    while idx < len(cust_pool):\n        c = cust_pool[idx]\n        feas = np.where(caps_arr >= dem_arr[c])[0]\n        if feas.size:\n            feas_costs = cost_arr[feas, c] + noise[idx]\n            f_idx = feas[feas_costs.argmin()]\n            bc = float(cost_arr[f_idx, c])\n            if (bc < best[0]) or (bc == best[0] and dem_arr[c] > best[1]):\n                best = (bc, float(dem_arr[c]), int(c), int(f_idx))\n        idx += 1\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "customer_best_cost_then_high_demand_tiebreak_aug_123": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min based selection with temperature scaling and epsilon\u2011protected normalisation.\"\"\"\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float), 0, np.inf)\n\n    best = (np.inf, -np.inf, None, None)  # (best_cost, demand, customer, facility)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size:\n            feas_costs = costs[feas, c]\n            # Soft\u2011min with temperature\n            T = 0.5\n            weights = np.exp(-feas_costs / (T + 1e-12))\n            weights /= (weights.sum() + 1e-12)          # epsilon\u2011protected normalisation\n            f = feas[np.argmax(weights)]\n            bc = float(costs[f, c])\n            if (bc < best[0]) or (bc == best[0] and dem[c] > best[1]):\n                best = (bc, float(dem[c]), int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "customer_best_cost_then_high_demand_tiebreak_aug_124": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Randomised top\u2011k choice among the two cheapest feasible facilities.\"\"\"\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float), 0, np.inf)\n\n    rng = np.random.default_rng(42)          # deterministic seed\n    best = (np.inf, -np.inf, None, None)     # (best_cost, demand, customer, facility)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size:\n            feas_costs = costs[feas, c]\n            sorted_idx = np.argsort(feas_costs)\n            top_k = min(2, feas.size)\n            candidates = feas[sorted_idx[:top_k]]\n            f = rng.choice(candidates)      # random among best two\n            bc = float(costs[f, c])\n            if (bc < best[0]) or (bc == best[0] and dem[c] > best[1]):\n                best = (bc, float(dem[c]), int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "customer_best_cost_then_high_demand_tiebreak_aug_125": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised global search over the feasible sub\u2011matrix.\"\"\"\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float), 0, np.inf)\n\n    # Map indices to sub\u2011matrices\n    fac_ids = np.asarray(remaining_capacities, dtype=int)\n    cust_ids = np.asarray(remaining_customers, dtype=int)\n\n    caps_sub = caps[fac_ids]\n    dem_sub  = dem[cust_ids]\n    cost_sub = costs[np.ix_(fac_ids, cust_ids)]\n\n    # Feasibility mask\n    feasible = caps_sub[:, None] >= dem_sub[None, :]\n    large = np.inf\n    masked_cost = np.where(feasible, cost_sub, large)\n\n    flat_idx = np.argmin(masked_cost)\n    if np.isinf(masked_cost.flat[flat_idx]):\n        return None, None\n\n    f_idx, c_idx = np.unravel_index(flat_idx, masked_cost.shape)\n    return int(cust_ids[c_idx]), int(fac_ids[f_idx])\n\n",
  "greedy_with_facility_risk_of_starvation_aug_126": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 1 \u2013 vectorised best\u2011facility search with deterministic noise.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    delta = 1.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # 1\ufe0f\u20e3  Determine each customer's best feasible facility\n    best_fac = {}\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        best_idx = int(np.argmin(costs[feas, c]))\n        best_fac[int(c)] = int(feas[best_idx])\n\n    # 2\ufe0f\u20e3  Count how many customers consider each facility the best\n    belong = np.zeros(len(caps), dtype=float)\n    for f in best_fac.values():\n        belong[f] += 1.0\n\n    # 3\ufe0f\u20e3  Fragility (small capacity + many dependents)\n    frag = (belong + 1.0) / (caps + 1.0 + 1e-12)\n    frag = np.clip(frag, 0, np.inf)          # safety clip\n\n    # 4\ufe0f\u20e3  Pick the best customer\u2013facility pair\n    best_val = np.inf\n    best_c, best_f = None, None\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        score = costs[feas, c] + delta * frag[feas]\n        # deterministic tie\u2011breaker: tiny noise depending on customer id\n        noise = (c % 5) * 1e-6\n        score += noise\n        idx = int(np.argmin(score))\n        if score[idx] < best_val:\n            best_val = float(score[idx])\n            best_c = int(c)\n            best_f = int(feas[idx])\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "greedy_with_facility_risk_of_starvation_aug_127": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 2 \u2013 while\u2011loop traversal, median\u2011based fragility, random top\u2011k choice.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    delta = 0.7\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem = list(remaining_customers)\n\n    # 1\ufe0f\u20e3  Best\u2011facility mapping\n    best_fac = {}\n    while rem:\n        c = rem.pop()\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        best_idx = int(np.argmin(costs[feas, c]))\n        best_fac[int(c)] = int(feas[best_idx])\n\n    # 2\ufe0f\u20e3  Count dependents\n    belong = np.zeros(len(caps), dtype=float)\n    for f in best_fac.values():\n        belong[f] += 1.0\n\n    # 3\ufe0f\u20e3  Fragility using median of dependents\n    frag = np.clip(\n        np.median(belong + 1) / (caps + 1 + 1e-12),\n        0,\n        np.inf,\n    )\n\n    # 4\ufe0f\u20e3  Random top\u2011k selection per customer\n    rng = np.random.default_rng(42)          # deterministic seed\n    best_val = np.inf\n    best_c, best_f = None, None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        score = costs[feas, c] + delta * frag[feas]\n        score = np.clip(score, 0, 1e9)       # avoid overflow\n        top_k = np.argpartition(score, 3)[:3]   # indices of three smallest scores\n        chosen = top_k[rng.integers(0, len(top_k))]\n        val = float(score[chosen])\n        if val < best_val:\n            best_val = val\n            best_c = int(c)\n            best_f = int(feas[chosen])\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "greedy_with_facility_risk_of_starvation_aug_128": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 4 \u2013 while loop, sum\u2011based fragility, deterministic noise, delta = 0.5.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    delta = 0.5\n    cap = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    custs = list(remaining_customers)\n\n    # 1\ufe0f\u20e3  Best\u2011facility lookup\n    best_fac = {}\n    while custs:\n        c = custs.pop()\n        feas = np.where(cap >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        best_idx = int(np.argmin(costs[feas, c]))\n        best_fac[int(c)] = int(feas[best_idx])\n\n    # 2\ufe0f\u20e3  Count dependents\n    belong = np.zeros(len(cap), dtype=float)\n    for f in best_fac.values():\n        belong[f] += 1.0\n\n    # 3\ufe0f\u20e3  Fragility via sum of dependents\n    frag = np.clip(\n        np.sum(belong + 1) / (cap + 1 + 1e-12),\n        0,\n        np.inf,\n    )\n\n    # 4\ufe0f\u20e3  Deterministic selection with noise\n    best_val = np.inf\n    best_c, best_f = None, None\n    for c in remaining_customers:\n        feas = np.where(cap >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        score = costs[feas, c] + delta * frag[feas]\n        # small deterministic noise\n        noise = ((c * 17) % 9) * 1e-6\n        score += noise\n        idx = int(np.argmin(score))\n        val = float(score[idx])\n        if val < best_val:\n            best_val = val\n            best_c = int(c)\n            best_f = int(feas[idx])\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "max_avg_cost_customer_then_best_facility_aug_129": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Hard\u2011first: pick customer with highest median feasible cost; assign to its cheapest feasible facility.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n    cost_mat = np.clip(cost_mat, 0, np.inf)  # ensure non\u2011negative values\n\n    best_key = None\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas_idx = np.where(cap_arr >= dem_arr[c])[0]\n        if feas_idx.size == 0:\n            continue\n\n        feas_costs = cost_mat[feas_idx, c]\n        mean_cost = float(np.median(feas_costs + 1e-12))  # deterministic noise in mean\n        f = int(feas_idx[np.argmin(feas_costs)])\n\n        # deterministic tie\u2011breaking noise\n        noise = (c * 1e-6) + (f * 1e-7)\n        key = (-mean_cost, float(cost_mat[f, c]) + noise)\n\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "max_avg_cost_customer_then_best_facility_aug_130": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Weighted hard\u2011first with random top\u2011k selection.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n    cost_mat = np.clip(cost_mat, 0, np.inf)\n\n    rng = np.random.default_rng()\n    best_key = None\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas_idx = np.where(cap_arr >= dem_arr[c])[0]\n        if feas_idx.size == 0:\n            continue\n\n        feas_costs = cost_mat[feas_idx, c]\n        mean_cost = float(np.sum(feas_costs) / (feas_idx.size + 1e-12))\n        min_cost = float(np.min(feas_costs))\n\n        # weighted score: 0.6*mean + 0.4*min\n        weighted_score = 0.6 * mean_cost + 0.4 * min_cost\n\n        # random choice among the cheapest top\u20113\n        sorted_idx = np.argsort(feas_costs)\n        top_k = min(3, feas_idx.size)\n        chosen = feas_idx[sorted_idx[rng.integers(0, top_k)]]\n\n        key = (-weighted_score, float(cost_mat[chosen, c]))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(chosen)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "max_avg_cost_customer_then_best_facility_aug_131": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Iterative selection with variance proxy and deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n    cost_mat = np.clip(cost_mat, 0, np.inf)\n\n    best_key = None\n    best_c = None\n    best_f = None\n\n    cust_iter = iter(remaining_customers)\n    while True:\n        try:\n            cust = next(cust_iter)\n        except StopIteration:\n            break\n\n        feas = np.where(cap_arr >= dem_arr[cust])[0]\n        if feas.size == 0:\n            continue\n\n        feas_costs = cost_mat[feas, cust]\n        var_proxy = np.var(feas_costs ** 2)  # variance proxy via squared costs\n        mean_cost = float(np.mean(feas_costs + 1e-12))\n        score = mean_cost + 0.1 * var_proxy\n\n        # deterministic tie\u2011breaking noise\n        noise = (cust ** 2) * 1e-6 + (feas[0] ** 2) * 1e-7\n        key = (score, noise)\n\n        chosen = feas[np.argmin(feas_costs)]\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(cust)\n            best_f = int(chosen)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "max_avg_cost_customer_then_best_facility_aug_132": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min based selection with summed costs and deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n    cost_mat = np.clip(cost_mat, 0, np.inf)\n\n    rng = np.random.default_rng()\n    best_key = None\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(cap_arr >= dem_arr[c])[0]\n        if feas.size == 0:\n            continue\n\n        feas_costs = cost_mat[feas, c]\n        total_cost = float(np.sum(feas_costs + 1e-12))\n\n        # soft\u2011min: inverse of cost\n        inv = 1.0 / (feas_costs + 1e-12)\n        softmin = feas[np.argmax(inv)]\n\n        score = 0.7 * total_cost + 0.3 * float(cost_mat[softmin, c])\n\n        # small deterministic noise\n        noise = (c * 1e-6) + (softmin * 1e-7)\n        key = (score, noise)\n\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(softmin)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "thresholded_options_count_priority_aug_133": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised selection using a soft\u2011min facility choice and median threshold.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    dem = np.asarray(customer_demands, dtype=np.float64)\n    C = np.asarray(assignment_costs, dtype=np.float64)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Gather all feasible costs for threshold computation\n    feas_vals = [\n        C[feas, c].tolist()\n        for c in rem\n        for feas in [np.where(caps >= dem[c])[0]]\n        if feas.size\n    ]\n    if not feas_vals:\n        return None, None\n    # Median threshold\n    thr = float(np.median([v for sub in feas_vals for v in sub]))\n\n    rng = np.random.default_rng(0)  # deterministic noise\n    best_c, best_f = None, None\n    best_score = np.inf\n\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        costs = C[feas, c]\n        # Add tiny deterministic noise for tie\u2011breaking\n        noise = rng.uniform(-1e-8, 1e-8, size=feas.shape[0])\n        costs_noisy = costs + noise\n\n        # Soft\u2011min facility selection\n        alpha = 5.0\n        exp_vals = np.exp(-alpha * costs_noisy)\n        denom = exp_vals.sum() + 1e-12          # epsilon to avoid div\u2011by\u2011zero\n        probs = exp_vals / denom\n        probs = np.clip(probs, 1e-12, 1.0)      # keep probabilities valid\n\n        # Expected facility index (rounded)\n        idx = int(np.round(np.sum(probs * feas)))\n        # Scoring: fewest good options + weighted cost\n        good = int(np.sum(costs_noisy <= thr))\n        score = good + 0.5 * C[idx, c]\n        if score < best_score:\n            best_score = score\n            best_c, best_f = int(c), int(idx)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "thresholded_options_count_priority_aug_134": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"While\u2011loop based selection with mean\u2011plus\u2011std threshold and top\u2011k logic.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    dem = np.asarray(customer_demands, dtype=np.float64)\n    C = np.asarray(assignment_costs, dtype=np.float64)\n\n    rem = list(remaining_customers)\n    best_c, best_f = None, None\n\n    while rem:\n        # Compute threshold using mean + 0.1*std (manual division with epsilon)\n        feas_vals = []\n        for c in rem:\n            feas = np.where(caps >= dem[c])[0]\n            if feas.size:\n                feas_vals.extend(C[feas, c].tolist())\n        if not feas_vals:\n            break\n        sum_vals = np.sum(feas_vals)\n        count_vals = len(feas_vals)\n        mean = sum_vals / (count_vals + 1e-12)\n        std = np.sqrt(np.sum((np.array(feas_vals) - mean) ** 2) / (count_vals + 1e-12))\n        thr = float(mean + 0.1 * std)\n\n        # Pick customer with fewest feasible facilities\n        min_feas = np.inf\n        candidate_c = None\n        for c in rem:\n            feas = np.where(caps >= dem[c])[0]\n            if feas.size == 0:\n                continue\n            if feas.size < min_feas:\n                min_feas = feas.size\n                candidate_c = c\n        if candidate_c is None:\n            break\n\n        feas = np.where(caps >= dem[candidate_c])[0]\n        costs = C[feas, candidate_c]\n        # Clip costs to avoid extreme values\n        costs = np.clip(costs, 0.0, 1e6)\n        good = int(np.sum(costs <= thr))\n        idx = int(feas[np.argmin(costs)])\n        best_c, best_f = int(candidate_c), int(idx)\n        rem.remove(candidate_c)\n        break\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "thresholded_options_count_priority_aug_135": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"List\u2011comprehension based threshold, max aggregation, and random top\u2011k facility choice.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    dem = np.asarray(customer_demands, dtype=np.float64)\n    C = np.asarray(assignment_costs, dtype=np.float64)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Gather feasible costs via list comprehension\n    feas_vals = [\n        C[feas, c]\n        for c in rem\n        for feas in [np.where(caps >= dem[c])[0]]\n        if feas.size\n    ]\n    if not feas_vals:\n        return None, None\n\n    # Use maximum cost as threshold\n    thr = float(np.max([v.max() for v in feas_vals]))\n\n    rng = np.random.default_rng(1)  # deterministic\n    best_c, best_f = None, None\n    best_score = np.inf\n\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n\n        costs = C[feas, c]\n        # Random choice among top\u2011k (k=7) cheapest facilities\n        k = min(7, feas.size)\n        top_k_idx = np.argpartition(costs, k - 1)[:k]\n        chosen_idx = rng.choice(top_k_idx)\n        idx = int(feas[chosen_idx])\n\n        # Scoring: good options + ratio of cost to remaining capacity\n        good = int(np.sum(costs <= thr))\n        ratio = costs[chosen_idx] / (caps[idx] + 1e-12)  # epsilon\n        score = good + ratio\n        if score < best_score:\n            best_score = score\n            best_c, best_f = int(c), int(idx)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "thresholded_options_count_priority_aug_136": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"While\u2011loop with inverted logic, clipped costs, and weighted scoring.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    dem = np.asarray(customer_demands, dtype=np.float64)\n    C = np.asarray(assignment_costs, dtype=np.float64)\n\n    rem = list(remaining_customers)\n    best_c, best_f = None, None\n\n    while rem:\n        # Threshold: 30th percentile of all feasible costs\n        feas_vals = []\n        for c in rem:\n            feas = np.where(caps >= dem[c])[0]\n            if feas.size:\n                feas_vals.extend(C[feas, c].tolist())\n        if not feas_vals:\n            break\n        thr = float(np.quantile(np.asarray(feas_vals), 0.30))\n\n        # Invert selection: pick customer with most feasible facilities\n        max_feas = -1\n        candidate_c = None\n        for c in rem:\n            feas = np.where(caps >= dem[c])[0]\n            if feas.size > max_feas:\n                max_feas = feas.size\n                candidate_c = c\n        if candidate_c is None:\n            break\n\n        feas = np.where(caps >= dem[candidate_c])[0]\n        costs = C[feas, candidate_c]\n        # Clip costs to [0, 1e6] to avoid extreme values\n        costs = np.clip(costs, 0.0, 1e6)\n\n        # Weighted scoring: 0.6 * good options + 0.4 * normalized cost\n        good = int(np.sum(costs <= thr))\n        norm_cost = costs / (np.max(costs) + 1e-12)  # epsilon\n        idx = int(feas[np.argmin(norm_cost)])\n        score = 0.6 * good + 0.4 * norm_cost[np.argmin(norm_cost)]\n\n        if best_c is None or score < best_score:\n            best_c, best_f = int(candidate_c), int(idx)\n            best_score = score\n\n        rem.remove(candidate_c)\n        break\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "minimize_variance_of_remaining_capacities_aug_137": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Greedy selection based on the variance of remaining capacities.\n    Uses a fully vectorised approach for each customer but still loops over customers.\n    Adds a tiny random noise to the cost for deterministic tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (var_after, cost, customer, facility)\n\n    for c in remaining_customers:\n        d = dem[c]\n        feasible = np.where(caps0 >= d)[0]\n        for f in feasible:\n            caps = caps0.copy()\n            caps[f] -= d\n            var_after = np.var(caps) + 1e-12          # epsilon to avoid exact 0\n            cost = C[f, c]\n            noise = np.random.uniform(0, 1e-6)       # deterministic tie\u2011break\n            key = (var_after, cost + noise)\n            if key < best[:2]:\n                best = (var_after, cost + noise, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "minimize_variance_of_remaining_capacities_aug_138": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Selects the next assignment using a soft\u2011min score (variance + 0.5*cost)\n    and then randomly picks one among the top\u2011k best candidates.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    scores = []\n    pairs = []\n\n    for c in remaining_customers:\n        d = dem[c]\n        feasible = np.where(caps0 >= d)[0]\n        for f in feasible:\n            caps = caps0.copy()\n            caps[f] -= d\n            var_after = np.var(caps) + 1e-12\n            cost = C[f, c]\n            score = var_after + 0.5 * cost\n            scores.append(score)\n            pairs.append((int(c), int(f)))\n\n    if not scores:\n        return None, None\n\n    scores = np.array(scores)\n    exp_neg = np.exp(-scores)\n    probs = exp_neg / (np.sum(exp_neg) + 1e-12)   # epsilon on denominator\n\n    # Pick one of the top\u2011k candidates randomly\n    top_k = 5\n    idx_sorted = np.argsort(scores)               # ascending order\n    top_idx = idx_sorted[:top_k]\n    chosen = np.random.choice(top_idx)\n\n    return pairs[chosen]\n\n",
  "minimize_variance_of_remaining_capacities_aug_139": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses the median of remaining capacities as the objective instead of variance.\n    Adds a small noise to the cost for tie\u2011breaking and chooses the best pair.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (median_after, cost, customer, facility)\n\n    for c in remaining_customers:\n        d = dem[c]\n        feasible = np.where(caps0 >= d)[0]\n        for f in feasible:\n            caps = caps0.copy()\n            caps[f] -= d\n            med_after = np.median(caps) + 1e-12\n            cost = C[f, c] + np.random.uniform(0, 1e-6)   # noise for tie\u2011break\n            key = (med_after, cost)\n            if key < best[:2]:\n                best = (med_after, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "minimize_variance_of_remaining_capacities_aug_140": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Minimises the maximum remaining capacity after an assignment.\n    Capacities are clipped to avoid negative values.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (max_after, cost, customer, facility)\n\n    for c in remaining_customers:\n        d = dem[c]\n        feasible = np.where(caps0 >= d)[0]\n        for f in feasible:\n            caps = caps0.copy()\n            caps[f] -= d\n            caps = np.clip(caps, 0, caps0)           # ensure no negative capacity\n            max_after = np.max(caps) + 1e-12\n            cost = C[f, c]\n            key = (max_after, cost)\n            if key < best[:2]:\n                best = (max_after, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "gini_balance_penalty_aug_141": "import numpy as np\nfrom typing import List, Tuple\n\ndef _gini(x: np.ndarray) -> float:\n    x = np.asarray(x, dtype=float)\n    x = np.clip(x, 0.0, None)\n    if x.size == 0:\n        return 0.0\n    s = float(np.sum(x))\n    if s <= 1e-12:\n        return 0.0\n    xs = np.sort(x)\n    n = xs.size\n    idx = np.arange(1, n + 1, dtype=float)\n    denom = n * s + 1e-12\n    return float((2.0 * np.sum(idx * xs) / denom) - (n + 1.0) / n)\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    weight = 8.0  # tuned weight\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    best_score = np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas_f = np.where(caps0 >= d)[0]\n        for f in feas_f:\n            caps = caps0.copy()\n            caps[f] -= d\n            caps = np.clip(caps, 0.0, None)\n            score = float(cost[f, c]) + weight * _gini(caps) + 1e-9 * (c + f)  # tie\u2011breaking noise\n            if score < best_score:\n                best_score = score\n                best_c = int(c)\n                best_f = int(f)\n\n    return best_c, best_f\n\n",
  "gini_balance_penalty_aug_142": "import numpy as np\nfrom typing import List, Tuple\n\ndef _gini(x: np.ndarray) -> float:\n    x = np.asarray(x, dtype=float)\n    x = np.clip(x, 0.0, None)\n    if x.size == 0:\n        return 0.0\n    s = float(np.sum(x))\n    if s <= 1e-12:\n        return 0.0\n    xs = np.sort(x)\n    n = xs.size\n    idx = np.arange(1, n + 1, dtype=float)\n    denom = n * s + 1e-12\n    return float((2.0 * np.sum(idx * xs) / denom) - (n + 1.0) / n)\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng(seed=42)\n    weight = 5.0\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    candidates = []\n    scores = []\n\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[f] -= d\n            caps = np.clip(caps, 0.0, None)\n            score = float(cost[f, c]) + weight * _gini(caps)\n            candidates.append((int(c), int(f)))\n            scores.append(score)\n\n    if not candidates:\n        return None, None\n\n    scores_arr = np.array(scores, dtype=float)\n    # soft\u2011min probabilities\n    tau = 0.5\n    exp_vals = np.exp(-scores_arr / (tau + 1e-12))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    # pick among the top\u2011k highest probabilities\n    k = 3\n    top_k_idx = np.argpartition(probs, -k)[-k:]\n    top_k_probs = probs[top_k_idx]\n    chosen_idx = rng.choice(top_k_idx, p=top_k_probs / top_k_probs.sum())\n    return candidates[chosen_idx]\n\n",
  "gini_balance_penalty_aug_143": "import numpy as np\nfrom typing import List, Tuple\n\ndef _gini(vals: np.ndarray) -> float:\n    vals = np.asarray(vals, dtype=float)\n    vals = np.clip(vals, 0.0, None)\n    if vals.size == 0:\n        return 0.0\n    total = float(np.sum(vals))\n    if total <= 1e-12:\n        return 0.0\n    sorted_vals = np.sort(vals)\n    n = sorted_vals.size\n    indices = np.arange(1, n + 1, dtype=float)\n    denom = n * total + 1e-12\n    return float((2.0 * np.sum(indices * sorted_vals) / denom) - (n + 1.0) / n)\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    lambda_coef = 12.0  # tuned\n    caps_initial = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n\n    for cust in remaining_customers:\n        dem_val = float(demands[cust])\n        feasible_facs = np.where(caps_initial >= dem_val)[0]\n        for fac in feasible_facs:\n            caps_copy = caps_initial.copy()\n            caps_copy[fac] -= dem_val\n            caps_copy = np.clip(caps_copy, 0.0, None)\n            score = float(costs[fac, cust]) + lambda_coef * _gini(caps_copy) + 1e-7 * (cust - fac)\n            if score < best[0]:\n                best = (score, int(cust), int(fac))\n\n    return best[1], best[2]\n\n",
  "entropy_utilization_penalty_aug_144": "import numpy as np\nfrom typing import List, Tuple\n\ndef _entropy(p: np.ndarray) -> float:\n    \"\"\"Shannon entropy with clipping and safe division.\"\"\"\n    p = np.asarray(p, dtype=float)\n    p = np.clip(p, 1e-12, None)\n    p = p / float(np.sum(p) + 1e-12)\n    return float(-np.sum(p * np.log(p)))\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised search for the next facility\u2013customer assignment.\n    Uses a cost\u2011minus\u2011entropy score with deterministic tie breaking.\n    \"\"\"\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr  = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    n_cust = len(remaining_customers)\n    n_fac  = len(remaining_capacities)\n    scores = np.full((n_cust, n_fac), np.inf, dtype=float)\n\n    rng = np.random.default_rng()\n    noise = rng.uniform(0, 1e-6, size=(n_cust, n_fac))\n\n    for i, cust in enumerate(remaining_customers):\n        d = float(dem_arr[cust])\n        feasible = np.where(caps_arr >= d)[0]\n        if feasible.size == 0:\n            continue\n        for f in feasible:\n            new_caps = caps_arr.copy()\n            new_caps[f] -= d\n            ent = _entropy(new_caps + 1e-9)\n            scores[i, f] = float(cost_arr[f, cust]) - 3.0 * ent\n\n    # Add tiny noise for deterministic tie breaking\n    scores += noise\n    flat_idx = np.argmin(scores)\n    cust_idx, fac_idx = np.unravel_index(flat_idx, scores.shape)\n    return (remaining_customers[cust_idx], int(fac_idx)) if np.isfinite(scores[cust_idx, fac_idx]) else (None, None)\n\n",
  "entropy_utilization_penalty_aug_145": "import numpy as np\nfrom typing import List, Tuple\n\ndef _entropy(p: np.ndarray) -> float:\n    p = np.asarray(p, dtype=float)\n    p = np.clip(p, 1e-12, None)\n    p = p / float(np.sum(p) + 1e-12)\n    return float(-np.sum(p * np.log(p)))\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Greedy selection with a cost\u202f+\u202fentropy score.\n    Uses a larger beta and deterministic noise for tie breaking.\n    \"\"\"\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr  = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    n_cust = len(remaining_customers)\n    n_fac  = len(remaining_capacities)\n    scores = np.full((n_cust, n_fac), np.inf, dtype=float)\n\n    rng = np.random.default_rng()\n    noise = rng.uniform(0, 1e-6, size=(n_cust, n_fac))\n\n    for i, cust in enumerate(remaining_customers):\n        d = float(dem_arr[cust])\n        feasible = np.where(caps_arr >= d)[0]\n        if feasible.size == 0:\n            continue\n        for f in feasible:\n            new_caps = caps_arr.copy()\n            new_caps[f] -= d\n            ent = _entropy(new_caps + 1e-9)\n            # Cost is increased by entropy (positive beta)\n            scores[i, f] = float(cost_arr[f, cust]) + 2.5 * ent\n\n    scores += noise\n    flat_idx = np.argmin(scores)\n    cust_idx, fac_idx = np.unravel_index(flat_idx, scores.shape)\n    return (remaining_customers[cust_idx], int(fac_idx)) if np.isfinite(scores[cust_idx, fac_idx]) else (None, None)\n\n",
  "entropy_utilization_penalty_aug_146": "import numpy as np\nfrom typing import List, Tuple\n\ndef _entropy(p: np.ndarray) -> float:\n    p = np.asarray(p, dtype=float)\n    p = np.clip(p, 1e-12, None)\n    p = p / float(np.sum(p) + 1e-12)\n    return float(-np.sum(p * np.log(p)))\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Soft\u2011min sampling of the next assignment.\n    The probability of a candidate is proportional to exp(-score / T).\n    \"\"\"\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr  = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    n_cust = len(remaining_customers)\n    n_fac  = len(remaining_capacities)\n    scores = np.full((n_cust, n_fac), np.inf, dtype=float)\n\n    for i, cust in enumerate(remaining_customers):\n        d = float(dem_arr[cust])\n        feasible = np.where(caps_arr >= d)[0]\n        if feasible.size == 0:\n            continue\n        for f in feasible:\n            new_caps = caps_arr.copy()\n            new_caps[f] -= d\n            ent = _entropy(new_caps + 1e-9)\n            scores[i, f] = float(cost_arr[f, cust]) - 3.0 * ent\n\n    # Flatten and keep only feasible scores\n    flat_scores = scores.ravel()\n    feasible_mask = np.isfinite(flat_scores)\n    if not np.any(feasible_mask):\n        return (None, None)\n\n    # Soft\u2011min temperature\n    T = 1.0\n    # Compute probabilities, adding epsilon to avoid division by zero\n    logits = -flat_scores[feasible_mask] / (T + 1e-12)\n    exp_logits = np.exp(logits - np.max(logits))\n    probs = exp_logits / (np.sum(exp_logits) + 1e-12)\n\n    rng = np.random.default_rng()\n    chosen_flat = rng.choice(np.where(feasible_mask)[0], p=probs)\n    cust_idx, fac_idx = np.unravel_index(chosen_flat, scores.shape)\n    return (remaining_customers[cust_idx], int(fac_idx))\n\n",
  "entropy_utilization_penalty_aug_147": "import numpy as np\nfrom typing import List, Tuple\n\ndef _entropy(p: np.ndarray) -> float:\n    p = np.asarray(p, dtype=float)\n    p = np.clip(p, 1e-12, None)\n    p = p / float(np.sum(p) + 1e-12)\n    return float(-np.sum(p * np.log(p)))\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Randomly pick among the top\u2011k feasible assignments,\n    weighted by the inverse of the cost.\n    \"\"\"\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr  = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    n_cust = len(remaining_customers)\n    n_fac  = len(remaining_capacities)\n    scores = np.full((n_cust, n_fac), np.inf, dtype=float)\n\n    for i, cust in enumerate(remaining_customers):\n        d = float(dem_arr[cust])\n        feasible = np.where(caps_arr >= d)[0]\n        if feasible.size == 0:\n            continue\n        for f in feasible:\n            new_caps = caps_arr.copy()\n            new_caps[f] -= d\n            ent = _entropy(new_caps + 1e-9)\n            scores[i, f] = float(cost_arr[f, cust]) - 3.0 * ent\n\n    flat_scores = scores.ravel()\n    feasible_mask = np.isfinite(flat_scores)\n    if not np.any(feasible_mask):\n        return (None, None)\n\n    # Take the top\u2011k (k=3) lowest scores\n    top_k = 3\n    feasible_indices = np.where(feasible_mask)[0]\n    feasible_scores = flat_scores[feasible_indices]\n    if feasible_scores.size <= top_k:\n        chosen_idx = rng.choice(feasible_indices)\n    else:\n        top_indices = np.argpartition(feasible_scores, top_k)[:top_k]\n        top_mask = np.zeros_like(feasible_indices, dtype=bool)\n        top_mask[top_indices] = True\n        chosen_idx = rng.choice(feasible_indices[top_mask])\n\n    cust_idx, fac_idx = np.unravel_index(chosen_idx, scores.shape)\n    return (remaining_customers[cust_idx], int(fac_idx))\n\n",
  "zscore_facility_preference_aug_148": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised selection using median statistics and soft\u2011min weighting.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Compute median and std over remaining customers for each facility\n    mu = np.median(C[:, rem], axis=1)\n    sd = np.std(C[:, rem], axis=1, ddof=0)\n    sd = np.maximum(sd, 1e-12)          # epsilon to avoid div\u2011by\u2011zero\n\n    # For every facility, find which remaining customers are feasible\n    feas_mask = caps[:, None] >= dem[rem]  # shape (facilities, customers)\n    # Compute z\u2011scores only where feasible\n    z = np.full_like(C, np.inf, dtype=float)\n    z[feas_mask] = (C[feas_mask, rem[feas_mask[0]]]\n                    - mu[feas_mask[0]]) / sd[feas_mask[0]]\n\n    # Add tiny deterministic noise to break ties\n    noise = np.arange(z.size).reshape(z.shape) * 1e-9\n    z += noise\n\n    # Clip extreme values for numerical stability\n    z = np.clip(z, -10.0, 10.0)\n\n    # Soft\u2011min weighting (temperature = 1.0)\n    weights = np.exp(-z)                 # larger weight for smaller z\n    best_idx = np.unravel_index(np.argmax(weights), weights.shape)\n    best_customer, best_facility = rem[best_idx[1]], int(best_idx[0])\n\n    return int(best_customer), int(best_facility)\n\n",
  "zscore_facility_preference_aug_149": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Imperative loop with list comprehensions and max\u2011based aggregation.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Use max instead of mean for facility statistics\n    mu = np.max(C[:, rem], axis=1)\n    sd = np.std(C[:, rem], axis=1, ddof=0)\n    sd = np.maximum(sd, 1e-12)          # epsilon\n\n    best_val = np.inf\n    best_cust = best_fac = None\n    idx = 0\n\n    while idx < len(rem):\n        cust = rem[idx]\n        feas = np.where(caps >= dem[cust])[0]\n        if feas.size > 0:\n            z_vals = (C[feas, cust] - mu[feas]) / sd[feas]\n            z_vals = np.clip(z_vals, -8.0, 8.0)          # bounding\n            # Add deterministic noise for tie\u2011breaking\n            z_vals += np.arange(z_vals.size) * 1e-8\n            k = int(np.argmin(z_vals))\n            val = float(z_vals[k])\n            if val < best_val:\n                best_val = val\n                best_cust = cust\n                best_fac = int(feas[k])\n        idx += 1\n\n    return (int(best_cust), int(best_fac)) if best_cust is not None else (None, None)\n\n",
  "zscore_facility_preference_aug_150": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Random choice among the top\u2011k lowest z\u2011scores.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    mu = np.mean(C[:, rem], axis=1)\n    sd = np.std(C[:, rem], axis=1, ddof=0)\n    sd = np.maximum(sd, 1e-12)\n\n    best_candidates = []\n\n    for cust in rem:\n        feas = np.where(caps >= dem[cust])[0]\n        if feas.size == 0:\n            continue\n        z = (C[feas, cust] - mu[feas]) / sd[feas]\n        z = np.clip(z, -5.0, 5.0)\n        # Take top\u2011k (k=3) facilities\n        top_k = np.argpartition(z, 3)[:3]\n        for idx in top_k:\n            best_candidates.append((z[idx], int(cust), int(feas[idx])))\n\n    if not best_candidates:\n        return None, None\n\n    # Randomly pick among the best candidates\n    best_candidates.sort(key=lambda x: x[0])\n    top_vals = [c[0] for c in best_candidates]\n    min_val = top_vals[0]\n    ties = [c for c in best_candidates if abs(c[0] - min_val) < 1e-9]\n    chosen = np.random.choice(len(ties))\n    _, cust, fac = ties[chosen]\n    return int(cust), int(fac)\n\n",
  "zscore_facility_preference_aug_151": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min with temperature and sqrt\u2011based standard deviation.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    mu = np.mean(C[:, rem], axis=1)\n    sd = np.sqrt(np.mean((C[:, rem] - mu[:, None])**2, axis=1))\n    sd = np.maximum(sd, 1e-12)\n\n    best_val = np.inf\n    best_cust = best_fac = None\n\n    for cust in rem:\n        feas = np.where(caps >= dem[cust])[0]\n        if feas.size == 0:\n            continue\n        z = (C[feas, cust] - mu[feas]) / sd[feas]\n        z = np.clip(z, -5.0, 5.0)\n        # Soft\u2011min with temperature 0.5\n        weights = np.exp(-z / 0.5)\n        k = int(np.argmax(weights))\n        val = float(z[k])\n        if val < best_val:\n            best_val = val\n            best_cust = cust\n            best_fac = int(feas[k])\n\n    return (int(best_cust), int(best_fac)) if best_cust is not None else (None, None)\n\n",
  "rank_sum_cost_and_slack_aug_152": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 1 \u2013 uses list comprehensions, weighted rank sum, and deterministic tie\u2011breaking noise.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs_mat = np.asarray(assignment_costs, dtype=float)\n\n    # Build feasible (customer, facility) pairs\n    pairs = [(c, f) for c in remaining_customers\n             for f in np.where(caps >= dem[c])[0]]\n\n    if not pairs:\n        return None, None\n\n    # Extract cost and slack vectors\n    costs = np.array([costs_mat[f, c] for c, f in pairs], dtype=float)\n    slacks = np.array([caps[f] - dem[c] for c, f in pairs], dtype=float)\n    slacks = np.clip(slacks, 0, None)  # avoid negative slacks\n\n    # Rank costs and slacks (lower is better)\n    cost_rank = np.argsort(np.argsort(costs))\n    slack_rank = np.argsort(np.argsort(slacks))\n\n    # Weighted score + deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(len(pairs))\n    score = 0.6 * cost_rank + 0.4 * slack_rank + noise\n\n    idx = int(np.argmin(score))\n    return pairs[idx][0], pairs[idx][1]\n\n",
  "rank_sum_cost_and_slack_aug_153": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 3 \u2013 proxy log\u2011cost, median\u2011based slack deviation, weighted ranking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs_mat = np.asarray(assignment_costs, dtype=float)\n\n    pairs = [(c, f) for c in remaining_customers\n             for f in np.where(caps >= dem[c])[0]]\n\n    if not pairs:\n        return None, None\n\n    costs = np.array([costs_mat[f, c] for c, f in pairs], dtype=float)\n    slacks = np.array([caps[f] - dem[c] for c, f in pairs], dtype=float)\n    slacks = np.clip(slacks, 0, None)\n\n    # Proxy cost via log transform\n    cost_proxy = np.log(costs + 1e-12)\n    cost_rank = np.argsort(np.argsort(cost_proxy))\n\n    # Slack deviation from median\n    slack_med = np.median(slacks)\n    slack_diff = np.abs(slacks - slack_med)\n    slack_rank = np.argsort(np.argsort(slack_diff))\n\n    noise = 1e-9 * np.arange(len(pairs))\n    score = 0.7 * cost_rank + 0.3 * slack_rank + noise\n\n    idx = int(np.argmin(score))\n    return pairs[idx][0], pairs[idx][1]\n\n",
  "pareto_front_weighted_pick_aug_154": "import numpy as np\nfrom typing import List, Tuple\n\ndef _pareto_mask(vals: np.ndarray) -> np.ndarray:\n    \"\"\"Return a boolean mask of Pareto\u2011optimal points (minimise both columns).\"\"\"\n    n = vals.shape[0]\n    mask = np.ones(n, dtype=bool)\n    for i in range(n):\n        if not mask[i]:\n            continue\n        dominated = np.all(vals <= vals[i], axis=1) & np.any(vals < vals[i], axis=1)\n        mask[dominated] = False\n    return mask\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Build all feasible (customer, facility) pairs, keep the Pareto front on\n    (cost, slack), and choose the pair with the smallest weighted sum\n    (cost + 0.5 * slack).\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # weights for the objective\n    w_cost = 1.0\n    w_slack = 0.5\n\n    # convert lists to numpy arrays for vectorised operations\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # containers for flattened data\n    all_costs = []\n    all_slacks = []\n    all_customers = []\n    all_facilities = []\n\n    for cust in remaining_customers:\n        d = dem[cust]\n        # facilities that can accommodate the customer\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n        cust_arr = np.full(feasible.shape, cust, dtype=int)\n        fac_arr = feasible.astype(int)\n\n        all_customers.append(cust_arr)\n        all_facilities.append(fac_arr)\n        all_costs.append(costs[fac_arr, cust])\n        # slack = remaining capacity after the assignment\n        slack_arr = caps[feasible] - d\n        # clip slack to avoid numerical artefacts\n        slack_arr = np.clip(slack_arr, 0.0, 1e6)\n        all_slacks.append(slack_arr)\n\n    if not all_costs:\n        return None, None\n\n    # flatten all arrays\n    costs_flat = np.concatenate(all_costs)\n    slacks_flat = np.concatenate(all_slacks)\n    customers_flat = np.concatenate(all_customers)\n    facilities_flat = np.concatenate(all_facilities)\n\n    crit = np.vstack((costs_flat, slacks_flat)).T\n    mask = _pareto_mask(crit)\n    idxs = np.nonzero(mask)[0]\n\n    # weighted score\n    scores = w_cost * costs_flat[idxs] + w_slack * slacks_flat[idxs]\n    best_idx = np.argmin(scores)\n\n    best_cust = int(customers_flat[idxs[best_idx]])\n    best_fac = int(facilities_flat[idxs[best_idx]])\n    return best_cust, best_fac\n\n",
  "pareto_front_weighted_pick_aug_155": "import numpy as np\nfrom typing import List, Tuple\n\ndef _pareto_mask(vals: np.ndarray) -> np.ndarray:\n    n = vals.shape[0]\n    mask = np.ones(n, dtype=bool)\n    for i in range(n):\n        if not mask[i]:\n            continue\n        dominated = np.all(vals <= vals[i], axis=1) & np.any(vals < vals[i], axis=1)\n        mask[dominated] = False\n    return mask\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Use a soft\u2011min selection: compute a score, add tiny Gaussian noise for\n    tie\u2011breaking, exponentiate with a temperature, and pick the facility with\n    the highest probability.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # soft\u2011min temperature (avoid division by zero)\n    temp = 1.0 + 1e-12\n    w_cost = 1.0\n    w_slack = 0.5\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    all_costs = []\n    all_slacks = []\n    all_customers = []\n    all_facilities = []\n\n    for cust in remaining_customers:\n        d = dem[cust]\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n        cust_arr = np.full(feasible.shape, cust, dtype=int)\n        fac_arr = feasible.astype(int)\n\n        all_customers.append(cust_arr)\n        all_facilities.append(fac_arr)\n        all_costs.append(costs[fac_arr, cust])\n\n        slack_arr = caps[feasible] - d\n        slack_arr = np.clip(slack_arr, 0.0, 1e6)\n        all_slacks.append(slack_arr)\n\n    if not all_costs:\n        return None, None\n\n    costs_flat = np.concatenate(all_costs)\n    slacks_flat = np.concatenate(all_slacks)\n    customers_flat = np.concatenate(all_customers)\n    facilities_flat = np.concatenate(all_facilities)\n\n    # weighted score with small Gaussian noise for deterministic tie\u2011breaking\n    rng = np.random.default_rng(seed=42)\n    noise = rng.normal(0, 1e-8, size=costs_flat.shape)\n    scores = w_cost * costs_flat + w_slack * slacks_flat + noise\n\n    # soft\u2011min probability\n    probs = np.exp(-scores / temp)\n    probs = probs / (np.sum(probs) + 1e-12)  # avoid division by zero\n\n    best_idx = np.argmax(probs)\n    best_cust = int(customers_flat[best_idx])\n    best_fac = int(facilities_flat[best_idx])\n    return best_cust, best_fac\n\n",
  "pareto_front_weighted_pick_aug_156": "import numpy as np\nfrom typing import List, Tuple\n\ndef _pareto_mask(vals: np.ndarray) -> np.ndarray:\n    n = vals.shape[0]\n    mask = np.ones(n, dtype=bool)\n    for i in range(n):\n        if not mask[i]:\n            continue\n        dominated = np.all(vals <= vals[i], axis=1) & np.any(vals < vals[i], axis=1)\n        mask[dominated] = False\n    return mask\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Pick a random assignment among the top\u2011k lowest weighted scores.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    w_cost = 1.0\n    w_slack = 0.5\n    top_k = 5\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    all_costs = []\n    all_slacks = []\n    all_customers = []\n    all_facilities = []\n\n    for cust in remaining_customers:\n        d = dem[cust]\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n        cust_arr = np.full(feasible.shape, cust, dtype=int)\n        fac_arr = feasible.astype(int)\n\n        all_customers.append(cust_arr)\n        all_facilities.append(fac_arr)\n        all_costs.append(costs[fac_arr, cust])\n\n        slack_arr = caps[feasible] - d\n        slack_arr = np.clip(slack_arr, 0.0, 1e6)\n        all_slacks.append(slack_arr)\n\n    if not all_costs:\n        return None, None\n\n    costs_flat = np.concatenate(all_costs)\n    slacks_flat = np.concatenate(all_slacks)\n    customers_flat = np.concatenate(all_customers)\n    facilities_flat = np.concatenate(all_facilities)\n\n    # weighted score with tiny uniform noise for deterministic tie\u2011breaking\n    rng = np.random.default_rng(seed=123)\n    noise = rng.uniform(-1e-9, 1e-9, size=costs_flat.shape)\n    scores = w_cost * costs_flat + w_slack * slacks_flat + noise\n\n    # find top\u2011k indices with smallest scores\n    if scores.size <= top_k:\n        chosen_idx = np.argmin(scores)\n    else:\n        top_indices = np.argpartition(scores, top_k)[:top_k]\n        top_scores = scores[top_indices]\n        # randomly pick one among the top\u2011k\n        chosen_idx = top_indices[rng.integers(0, top_k)]\n\n    best_cust = int(customers_flat[chosen_idx])\n    best_fac = int(facilities_flat[chosen_idx])\n    return best_cust, best_fac\n\n",
  "pareto_front_weighted_pick_aug_157": "import numpy as np\nfrom typing import List, Tuple\n\ndef _pareto_mask(vals: np.ndarray) -> np.ndarray:\n    n = vals.shape[0]\n    mask = np.ones(n, dtype=bool)\n    for i in range(n):\n        if not mask[i]:\n            continue\n        dominated = np.all(vals <= vals[i], axis=1) & np.any(vals < vals[i], axis=1)\n        mask[dominated] = False\n    return mask\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Normalise slack by the median slack, use deterministic noise for\n    tie\u2011breaking, and clip extreme costs to keep values bounded.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    w_cost = 1.0\n    w_slack = 0.7\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    all_costs = []\n    all_slacks = []\n    all_customers = []\n    all_facilities = []\n\n    for cust in remaining_customers:\n        d = dem[cust]\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n        cust_arr = np.full(feasible.shape, cust, dtype=int)\n        fac_arr = feasible.astype(int)\n\n        all_customers.append(cust_arr)\n        all_facilities.append(fac_arr)\n        all_costs.append(costs[fac_arr, cust])\n\n        slack_arr = caps[feasible] - d\n        slack_arr = np.clip(slack_arr, 0.0, 1e6)\n        all_slacks.append(slack_arr)\n\n    if not all_costs:\n        return None, None\n\n    costs_flat = np.concatenate(all_costs)\n    slacks_flat = np.concatenate(all_slacks)\n    customers_flat = np.concatenate(all_customers)\n    facilities_flat = np.concatenate(all_facilities)\n\n    # normalise slack by the median (avoid division by zero)\n    median_slack = np.median(slacks_flat) + 1e-12\n    norm_slack = slacks_flat / median_slack\n    norm_slack = np.clip(norm_slack, 0.0, 10.0)\n\n    # clip costs to keep them bounded\n    costs_flat = np.clip(costs_flat, 0.0, 1e6)\n\n    # deterministic noise based on index to break ties\n    deterministic_noise = 1e-9 * np.arange(costs_flat.size, dtype=float)\n    scores = w_cost * costs_flat + w_slack * norm_slack + deterministic_noise\n\n    best_idx = np.argmin(scores)\n    best_cust = int(customers_flat[best_idx])\n    best_fac = int(facilities_flat[best_idx])\n    return best_cust, best_fac\n\n",
  "log_barrier_utilization_aug_158": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy search with a while\u2011loop and vectorised feasibility checks.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    mu = 4.0\n    eps = 1e-9\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    cust_iter = iter(remaining_customers)\n    while True:\n        try:\n            c = next(cust_iter)\n        except StopIteration:\n            break\n\n        d = dem[c]\n        feasible = np.where(caps >= d)[0]\n        for f in feasible:\n            slack = caps[f] - d\n            slack = np.clip(slack, 0.0, np.inf)\n            score = cost[f, c] - mu * np.log(slack + eps + 1.0)\n            if score < best_score:\n                best_score = score\n                best_cust = int(c)\n                best_fac = int(f)\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "log_barrier_utilization_aug_159": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Score based on inverse slack with deterministic tie\u2011breaking and top\u2011k sampling.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    mu = 6.0\n    eps = 1e-8\n    top_k = 5\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    scores = []\n    pairs = []\n\n    for idx, c in enumerate(remaining_customers):\n        d = dem[c]\n        feasible = np.where(caps >= d)[0]\n        for f in feasible:\n            slack = caps[f] - d\n            denom = slack + eps\n            denom = np.clip(denom, 1e-12, np.inf)\n            score = cost[f, c] + mu * (1.0 / denom)\n            score += idx * 1e-6          # deterministic tie\u2011breaking noise\n            scores.append(score)\n            pairs.append((int(c), int(f)))\n\n    if not scores:\n        return None, None\n\n    scores = np.array(scores)\n    top_indices = np.argsort(scores)[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n    return pairs[chosen_idx]\n\n",
  "log_barrier_utilization_aug_160": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min sampling over all feasible assignments with deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    mu = 4.0\n    eps = 1e-9\n    temperature = 0.5\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    scores = []\n    pairs = []\n\n    for idx, c in enumerate(remaining_customers):\n        d = dem[c]\n        feasible = np.where(caps >= d)[0]\n        for f in feasible:\n            slack = caps[f] - d\n            slack = np.clip(slack, 0.0, np.inf)\n            score = cost[f, c] - mu * np.log(slack + eps + 1.0)\n            score += idx * 1e-6          # deterministic tie\u2011breaking\n            scores.append(score)\n            pairs.append((int(c), int(f)))\n\n    if not scores:\n        return None, None\n\n    scores = np.array(scores)\n    weights = np.exp(-scores / (temperature + 1e-12))\n    probs = weights / np.clip(np.sum(weights), 1e-12, None)\n    chosen_idx = np.random.choice(len(scores), p=probs)\n    return pairs[chosen_idx]\n\n",
  "log_barrier_utilization_aug_161": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Approximate log via log1p and random top\u2011k selection with deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    mu = 5.0\n    eps = 1e-7\n    top_k = 7\n\n    cap_vec = np.asarray(remaining_capacities, dtype=float)\n    dem_vec = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    all_scores = []\n    all_pairs = []\n\n    for c_idx, cust in enumerate(remaining_customers):\n        demand = dem_vec[cust]\n        feasible = np.where(cap_vec >= demand)[0]\n        for f_idx in feasible:\n            slack = cap_vec[f_idx] - demand\n            slack = np.clip(slack, 0.0, np.inf)\n            score = cost_mat[f_idx, cust] - mu * np.log1p(slack + eps)\n            score += c_idx * 1e-7          # deterministic tie\u2011breaking\n            all_scores.append(score)\n            all_pairs.append((int(cust), int(f_idx)))\n\n    if not all_scores:\n        return None, None\n\n    all_scores = np.array(all_scores)\n    top_indices = np.argsort(all_scores)[:top_k]\n    chosen = np.random.choice(top_indices)\n    return all_pairs[chosen]\n\n",
  "roulette_customer_by_demand_then_best_facility_aug_162": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Select a customer proportionally to its demand and assign it to a facility\n    using a soft\u2011min probability distribution.  All operations are vectorised\n    where possible and safety checks are in place.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, None)\n    dem = np.clip(np.asarray(customer_demands, dtype=float), 0, None)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float), 0, None)\n\n    # Build candidate list with a while loop\n    candidates: List[int] = []\n    weights: List[float] = []\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        feas = caps >= dem[c]\n        if feas.any():\n            candidates.append(c)\n            weights.append(float(dem[c]))\n        idx += 1\n\n    if not candidates:\n        return None, None\n\n    weights = np.asarray(weights, dtype=float)\n    probs = weights / (np.sum(weights) + 1e-12)          # avoid div\u2011by\u2011zero\n    customer = int(rng.choice(candidates, p=probs))\n\n    # Soft\u2011min facility selection with deterministic tie\u2011breaking\n    feas = caps >= dem[customer]\n    feasible_idx = np.where(feas)[0]\n    if feasible_idx.size == 0:\n        return customer, None\n\n    beta = 5.0\n    cost_subset = costs[feasible_idx, customer]\n    # tiny deterministic noise to break ties\n    noise = np.arange(feasible_idx.size) * 1e-9\n    cost_noisy = cost_subset + noise\n    exp_vals = np.exp(-beta * cost_noisy)\n    softmin_probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    facility = int(rng.choice(feasible_idx, p=softmin_probs))\n    return customer, facility\n\n",
  "roulette_customer_by_demand_then_best_facility_aug_163": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised implementation that uses a weighted score based on demand and\n    mean cost, selects the top\u2011k customers, and assigns to the cheapest facility\n    with deterministic noise for tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, None)\n    dem = np.clip(np.asarray(customer_demands, dtype=float), 0, None)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float), 0, None)\n\n    # Feasibility matrix: facilities x customers\n    feas_mat = caps[:, None] >= dem[remaining_customers]\n    # Customers that have at least one feasible facility\n    mask = feas_mat.any(axis=0)\n    if not mask.any():\n        return None, None\n\n    valid_customers = np.array(remaining_customers)[mask]\n    # Weighted score: 60\u202f% demand + 40\u202f% mean cost\n    mean_costs = np.mean(costs[:, valid_customers], axis=0)\n    scores = 0.6 * dem[valid_customers] + 0.4 * mean_costs\n    scores = np.clip(scores, 0, None)\n    probs = scores / (np.sum(scores) + 1e-12)\n\n    # Sample among the top\u2011k customers\n    top_k = 7\n    top_indices = np.argpartition(-scores, top_k - 1)[:top_k]\n    top_customers = valid_customers[top_indices]\n    top_probs = probs[top_indices] / (np.sum(probs[top_indices]) + 1e-12)\n    customer = int(rng.choice(top_customers, p=top_probs))\n\n    # Facility assignment: cheapest facility with deterministic noise\n    feas = caps >= dem[customer]\n    feasible_facilities = np.where(feas)[0]\n    if feasible_facilities.size == 0:\n        return customer, None\n    facility_means = np.mean(costs[feasible_facilities, :], axis=1)\n    noise = np.arange(feasible_facilities.size) * 1e-8\n    facility = int(feasible_facilities[np.argmin(facility_means + noise)])\n    return customer, facility\n\n",
  "roulette_customer_by_demand_then_best_facility_aug_164": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"For\u2011loop implementation that inverts the feasibility test, uses a\n    hybrid weighting scheme, adds deterministic noise to weights, and\n    selects the facility with the minimal cost plus a tie\u2011breaking offset.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, None)\n    dem = np.clip(np.asarray(customer_demands, dtype=float), 0, None)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float), 0, None)\n\n    candidates: List[int] = []\n    weights: List[float] = []\n\n    for c in remaining_customers:\n        feas = caps >= dem[c]\n        if not feas.any():\n            continue\n        candidates.append(c)\n        feasible_idx = np.where(feas)[0]\n        min_cost = np.min(costs[feasible_idx, c])\n        weights.append(0.7 * dem[c] + 0.3 * min_cost)\n\n    if not candidates:\n        return None, None\n\n    weights = np.asarray(weights, dtype=float)\n    # Add deterministic noise before normalisation\n    weights += np.arange(len(candidates)) * 1e-9\n    probs = weights / (np.sum(weights) + 1e-12)\n    customer = int(rng.choice(candidates, p=probs))\n\n    # Facility assignment with deterministic tie\u2011breaking\n    feas = caps >= dem[customer]\n    feasible_idx = np.where(feas)[0]\n    if feasible_idx.size == 0:\n        return customer, None\n    cost_subset = costs[feasible_idx, customer]\n    noise = np.arange(feasible_idx.size) * 1e-8\n    facility = int(feasible_idx[np.argmin(cost_subset + noise)])\n    return customer, facility\n\n",
  "roulette_customer_by_demand_then_best_facility_aug_165": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"While\u2011loop construction of candidates, soft\u2011max customer selection,\n    soft\u2011min facility selection among the top\u2011k cheapest facilities, and\n    deterministic noise for tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float), 0, None)\n    dem = np.clip(np.asarray(customer_demands, dtype=float), 0, None)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float), 0, None)\n\n    # Build candidates with a while loop\n    candidates: List[int] = []\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        feas = caps >= dem[c]\n        if feas.any():\n            candidates.append(c)\n        idx += 1\n\n    if not candidates:\n        return None, None\n\n    # Soft\u2011max customer probabilities\n    demands = np.asarray([dem[c] for c in candidates], dtype=float)\n    beta = 0.5\n    exp_vals = np.exp(beta * demands)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n    customer = int(rng.choice(candidates, p=probs))\n\n    # Facility selection: soft\u2011min over top\u2011k cheapest facilities\n    feas = caps >= dem[customer]\n    feasible_idx = np.where(feas)[0]\n    if feasible_idx.size == 0:\n        return customer, None\n\n    top_k = 5\n    if feasible_idx.size <= top_k:\n        top_indices = feasible_idx\n    else:\n        cost_subset = costs[feasible_idx, customer]\n        top_indices = feasible_idx[np.argpartition(cost_subset, top_k - 1)[:top_k]]\n\n    beta_f = 3.0\n    cost_subset = costs[top_indices, customer]\n    exp_vals = np.exp(-beta_f * cost_subset)\n    probs_f = exp_vals / (np.sum(exp_vals) + 1e-12)\n    facility = int(rng.choice(top_indices, p=probs_f))\n    return customer, facility\n\n",
  "roulette_facility_by_capacity_then_best_customer_aug_166": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    eps = 1e-12\n\n    arr_caps = np.asarray(remaining_capacities, dtype=float)\n    arr_dem = np.asarray(customer_demands, dtype=float)\n    arr_cost = np.asarray(assignment_costs, dtype=float)\n    arr_rem  = np.asarray(remaining_customers, dtype=int)\n\n    # Facilities that can serve at least one remaining customer\n    feasible_fac = []\n    weights = []\n    for f in range(len(arr_caps)):\n        if np.any(arr_dem[arr_rem] <= arr_caps[f]):\n            feasible_fac.append(int(f))\n            weights.append(float(arr_caps[f]))\n\n    if not feasible_fac:\n        return None, None\n\n    # Soft\u2011max weighting over capacities\n    w = np.asarray(weights, dtype=float)\n    exp_w = np.exp(w - np.max(w))          # numerical stability\n    w_norm = exp_w / (np.sum(exp_w) + eps)\n    w_norm = np.clip(w_norm, 0, 1)\n\n    fac_idx = int(rng.choice(np.asarray(feasible_fac, dtype=int), p=w_norm))\n\n    feas_customers = arr_rem[np.where(arr_dem[arr_rem] <= arr_caps[fac_idx])[0]]\n    if feas_customers.size == 0:\n        return None, None\n\n    # Soft\u2011min over assignment costs with tiny noise for tie\u2011breaking\n    costs = arr_cost[fac_idx, feas_customers] + rng.uniform(0, 1e-6, size=feas_customers.shape)\n    exp_neg_cost = np.exp(-costs - np.min(costs))\n    prob = exp_neg_cost / (np.sum(exp_neg_cost) + eps)\n    prob = np.clip(prob, 0, 1)\n\n    cust_idx = int(rng.choice(feas_customers, p=prob))\n    return cust_idx, fac_idx\n\n",
  "roulette_facility_by_capacity_then_best_customer_aug_167": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    eps = 1e-12\n    top_k = 5\n\n    fac_caps  = np.asarray(remaining_capacities, dtype=float)\n    cust_dem  = np.asarray(customer_demands, dtype=float)\n    cost_mat  = np.asarray(assignment_costs, dtype=float)\n    cust_rem  = np.asarray(remaining_customers, dtype=int)\n\n    # While loop to collect feasible facilities\n    feasible_fac = []\n    weights = []\n    idx = 0\n    while idx < len(fac_caps):\n        if np.any(cust_dem[cust_rem] <= fac_caps[idx]):\n            feasible_fac.append(int(idx))\n            weights.append(float(fac_caps[idx]))\n        idx += 1\n\n    if not feasible_fac:\n        return None, None\n\n    w = np.asarray(weights, dtype=float)\n    # Median\u2011based normalisation to dampen outliers\n    med = np.median(w) + eps\n    w_norm = w / med\n    w_norm = w_norm / (np.sum(w_norm) + eps)\n    w_norm = np.clip(w_norm, 0, 1)\n\n    fac_idx = int(rng.choice(np.asarray(feasible_fac, dtype=int), p=w_norm))\n\n    feas_cust = cust_rem[np.where(cust_dem[cust_rem] <= fac_caps[fac_idx])[0]]\n    if feas_cust.size == 0:\n        return None, None\n\n    costs = cost_mat[fac_idx, feas_cust]\n    # Keep only the top_k cheapest customers\n    if feas_cust.size <= top_k:\n        top_k_cust = feas_cust\n    else:\n        idx_sort = np.argsort(costs)\n        top_k_cust = feas_cust[idx_sort[:top_k]]\n\n    cust_idx = int(rng.choice(top_k_cust))\n    return cust_idx, fac_idx\n\n",
  "roulette_facility_by_capacity_then_best_customer_aug_168": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    eps = 1e-12\n    top_k = 3\n\n    arr_caps  = np.asarray(remaining_capacities, dtype=float)\n    arr_dem   = np.asarray(customer_demands, dtype=float)\n    arr_cost  = np.asarray(assignment_costs, dtype=float)\n    arr_rem   = np.asarray(remaining_customers, dtype=int)\n\n    # Invert feasibility: include facility unless ALL customers exceed its capacity\n    feasible_fac = [i for i in range(len(arr_caps))\n                    if not np.all(arr_dem[arr_rem] > arr_caps[i])]\n    if not feasible_fac:\n        return None, None\n\n    # Weight using the difference from the maximum capacity\n    max_cap = np.max(arr_caps)\n    weights = [max_cap - arr_caps[i] + eps for i in feasible_fac]\n    w = np.asarray(weights, dtype=float)\n    w = w / (np.sum(w) + eps)\n    w = np.clip(w, 0, 1)\n\n    fac_idx = int(rng.choice(np.asarray(feasible_fac, dtype=int), p=w))\n\n    feas_cust = arr_rem[np.where(arr_dem[arr_rem] <= arr_caps[fac_idx])[0]]\n    if feas_cust.size == 0:\n        return None, None\n\n    costs = arr_cost[fac_idx, feas_cust]\n    # Keep the cheapest top_k customers\n    if feas_cust.size <= top_k:\n        top_cust = feas_cust\n    else:\n        top_cust = feas_cust[np.argsort(costs)[:top_k]]\n\n    cust_idx = int(rng.choice(top_cust))\n    return cust_idx, fac_idx\n\n",
  "roulette_facility_by_capacity_then_best_customer_aug_169": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    eps = 1e-12\n\n    caps  = np.asarray(remaining_capacities, dtype=float)\n    dem   = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem   = np.asarray(remaining_customers, dtype=int)\n\n    # Facilities that can serve at least one remaining customer\n    feasible_fac = [i for i in range(len(caps))\n                    if np.any(dem[rem] <= caps[i])]\n    if not feasible_fac:\n        return None, None\n\n    # Deterministic choice: facility with the largest remaining capacity\n    fac_caps = caps[feasible_fac]\n    max_cap = np.max(fac_caps)\n    max_idx = [feasible_fac[i] for i, c in enumerate(fac_caps)\n               if np.isclose(c, max_cap, atol=eps)]\n    fac_idx = int(rng.choice(max_idx))\n\n    feas_customers = rem[np.where(dem[rem] <= caps[fac_idx])[0]]\n    if feas_customers.size == 0:\n        return None, None\n\n    # Deterministic choice: customer with the lowest assignment cost\n    cust_costs = costs[fac_idx, feas_customers]\n    min_cost = np.min(cust_costs)\n    min_idx = feas_customers[np.where(np.isclose(cust_costs, min_cost, atol=eps))[0]]\n    cust_idx = int(rng.choice(min_idx))\n\n    return cust_idx, fac_idx\n\n",
  "top_quantile_demand_focus_aug_170": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Choose the top 30\u202f% highest\u2011demand customers\n    thresh = np.quantile(dem[rem], 0.7)\n    subset = rem[dem[rem] >= thresh]\n    if subset.size == 0:\n        subset = rem\n\n    best_score = np.inf\n    best_cust, best_fac = None, None\n\n    for cust in subset:\n        feas = np.where(caps >= dem[cust])[0]\n        if feas.size == 0:\n            continue\n\n        slack = np.clip(caps[feas] - dem[cust], 0, None)\n        score = costs[feas, cust] / (slack + 1e-12)   # \u03b5 to avoid division by zero\n        idx = np.argmin(score)\n\n        if score[idx] < best_score:\n            best_score = score[idx]\n            best_cust = int(cust)\n            best_fac = int(feas[idx])\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "top_quantile_demand_focus_aug_171": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Focus on the most demanding 25\u202f% customers\n    thresh = np.quantile(dem[rem], 0.75)\n    subset = rem[dem[rem] >= thresh]\n    if subset.size == 0:\n        subset = rem\n\n    best_cust, best_fac = None, None\n    best_prob = -1.0\n    idx = 0\n\n    while idx < subset.size:\n        cust = subset[idx]\n        feas = np.where(caps >= dem[cust])[0]\n        if feas.size > 0:\n            slack = np.clip(caps[feas] - dem[cust], 0, None)\n            score = costs[feas, cust] / (slack + 1e-12)\n\n            # Softmin selection with temperature\n            temp = 0.5\n            exp_vals = np.exp(-score / (temp + 1e-12))\n            probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n            chosen_idx = np.argmax(probs)\n\n            chosen_fac = int(feas[chosen_idx])\n            chosen_prob = probs[chosen_idx]\n\n            if chosen_prob > best_prob:\n                best_prob = chosen_prob\n                best_cust = int(cust)\n                best_fac = chosen_fac\n        idx += 1\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "top_quantile_demand_focus_aug_172": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Pick the top 15\u202f% highest\u2011demand customers\n    thresh = np.quantile(dem[rem], 0.85)\n    subset = rem[dem[rem] >= thresh]\n    if subset.size == 0:\n        subset = rem\n\n    best_cust, best_fac = None, None\n    best_median = np.inf\n\n    for cust in subset:\n        feas = np.where(caps >= dem[cust])[0]\n        if feas.size == 0:\n            continue\n\n        median_cost = np.median(costs[feas, cust]) + 1e-12 * np.random.rand()\n        if median_cost < best_median:\n            best_median = median_cost\n            best_cust = int(cust)\n            # pick the facility whose cost is closest to the median\n            diffs = np.abs(costs[feas, cust] - median_cost)\n            chosen_idx = np.argmin(diffs)\n            best_fac = int(feas[chosen_idx])\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "top_quantile_demand_focus_aug_173": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Consider the top 7 customers (or fewer if less than 7 remain)\n    top_k = 7 if len(rem) >= 7 else len(rem)\n    sorted_idx = np.argsort(-dem[rem])[:top_k]\n    subset = rem[sorted_idx]\n\n    best_cust, best_fac = None, None\n    best_prob = -1.0\n\n    for cust in subset:\n        feas = np.where(caps >= dem[cust])[0]\n        if feas.size == 0:\n            continue\n\n        # Inject tiny noise to break ties\n        noisy_cost = costs[feas, cust] + 0.01 * np.random.rand(feas.size)\n        clipped_cost = np.clip(noisy_cost, 0, np.max(noisy_cost) + 1e-12)\n\n        exp_vals = np.exp(-clipped_cost)\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n        chosen_idx = np.argmax(probs)\n\n        chosen_fac = int(feas[chosen_idx])\n        chosen_prob = probs[chosen_idx]\n\n        if chosen_prob > best_prob:\n            best_prob = chosen_prob\n            best_cust = int(cust)\n            best_fac = chosen_fac\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "bottom_quantile_demand_pack_aug_174": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Greedy assignment that first restricts to the 25\u2011percentile of demands,\n    then chooses the cheapest feasible pair.  Uses a while loop and\n    a random tie\u2011breaker among the top\u20115 cheapest options.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float),\n                   a_min=1e-12, a_max=None)          # avoid zero capacity\n    dem_all = np.asarray(customer_demands, dtype=float)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float),\n                    a_min=0, a_max=None)            # costs must be non\u2011negative\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    # 25\u2011percentile threshold\n    q = np.quantile(dem_all[rem], 0.25, interpolation='linear')\n    subset = rem[dem_all[rem] <= q]\n    if subset.size == 0:\n        subset = rem\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n\n    idx = 0\n    while idx < subset.size:\n        c = subset[idx]\n        # feasibility ratio uses division with epsilon\n        feas_mask = caps >= dem_all[c] + 1e-12\n        feas = np.where(feas_mask)[0]\n        for f in feas:\n            # cost per unit demand \u2013 division uses epsilon\n            val = costs[f, c] / (dem_all[c] + 1e-12)\n            if val < best_val:\n                best_val = val\n                best_c = int(c)\n                best_f = int(f)\n        idx += 1\n\n    if best_c is None:\n        return None, None\n\n    # Collect all feasible pairs and pick a random one among the top\u20115 cheapest\n    all_pairs = []\n    for c in subset:\n        feas_mask = caps >= dem_all[c] + 1e-12\n        feas = np.where(feas_mask)[0]\n        for f in feas:\n            all_pairs.append((costs[f, c], int(c), int(f)))\n    all_pairs.sort(key=lambda x: x[0])\n    top_k = 5\n    candidates = [p[1:] for p in all_pairs[:top_k]]\n    chosen = np.random.choice(candidates, size=1)[0]\n    return chosen[0], chosen[1]\n\n",
  "bottom_quantile_demand_pack_aug_175": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a weighted soft\u2011min criterion (cost + 0.1*demand) and selects\n    among the top\u20117 cheapest options.  Deterministic noise is added to\n    break ties.  The 25\u2011percentile of demands is still used for filtering.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float),\n                   a_min=1e-12, a_max=None)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float),\n                    a_min=0, a_max=None)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    q = np.quantile(dem_all[rem], 0.25, interpolation='linear')\n    subset = rem[dem_all[rem] <= q]\n    if subset.size == 0:\n        subset = rem\n\n    weighted = []\n    for c in subset:\n        feas_mask = caps >= dem_all[c] + 1e-12\n        feas = np.where(feas_mask)[0]\n        for f in feas:\n            # weighted score: cost + 0.1 * demand\n            score = costs[f, c] + 0.1 * dem_all[c]\n            weighted.append((score, int(c), int(f)))\n\n    if not weighted:\n        return None, None\n\n    weighted.sort(key=lambda x: x[0])\n    top_k = 7\n    # deterministic noise: add a tiny epsilon based on the index\n    noisy = [(val[0] + 1e-6 * idx, val[1], val[2]) for idx, val in enumerate(weighted[:top_k])]\n    noisy.sort(key=lambda x: x[0])\n    chosen_c, chosen_f = noisy[0][1], noisy[0][2]\n    return chosen_c, chosen_f\n\n",
  "bottom_quantile_demand_pack_aug_176": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Fully vectorised selection: build a feasibility mask, replace infeasible\n    entries with +inf, then use np.argmin.  Soft\u2011min weighting is applied\n    before the argmin to avoid hard ties.  Epsilon is added to all\n    divisions to satisfy the safety rule.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float),\n                   a_min=1e-12, a_max=None)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float),\n                    a_min=0, a_max=None)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    q = np.quantile(dem_all[rem], 0.25, interpolation='linear')\n    subset = rem[dem_all[rem] <= q]\n    if subset.size == 0:\n        subset = rem\n\n    # Broadcast capacities and demands to create a feasibility matrix\n    feas = caps[:, None] >= dem_all[None, subset] + 1e-12\n    cost_sub = costs[:, subset]\n    # Replace infeasible costs with +inf\n    masked_cost = np.where(feas, cost_sub, np.inf)\n\n    # Apply a soft\u2011min weighting: exp(-beta * cost)\n    beta = 1.0\n    softmin = np.exp(-beta * masked_cost)\n    softmin = np.clip(softmin, 0, None)          # avoid negative values\n\n    # Find the index of the minimal weighted cost\n    flat_idx = np.argmin(softmin)\n    f_idx, c_idx = np.unravel_index(flat_idx, softmin.shape)\n    chosen_f = int(f_idx)\n    chosen_c = int(subset[c_idx])\n\n    if np.isinf(masked_cost[chosen_f, c_idx]):\n        return None, None\n    return chosen_c, chosen_f\n\n",
  "bottom_quantile_demand_pack_aug_177": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses the median of demands to filter customers, then selects the\n    facility with the maximum remaining capacity among all feasible\n    assignments.  Ties are broken deterministically by adding a tiny\n    epsilon based on the facility index.  np.clip is used to keep\n    capacities non\u2011negative.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.clip(np.asarray(remaining_capacities, dtype=float),\n                   a_min=1e-12, a_max=None)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    costs = np.clip(np.asarray(assignment_costs, dtype=float),\n                    a_min=0, a_max=None)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    # Median threshold instead of 25th percentile\n    q = np.median(dem_all[rem])\n    subset = rem[dem_all[rem] <= q]\n    if subset.size == 0:\n        subset = rem\n\n    best_f = None\n    best_c = None\n    best_cap = -1.0\n\n    for c in subset:\n        feas_mask = caps >= dem_all[c] + 1e-12\n        feas = np.where(feas_mask)[0]\n        for f in feas:\n            # Use remaining capacity as score\n            score = caps[f]\n            # deterministic tie\u2011breaker: add epsilon * facility index\n            score += 1e-6 * f\n            if score > best_cap:\n                best_cap = score\n                best_f = int(f)\n                best_c = int(c)\n\n    if best_c is None:\n        return None, None\n    return best_c, best_f\n\n",
  "mini_batch_top_demand_best_pair_aug_178": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised greedy with weighted cost and utilisation penalty.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Parameters\n    M = 8\n    eps = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C   = np.asarray(assignment_costs, dtype=float)\n\n    # Pick the M customers with highest demand\n    rem = np.asarray(remaining_customers, dtype=int)\n    top_idx = rem[np.argsort(-dem[rem])[:M]]\n\n    best_score = np.inf\n    best_cust, best_fac = None, None\n\n    for cust in top_idx:\n        # Facilities that can still serve this customer\n        feasible = np.where(caps >= dem[cust])[0]\n        for fac in feasible:\n            # Utilisation ratio (clipped to avoid division by zero)\n            util_ratio = np.clip(\n                (caps[fac] - dem[cust]) / (caps[fac] + eps), 0.0, 1.0\n            )\n            # Combined score: raw cost + penalty for utilisation\n            score = C[fac, cust] + 0.5 * (1.0 - util_ratio)\n            # Tiny deterministic noise to break ties\n            score += np.random.rand() * 1e-6\n            if score < best_score:\n                best_score = score\n                best_cust, best_fac = cust, fac\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "mini_batch_top_demand_best_pair_aug_179": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"While\u2011loop based greedy with normalised cost and utilisation penalty.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    top_k = 7\n    eps   = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    batch = rem[np.argsort(-dem[rem])[:top_k]]\n\n    idx = 0\n    best_cost = np.inf\n    best_cust, best_fac = None, None\n\n    while idx < batch.size:\n        cust = batch[idx]\n        # List comprehension for feasible facilities\n        feas = [f for f in range(caps.size) if caps[f] >= dem[cust]]\n        for fac in feas:\n            norm_cost = np.clip(C[fac, cust] / (dem[cust] + eps), 0, np.inf)\n            util = np.clip((caps[fac] - dem[cust]) / (caps[fac] + eps), 0, 1)\n            score = 0.7 * norm_cost + 0.3 * (1.0 - util)\n            if score < best_cost:\n                best_cost = score\n                best_cust, best_fac = cust, fac\n        idx += 1\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "mini_batch_top_demand_best_pair_aug_180": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min sampling over feasible assignments.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    M = 8\n    eps = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    candidates = rem[np.argsort(-dem[rem])[:M]]\n\n    scores = []\n    pairs  = []\n\n    for cust in candidates:\n        feas = [f for f in range(caps.size) if caps[f] >= dem[cust]]\n        for fac in feas:\n            util = (caps[fac] - dem[cust]) / (caps[fac] + eps)\n            score = C[fac, cust] + 0.4 * (1.0 - util)\n            scores.append(score)\n            pairs.append((cust, fac))\n\n    if not scores:\n        return None, None\n\n    # Soft\u2011min probabilities\n    min_score = min(scores)\n    exp_vals  = np.exp(-(np.array(scores) - min_score) / (1.0 + eps))\n    probs     = exp_vals / (np.sum(exp_vals) + eps)\n    idx       = np.random.choice(len(pairs), p=probs)\n\n    return pairs[idx]\n\n",
  "mini_batch_top_demand_best_pair_aug_181": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Median\u2011based selection with random tie\u2011breaking among top 5.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    top_k = 10\n    eps   = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    top_idx = rem[np.argsort(-dem[rem])[:top_k]]\n\n    pair_scores = []\n\n    for cust in top_idx:\n        feas = np.where(caps >= dem[cust])[0]\n        for fac in feas:\n            cost_clipped = np.clip(C[fac, cust], 0, 1e6)\n            pair_scores.append((cust, fac, cost_clipped))\n\n    if not pair_scores:\n        return None, None\n\n    # Sort by cost and pick the median pair\n    pair_scores.sort(key=lambda x: x[2])\n    median_pair = pair_scores[len(pair_scores) // 2][:2]\n\n    # Random choice among the five cheapest pairs\n    top_five = pair_scores[:5]\n    chosen   = np.random.choice(len(top_five))\n    return top_five[chosen][0], top_five[chosen][1]\n\n",
  "maximize_future_feasibility_count_aug_182": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection based on remaining feasible facility options.\n    Uses while\u2011loops and explicit list comprehensions for clarity.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    cust_list = list(remaining_customers)\n    best = (-np.inf, np.inf, None, None)  # (cnt, cost, c, f)\n\n    i = 0\n    while i < len(cust_list):\n        c = cust_list[i]\n        i += 1\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            new_caps = caps.copy()\n            new_caps[f] -= d\n            new_caps = np.clip(new_caps, 0, np.inf)\n            cnt = 0\n            for c2 in cust_list:\n                if c2 == c:\n                    continue\n                cnt += int(np.sum(new_caps >= dem[c2]))\n            cost = float(costs[f, c])\n            if cnt > best[0] or (cnt == best[0] and cost < best[1]):\n                best = (cnt, cost, c, f)\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "maximize_future_feasibility_count_aug_183": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Weighted scoring with top\u2011k customer pruning and deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Hyper\u2011parameters\n    top_k = 7\n    alpha = 0.6   # weight for feasibility count\n    beta = 0.4    # weight for cost\n    noise_eps = 1e-6\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Consider only the largest\u2011demand customers\n    sorted_cust = sorted(remaining_customers,\n                         key=lambda x: dem[x],\n                         reverse=True)[:top_k]\n\n    best_score = -np.inf\n    best_pair = (None, None)\n\n    for c in sorted_cust:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            new_caps = caps.copy()\n            new_caps[f] -= d\n            new_caps = np.clip(new_caps, 0, np.inf)\n            cnt = int(np.sum(new_caps >= dem[remaining_customers]))\n            cost = float(costs[f, c])\n            # Add tiny deterministic noise for tie\u2011breaking\n            noise = np.random.rand() * noise_eps\n            score = alpha * cnt - beta * cost + noise\n            if score > best_score:\n                best_score = score\n                best_pair = (c, f)\n\n    return best_pair if best_pair[0] is not None else (None, None)\n\n",
  "maximize_future_feasibility_count_aug_184": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Randomised tie\u2011breaking among top\u2011k assignments.\n    Uses a different feasibility metric (customers still served).\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    top_k = 5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    candidates = []\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            new_caps = caps.copy()\n            new_caps[f] -= d\n            new_caps = np.clip(new_caps, 0, np.inf)\n            # Count of customers that still have at least one facility\n            served = int(np.sum(np.any(new_caps[:, None] >= dem[remaining_customers], axis=0)))\n            cost = float(costs[f, c])\n            # Score: fewer cost, more served\n            score = served - 0.01 * cost\n            candidates.append((score, c, f))\n\n    if not candidates:\n        return None, None\n\n    # Sort by score descending\n    candidates.sort(key=lambda x: x[0], reverse=True)\n    # Pick randomly among top\u2011k\n    top_candidates = candidates[:top_k]\n    chosen = np.random.choice(len(top_candidates))\n    _, c_best, f_best = top_candidates[chosen]\n    return c_best, f_best\n\n",
  "maximize_future_feasibility_count_aug_185": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised evaluation of all feasible assignments with random tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    best_pair = (None, None)\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            new_caps = caps.copy()\n            new_caps[f] -= d\n            new_caps = np.clip(new_caps, 0, np.inf)\n            # Feasible facility count for all other customers (vectorised)\n            cnt = int(np.sum(np.sum(new_caps[:, None] >= dem[remaining_customers], axis=0)))\n            cost = float(costs[f, c])\n            # Weighted score with epsilon in denominator for safety\n            score = (cnt + 1e-12) / (cost + 1e-12)\n            if score > best_score:\n                best_score = score\n                best_pair = (c, f)\n\n    return best_pair if best_pair[0] is not None else (None, None)\n\n",
  "minimize_feasibility_loss_aug_186": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # baseline feasible edges\n    base_edges = sum(int(np.sum(caps >= demands[c])) for c in remaining_customers)\n\n    best = (np.inf, np.inf, None, None)          # (loss, cost, customer, facility)\n    noise_scale = 1e-8                           # deterministic tie\u2011breaker\n\n    for c in remaining_customers:\n        d = demands[c]\n        feasible_fs = np.where(caps >= d)[0]\n        for f in feasible_fs:\n            new_caps = caps.copy()\n            new_caps[f] = np.clip(new_caps[f] - d, 0.0, np.inf)\n            edges = sum(int(np.sum(new_caps >= demands[c2])) for c2 in remaining_customers if c2 != c)\n            loss = base_edges - edges\n            cost = costs[f, c]\n            key = (loss, cost + noise_scale * (c * 1000 + f))\n            if key < best[:2]:\n                best = (loss, cost, c, f)\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "minimize_feasibility_loss_aug_187": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    base_edges = sum(int(np.sum(caps >= demands[c])) for c in remaining_customers)\n\n    weight_loss = 0.6\n    weight_cost = 0.4\n    top_k = 5\n\n    candidates = []\n\n    for c in remaining_customers:\n        d = demands[c]\n        feasible_fs = np.where(caps >= d)[0]\n        for f in feasible_fs:\n            new_caps = caps.copy()\n            new_caps[f] = np.clip(new_caps[f] - d, 0.0, np.inf)\n            edges = sum(int(np.sum(new_caps >= demands[c2])) for c2 in remaining_customers if c2 != c)\n            loss = base_edges - edges\n            cost = costs[f, c]\n            score = weight_loss * loss + weight_cost * cost\n            candidates.append((score, c, f))\n\n    if not candidates:\n        return None, None\n\n    candidates.sort(key=lambda x: x[0])\n    top_candidates = candidates[:top_k]\n    chosen = np.random.choice(len(top_candidates))\n    _, best_c, best_f = top_candidates[chosen]\n    return best_c, best_f\n\n",
  "minimize_feasibility_loss_aug_188": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    base_edges = sum(int(np.sum(caps >= demands[c])) for c in remaining_customers)\n\n    scores = []\n\n    for c in remaining_customers:\n        d = demands[c]\n        feasible_fs = np.where(caps >= d)[0]\n        for f in feasible_fs:\n            new_caps = caps.copy()\n            new_caps[f] = np.clip(new_caps[f] - d, 0.0, np.inf)\n            feas_arr = new_caps >= demands\n            approx_edges = int(np.mean(feas_arr.astype(int)) * len(remaining_customers))\n            loss = base_edges - approx_edges\n            cost = costs[f, c]\n            scores.append((loss, cost, c, f))\n\n    if not scores:\n        return None, None\n\n    losses = np.array([s[0] for s in scores], dtype=float)\n    costs_arr = np.array([s[1] for s in scores], dtype=float)\n    combined = 0.7 * losses + 0.3 * costs_arr\n    exp_vals = np.exp(-combined)\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n    chosen_idx = np.random.choice(len(scores), p=probs)\n    _, _, best_c, best_f = scores[chosen_idx]\n    return best_c, best_f\n\n",
  "minimize_feasibility_loss_aug_189": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    base_edges = 0\n    for c in remaining_customers:\n        base_edges += int(np.sum(caps >= demands[c]))\n\n    best = (np.inf, np.inf, None, None)\n\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        d = demands[c]\n        feasible_fs = np.where(caps >= d)[0]\n        f_idx = 0\n        while f_idx < len(feasible_fs):\n            f = feasible_fs[f_idx]\n            new_caps = caps.copy()\n            new_caps[f] = np.clip(new_caps[f] - d, 0.0, np.inf)\n            edges = 0\n            jdx = 0\n            while jdx < len(remaining_customers):\n                c2 = remaining_customers[jdx]\n                if c2 == c:\n                    jdx += 1\n                    continue\n                edges += int(np.sum(new_caps >= demands[c2]))\n                jdx += 1\n            loss = base_edges - edges\n            cost = costs[f, c]\n            key = (loss, cost)\n            if key < best[:2]:\n                best = (loss, cost, c, f)\n            f_idx += 1\n        idx += 1\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "facility_opportunity_cost_customer_choice_aug_190": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 1 \u2013 List\u2011comprehension + deterministic tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Vectorised data\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands,  dtype=float)\n    C    = np.asarray(assignment_costs,    dtype=float)\n    rem  = np.asarray(remaining_customers, dtype=int)\n\n    best_gap   = -np.inf\n    best_pair  = (None, None)\n\n    # Iterate over facilities using a list comprehension for feasible customers\n    for f in range(len(caps)):\n        feas_idx = [c for c in rem if dem[c] <= caps[f]]\n        if not feas_idx:\n            continue\n\n        costs = C[f, feas_idx]\n        # Add tiny noise to costs to break ties deterministically\n        noise  = np.linspace(0, 1e-8, len(costs))\n        costs  = costs + noise\n        order  = np.argsort(costs)\n\n        if len(costs) == 1:\n            gap = 1e12\n            chosen = feas_idx[order[0]]\n        else:\n            # Gap between best and second best\n            gap = costs[order[1]] - costs[order[0]]\n            chosen = feas_idx[order[0]]\n\n        # Keep the largest gap\n        if gap > best_gap:\n            best_gap  = gap\n            best_pair = (chosen, f)\n\n    return best_pair if best_pair[0] is not None else (None, None)\n\n",
  "facility_opportunity_cost_customer_choice_aug_191": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 2 \u2013 While\u2011loop, softmin selection, weighted gap.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands,  dtype=float)\n    C    = np.asarray(assignment_costs,    dtype=float)\n    rem  = np.asarray(remaining_customers, dtype=int)\n\n    best_gap   = -np.inf\n    best_pair  = (None, None)\n\n    f = 0\n    while f < len(caps):\n        feas_idx = rem[dem[rem] <= caps[f]]\n        if feas_idx.size > 0:\n            costs = C[f, feas_idx]\n            # Softmin weights (beta = 5.0)\n            beta  = 5.0\n            weights = np.exp(-beta * costs)\n            weights = weights / (np.sum(weights) + 1e-12)  # epsilon to avoid div\u2011by\u2011zero\n            chosen = int(feas_idx[np.argmax(weights)])\n\n            # Weighted gap: difference between chosen cost and weighted mean of others\n            other_costs = costs[np.arange(len(costs)) != np.argmin(costs)]\n            mean_other  = np.mean(other_costs) if other_costs.size else 0.0\n            gap = mean_other - costs[np.argmin(costs)]\n\n            if gap > best_gap:\n                best_gap  = gap\n                best_pair = (chosen, f)\n        f += 1\n\n    return best_pair if best_pair[0] is not None else (None, None)\n\n",
  "facility_opportunity_cost_customer_choice_aug_192": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 3 \u2013 Random choice among top\u2011k, median gap, deterministic noise.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands,  dtype=float)\n    C    = np.asarray(assignment_costs,    dtype=float)\n    rem  = np.asarray(remaining_customers, dtype=int)\n\n    best_gap   = -np.inf\n    best_pair  = (None, None)\n    top_k = 5  # hyper\u2011parameter\n\n    for f in range(len(caps)):\n        feas_idx = rem[dem[rem] <= caps[f]]\n        if feas_idx.size == 0:\n            continue\n\n        costs = C[f, feas_idx]\n        # Add deterministic noise to break ties\n        noise = np.arange(len(costs)) * 1e-9\n        costs = costs + noise\n\n        # Select top\u2011k cheapest customers\n        order = np.argsort(costs)\n        top_idx = feas_idx[order[:min(top_k, len(order))]]\n\n        # Randomly pick one from the top\u2011k\n        chosen = int(np.random.choice(top_idx))\n\n        # Gap as difference between median of all feasible costs and chosen cost\n        gap = np.median(costs) - costs[order[0]]\n\n        if gap > best_gap:\n            best_gap  = gap\n            best_pair = (chosen, f)\n\n    return best_pair if best_pair[0] is not None else (None, None)\n\n",
  "facility_opportunity_cost_customer_choice_aug_193": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 4 \u2013 Fully vectorised gap matrix, argmax selection, clipped values.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands,  dtype=float)\n    C    = np.asarray(assignment_costs,    dtype=float)\n    rem  = np.asarray(remaining_customers, dtype=int)\n\n    # Build feasibility mask\n    feas_mask = dem[rem][:, None] <= caps[None, :]\n    feas_mask = feas_mask.astype(bool)\n\n    # Mask costs with large penalty where infeasible\n    large_penalty = 1e12\n    masked_costs = np.where(feas_mask, C[:, rem], large_penalty)\n\n    # Compute gap matrix: difference between best and second best per facility\n    sorted_costs = np.sort(masked_costs, axis=1)\n    gaps = sorted_costs[:, 1] - sorted_costs[:, 0]\n    gaps = np.clip(gaps, -np.inf, np.inf)  # ensure valid\n\n    # Select facility with maximum gap\n    best_f = int(np.argmax(gaps))\n    # Within that facility, pick the customer with minimum cost\n    best_c = int(rem[np.argmin(C[best_f, rem])])\n\n    return (best_c, best_f) if gaps[best_f] > -np.inf else (None, None)\n\n",
  "shadow_price_capacity_scarcity_aug_194": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised score with deterministic tie\u2011breaking noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    caps = np.clip(caps, 1e-12, None)                    # avoid zero capacity\n    dem_all = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Shadow price: inverse of remaining capacity\n    pi = 1.0 / (caps + 1.0 + 1e-12)\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        scores = costs[feas, int(c)] + pi[feas] * d\n        # deterministic tie\u2011breaking noise\n        scores += np.arange(scores.size) * 1e-9\n        idx = int(np.argmin(scores))\n        f = int(feas[idx])\n        val = float(scores[idx])\n        if val < best_val:\n            best_val = val\n            best_c = int(c)\n            best_f = f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "shadow_price_capacity_scarcity_aug_195": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"While\u2011loop variant with top\u2011k random choice among feasible facilities.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    caps = np.clip(caps, 1e-12, None)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Weighted shadow price with reduced influence\n    pi = 0.6 / (caps + 1.0 + 1e-12)\n\n    rng = np.random.default_rng(42)\n    best_val = np.inf\n    best_c = None\n    best_f = None\n\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size > 0:\n            scores = costs[feas, int(c)] + pi[feas] * d\n            # choose among the best 7 (or fewer) assignments\n            top_k = min(7, scores.size)\n            top_idx = np.argpartition(scores, top_k - 1)[:top_k]\n            chosen_idx = rng.choice(top_idx)\n            f = int(feas[chosen_idx])\n            val = float(scores[chosen_idx])\n            if val < best_val:\n                best_val = val\n                best_c = int(c)\n                best_f = f\n        idx += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "shadow_price_capacity_scarcity_aug_196": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Maximising negative score with deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    caps = np.clip(caps, 1e-12, None)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    pi = 1.0 / (caps + 1.0 + 1e-12)\n\n    best_val = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        scores = costs[feas, int(c)] + pi[feas] * d\n        # deterministic noise for tie\u2011breaking\n        scores += np.arange(scores.size) * 1e-8\n        idx = int(np.argmax(-scores))          # argmax of negative scores\n        f = int(feas[idx])\n        val = -float(scores[idx])              # convert back to positive score\n        if val > best_val:\n            best_val = val\n            best_c = int(c)\n            best_f = f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "shadow_price_capacity_scarcity_aug_197": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min probabilistic selection with temperature scaling.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    caps = np.clip(caps, 1e-12, None)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    pi = 1.0 / (caps + 1.0 + 1e-12)\n\n    rng = np.random.default_rng(123)\n    best_val = np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        scores = costs[feas, int(c)] + pi[feas] * d\n        # soft\u2011min probabilities\n        temperature = 0.5\n        probs = np.exp(-scores / temperature)\n        probs /= np.sum(probs)\n        chosen_idx = rng.choice(len(probs), p=probs)\n        f = int(feas[chosen_idx])\n        val = float(scores[chosen_idx])\n        if val < best_score:\n            best_score = val\n            best_c = int(c)\n            best_f = f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "cost_minus_capacity_bonus_aug_198": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised greedy selection with a small noise perturbation for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    kappa = 0.25  # weight for remaining capacity penalty\n    best_score = np.inf\n    best_c = best_f = None\n\n    for c in remaining_customers:\n        d = demands[c]\n        # facilities that can still serve the customer\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        rem_after = caps[feas] - d\n        rem_after = np.clip(rem_after, 0, np.inf)          # avoid negative slack\n        scores = costs[feas, c] - kappa * rem_after\n\n        # small deterministic noise to break ties\n        noise = np.random.uniform(0, 1e-6, size=scores.shape)\n        scores += noise\n\n        idx = np.argmin(scores)\n        if scores[idx] < best_score:\n            best_score = scores[idx]\n            best_c = c\n            best_f = feas[idx]\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "cost_minus_capacity_bonus_aug_199": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Greedy selection using a while loop and a soft\u2011min probability for choosing\n    among feasible facilities.  A temperature controls the randomness.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    kappa = 0.15\n    best_score = np.inf\n    best_c = best_f = None\n    idx = 0\n\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        d = demands[c]\n        feas = [f for f in range(len(caps)) if caps[f] >= d]\n        if feas:\n            rem_after = caps[feas] - d\n            rem_after = np.clip(rem_after, 0, np.inf)\n            scores = costs[feas, c] - kappa * rem_after\n\n            # soft\u2011min probabilities\n            temp = 0.5\n            probs = np.exp(-scores / (temp + 1e-12))\n            probs /= np.sum(probs) + 1e-12\n\n            chosen = np.random.choice(feas, p=probs)\n            chosen_score = costs[chosen, c] - kappa * (caps[chosen] - d)\n            if chosen_score < best_score:\n                best_score = chosen_score\n                best_c = c\n                best_f = chosen\n        idx += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "cost_minus_capacity_bonus_aug_200": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses the maximum remaining capacity after assignment as a penalty\n    and selects the facility with the lowest adjusted cost.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    kappa = 0.3\n    best_score = np.inf\n    best_c = best_f = None\n\n    for c in remaining_customers:\n        d = demands[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        rem_after = caps[feas] - d\n        rem_after = np.clip(rem_after, 0, np.inf)\n\n        # penalty based on the worst remaining capacity\n        penalty = np.max(rem_after) / (caps.mean() + 1e-12)\n        scores = costs[feas, c] + kappa * penalty\n\n        idx = np.argmin(scores)\n        if scores[idx] < best_score:\n            best_score = scores[idx]\n            best_c = c\n            best_f = feas[idx]\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "cost_minus_capacity_bonus_aug_201": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Randomly picks among the top\u2011k best assignments for each customer.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    kappa = 0.2\n    top_k = 5\n    best_score = np.inf\n    best_c = best_f = None\n\n    for c in remaining_customers:\n        d = demands[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        rem_after = caps[feas] - d\n        rem_after = np.clip(rem_after, 0, np.inf)\n\n        scores = costs[feas, c] - kappa * rem_after\n        sorted_idx = np.argsort(scores)\n        k = min(top_k, len(sorted_idx))\n        candidates = feas[sorted_idx[:k]]\n\n        chosen = np.random.choice(candidates)\n        chosen_score = costs[chosen, c] - kappa * (caps[chosen] - d)\n        if chosen_score < best_score:\n            best_score = chosen_score\n            best_c = c\n            best_f = chosen\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "balanced_used_capacity_increment_aug_202": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Greedy selection based on cost + weighted peak\u2011utilization increase.\n    Uses vectorised operations and deterministic noise for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 10.0\n    eps = 1e-12\n\n    caps_rem = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Current load per facility\n    used = np.array([sum(dem[c] for c in custs) for custs in assignments], dtype=float)\n\n    # Total available capacity (used + remaining)\n    total = np.maximum(used + caps_rem, eps)\n\n    # Utilisation ratio, clipped to [0,1]\n    util0 = np.clip(used / total, 0.0, 1.0)\n    peak0 = float(np.max(util0)) if util0.size else 0.0\n\n    best_score = np.inf\n    best_cust, best_fac = None, None\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps_rem >= d)[0]\n        for f in feas:\n            used2 = used.copy()\n            used2[f] += d\n            util2 = np.clip(used2 / total, 0.0, 1.0)\n            peak2 = float(np.max(util2))\n            # deterministic noise to break ties\n            noise = 1e-6 * (c + f)\n            score = float(C[f, c]) + lam * (peak2 - peak0) + noise\n            if score < best_score:\n                best_score = score\n                best_cust, best_fac = c, f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "balanced_used_capacity_increment_aug_203": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a while\u2011loop, list comprehensions and a top\u2011k selection.\n    Utilisation is averaged (np.mean) and ties are resolved by picking\n    the minimal cost among the top\u20115 candidates.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 8.0\n    eps = 1e-12\n    top_k = 5\n\n    caps_rem = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    used = np.array([sum(dem[c] for c in custs) for custs in assignments], dtype=float)\n    total = np.maximum(used + caps_rem, eps)\n    util0 = np.clip(used / total, 0.0, 1.0)\n    peak0 = float(np.mean(util0))  # using mean instead of max\n\n    best_cust, best_fac = None, None\n    best_score = np.inf\n\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        d = dem[c]\n        feas = np.where(caps_rem >= d)[0]\n        for f in feas:\n            used2 = used.copy()\n            used2[f] += d\n            util2 = np.clip(used2 / total, 0.0, 1.0)\n            peak2 = float(np.mean(util2))\n            score = float(C[f, c]) + lam * (peak2 - peak0)\n            if score < best_score:\n                best_score = score\n                best_cust, best_fac = c, f\n        idx += 1\n\n    # If we found candidates, refine by top\u2011k selection\n    if best_cust is not None:\n        candidates = []\n        for c in remaining_customers:\n            d = dem[c]\n            feas = np.where(caps_rem >= d)[0]\n            for f in feas:\n                used2 = used.copy()\n                used2[f] += d\n                util2 = np.clip(used2 / total, 0.0, 1.0)\n                peak2 = float(np.mean(util2))\n                score = float(C[f, c]) + lam * (peak2 - peak0)\n                candidates.append((score, c, f))\n        candidates.sort(key=lambda x: x[0])\n        top_candidates = candidates[:top_k]\n        # pick the one with minimal cost among top\u2011k\n        best_cust, best_fac = min(top_candidates, key=lambda x: C[x[2], x[1]])[1:]\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "balanced_used_capacity_increment_aug_204": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Employs median utilisation, a negative lambda to favour lower peaks,\n    and deterministic noise for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = -5.0  # negative weight to discourage high peaks\n    eps = 1e-12\n\n    caps_rem = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    used = np.array([sum(dem[c] for c in custs) for custs in assignments], dtype=float)\n    total = np.maximum(used + caps_rem, eps)\n\n    util0 = np.clip(used / total, 0.0, 1.0)\n    peak0 = float(np.median(util0))  # median instead of max\n\n    best_score = np.inf\n    best_cust, best_fac = None, None\n\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps_rem >= d)[0]\n        for f in feas:\n            used2 = used.copy()\n            used2[f] += d\n            util2 = np.clip(used2 / total, 0.0, 1.0)\n            peak2 = float(np.max(util2))\n            noise = 1e-6 * (c * f)  # deterministic noise\n            score = float(C[f, c]) + lam * (peak2 - peak0) + noise\n            if score < best_score:\n                best_score = score\n                best_cust, best_fac = c, f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "balanced_used_capacity_increment_aug_205": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a softmin selection: computes weights as exp(-score) and picks the\n    third highest weight among the top\u20117 candidates. Utilisation is clipped\n    and epsilon is added to avoid division by zero.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 8.0\n    eps = 1e-12\n    top_k = 7\n\n    caps_rem = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Current load per facility\n    used = np.zeros(len(assignments), dtype=float)\n    for idx, custs in enumerate(assignments):\n        np.add.at(used, idx, dem[custs])\n\n    total = np.maximum(used + caps_rem, eps)\n    util0 = np.clip(used / total, 0.0, 1.0)\n    peak0 = float(np.max(util0))\n\n    scores = []\n    for c in remaining_customers:\n        d = dem[c]\n        feas = np.where(caps_rem >= d)[0]\n        for f in feas:\n            used2 = used.copy()\n            used2[f] += d\n            util2 = np.clip(used2 / total, 0.0, 1.0)\n            peak2 = float(np.max(util2))\n            score = float(C[f, c]) + lam * (peak2 - peak0)\n            scores.append((score, c, f))\n\n    if not scores:\n        return (None, None)\n\n    # Softmin weights\n    scores_array = np.array(scores, dtype=float)\n    weight = np.exp(-scores_array[:, 0])\n    idx_sorted = np.argsort(-weight)  # descending weight\n    top_indices = idx_sorted[:top_k]\n    if len(top_indices) < 3:\n        chosen_idx = top_indices[0]\n    else:\n        chosen_idx = top_indices[2]  # third highest weight\n    _, chosen_c, chosen_f = scores_array[chosen_idx]\n    return int(chosen_c), int(chosen_f)\n\n",
  "facility_cheapest_customer_with_best_fit_aug_206": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised selection with deterministic noise for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    dem = np.asarray(customer_demands, dtype=np.float64)\n    costs = np.asarray(assignment_costs, dtype=np.float64)\n    rem = np.asarray(remaining_customers, dtype=np.int64)\n\n    best_pair = None\n    best_key = (np.inf, np.inf)  # (slack, cost)\n\n    for f in range(caps.size):\n        # feasible customers for facility f\n        feas = rem[dem[rem] <= caps[f]]\n        if feas.size == 0:\n            continue\n\n        # Slack and cost vectors\n        slack = caps[f] - dem[feas]\n        slack = np.clip(slack, 0, None)  # avoid negative values\n        cost = costs[f, feas]\n\n        # Add tiny deterministic noise to avoid exact ties\n        noise = np.random.rand(feas.size) * 1e-6\n        key = np.min(slack + noise)  # use slack + noise as primary key\n        idx = np.argmin(slack + noise)\n\n        chosen_c = int(feas[idx])\n        chosen_f = int(f)\n        chosen_slack = float(slack[idx])\n        chosen_cost = float(cost[idx])\n\n        # Compare by slack then cost\n        if (chosen_slack, chosen_cost) < best_key:\n            best_key = (chosen_slack, chosen_cost)\n            best_pair = (chosen_c, chosen_f)\n\n    return best_pair if best_pair is not None else (None, None)\n\n",
  "facility_cheapest_customer_with_best_fit_aug_207": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    While\u2011loop implementation with soft\u2011min (random choice among top\u2011k cheapest)\n    and epsilon added to denominators for numerical safety.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    demands = np.asarray(customer_demands, dtype=np.float64)\n    costs = np.asarray(assignment_costs, dtype=np.float64)\n    rem = np.asarray(remaining_customers, dtype=np.int64)\n\n    best = (np.inf, np.inf, None, None)  # (slack, cost, c, f)\n    f = 0\n    top_k = 7\n\n    while f < caps.size:\n        feas = rem[demands[rem] <= caps[f]]\n        if feas.size > 0:\n            cost_vals = costs[f, feas]\n            # random choice among the top_k cheapest customers\n            sorted_idx = np.argsort(cost_vals)\n            k_idx = sorted_idx[:min(top_k, feas.size)]\n            chosen_idx = np.random.choice(k_idx)\n            c = int(feas[chosen_idx])\n\n            slack = float(caps[f] - demands[c])\n            # Use slack ratio as a secondary metric, add epsilon to avoid div\u20110\n            slack_ratio = slack / (demands[c] + 1e-12)\n\n            key = (slack_ratio, float(costs[f, c]), c, f)\n            if key < best:\n                best = key\n        f += 1\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "facility_cheapest_customer_with_best_fit_aug_208": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    List\u2011comprehension based selection that inverts the usual feasibility check\n    and uses the median slack to rank facilities. Small noise added for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    dem = np.asarray(customer_demands, dtype=np.float64)\n    cost_mat = np.asarray(assignment_costs, dtype=np.float64)\n    rem = np.asarray(remaining_customers, dtype=np.int64)\n\n    best_pair = None\n    best_key = (np.inf, np.inf, None, None)  # (median_slack, cost, c, f)\n\n    for f in range(caps.size):\n        feasible = [c for c in rem if dem[c] <= caps[f]]\n        if not feasible:\n            continue\n\n        slacks = [caps[f] - dem[c] for c in feasible]\n        median_slack = np.median(slacks)\n\n        # Cheapest cost with tiny deterministic noise\n        costs = [cost_mat[f, c] + np.random.rand() * 1e-6 for c in feasible]\n        idx_min = np.argmin(costs)\n        c = int(feasible[idx_min])\n\n        key = (median_slack, float(cost_mat[f, c]), c, f)\n        if key < best_key:\n            best_key = key\n            best_pair = (c, f)\n\n    return best_pair if best_pair is not None else (None, None)\n\n",
  "facility_cheapest_customer_with_best_fit_aug_209": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Proxy\u2011based selection that maximises the maximum slack per facility and then\n    chooses the cheapest feasible customer with a small noise tie\u2011breaker.\n    Epsilon added to denominators to avoid division by zero.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    dem = np.asarray(customer_demands, dtype=np.float64)\n    cost_mat = np.asarray(assignment_costs, dtype=np.float64)\n    rem = np.asarray(remaining_customers, dtype=np.int64)\n\n    # Slack matrix (facilities \u00d7 remaining customers)\n    slack_mat = caps[:, None] - dem[rem]\n    slack_mat = np.clip(slack_mat, 0, None)          # ensure non\u2011negative\n    max_slack = np.max(slack_mat, axis=1)            # max slack per facility\n\n    # Choose facility with largest maximum slack\n    f = int(np.argmax(max_slack))\n\n    # Feasible customers for this facility\n    feas = rem[slack_mat[f] > 0]\n    if feas.size == 0:\n        return None, None\n\n    # Cost vector for feasible customers\n    cost_vals = cost_mat[f, feas]\n    # Add deterministic noise for tie\u2011breaking\n    noisy_costs = cost_vals + np.random.rand(feas.size) * 1e-6\n\n    # Compute a combined metric: ratio of slack to demand (with epsilon)\n    ratios = slack_mat[f, feas] / (dem[feas] + 1e-12)\n    combined = ratios + noisy_costs * 1e-3  # small weight for cost\n\n    idx_min = np.argmin(combined)\n    c = int(feas[idx_min])\n\n    return (c, f)\n\n",
  "customer_cheapest_facility_with_best_fit_aug_210": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that selects the customer\u2011facility pair with the\n    smallest slack.  Ties are broken by the lowest assignment cost.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr   = np.asarray(remaining_capacities, dtype=float)\n    dem_arr   = np.asarray(customer_demands, dtype=float)\n    cost_arr  = np.asarray(assignment_costs, dtype=float)\n\n    cust_idx  = np.asarray(remaining_customers, dtype=int)\n    fac_idx   = np.arange(cap_arr.size, dtype=int)\n\n    # Feasibility mask: True where a facility can serve the customer\n    mask  = cap_arr[:, None] >= dem_arr[cust_idx][None, :]\n    # Slack and cost only for feasible assignments\n    slack = np.where(mask,\n                     cap_arr[:, None] - dem_arr[cust_idx][None, :] + 1e-12,\n                     np.inf)\n    cost  = np.where(mask,\n                     cost_arr[:, cust_idx][None, :],\n                     np.inf)\n\n    # Ensure slack is non\u2011negative\n    slack = np.clip(slack, 0, np.inf)\n\n    # Find the minimal slack\n    min_slack = np.min(slack)\n    # Candidates with that slack\n    cand_mask = slack == min_slack\n    # Among them, pick the one with the smallest cost\n    best_idx  = np.argmin(cost * cand_mask + np.inf * (~cand_mask))\n    f         = fac_idx[best_idx // cost.shape[1]]\n    c         = cust_idx[best_idx % cost.shape[1]]\n    return int(c), int(f)\n\n",
  "customer_cheapest_facility_with_best_fit_aug_211": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Weighted scoring variant: slack and cost are combined with tunable\n    coefficients.  The top_k cheapest assignments are considered and a\n    deterministic random choice is made among them.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng(seed=42)\n\n    cap_arr   = np.asarray(remaining_capacities, dtype=float)\n    dem_arr   = np.asarray(customer_demands, dtype=float)\n    cost_arr  = np.asarray(assignment_costs, dtype=float)\n\n    cust_idx  = np.asarray(remaining_customers, dtype=int)\n    fac_idx   = np.arange(cap_arr.size, dtype=int)\n\n    mask  = cap_arr[:, None] >= dem_arr[cust_idx][None, :]\n    slack = np.where(mask,\n                     cap_arr[:, None] - dem_arr[cust_idx][None, :] + 1e-12,\n                     np.inf)\n    cost  = np.where(mask,\n                     cost_arr[:, cust_idx][None, :],\n                     np.inf)\n\n    # Clip slack to avoid negative values\n    slack = np.clip(slack, 0, np.inf)\n\n    # Tunable weights\n    w_slack = 0.4\n    w_cost  = 0.6\n\n    score = w_slack * slack + w_cost * cost\n    # Deterministic tie\u2011breaking noise\n    noise = 1e-6 * rng.normal(size=score.shape)\n    score += noise\n\n    # Consider only the top_k cheapest assignments\n    top_k = 7\n    flat_idx = np.argsort(score, axis=None)[:top_k]\n    chosen = rng.choice(flat_idx)\n    f = fac_idx[chosen // cost.shape[1]]\n    c = cust_idx[chosen % cost.shape[1]]\n    return int(c), int(f)\n\n",
  "customer_cheapest_facility_with_best_fit_aug_212": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Probabilistic assignment: for each customer, a softmax over the negative\n    costs selects a facility.  The customer with the smallest resulting\n    slack is chosen; ties are broken by the lowest cost.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr   = np.asarray(remaining_capacities, dtype=float)\n    dem_arr   = np.asarray(customer_demands, dtype=float)\n    cost_arr  = np.asarray(assignment_costs, dtype=float)\n\n    cust_idx  = np.asarray(remaining_customers, dtype=int)\n    fac_idx   = np.arange(cap_arr.size, dtype=int)\n\n    mask  = cap_arr[:, None] >= dem_arr[cust_idx][None, :]\n    cost_masked = np.where(mask,\n                           cost_arr[:, cust_idx][None, :],\n                           np.inf)\n\n    # Softmax over negative costs (higher cost \u2192 lower probability)\n    exp_neg = np.exp(-cost_masked + 1e-12)          # small shift to avoid overflow\n    denom   = np.sum(exp_neg, axis=0, keepdims=True) + 1e-12\n    probs   = np.clip(exp_neg / denom, 0, 1)\n\n    # Facility with highest probability for each customer\n    f_idx = np.argmax(probs, axis=0)\n\n    slack = cap_arr[f_idx] - dem_arr[cust_idx] + 1e-12\n    slack = np.clip(slack, 0, np.inf)\n\n    cost = cost_arr[f_idx, cust_idx]\n\n    # Choose the pair with minimal slack, then minimal cost\n    best_idx = np.argmin(slack)\n    min_slack = slack[best_idx]\n    cand_mask = slack == min_slack\n    if np.any(cand_mask):\n        cand_costs = cost[cand_mask]\n        best_idx = np.where(cand_mask)[0][np.argmin(cand_costs)]\n\n    c = cust_idx[best_idx]\n    f = fac_idx[f_idx[best_idx]]\n    return int(c), int(f)\n\n",
  "customer_cheapest_facility_with_best_fit_aug_213": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Imperative loop variant that iteratively updates the best slack/cost pair.\n    Uses a while loop and inverts the usual comparison logic for variety.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr   = np.asarray(remaining_capacities, dtype=float)\n    dem_arr   = np.asarray(customer_demands, dtype=float)\n    cost_arr  = np.asarray(assignment_costs, dtype=float)\n\n    customers = list(remaining_customers)\n    best_slack = np.inf\n    best_cost  = np.inf\n    best_c = None\n    best_f = None\n\n    rng = np.random.default_rng(seed=42)\n\n    while customers:\n        c = customers.pop(0)\n        d = dem_arr[c]\n        for f, cap in enumerate(cap_arr):\n            if cap + 1e-12 >= d:                     # feasibility guard\n                slack = cap - d + 1e-12\n                slack = np.clip(slack, 0, np.inf)\n                cost  = cost_arr[f, c]\n                # Inverted comparison: keep the pair with *larger* slack\n                # but if slack equals, keep the *smaller* cost\n                if (slack > best_slack) or (slack == best_slack and cost < best_cost):\n                    best_slack = slack\n                    best_cost  = cost\n                    best_c = c\n                    best_f = f\n\n    # Add deterministic noise to break any remaining ties\n    if best_c is not None:\n        noise = 1e-6 * rng.normal()\n        best_slack += noise\n        return int(best_c), int(best_f)\n    return None, None\n\n",
  "quantile_clipped_cost_selection_aug_214": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation with deterministic noise for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C   = np.asarray(assignment_costs, dtype=float)\n\n    # Feasibility mask (facilities \u00d7 customers)\n    mask = caps[:, None] >= dem[None, :]\n    feasible_costs = np.where(mask, C, np.inf)\n\n    # Gather all feasible cost values for percentile clipping\n    feas_vals = feasible_costs[feasible_costs != np.inf]\n    if feas_vals.size == 0:\n        return None, None\n\n    # Clip at the 90\u2011th percentile\n    clip = float(np.quantile(feas_vals, 0.90))\n    clipped = np.minimum(feasible_costs, clip)\n\n    # Deterministic noise (avoids ties)\n    noise = 1e-9 * np.arange(clipped.size).reshape(clipped.shape)\n    best_idx = np.unravel_index(np.argmin(clipped + noise), clipped.shape)\n\n    if np.isinf(clipped[best_idx]):\n        return None, None\n\n    # Return (customer, facility)\n    return int(best_idx[1]), int(best_idx[0])\n\n",
  "quantile_clipped_cost_selection_aug_215": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Soft\u2011min selection with a relaxed percentile (85\u202f%) and temperature scaling.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    mask = caps[:, None] >= dem[None, :]\n    feas_costs = np.where(mask, C, np.inf)\n\n    feas_vals = feas_costs[feas_costs != np.inf]\n    if feas_vals.size == 0:\n        return None, None\n\n    clip = float(np.quantile(feas_vals, 0.85))\n    clipped = np.minimum(feas_costs, clip)\n\n    eps = 1e-12\n    temp = 1.0\n    # Soft\u2011min weights\n    weights = np.exp(-clipped / (temp + eps))\n    weights = np.where(mask, weights, -np.inf)\n\n    best_flat = np.argmax(weights)\n    best_idx  = np.unravel_index(best_flat, weights.shape)\n\n    if weights[best_idx] == -np.inf:\n        return None, None\n\n    return int(best_idx[1]), int(best_idx[0])\n\n",
  "quantile_clipped_cost_selection_aug_216": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses capacity slack as a weight: cost / (slack + epsilon).\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    slack = caps[:, None] - dem[None, :]\n    mask  = slack >= 0\n    feas_costs = np.where(mask, C, np.inf)\n\n    feas_vals = feas_costs[feas_costs != np.inf]\n    if feas_vals.size == 0:\n        return None, None\n\n    clip = float(np.quantile(feas_vals, 0.90))\n    clipped = np.minimum(feas_costs, clip)\n\n    eps = 1e-12\n    weighted = clipped / (slack + eps)\n    weighted = np.where(mask, weighted, np.inf)\n\n    best_idx = np.unravel_index(np.argmin(weighted), weighted.shape)\n    if np.isinf(weighted[best_idx]):\n        return None, None\n\n    return int(best_idx[1]), int(best_idx[0])\n\n",
  "quantile_clipped_cost_selection_aug_217": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Top\u2011k selection (k=7) after clipping at the 80\u2011th percentile.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    mask = caps[:, None] >= dem[None, :]\n    feas_costs = np.where(mask, C, np.inf)\n\n    feas_vals = feas_costs[feas_costs != np.inf]\n    if feas_vals.size == 0:\n        return None, None\n\n    clip = float(np.quantile(feas_vals, 0.80))\n    clipped = np.minimum(feas_costs, clip)\n\n    top_k = 7\n    # Extract indices of feasible entries\n    fac_idx, cust_idx = np.where(mask)\n    flat_costs = clipped[mask]\n\n    # Get indices of the k smallest feasible costs\n    if flat_costs.size <= top_k:\n        chosen_flat = np.argmin(flat_costs)\n    else:\n        partition = np.argpartition(flat_costs, top_k - 1)[:top_k]\n        chosen_flat = partition[0]  # deterministic tie\u2011break by order\n\n    # Map back to (customer, facility)\n    return int(cust_idx[chosen_flat]), int(fac_idx[chosen_flat])\n\n",
  "stochastic_ranking_cost_vs_slack_aug_218": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 1 \u2013 uses a while\u2011loop to build candidate pairs,\n    adds a small deterministic noise to break ties, and\n    clips slack values to avoid negatives.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    # probability to compare by cost vs slack\n    p = 0.7\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C   = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        d = float(dem[c])\n        # find facilities that can still serve the customer\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            slack = caps[f] - d\n            # deterministic noise: small uniform value added to cost\n            noise = rng.uniform(0, 1e-6)\n            pairs.append((int(c), int(f), float(C[f, c]) + noise, float(slack)))\n        idx += 1\n\n    if not pairs:\n        return None, None\n\n    # bubble\u2011like passes \u2013 keep original stochastic comparison\n    pairs = list(pairs)\n    for _ in range(8):\n        swapped = False\n        i = 0\n        while i < len(pairs) - 1:\n            a, b = pairs[i], pairs[i + 1]\n            if rng.random() < p:\n                better = a[2] <= b[2]\n            else:\n                better = a[3] <= b[3]\n            if not better:\n                pairs[i], pairs[i + 1] = pairs[i + 1], pairs[i]\n                swapped = True\n            i += 1\n        if not swapped:\n            break\n\n    c, f, _, _ = pairs[0]\n    return c, f\n\n",
  "stochastic_ranking_cost_vs_slack_aug_219": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 2 \u2013 employs a soft\u2011min probability distribution over\n    the top\u2011k candidate pairs, with tuned weights and clipping.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    top_k = 7          # tuned hyper\u2011parameter\n    cost_weight = 0.4  # tuned weight\n    slack_weight = 0.6 # tuned weight\n    eps = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    # Build candidate list\n    pairs = [(c, f, float(C[f, c]), float(caps[f] - dem[c]))\n             for c in remaining_customers\n             for f in range(len(caps))\n             if caps[f] >= dem[c]]\n\n    if not pairs:\n        return None, None\n\n    # Compute combined score (lower is better)\n    scores = np.array([cost_weight * p[2] + slack_weight * p[3] for p in pairs])\n    # Soft\u2011min probabilities\n    exp_neg = np.exp(-scores / (np.std(scores) + eps))\n    probs = exp_neg / (np.sum(exp_neg) + eps)\n\n    # Sample among top_k based on probabilities\n    idxs = np.argsort(probs)[-top_k:]  # indices of top_k probabilities\n    probs_top = probs[idxs]\n    probs_top /= np.sum(probs_top) + eps\n    chosen = rng.choice(idxs, p=probs_top)\n\n    c, f, _, _ = pairs[chosen]\n    return int(c), int(f)\n\n",
  "stochastic_ranking_cost_vs_slack_aug_220": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 3 \u2013 uses inverted bubble sort logic, median slack\n    for tie\u2011breaking, and explicit epsilon handling.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    p = 0.7\n    eps = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    # Build all feasible pairs\n    pairs = []\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            slack = caps[f] - d\n            pairs.append((int(c), int(f), float(C[f, c]), float(slack)))\n\n    if not pairs:\n        return None, None\n\n    # Inverted bubble sort: keep swapping when current is better\n    for _ in range(8):\n        swapped = False\n        for i in range(len(pairs) - 1):\n            a, b = pairs[i], pairs[i + 1]\n            if rng.random() < p:\n                better = a[2] <= b[2]\n            else:\n                # use median slack as tie\u2011breaker\n                median_slack = np.median([a[3], b[3]]) + eps\n                better = a[3] <= median_slack\n            if not better:\n                pairs[i], pairs[i + 1] = pairs[i + 1], pairs[i]\n                swapped = True\n        if not swapped:\n            break\n\n    c, f, _, _ = pairs[0]\n    return c, f\n\n",
  "stochastic_ranking_cost_vs_slack_aug_221": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 4 \u2013 constructs pairs with a list comprehension,\n    sorts by a weighted sum of cost and slack,\n    then picks randomly among the best k candidates.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    top_k = 5\n    cost_coef = 0.6\n    slack_coef = 0.4\n    eps = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    # Build feasible pairs in one comprehension\n    pairs = [(c, f,\n              float(C[f, c]),\n              float(caps[f] - dem[c]))\n             for c in remaining_customers\n             for f in range(len(caps))\n             if caps[f] >= dem[c]]\n\n    if not pairs:\n        return None, None\n\n    # Compute weighted score\n    scores = np.array([cost_coef * p[2] + slack_coef * p[3] for p in pairs])\n    # Sort indices by score\n    sorted_idx = np.argsort(scores)\n    # Randomly pick among the top_k best\n    best_idx = sorted_idx[:top_k]\n    chosen = rng.choice(best_idx)\n\n    c, f, _, _ = pairs[chosen]\n    return int(c), int(f)\n\n",
  "min_cost_under_capacity_fraction_rule_aug_222": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that prefers assignments keeping facility capacity\n    above a fraction of the median customer demand.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_customers = np.asarray(remaining_customers, dtype=int)\n\n    # Median\u2011based target capacity\n    avg_d = np.median(dem[rem_customers]) if rem_customers.size else np.median(dem)\n    target = 0.4 * max(1e-9, avg_d)\n    target = np.clip(target, 0, np.inf)\n\n    # Remaining capacity if each customer were assigned to each facility\n    rem_cap_matrix = caps - dem[rem_customers][:, None]          # shape: (customers, facilities)\n    rem_cap_matrix = np.clip(rem_cap_matrix, 0, np.inf)          # avoid negative capacities\n\n    # Violation of the target (0 if above target, otherwise deficit)\n    viol_matrix = np.maximum(0.0, target - rem_cap_matrix)\n\n    # Cost matrix aligned with customers x facilities\n    cost_matrix = costs[:, rem_customers].T                      # shape: (customers, facilities)\n\n    # Composite score: weighted sum of violation and cost\n    score_matrix = viol_matrix + 0.5 * cost_matrix\n\n    # Deterministic noise to break ties\n    noise = np.arange(score_matrix.size).reshape(score_matrix.shape) * 1e-6\n    score_matrix += noise\n\n    # Pick the best assignment\n    flat_idx = np.argmin(score_matrix)\n    cust_idx, fac_idx = np.unravel_index(flat_idx, score_matrix.shape)\n\n    return int(rem_customers[cust_idx]), int(fac_idx)\n\n",
  "min_cost_under_capacity_fraction_rule_aug_223": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Imperative version using while loops and list comprehensions.\n    Adds deterministic noise for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_customers = list(remaining_customers)\n    frac = 0.40\n    avg_d = float(np.mean(dem[rem_customers]))\n    target = frac * max(1e-9, avg_d)\n    target = np.clip(target, 0, np.inf)\n\n    best = None\n    idx = 0\n    while idx < len(rem_customers):\n        c = rem_customers[idx]\n        d = dem[c]\n        feas = [f for f, cap in enumerate(caps) if cap >= d]\n        for f in feas:\n            rem_after = caps[f] - d\n            viol = target - rem_after if rem_after < target else 0.0\n            cost = costs[f, c]\n            noise = 1e-9 * (c + f)                     # deterministic tie\u2011break\n            key = (viol + noise, cost + noise)\n            if best is None or key < best[0]:\n                best = (key, c, f)\n        idx += 1\n\n    return (int(best[1]), int(best[2])) if best else (None, None)\n\n",
  "min_cost_under_capacity_fraction_rule_aug_224": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Randomised top\u2011k selection. Uses sum for average demand and\n    a soft\u2011min style scoring. Adds an epsilon to avoid division by zero.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_customers = np.asarray(remaining_customers, dtype=int)\n\n    avg_d = float(np.sum(dem[rem_customers]) / (len(rem_customers) + 1e-12))\n    target = 0.4 * max(1e-9, avg_d)\n    target = np.clip(target, 0, np.inf)\n\n    candidates = []\n    for c in rem_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            rem_after = caps[f] - d\n            viol = target - rem_after if rem_after < target else 0.0\n            cost = costs[f, c]\n            score = viol + cost\n            candidates.append((score, c, f))\n\n    # Sort by score and pick a random element among the best few\n    candidates.sort(key=lambda x: x[0])\n    top_k = min(7, len(candidates))\n    top = candidates[:top_k]\n    idx = np.random.choice(len(top))\n    _, c, f = top[idx]\n    return int(c), int(f)\n\n",
  "min_cost_under_capacity_fraction_rule_aug_225": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses np.clip for capacity bounds, np.max for aggregate,\n    and a weighted score with deterministic noise.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_customers = np.asarray(remaining_customers, dtype=int)\n\n    avg_d = float(np.mean(dem[rem_customers]))\n    target = 0.4 * max(1e-9, avg_d)\n    target = np.clip(target, 0, np.inf)\n\n    best = (np.inf, None, None)   # (score, customer, facility)\n    for c in rem_customers:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            rem_after = caps[f] - d\n            rem_after = np.clip(rem_after, 0, np.inf)\n            viol = max(0.0, target - rem_after)\n            cost = costs[f, c]\n            score = 0.3 * viol + 0.7 * cost\n            noise = 1e-8 * (c * 31 + f)   # deterministic tie\u2011break\n            key = score + noise\n            if key < best[0]:\n                best = (key, c, f)\n\n    return (int(best[1]), int(best[2])) if best[2] is not None else (None, None)\n\n",
  "most_dependent_on_single_facility_aug_226": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best_margin = -np.inf\n    best_c = None\n    best_f = None\n\n    # Iterate with a while\u2011loop instead of a for\u2011loop\n    i = 0\n    while i < len(remaining_customers):\n        c = int(remaining_customers[i])\n        feas = np.nonzero(caps >= dem[c])[0]\n        if feas.size:\n            vals = C[feas, c]\n            if vals.size == 1:\n                margin = 1e12\n                f = int(feas[0])\n            else:\n                order = np.argsort(vals)\n                f = int(feas[order[0]])\n                margin = float(vals[order[1]] - vals[order[0]])\n            if margin > best_margin:\n                best_margin = margin\n                best_c = c\n                best_f = f\n        i += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "most_dependent_on_single_facility_aug_227": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    best_cust = None\n    best_fac = None\n\n    for cust in remaining_customers:\n        cust = int(cust)\n        feas_idx = np.where(cap_arr >= dem_arr[cust])[0]\n        if feas_idx.size == 0:\n            continue\n\n        costs = cost_mat[feas_idx, cust]\n        if costs.size == 1:\n            margin = 1e12\n            chosen = int(feas_idx[0])\n        else:\n            order = np.argsort(costs)\n            chosen = int(feas_idx[order[0]])\n            # Tuned weight for the margin\n            margin = (costs[order[1]] - costs[order[0]]) * 0.75\n        margin = np.clip(margin, -1e6, 1e6)\n        if margin > best_score:\n            best_score = margin\n            best_cust = cust\n            best_fac = chosen\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "most_dependent_on_single_facility_aug_228": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    cap_vec = np.asarray(remaining_capacities, dtype=float)\n    dem_vec = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    best_median = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        c = int(c)\n        feas = np.where(cap_vec >= dem_vec[c])[0]\n        if feas.size == 0:\n            continue\n\n        # Deterministic noise to break ties\n        noise = 1e-6 * feas\n        costs = cost_mat[feas, c] + noise\n\n        if costs.size == 1:\n            median_diff = 1e12\n            f = int(feas[0])\n        else:\n            sorted_idx = np.argsort(costs)\n            f = int(feas[sorted_idx[0]])\n            diffs = costs[sorted_idx[1:]] - costs[sorted_idx[0]]\n            median_diff = float(np.median(diffs))\n        median_diff = np.clip(median_diff, -1e6, 1e6)\n        if median_diff > best_median:\n            best_median = median_diff\n            best_c = c\n            best_f = f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "most_dependent_on_single_facility_aug_229": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    best_prob = -np.inf\n    best_c = None\n    best_f = None\n\n    temperature = 5.0  # controls softness of the softmin\n\n    for c in remaining_customers:\n        c = int(c)\n        feas = np.where(cap_arr >= dem_arr[c])[0]\n        if feas.size == 0:\n            continue\n\n        costs = cost_mat[feas, c]\n        exp_vals = np.exp(-costs / (temperature + 1e-12))\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n        probs = np.clip(probs, 1e-12, 1.0)\n\n        idx_best = int(np.argmax(probs))\n        f = int(feas[idx_best])\n        score = float(probs[idx_best])\n\n        if score > best_prob:\n            best_prob = score\n            best_c = c\n            best_f = f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "favor_underutilized_facilities_cost_adjusted_aug_230": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised selection with deterministic noise for tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rho = 0.40\n    eps = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Compute used capacity for each facility\n    used = np.array([sum(float(dem[c]) for c in custs) for custs in assignments], dtype=float)\n\n    # Utilisation ratio and discount factor\n    total = used + caps + eps\n    util = used / total\n    discount = 1.0 - rho * (1.0 - util)\n    discount = np.clip(discount, 0.5, 1.0)   # bound discount\n\n    best_cost = np.inf\n    best_cust = None\n    best_fac = None\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.flatnonzero(caps >= d)\n        if feas.size == 0:\n            continue\n\n        # deterministic tiny noise to break ties\n        noise = 1e-9 * (feas + 1)\n        adj = C[feas, int(c)] * discount[feas] + noise\n        idx = int(np.argmin(adj))\n        f = int(feas[idx])\n        val = float(adj[idx])\n\n        if val < best_cost:\n            best_cost = val\n            best_cust = int(c)\n            best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "favor_underutilized_facilities_cost_adjusted_aug_231": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min probabilistic selection with a while loop.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rho = 0.30\n    beta = 5.0\n    eps = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    used = np.array([sum(float(dem[c]) for c in custs) for custs in assignments], dtype=float)\n\n    total = used + caps + eps\n    util = used / total\n    discount = 1.0 - rho * (1.0 - util)\n    discount = np.clip(discount, 0.6, 1.0)\n\n    best_cust, best_fac = None, None\n    best_cost = np.inf\n\n    cust_iter = iter(remaining_customers)\n    while True:\n        try:\n            c = next(cust_iter)\n        except StopIteration:\n            break\n\n        d = float(dem[int(c)])\n        feas = np.flatnonzero(caps >= d)\n        if feas.size == 0:\n            continue\n\n        adj = C[feas, int(c)] * discount[feas]\n        probs = np.exp(-adj * beta)\n        probs /= probs.sum() + eps\n        chosen = np.random.choice(feas, p=probs)\n        val = float(adj[np.where(feas == chosen)[0][0]])\n\n        if val < best_cost:\n            best_cost = val\n            best_cust = int(c)\n            best_fac = int(chosen)\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "favor_underutilized_facilities_cost_adjusted_aug_232": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Top\u2011k deterministic selection with median utilisation.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rho = 0.35\n    top_k = 3\n    eps = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # use median of used capacities for utilisation calculation\n    used = np.array([sum(float(dem[c]) for c in custs) for custs in assignments], dtype=float)\n    median_used = np.median(used)\n    total = median_used + caps + eps\n    util = median_used / total\n    discount = 1.0 - rho * (1.0 - util)\n    discount = np.clip(discount, 0.5, 1.0)\n\n    best_cust, best_fac = None, None\n    best_cost = np.inf\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.flatnonzero(caps >= d)\n        if feas.size == 0:\n            continue\n\n        adj = C[feas, int(c)] * discount[feas]\n        if feas.size <= top_k:\n            candidates = feas\n        else:\n            top_indices = np.argpartition(adj, top_k)[:top_k]\n            candidates = feas[top_indices]\n\n        # deterministic choice among top candidates\n        chosen_idx = int(np.argmin(adj[np.isin(feas, candidates)]))\n        f = int(feas[chosen_idx])\n        val = float(adj[chosen_idx])\n\n        if val < best_cost:\n            best_cost = val\n            best_cust = int(c)\n            best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "favor_underutilized_facilities_cost_adjusted_aug_233": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Random tie\u2011break with clipped discount and sum utilisation.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rho = 0.32\n    eps = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    used = np.array([sum(float(dem[c]) for c in custs) for custs in assignments], dtype=float)\n    total = used + caps + eps\n    util = used / total\n    discount = 1.0 - rho * (1.0 - util)\n    discount = np.clip(discount, 0.7, 1.0)\n\n    best_cust, best_fac = None, None\n    best_cost = np.inf\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.flatnonzero(caps >= d)\n        if feas.size == 0:\n            continue\n\n        adj = C[feas, int(c)] * discount[feas]\n        min_val = np.min(adj)\n        ties = feas[adj == min_val]\n        f = int(np.random.choice(ties))  # random tie\u2011break\n        val = float(adj[adj == min_val][0])\n\n        if val < best_cost:\n            best_cost = val\n            best_cust = int(c)\n            best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "min_cost_with_facility_quota_pressure_aug_234": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    asgns = assignments\n    custs = remaining_customers\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dems = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    lam = 0.7\n    counts = np.asarray([len(a) for a in asgns], dtype=float)\n    target = np.mean(counts) if counts.size else 0.0\n    target += 1e-12  # epsilon to avoid division\u2011by\u2011zero in later ops\n\n    best_val = np.inf\n    best_cust = None\n    best_fac = None\n    rng = np.random.default_rng(42)\n\n    for c in custs:\n        d = float(dems[int(c)])\n        feas_idx = np.where(caps >= d)[0]\n        if feas_idx.size == 0:\n            continue\n\n        pressure = np.abs((counts[feas_idx] + 1.0) - target)\n        pressure = np.clip(pressure, 0, 1e6)          # bound pressure\n        score = costs[feas_idx, int(c)] + lam * pressure\n\n        # deterministic noise for tie\u2011breaking\n        noise = rng.uniform(0, 1e-6, size=score.shape)\n        score += noise\n\n        idx = int(np.argmin(score))\n        f = int(feas_idx[idx])\n        val = float(score[idx])\n\n        if val < best_val:\n            best_val = val\n            best_cust = int(c)\n            best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "min_cost_with_facility_quota_pressure_aug_235": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    asgns = assignments\n    custs = remaining_customers\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dems = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    lam = 0.6\n    counts = np.asarray([len(a) for a in asgns], dtype=float)\n    target = np.median(counts) if counts.size else 0.0\n    target += 1e-12\n\n    best_val = np.inf\n    best_cust = None\n    best_fac = None\n    rng = np.random.default_rng(123)\n\n    for c in custs:\n        d = float(dems[int(c)])\n        feas_idx = np.where(caps >= d)[0]\n        if feas_idx.size == 0:\n            continue\n\n        pressure = np.abs((counts[feas_idx] + 1.0) - target)\n        pressure = np.clip(pressure, 0, 1e6)\n        score = costs[feas_idx, int(c)] + lam * pressure\n\n        # softmin with temperature for probabilistic choice\n        temp = 0.5\n        exp_scores = np.exp(-score / (temp + 1e-12))\n        probs = exp_scores / (np.sum(exp_scores) + 1e-12)\n\n        # pick a random facility among the top\u2011k cheapest\n        top_k = min(5, len(score))\n        top_indices = np.argsort(score)[:top_k]\n        chosen_idx = rng.choice(top_indices)\n        f = int(feas_idx[chosen_idx])\n        val = float(score[chosen_idx])\n\n        if val < best_val:\n            best_val = val\n            best_cust = int(c)\n            best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "min_cost_with_facility_quota_pressure_aug_236": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    asgns = assignments\n    custs = remaining_customers\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dems = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    lam = 0.9\n    counts = np.asarray([len(a) for a in asgns], dtype=float)\n    target = np.mean(counts) if counts.size else 0.0\n    target += 1e-12\n\n    best_val = np.inf\n    best_cust = None\n    best_fac = None\n    rng = np.random.default_rng(7)\n\n    for c in custs:\n        d = float(dems[int(c)])\n        feas_idx = np.where(caps >= d)[0]\n        if feas_idx.size == 0:\n            continue\n\n        pressure = np.abs((counts[feas_idx] + 1.0) - target)\n        # use the maximum pressure value for all candidates\n        pressure = np.full_like(pressure, np.max(pressure))\n        pressure = np.clip(pressure, 0, 1e6)\n        score = costs[feas_idx, int(c)] + lam * pressure\n\n        # deterministic noise to break ties\n        noise = rng.uniform(0, 1e-7, size=score.shape)\n        score += noise\n\n        idx = int(np.argmin(score))\n        f = int(feas_idx[idx])\n        val = float(score[idx])\n\n        if val < best_val:\n            best_val = val\n            best_cust = int(c)\n            best_fac = f\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "min_cost_with_facility_quota_pressure_aug_237": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    asgns = assignments\n    custs = remaining_customers\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dems = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    lam = 0.8\n    counts = np.asarray([len(a) for a in asgns], dtype=float)\n    target = np.median(counts) if counts.size else 0.0\n    target += 1e-12\n\n    best_val = np.inf\n    best_cust = None\n    best_fac = None\n    rng = np.random.default_rng(999)\n\n    idx = 0\n    while idx < len(custs):\n        c = custs[idx]\n        d = float(dems[int(c)])\n        feas_idx = np.where(caps >= d)[0]\n        if feas_idx.size != 0:\n            pressure = np.abs((counts[feas_idx] + 1.0) - target)\n            pressure = np.clip(pressure, 0, 1e6)\n            score = costs[feas_idx, int(c)] + lam * pressure\n\n            # random choice among the top\u2011k cheapest\n            top_k = min(4, len(score))\n            top_indices = np.argsort(score)[:top_k]\n            chosen_idx = rng.choice(top_indices)\n            f = int(feas_idx[chosen_idx])\n            val = float(score[chosen_idx])\n\n            if val < best_val:\n                best_val = val\n                best_cust = int(c)\n                best_fac = f\n        idx += 1\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "bottleneck_facility_capacity_protection_aug_238": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that scans all feasible assignments at once.\n    Small random noise is added to break ties deterministically.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Parameters\n    penalty_coeff = 5.0\n    epsilon = 1e-12\n\n    # Convert to numpy arrays\n    caps_arr   = np.asarray(remaining_capacities, dtype=float) + epsilon\n    demands_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat   = np.asarray(assignment_costs, dtype=float)\n\n    # Penalty scaling: larger for smaller capacities\n    cap_scale = (np.max(caps_arr) + 1.0) / (caps_arr + 1.0)\n\n    best_score = np.inf\n    best_c = best_f = None\n    noise = np.random.rand() * 1e-6  # tiny deterministic noise for tie\u2011breaking\n\n    for c in remaining_customers:\n        d = demands_arr[c]\n        # Facilities that can still host the customer\n        feasible = caps_arr >= d\n        if not np.any(feasible):\n            continue\n\n        # Compute penalty for each feasible facility\n        penalty = penalty_coeff * cap_scale[feasible] * \\\n                  (d / (caps_arr[feasible] + epsilon))\n        # Total score (cost + penalty)\n        scores = cost_mat[feasible, c] + penalty\n        min_idx = np.argmin(scores)\n        score = scores[min_idx]\n\n        if score + noise < best_score:\n            best_score = score\n            best_c = c\n            best_f = np.where(feasible)[0][min_idx]\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "bottleneck_facility_capacity_protection_aug_239": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a soft\u2011min (Boltzmann) selection over all feasible assignments.\n    The top\u2011k candidates are considered before sampling.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Parameters\n    lam = 4.5\n    epsilon = 1e-12\n    top_k = 5\n\n    caps = np.asarray(remaining_capacities, dtype=float) + epsilon\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    # Compute penalty scaling: inversely proportional to capacity\n    scale = (np.max(caps) + 1.0) / (caps + 1.0)\n\n    # Build full score matrix (inf for infeasible pairs)\n    num_fac = caps.size\n    num_cus = len(remaining_customers)\n    scores = np.full((num_cus, num_fac), np.inf, dtype=float)\n\n    for idx, c in enumerate(remaining_customers):\n        d = dem[c]\n        feasible = caps >= d\n        if not np.any(feasible):\n            continue\n        penalty = lam * scale[feasible] * (d / (caps[feasible] + epsilon))\n        scores[idx, feasible] = cost[feasible, c] + penalty\n\n    # Soft\u2011min weights\n    weights = np.exp(-scores)  # larger scores -> smaller weights\n    weights = np.clip(weights, 0, 1e6)  # prevent overflow\n    weights_sum = np.sum(weights)\n    if weights_sum == 0:\n        return None, None\n    probs = weights / weights_sum\n\n    # Flatten indices\n    flat_idx = np.random.choice(probs.size, p=probs.ravel())\n    c_idx, f_idx = np.unravel_index(flat_idx, probs.shape)\n    chosen_c = remaining_customers[c_idx]\n    chosen_f = f_idx\n\n    # Ensure the chosen pair is feasible\n    if scores[c_idx, f_idx] == np.inf:\n        return None, None\n    return (chosen_c, chosen_f)\n\n",
  "bottleneck_facility_capacity_protection_aug_240": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Implements a penalty that grows quadratically with the capacity ratio.\n    Uses the median penalty across facilities to normalise the score.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Parameters\n    lam = 6.0\n    epsilon = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float) + epsilon\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    # Quadratic penalty scaling\n    scale = (np.max(caps) + 1.0) / (caps + 1.0)\n    best_score = np.inf\n    best_c = best_f = None\n\n    for c in remaining_customers:\n        d = dem[c]\n        feasible = caps >= d\n        if not np.any(feasible):\n            continue\n\n        # Penalty: quadratic in demand/capacity\n        ratio = np.clip(d / (caps[feasible] + epsilon), 0, 1)\n        penalty = lam * scale[feasible] * (ratio ** 2)\n\n        # Total cost\n        scores = cost[feasible, c] + penalty\n\n        # Normalise using the median penalty to reduce influence of outliers\n        median_pen = np.median(penalty)\n        scores_norm = scores + median_pen\n\n        min_idx = np.argmin(scores_norm)\n        score = scores_norm[min_idx]\n\n        if score < best_score:\n            best_score = score\n            best_c = c\n            best_f = np.where(feasible)[0][min_idx]\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "bottleneck_facility_capacity_protection_aug_241": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a proxy approximation: log\u2011scaled capacities and top\u2011k selection.\n    The best pair among the top\u2011k lowest scores is returned.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Parameters\n    lam = 5.5\n    epsilon = 1e-12\n    top_k = 7\n\n    caps = np.asarray(remaining_capacities, dtype=float) + epsilon\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    # Log\u2011based scaling to dampen capacity effects\n    log_scale = np.log1p(caps)  # log(1 + cap)\n    scale = (np.max(log_scale) + 1.0) / (log_scale + 1.0)\n\n    # Build score list\n    score_list = []\n    for c in remaining_customers:\n        d = dem[c]\n        feasible = caps >= d\n        if not np.any(feasible):\n            continue\n        penalty = lam * scale[feasible] * (d / (caps[feasible] + epsilon))\n        scores = cost[feasible, c] + penalty\n        for f_idx, s in zip(np.where(feasible)[0], scores):\n            score_list.append((s, c, f_idx))\n\n    if not score_list:\n        return None, None\n\n    # Sort scores and pick top_k\n    score_list.sort(key=lambda x: x[0])\n    top_candidates = score_list[:top_k]\n\n    # Return the candidate with the minimal raw cost (ignoring penalty)\n    best = min(top_candidates, key=lambda x: cost[x[2], x[1]])\n    return (best[1], best[2])\n\n",
  "two_stage_customer_cluster_by_cost_profile_aug_242": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised selection of the next assignment.\n    Chooses the customer with the smallest standard deviation of feasible costs\n    (adding a tiny random perturbation for deterministic tie\u2011breaking),\n    then assigns the cheapest feasible facility.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    # Compute std for every customer (feasible facilities only)\n    std_vals = np.full(len(remaining_customers), np.inf, dtype=float)\n    for idx, cust in enumerate(remaining_customers):\n        feasible = np.where(caps >= dem[cust])[0]\n        if feasible.size == 0:\n            continue\n        costs = C[feasible, cust]\n        mean_cost = np.mean(costs)\n        # add epsilon to variance to avoid sqrt(0) when all costs equal\n        var = np.mean((costs - mean_cost)**2) + 1e-12\n        std_vals[idx] = np.sqrt(var)\n\n    # Add a tiny deterministic noise to break ties\n    noise = np.arange(len(remaining_customers)) * 1e-6\n    std_vals += noise\n\n    # Select customer with minimal std\n    cust_idx = np.argmin(std_vals)\n    chosen_cust = remaining_customers[cust_idx]\n\n    # Find cheapest feasible facility for this customer\n    feasible_f = np.where(caps >= dem[chosen_cust])[0]\n    if feasible_f.size == 0:\n        return None, None\n    chosen_f = feasible_f[np.argmin(C[feasible_f, chosen_cust])]\n\n    return chosen_cust, chosen_f\n\n",
  "two_stage_customer_cluster_by_cost_profile_aug_243": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Weighted scoring of customers using a mix of median cost spread and cheapest cost.\n    Top\u2011k customers are considered and the best among them is chosen.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    # Normalisation constant for costs\n    max_cost = np.max(C) + 1e-12  # epsilon to avoid division by zero\n\n    scores = np.full(len(remaining_customers), np.inf, dtype=float)\n    for idx, cust in enumerate(remaining_customers):\n        feasible = np.where(caps >= dem[cust])[0]\n        if feasible.size == 0:\n            continue\n        costs = C[feasible, cust]\n        median_spread = np.median(costs)  # use median instead of std\n        cheapest = np.min(costs) / max_cost\n        # Weighted score\n        scores[idx] = 0.6 * median_spread + 0.4 * cheapest\n\n    # Deterministic noise for tie\u2011breaking\n    scores += np.arange(len(remaining_customers)) * 1e-6\n\n    # Consider top_k customers\n    top_k = 7\n    top_indices = np.argsort(scores)[:top_k]\n    best_idx = top_indices[np.argmin(scores[top_indices])]\n\n    chosen_cust = remaining_customers[best_idx]\n    feasible_f = np.where(caps >= dem[chosen_cust])[0]\n    if feasible_f.size == 0:\n        return None, None\n    chosen_f = feasible_f[np.argmin(C[feasible_f, chosen_cust])]\n\n    return chosen_cust, chosen_f\n\n",
  "two_stage_customer_cluster_by_cost_profile_aug_244": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Customer is selected by the smallest maximum feasible cost (with noise),\n    and the facility is chosen using a soft\u2011min probability distribution.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    max_costs = np.full(len(remaining_customers), np.inf, dtype=float)\n    for idx, cust in enumerate(remaining_customers):\n        feasible = np.where(caps >= dem[cust])[0]\n        if feasible.size == 0:\n            continue\n        max_costs[idx] = np.max(C[feasible, cust])\n\n    # Add deterministic noise to break ties\n    max_costs += np.arange(len(remaining_customers)) * 1e-6\n    cust_idx = np.argmin(max_costs)\n    chosen_cust = remaining_customers[cust_idx]\n\n    feasible_f = np.where(caps >= dem[chosen_cust])[0]\n    if feasible_f.size == 0:\n        return None, None\n\n    # Soft\u2011min probabilities for facility selection\n    beta = 10.0\n    costs = C[feasible_f, chosen_cust]\n    # avoid overflow by clipping exponent\n    exp_vals = np.exp(-beta * np.clip(costs, a_min=None, a_max=1e3))\n    probs = exp_vals / (np.sum(exp_vals) + 1e-12)  # epsilon in denominator\n    chosen_f = feasible_f[np.random.choice(len(feasible_f), p=probs)]\n\n    return chosen_cust, chosen_f\n\n",
  "two_stage_customer_cluster_by_cost_profile_aug_245": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a squared\u2011deviation proxy for spread, randomised top\u2011k customer selection,\n    and a while\u2011loop to find a feasible facility.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    spread_proxy = np.full(len(remaining_customers), np.inf, dtype=float)\n    for idx, cust in enumerate(remaining_customers):\n        feasible = np.where(caps >= dem[cust])[0]\n        if feasible.size == 0:\n            continue\n        costs = C[feasible, cust]\n        mean_cost = np.mean(costs)\n        # squared\u2011deviation proxy (no sqrt), epsilon added to mean calculation\n        proxy = np.mean((costs - mean_cost)**2 + 1e-12)\n        spread_proxy[idx] = proxy\n\n    # Randomly pick top_k customers\n    top_k = 5\n    top_indices = np.argpartition(spread_proxy, top_k)[:top_k]\n    chosen_idx = top_indices[np.argmin(spread_proxy[top_indices])]\n    chosen_cust = remaining_customers[chosen_idx]\n\n    feasible_f = np.where(caps >= dem[chosen_cust])[0]\n    if feasible_f.size == 0:\n        return None, None\n\n    # Randomly choose among the cheapest few facilities\n    cheapest_costs = C[feasible_f, chosen_cust]\n    sorted_f = feasible_f[np.argsort(cheapest_costs)]\n    # pick one of the top 3 cheapest\n    top_n = min(3, len(sorted_f))\n    chosen_f = sorted_f[np.random.randint(top_n)]\n\n    return chosen_cust, chosen_f\n\n",
  "max_cost_spread_customer_priority_aug_246": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Variation 1: While-loop, deterministic noise, list comprehension.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    best_spread = -np.inf\n    best_c = None\n    best_f = None\n\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        feas = np.where(cap_arr >= dem_arr[c])[0]\n        if feas.size != 0:\n            vals = cost_arr[feas, c]\n            spread = float(np.max(vals) - np.min(vals))\n            # deterministic tie\u2011breaking noise\n            spread += 1e-6 * (c + 1)\n            f = int(feas[np.argmin(vals)])\n            if spread > best_spread:\n                best_spread = spread\n                best_c = int(c)\n                best_f = int(f)\n        idx += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "max_cost_spread_customer_priority_aug_247": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Variation 2: Weighted score with top\u2011k selection and random choice.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    rng = np.random.default_rng(12345)\n    eps = 1e-12\n    scores = []\n    candidates = []\n\n    for c in remaining_customers:\n        feas = np.where(cap_arr >= dem_arr[c])[0]\n        if feas.size == 0:\n            continue\n        vals = cost_arr[feas, c]\n        min_cost = np.min(vals)\n        max_cost = np.max(vals)\n        spread = max_cost - min_cost\n        # weighted score: 0.6*spread + 0.4*(1/(min_cost+eps))\n        score = 0.6 * spread + 0.4 * (1.0 / (min_cost + eps))\n        # deterministic noise for tie\u2011breaking\n        score += (c + 1) * 1e-9\n        scores.append(score)\n        candidates.append((c, feas, vals))\n\n    if not scores:\n        return None, None\n\n    # select top_k customers by score\n    top_k = 7\n    idxs = np.argsort(scores)[-min(top_k, len(scores)):]\n    chosen_idx = rng.choice(idxs)\n    c, feas, vals = candidates[chosen_idx]\n\n    # choose facility among top_k cheapest\n    sorted_idx = np.argsort(vals)\n    top_k_f = 5\n    feasible_f_indices = feas[sorted_idx[:min(top_k_f, len(sorted_idx))]]\n    chosen_f = rng.choice(feasible_f_indices)\n\n    return int(c), int(chosen_f)\n\n",
  "max_cost_spread_customer_priority_aug_248": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Variation 4: Vectorized feasibility matrix, list comprehension, clipping, deterministic noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    cap_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_arr = np.asarray(assignment_costs, dtype=float)\n\n    # Build feasibility matrix once\n    feas_mat = np.outer(cap_arr, np.ones_like(dem_arr, dtype=bool)) >= dem_arr\n    # feas_mat shape (num_facilities, num_customers)\n\n    best_spread = -np.inf\n    best_c = None\n    best_f = None\n    rng = np.random.default_rng(24680)\n\n    for c in remaining_customers:\n        feas = np.where(feas_mat[:, c])[0]\n        if feas.size == 0:\n            continue\n        vals = cost_arr[feas, c]\n        spread = float(np.max(vals) - np.min(vals))\n        # clip spread to avoid extreme values\n        spread = np.clip(spread, 0, 1e9)\n        # deterministic noise\n        spread += 1e-6 * (c + rng.integers(1, 10))\n        f = int(feas[np.argmin(vals)])\n        if spread > best_spread:\n            best_spread = spread\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "min_cost_with_demand_percentile_penalty_aug_249": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 1 \u2013 heavy syntactic rewriting, list\u2011comprehension style,\n    and explicit percentile calculation with clipping.\n    \"\"\"\n    # rename for readability\n    assigned = assignments\n    candidates = remaining_customers\n    caps = remaining_capacities\n    demands = customer_demands\n    costs = assignment_costs\n\n    if not candidates:\n        return None, None\n\n    # parameters\n    alpha = 1.5\n    eps = 1e-12\n\n    # convert to numpy arrays\n    caps_arr = np.asarray(caps, dtype=float)\n    demands_arr = np.asarray(demands, dtype=float)\n    costs_arr = np.asarray(costs, dtype=float)\n\n    # indices of remaining customers\n    cand_idx = np.asarray(candidates, dtype=int)\n    d_vals = demands_arr[cand_idx]\n\n    if d_vals.size == 0:\n        return None, None\n\n    # percentile rank computation with safe division\n    n = d_vals.size\n    denom = max(n - 1, 1)  # avoid division by zero\n    order = np.argsort(d_vals)\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.linspace(0.0, 1.0, num=n, endpoint=True, dtype=float) / 1.0\n    pct = np.clip(ranks, 0.0, 1.0)  # ensure bounds\n\n    # mapping from customer index to percentile\n    pct_dict = {int(cand_idx[i]): pct[i] for i in range(n)}\n\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    for cust in cand_idx:\n        # feasible facilities for this customer\n        feasible = [f for f, cap in enumerate(caps_arr) if cap + eps >= demands_arr[cust]]\n        if not feasible:\n            continue\n        # choose facility with minimal cost\n        f_costs = costs_arr[feasible, cust]\n        f_min = feasible[int(np.argmin(f_costs))]\n        score = costs_arr[f_min, cust] + alpha * pct_dict[int(cust)]\n        if score < best_score:\n            best_score = score\n            best_cust = int(cust)\n            best_fac = int(f_min)\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "min_cost_with_demand_percentile_penalty_aug_250": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 2 \u2013 parameter tuning and softmin selection with deterministic RNG.\n    \"\"\"\n    # parameters\n    alpha = 1.8\n    tau = 0.3\n    top_k = 3\n    rng = np.random.default_rng(seed=42)\n\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    cand_idx = np.asarray(remaining_customers, dtype=int)\n    d_vals = demands[cand_idx]\n\n    n = d_vals.size\n    if n == 0:\n        return None, None\n\n    # percentile ranks with clipping\n    order = np.argsort(d_vals)\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.linspace(0.0, 1.0, num=n, endpoint=True)\n    pct = np.clip(ranks, 0.0, 1.0)\n    pct_dict = {int(cand_idx[i]): pct[i] for i in range(n)}\n\n    candidates = []\n    scores = []\n\n    for cust in cand_idx:\n        feas = np.where(caps >= demands[cust])[0]\n        if feas.size == 0:\n            continue\n        # pick facility with minimal cost\n        f_min = int(feas[np.argmin(costs[feas, cust])])\n        score = costs[f_min, cust] + alpha * pct_dict[int(cust)]\n        candidates.append((cust, f_min))\n        scores.append(score)\n\n    if not candidates:\n        return None, None\n\n    scores_arr = np.asarray(scores, dtype=float)\n    # softmin probabilities\n    probs = np.exp(-scores_arr / (tau + 1e-12))\n    probs /= np.clip(probs.sum(), 1e-12, None)\n    # choose facility with probability\n    idx = rng.choice(len(candidates), p=probs)\n    return candidates[idx]\n\n",
  "min_cost_with_demand_percentile_penalty_aug_251": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 3 \u2013 deterministic noise added for tie breaking and random\n    selection among top\u2011k candidates.\n    \"\"\"\n    # parameters\n    alpha = 1.7\n    top_k = 4\n    noise_scale = 1e-6\n    rng = np.random.default_rng(seed=123)\n\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    cand_idx = np.asarray(remaining_customers, dtype=int)\n    d_vals = demands[cand_idx]\n\n    n = d_vals.size\n    if n == 0:\n        return None, None\n\n    # percentile ranks with clipping\n    order = np.argsort(d_vals)\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.linspace(0.0, 1.0, num=n, endpoint=True)\n    pct = np.clip(ranks, 0.0, 1.0)\n    pct_dict = {int(cand_idx[i]): pct[i] for i in range(n)}\n\n    candidate_scores = []\n\n    for cust in cand_idx:\n        feas = np.where(caps >= demands[cust])[0]\n        if feas.size == 0:\n            continue\n        f_min = int(feas[np.argmin(costs[feas, cust])])\n        base_score = costs[f_min, cust] + alpha * pct_dict[int(cust)]\n        # deterministic noise\n        noise = noise_scale * (cust + f_min)\n        candidate_scores.append(((cust, f_min), base_score + noise))\n\n    if not candidate_scores:\n        return None, None\n\n    # sort by score and pick top_k\n    candidate_scores.sort(key=lambda x: x[1])\n    top_candidates = [c for c, _ in candidate_scores[:top_k]]\n    # random choice among top_k\n    chosen = rng.choice(top_candidates)\n    return chosen\n\n",
  "min_cost_with_demand_percentile_penalty_aug_252": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 4 \u2013 fully vectorised computation of feasible facilities,\n    scores, and selection using argmin.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # parameters\n    alpha = 2.0\n    eps = 1e-12\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demands = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    cand_idx = np.asarray(remaining_customers, dtype=int)\n    d_vals = demands[cand_idx]\n\n    n = d_vals.size\n    if n == 0:\n        return None, None\n\n    # percentile ranks with safe division\n    order = np.argsort(d_vals)\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.linspace(0.0, 1.0, num=n, endpoint=True)\n    pct = np.clip(ranks, 0.0, 1.0)\n\n    # Broadcast feasibility mask: facilities x customers\n    feas_mask = caps[:, None] >= demands[None, :]\n    # For each customer, mask only those who are remaining\n    feas_mask = feas_mask[:, cand_idx]\n\n    # For customers with no feasible facilities, set a large dummy cost\n    large_cost = 1e9\n    cost_matrix = costs[:, cand_idx]\n    cost_matrix[~feas_mask] = large_cost\n\n    # Compute scores\n    scores = cost_matrix + alpha * pct[None, :]\n\n    # Find minimal score for each customer\n    best_fac_idx = np.argmin(scores, axis=0)\n    best_score = scores[best_fac_idx, np.arange(n)]\n\n    # Select the customer with overall minimal score\n    min_idx = np.argmin(best_score)\n    if best_score[min_idx] >= large_cost:\n        return None, None\n\n    chosen_cust = int(cand_idx[min_idx])\n    chosen_fac = int(best_fac_idx[min_idx])\n\n    return chosen_cust, chosen_fac\n\n",
  "adaptive_topk_by_remaining_density_aug_253": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Soft\u2011min selection among the top\u2011K cheapest feasible pairs.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    n_rem = len(remaining_customers)\n    # K grows with the number of remaining customers\n    K = int(np.clip(np.ceil(0.20 * n_rem), 4, 20))\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Build list of feasible pairs using a list comprehension\n    pairs = [(C[f, c], c, f) for c in remaining_customers\n             for f in np.where(caps >= dem[c])[0]]\n\n    if not pairs:\n        return None, None\n\n    # Sort by raw cost and keep the top\u2011K\n    pairs.sort(key=lambda x: x[0])\n    top = pairs[:min(K, len(pairs))]\n\n    # Soft\u2011min probabilities (temperature 0.5)\n    costs = np.array([p[0] for p in top], dtype=float)\n    # Shift to avoid large exponents and add epsilon to the denominator\n    exp_neg = np.exp(-0.5 * (costs - costs.min()))\n    probs = exp_neg / (exp_neg.sum() + 1e-12)\n\n    # Weighted random choice among the top\u2011K\n    idx = rng.choice(len(top), p=probs)\n    _, c, f = top[idx]\n    return c, f\n\n",
  "adaptive_topk_by_remaining_density_aug_254": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Median\u2011cost selection with deterministic tie\u2011breaking noise.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    n_rem = len(remaining_customers)\n    K = int(np.clip(np.ceil(0.15 * n_rem), 3, 25))\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            pairs.append((C[f, c], c, f))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    top = pairs[:min(K, len(pairs))]\n\n    # Add a tiny deterministic noise proportional to the index\n    noisy = [(cost + 1e-9 * idx, c, f) for idx, (cost, c, f) in enumerate(top)]\n\n    # Choose the median of the noisy costs\n    noisy.sort(key=lambda x: x[0])\n    mid = len(noisy) // 2\n    _, c, f = noisy[mid]\n    return c, f\n\n",
  "adaptive_topk_by_remaining_density_aug_255": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Broadcasted feasibility mask with soft\u2011min selection.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    n_rem = len(remaining_customers)\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Feasibility mask: facilities x customers\n    feas_mask = caps[:, None] >= dem[remaining_customers]\n    if not feas_mask.any():\n        return None, None\n\n    # Costs for feasible pairs; infeasible pairs set to +inf\n    costs = np.where(feas_mask, C[:, remaining_customers], np.inf)\n\n    # Flatten and sort to get top\u2011K indices\n    flat_indices = np.argsort(costs.ravel())\n    K = int(np.clip(np.ceil(0.10 * n_rem), 2, 15))\n    top_indices = flat_indices[:min(K, flat_indices.size)]\n\n    # Convert flat indices back to 2\u2011D indices\n    f_idx, c_idx = np.unravel_index(top_indices, costs.shape)\n    top_costs = costs[f_idx, c_idx]\n\n    # Soft\u2011min probabilities (temperature = mean cost)\n    exp_neg = np.exp(-top_costs / (top_costs.mean() + 1e-12))\n    probs = exp_neg / (exp_neg.sum() + 1e-12)\n\n    chosen = rng.choice(len(top_indices), p=probs)\n    f = f_idx[chosen]\n    c = remaining_customers[c_idx[chosen]]\n    return c, f\n\n",
  "adaptive_topk_by_remaining_density_aug_256": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Weighted random choice among top\u2011K using capacity\u2011adjusted cost.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            # Capacity\u2011adjusted cost: cost + lambda * (demand / capacity)\n            weighted = C[f, c] + 0.1 * dem[c] / (caps[f] + 1e-12)\n            pairs.append((weighted, c, f))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    n_rem = len(remaining_customers)\n    K = int(np.clip(np.ceil(0.18 * n_rem), 3, 22))\n    top = pairs[:min(K, len(pairs))]\n\n    # Inverse\u2011cost probabilities\n    inv = 1.0 / (np.array([p[0] for p in top]) + 1e-12)\n    probs = inv / (inv.sum() + 1e-12)\n\n    rng = np.random.default_rng()\n    idx = rng.choice(len(top), p=probs)\n    _, c, f = top[idx]\n    return c, f\n\n",
  "min_cost_with_customer_degrees_penalty_aug_257": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that selects the customer\u2011facility pair with the\n    lowest cost + beta * degree, where degree is the number of facilities that\n    can serve the customer.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.6\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Feasibility matrix: True where a facility can serve a customer\n    feas = caps[:, None] >= dem[None, :]\n    # Degree of each customer (how many facilities can serve it)\n    deg = np.sum(feas, axis=0)\n\n    # Mask infeasible costs with +inf so they are never chosen\n    masked_cost = np.where(feas, C, np.inf)\n    # Score matrix: cost + beta * degree\n    score = masked_cost + beta * deg[None, :]\n    score = np.clip(score, -1e12, 1e12)          # avoid overflow\n\n    # Best facility for each customer\n    best_fac_for_cust = np.argmin(score, axis=0)\n    best_cost_for_cust = np.min(score, axis=0)\n\n    # Customers that still have at least one feasible facility\n    feasible_mask = best_cost_for_cust != np.inf\n    if not np.any(feasible_mask):\n        return None, None\n\n    # Pick the customer with the lowest best cost\n    idx = np.argmin(best_cost_for_cust[feasible_mask])\n    cust = np.arange(len(remaining_customers))[feasible_mask][idx]\n    fac = best_fac_for_cust[cust]\n\n    return int(remaining_customers[cust]), int(fac)\n\n",
  "min_cost_with_customer_degrees_penalty_aug_258": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    While\u2011loop based approach that explores the top\u2011k cheapest facilities for\n    each customer, adds deterministic noise for tie\u2011breaking, and keeps the\n    best overall assignment.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.5\n    top_k = 7\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    for cust in remaining_customers:\n        d = dem[cust]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        # Compute degree once per customer\n        deg = np.sum(caps >= d)\n\n        # Get the indices of the top_k cheapest feasible facilities\n        costs = C[feas, cust]\n        if feas.size <= top_k:\n            top_indices = feas\n        else:\n            top_k_idx = np.argpartition(costs, top_k)[:top_k]\n            top_indices = feas[top_k_idx]\n\n        # Scores for the selected facilities\n        scores = C[top_indices, cust] + beta * deg\n\n        # Deterministic noise to break ties\n        noise = np.random.rand(top_indices.size) * 1e-6\n        scores += noise\n\n        # Choose the best facility among the top_k for this customer\n        local_best_idx = np.argmin(scores)\n        local_fac = top_indices[local_best_idx]\n        local_score = scores[local_best_idx]\n\n        if local_score < best_score:\n            best_score = local_score\n            best_cust = cust\n            best_fac = local_fac\n\n    if best_cust is None:\n        return None, None\n    return int(best_cust), int(best_fac)\n\n",
  "min_cost_with_customer_degrees_penalty_aug_259": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Soft\u2011min (log\u2011sum\u2011exp) based selection.  It turns the cost+degree\n    into a probability distribution and picks the assignment with the\n    highest probability.  A tiny deterministic noise is added for\n    tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.6\n    T = 1.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Feasibility mask\n    feas = caps[:, None] >= dem[None, :]\n    deg = np.sum(feas, axis=0)\n\n    # Combined score (lower is better)\n    combined = C + beta * deg[None, :]\n    combined = np.where(feas, combined, np.inf)\n\n    # Soft\u2011min weights\n    weights = np.exp(-combined / (T + 1e-12))\n    # Deterministic noise to avoid exact ties\n    weights += np.random.rand(*weights.shape) * 1e-8\n\n    # Choose best facility per customer\n    best_fac = np.argmax(weights, axis=0)\n    best_weight = np.max(weights, axis=0)\n\n    if np.all(best_weight == 0):\n        return None, None\n\n    # Pick the customer with the highest weight\n    idx = np.argmax(best_weight)\n    return int(remaining_customers[idx]), int(best_fac[idx])\n\n",
  "min_cost_with_customer_degrees_penalty_aug_260": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Median\u2011based heuristic: for each customer, compute the median cost\n    across all feasible facilities and then minimise the absolute\n    deviation from that median plus a degree penalty.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    feas = caps[:, None] >= dem[None, :]\n    deg = np.sum(feas, axis=0)\n\n    # Median cost per customer over feasible facilities\n    median_cost = np.full(len(remaining_customers), np.inf, dtype=float)\n    for idx in range(len(remaining_customers)):\n        feas_idx = np.where(feas[:, idx])[0]\n        if feas_idx.size > 0:\n            median_cost[idx] = np.median(C[feas_idx, idx])\n\n    # Score = |cost - median| + beta * degree\n    score = np.abs(C - median_cost[None, :]) + beta * deg[None, :]\n    score = np.where(feas, score, np.inf)\n    score = np.clip(score, -1e12, 1e12)\n\n    best_fac = np.argmin(score, axis=0)\n    best_score = np.min(score, axis=0)\n\n    feasible_mask = best_score != np.inf\n    if not np.any(feasible_mask):\n        return None, None\n\n    idx = np.argmin(best_score[feasible_mask])\n    cust = np.arange(len(remaining_customers))[feasible_mask][idx]\n    return int(remaining_customers[cust]), int(best_fac[cust])\n\n",
  "min_cost_with_facility_degree_penalty_aug_261": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorized softmin selection with deterministic tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # degree: number of customers that can be served by each facility\n    deg = np.array([np.sum(dem[rem] <= cap) for cap in caps], dtype=float)\n\n    best_customer = None\n    best_facility = None\n    best_score = np.inf\n\n    # deterministic noise to break ties\n    noise = np.arange(len(caps), dtype=float) * 1e-6\n\n    for c in rem:\n        d = dem[c]\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n        score = costs[feasible, c] + beta * deg[feasible] + noise[feasible]\n        # softmin weighting\n        tau = 0.5\n        weights = np.exp(-score / tau)\n        idx = np.argmax(weights)\n        f = feasible[idx]\n        val = score[idx]\n        if val < best_score:\n            best_score = val\n            best_customer = c\n            best_facility = f\n\n    return (best_customer, best_facility) if best_customer is not None else (None, None)\n\n",
  "min_cost_with_facility_degree_penalty_aug_262": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"While\u2011loop selection with median degree and random top\u20113 choice.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.6\n    rng = np.random.default_rng(42)\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # degree: count of customers each facility can serve\n    deg = np.array([np.sum(dem[rem] <= cap) for cap in caps], dtype=float)\n    # normalize by median to avoid large values\n    deg = deg / (np.median(deg) + 1e-12)\n\n    best_customer = None\n    best_facility = None\n    best_score = np.inf\n\n    idx = 0\n    while idx < rem.size:\n        c = rem[idx]\n        d = dem[c]\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            idx += 1\n            continue\n        score = costs[feasible, c] + beta * deg[feasible]\n        top_k = 3\n        if feasible.size <= top_k:\n            top_indices = np.argsort(score)\n        else:\n            top_indices = np.argpartition(score, top_k - 1)[:top_k]\n            top_indices = top_indices[np.argsort(score[top_indices])]\n        chosen = rng.choice(top_indices)\n        f = feasible[chosen]\n        val = score[chosen]\n        if val < best_score:\n            best_score = val\n            best_customer = c\n            best_facility = f\n        idx += 1\n\n    return (best_customer, best_facility) if best_customer is not None else (None, None)\n\n",
  "min_cost_with_facility_degree_penalty_aug_263": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Log\u2011transformed cost and mean degree with deterministic tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.4\n    rng = np.random.default_rng(1)\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # degree as mean number of customers each facility can serve\n    deg = np.array([np.mean(dem[rem] <= cap) for cap in caps], dtype=float)\n\n    best_customer = None\n    best_facility = None\n    best_score = np.inf\n\n    for c in rem:\n        d = dem[c]\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n        cost_val = np.log1p(costs[feasible, c])          # log1p handles zero\n        score = cost_val + beta * deg[feasible]\n        noise = rng.uniform(0, 1e-6, size=feasible.size)  # deterministic noise\n        score += noise\n        idx = np.argmin(score)\n        f = feasible[idx]\n        val = score[idx]\n        if val < best_score:\n            best_score = val\n            best_customer = c\n            best_facility = f\n\n    return (best_customer, best_facility) if best_customer is not None else (None, None)\n\n",
  "min_cost_with_facility_degree_penalty_aug_264": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Penalty based on degree\u2011to\u2011capacity ratio, top\u20115 selection, random tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.7\n    rng = np.random.default_rng(7)\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # degree as max number of customers each facility can serve\n    deg = np.array([np.max(dem[rem] <= cap) for cap in caps], dtype=float)\n\n    best_customer = None\n    best_facility = None\n    best_score = np.inf\n\n    for c in rem:\n        d = dem[c]\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n        ratio = deg[feasible] / (caps[feasible] + 1e-12)  # epsilon to avoid div0\n        score = costs[feasible, c] + beta * ratio\n        top_k = 5\n        if feasible.size <= top_k:\n            top_indices = np.argsort(score)\n        else:\n            top_indices = np.argpartition(score, top_k - 1)[:top_k]\n            top_indices = top_indices[np.argsort(score[top_indices])]\n        chosen = rng.choice(top_indices)\n        f = feasible[chosen]\n        val = score[chosen]\n        if val < best_score:\n            best_score = val\n            best_customer = c\n            best_facility = f\n\n    return (best_customer, best_facility) if best_customer is not None else (None, None)\n\n",
  "max_demand_to_cost_ratio_aug_265": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that selects the customer\u2013facility pair with the\n    highest demand\u2011to\u2011cost ratio.  A small deterministic noise term is added\n    to break ties.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-12  # protects against division by zero\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    # feasible mask (facility, customer)\n    feas_mask = caps[:, None] >= dem[remaining_customers]\n    # replace infeasible costs with +inf so they do not influence argmin\n    costs_feasible = np.where(feas_mask, cost_mat[:, remaining_customers], np.inf)\n\n    # compute demand / (cost + eps)\n    ratios = dem[remaining_customers] / (costs_feasible + eps)\n\n    # add tiny noise for deterministic tie\u2011breaking\n    noise = np.random.uniform(-1e-6, 1e-6, size=ratios.shape)\n    ratios += noise\n\n    # find best customer\n    cust_idx = int(np.argmax(ratios))\n    best_customer = int(remaining_customers[cust_idx])\n\n    # choose facility with minimum cost for that customer\n    fac_idx = int(np.argmin(costs_feasible[:, cust_idx]))\n    best_facility = int(fac_idx)\n\n    # if no feasible assignment exists, return None\n    if np.isinf(costs_feasible[fac_idx, cust_idx]):\n        return None, None\n\n    return best_customer, best_facility\n\n",
  "max_demand_to_cost_ratio_aug_266": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    While\u2011loop implementation that iteratively checks each customer.  For\n    each customer the cheapest feasible facility is found; ties are broken\n    by randomly picking one of the equally cheapest facilities.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-12\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    best_ratio = -np.inf\n    best_cust = None\n    best_fac = None\n\n    cust_iter = iter(remaining_customers)\n    while True:\n        try:\n            cust = int(next(cust_iter))\n        except StopIteration:\n            break\n\n        d = float(dem[cust])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        # find minimal cost among feasible facilities\n        costs = cost_mat[feas, cust]\n        min_cost = np.min(costs)\n        # indices of facilities that tie for minimal cost\n        tie_indices = feas[np.where(np.isclose(costs, min_cost, atol=1e-9))[0]]\n        # deterministic random choice among ties\n        chosen_fac = int(np.random.choice(tie_indices))\n        ratio = d / (float(cost_mat[chosen_fac, cust]) + eps)\n\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_cust = cust\n            best_fac = chosen_fac\n\n    if best_cust is None:\n        return None, None\n    return best_cust, best_fac\n\n",
  "max_demand_to_cost_ratio_aug_267": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Randomised top\u2011k variant: for each customer we pick a random facility\n    among the top\u2011k cheapest feasible ones, compute the mean cost of those\n    facilities, and use that mean in the demand\u2011to\u2011cost ratio.  The\n    customer\u2013facility pair with the highest ratio is returned.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-12\n    top_k = 5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    best_ratio = -np.inf\n    best_cust = None\n    best_fac = None\n\n    for cust in remaining_customers:\n        d = float(dem[int(cust)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        # costs of feasible facilities\n        feas_costs = cost_mat[feas, int(cust)]\n        # indices of the cheapest top_k facilities\n        if feas_costs.size <= top_k:\n            top_indices = feas\n        else:\n            top_idx = np.argpartition(feas_costs, top_k)[:top_k]\n            top_indices = feas[top_idx]\n\n        # random pick among the top\u2011k\n        chosen_fac = int(np.random.choice(top_indices))\n        # mean cost of the top\u2011k facilities\n        mean_cost = np.mean(cost_mat[top_indices, int(cust)])\n        ratio = d / (mean_cost + eps)\n\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_cust = int(cust)\n            best_fac = chosen_fac\n\n    if best_cust is None:\n        return None, None\n    return best_cust, best_fac\n\n",
  "max_demand_to_cost_ratio_aug_268": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Median\u2011based variant: the cost of each customer is approximated by the\n    median of all facility costs for that customer.  For each customer we\n    choose the feasible facility whose cost is closest to that median.\n    The demand\u2011to\u2011median\u2011cost ratio is used for ranking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-12\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    best_ratio = -np.inf\n    best_cust = None\n    best_fac = None\n\n    for cust in remaining_customers:\n        d = float(dem[int(cust)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n\n        # median cost for this customer across all facilities\n        median_cost = np.median(cost_mat[:, int(cust)])\n        # choose feasible facility whose cost is closest to the median\n        feasible_costs = cost_mat[feas, int(cust)]\n        diff = np.abs(feasible_costs - median_cost)\n        chosen_idx = feas[np.argmin(diff)]\n        chosen_fac = int(chosen_idx)\n        ratio = d / (float(cost_mat[chosen_fac, cust]) + eps)\n\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_cust = int(cust)\n            best_fac = chosen_fac\n\n    if best_cust is None:\n        return None, None\n    return best_cust, best_fac\n\n",
  "minimax_customer_best_cost_aug_269": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 1 \u2013 Pure vectorised rewrite with a while\u2011loop.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    # Ensure capacities are never negative after clipping\n    caps = np.clip(caps, 0.0, None)\n\n    best_c = best_f = None\n    worst_best = -np.inf\n\n    # Iterate over customers using a while loop\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        # Facilities that can still serve this customer\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size > 0:\n            # Choose facility with minimal cost\n            best_fac = feasible[np.argmin(cost[feasible, c])]\n            best_cost = float(cost[best_fac, c])\n\n            if best_cost > worst_best:\n                worst_best = best_cost\n                best_c, best_f = int(c), int(best_fac)\n        idx += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "minimax_customer_best_cost_aug_270": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 2 \u2013 Weighted scoring that mixes capacity slack and inverse cost.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    # Avoid division by zero\n    eps = 1e-12\n\n    # Normalise capacity slack and inverse cost\n    slack_norm = (caps[:, None] - dem[None, :]) / (caps[:, None] + eps)\n    inv_cost   = 1.0 / (cost + eps)\n\n    # Weighting factors\n    w_slack = 0.4\n    w_cost  = 0.6\n\n    best_c = best_f = None\n    best_score = -np.inf\n\n    for c in remaining_customers:\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size == 0:\n            continue\n        # Compute weighted score for each feasible facility\n        scores = w_slack * slack_norm[feasible, c] + w_cost * inv_cost[feasible, c]\n        idx_best = np.argmax(scores)\n        f = feasible[idx_best]\n        score = float(scores[idx_best])\n\n        if score > best_score:\n            best_score = score\n            best_c, best_f = int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "minimax_customer_best_cost_aug_271": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 3 \u2013 Soft\u2011min selection with deterministic noise for tie breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps  = np.asarray(remaining_capacities, dtype=float)\n    dem   = np.asarray(customer_demands, dtype=float)\n    cost  = np.asarray(assignment_costs, dtype=float)\n\n    eps = 1e-12\n    noise_scale = 1e-6  # deterministic noise\n\n    best_c = best_f = None\n    best_softmin = np.inf\n\n    for c in remaining_customers:\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size == 0:\n            continue\n\n        # Soft\u2011min over costs (lower cost \u2192 higher probability)\n        soft_vals = np.exp(-cost[feasible, c] / (np.std(cost[feasible, c]) + eps))\n        # Add tiny deterministic noise to break ties\n        soft_vals += noise_scale * np.arange(len(soft_vals))\n        idx_best = np.argmax(soft_vals)\n        f = feasible[idx_best]\n        softmin_val = float(-np.log(soft_vals[idx_best] + eps))\n\n        if softmin_val < best_softmin:\n            best_softmin = softmin_val\n            best_c, best_f = int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "minimax_customer_best_cost_aug_272": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 4 \u2013 Median cost aggregation with max capacity slack.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps  = np.asarray(remaining_capacities, dtype=float)\n    dem   = np.asarray(customer_demands, dtype=float)\n    cost  = np.asarray(assignment_costs, dtype=float)\n\n    eps = 1e-12\n\n    best_c = best_f = None\n    best_metric = -np.inf\n\n    for c in remaining_customers:\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size == 0:\n            continue\n\n        # Median of costs for each facility\n        median_costs = np.median(cost[feasible, c])\n        # Max capacity slack among feasible facilities\n        slack = np.max(caps[feasible] - dem[c])\n\n        # Metric: higher slack and lower median cost\n        metric = slack / (median_costs + eps)\n        metric = np.clip(metric, -np.inf, np.inf)  # ensure bounded\n\n        if metric > best_metric:\n            best_metric = metric\n            best_c = int(c)\n            # Pick facility with minimal cost among those with median cost\n            f = feasible[np.argmin(cost[feasible, c])]\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "minimax_pair_cost_then_slack_aug_273": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that evaluates all feasible (facility, customer) pairs\n    at once, adds a tiny deterministic noise to break ties, and selects the pair\n    with the smallest criterion.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Convert inputs to NumPy arrays\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)[remaining_customers]\n    C = np.asarray(assignment_costs, dtype=float)[np.ix_(range(len(caps)), remaining_customers)]\n\n    # Ensure non\u2011negative capacities\n    caps = np.clip(caps, 0, None)\n\n    # Feasibility matrix: True where facility capacity >= customer demand\n    feas = caps[:, None] >= dem[None, :]\n    slack = caps[:, None] - dem[None, :]\n\n    # Normalise cost and compute the criterion\n    cmax = np.max(C) if C.size else 1.0\n    cmax = max(cmax, 1e-9)\n    crit = np.maximum(C / cmax,\n                      1.0 / (slack + 1.0 + 1e-12))\n    crit = np.where(feas, crit, np.inf)\n\n    # Add a tiny deterministic noise to break ties\n    noise = 1e-8 * np.arange(crit.size).reshape(crit.shape)\n    crit += noise\n\n    # Find the index of the minimal criterion\n    flat_idx = np.argmin(crit)\n    f, c = np.unravel_index(flat_idx, crit.shape)\n\n    if np.isinf(crit[f, c]):\n        return None, None\n    return int(c), int(f)\n\n",
  "minimax_pair_cost_then_slack_aug_274": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a while\u2011loop and a weighted sum of normalised cost and inverse slack\n    to determine the next assignment.  The function clips intermediate values\n    to avoid overflow and adds an epsilon to denominators.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    cmax = np.max(C) if C.size else 1.0\n    cmax = max(cmax, 1e-9)\n\n    best_crit = np.inf\n    best_cost = np.inf\n    best_c = best_f = None\n\n    cust_iter = iter(remaining_customers)\n    while True:\n        try:\n            c = next(cust_iter)\n        except StopIteration:\n            break\n        d = float(dem[int(c)])\n        for f, cap in enumerate(caps):\n            if cap >= d:\n                slack = float(cap - d)\n                cost = float(C[int(f), int(c)])\n                crit = 0.6 * (cost / cmax) + 0.4 * (1.0 / (slack + 1.0 + 1e-12))\n                crit = np.clip(crit, 0, 1e6)  # prevent overflow\n                if crit < best_crit or (np.isclose(crit, best_crit) and cost < best_cost):\n                    best_crit, best_cost = crit, cost\n                    best_c, best_f = int(c), int(f)\n\n    if best_c is None:\n        return None, None\n    return best_c, best_f\n\n",
  "minimax_pair_cost_then_slack_aug_275": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Generates all feasible pairs, then selects one using a soft\u2011min\n    probability distribution and a random choice among the top\u2011k candidates.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng(seed=42)  # deterministic randomness\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    cmax = np.max(C) if C.size else 1.0\n    cmax = max(cmax, 1e-9)\n\n    candidates = []\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        for f, cap in enumerate(caps):\n            if cap >= d:\n                slack = float(cap - d)\n                cost = float(C[int(f), int(c)])\n                crit = max(cost / cmax,\n                           1.0 / (slack + 1.0 + 1e-12))\n                candidates.append((crit, cost, int(c), int(f)))\n\n    if not candidates:\n        return None, None\n\n    crits = np.array([c[0] for c in candidates])\n\n    # Randomly pick among the top\u2011k lowest criteria\n    k = min(5, len(candidates))\n    top_k_idx = np.argpartition(crits, k - 1)[:k]\n    top_k_idx = top_k_idx[np.argsort(crits[top_k_idx])]\n    chosen = rng.choice(top_k_idx)\n    return candidates[chosen][2], candidates[chosen][3]\n\n",
  "minimax_pair_cost_then_slack_aug_276": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a mean of normalised cost and inverse slack as the criterion and\n    applies a while\u2011loop with list comprehensions.  Intermediate values are\n    clipped to keep them within a safe range.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    cmax = np.max(C) if C.size else 1.0\n    cmax = max(cmax, 1e-9)\n\n    best_crit = np.inf\n    best_cost = np.inf\n    best_c = best_f = None\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feasible = [(f, float(caps[f])) for f in range(len(caps)) if caps[f] >= d]\n        for f, cap in feasible:\n            slack = float(cap - d)\n            cost = float(C[int(f), int(c)])\n            crit = np.mean([cost / cmax,\n                            1.0 / (slack + 1.0 + 1e-12)])\n            crit = np.clip(crit, 0, 1e6)\n            if crit < best_crit or (np.isclose(crit, best_crit) and cost < best_cost):\n                best_crit, best_cost = crit, cost\n                best_c, best_f = int(c), int(f)\n\n    if best_c is None:\n        return None, None\n    return best_c, best_f\n\n",
  "annealed_softmax_pairs_aug_277": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    n_assigned = sum(len(a) for a in assignments)\n    n_rem = len(remaining_customers)\n\n    # Progress with safeguard against division by zero\n    denom = max(1, n_assigned + n_rem) + 1e-12\n    progress = n_assigned / denom\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem  = np.asarray(customer_demands, dtype=float)\n    C    = np.asarray(assignment_costs, dtype=float)\n\n    # Feasible pairs via broadcasting\n    dem_sub = dem[remaining_customers]\n    feas_matrix = caps[:, None] >= dem_sub\n    cs_idx, fs_idx = np.where(feas_matrix)\n    if cs_idx.size == 0:\n        return None, None\n\n    fs = np.array(remaining_customers)[fs_idx]\n    vals = C[cs_idx, fs] + rng.uniform(-1e-6, 1e-6, size=cs_idx.shape)\n\n    # Deterministic tie\u2011breaking with tiny noise\n    idx = int(np.argmin(vals))\n    return int(cs_idx[idx]), int(fs[idx])\n\n",
  "grasp_rcl_pairs_aug_278": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    GRASP-style selection with a restricted candidate list (RCL) built\n    using list comprehensions and deterministic tie\u2011breaking noise.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    alpha = 0.25          # 25\u202f% of the cheapest feasible pairs\n    eps = 1e-12           # safety epsilon\n\n    caps = np.clip(np.asarray(remaining_capacities, float), 0, None)\n    dem = np.asarray(customer_demands, float)\n    costs = np.asarray(assignment_costs, float)\n\n    # Build all feasible pairs using a list comprehension\n    pairs = [\n        (costs[f, c] + rng.uniform(0, 1e-6), c, f)   # deterministic noise\n        for c in remaining_customers\n        for f in np.where(caps[f] >= dem[c])[0]\n    ]\n\n    if not pairs:\n        return None, None\n\n    # Sort and select the top alpha\u2011fraction\n    pairs.sort(key=lambda x: x[0])\n    k = max(1, int(np.ceil(alpha * len(pairs))))\n    rcl = pairs[:k]\n\n    # Randomly pick one pair from the RCL\n    _, chosen_c, chosen_f = rng.choice(rcl)\n    return chosen_c, chosen_f\n\n",
  "grasp_rcl_pairs_aug_279": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a soft\u2011min probability distribution over feasible pairs.\n    Implements a while\u2011loop instead of a for\u2011loop and adds an\n    epsilon to the soft\u2011min denominator.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    temperature = 1.0   # controls softness of the distribution\n    eps = 1e-12\n\n    caps = np.clip(np.asarray(remaining_capacities, float), 0, None)\n    dem = np.asarray(customer_demands, float)\n    costs = np.asarray(assignment_costs, float)\n\n    # Collect all feasible pairs\n    feasible_pairs = []\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        # Find facilities that can serve customer c\n        feasible_f = np.where(caps >= dem[c])[0]\n        for f in feasible_f:\n            feasible_pairs.append((c, f, costs[f, c]))\n        idx += 1\n\n    if not feasible_pairs:\n        return None, None\n\n    # Compute soft\u2011min probabilities\n    pair_costs = np.array([p[2] for p in feasible_pairs], float)\n    min_cost = np.min(pair_costs)\n    # Shift costs to avoid large exponents\n    shifted = pair_costs - min_cost\n    weights = np.exp(-shifted / (temperature + eps))\n    probs = weights / (np.sum(weights) + eps)\n\n    # Randomly pick one pair according to the probabilities\n    chosen_idx = rng.choice(len(feasible_pairs), p=probs)\n    chosen_c, chosen_f, _ = feasible_pairs[chosen_idx]\n    return chosen_c, chosen_f\n\n",
  "grasp_rcl_pairs_aug_280": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised feasibility mask and cost flattening.\n    Uses the median of costs to determine a threshold and\n    selects top\u2011k pairs (k=7) with random tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    eps = 1e-12\n\n    caps = np.clip(np.asarray(remaining_capacities, float), 0, None)\n    dem = np.asarray(customer_demands, float)\n    costs = np.asarray(assignment_costs, float)\n\n    # Feasibility mask: rows=facilities, cols=customers\n    feas_mask = caps[:, None] >= dem[None, :]\n    # Flatten indices of feasible pairs\n    feas_idx = np.argwhere(feas_mask)\n    if feas_idx.size == 0:\n        return None, None\n\n    # Corresponding costs\n    flat_costs = costs[feas_idx[:, 0], feas_idx[:, 1]]\n    # Add tiny deterministic noise for tie\u2011breaking\n    noise = rng.uniform(0, 1e-6, size=flat_costs.shape)\n    flat_costs += noise\n\n    # Determine threshold using median\n    median_cost = np.median(flat_costs)\n    threshold = median_cost * 0.9  # allow some below median\n    # Filter pairs below threshold\n    below_thresh = flat_costs <= threshold\n    if not np.any(below_thresh):\n        # fallback to all feasible pairs\n        below_thresh = np.full(flat_costs.shape, True)\n\n    # Top\u2011k selection\n    k = min(7, np.sum(below_thresh))\n    top_k_idx = np.argpartition(flat_costs[below_thresh], k - 1)[:k]\n    # Randomly choose from the top\u2011k\n    chosen_idx = rng.choice(top_k_idx)\n    chosen_c = feas_idx[below_thresh][chosen_idx, 1]\n    chosen_f = feas_idx[below_thresh][chosen_idx, 0]\n    return chosen_c, chosen_f\n\n",
  "grasp_rcl_pairs_aug_281": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses np.argpartition to quickly obtain the k cheapest feasible pairs.\n    Tie\u2011breaking is done by shuffling equal\u2011cost pairs.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    eps = 1e-12\n\n    caps = np.clip(np.asarray(remaining_capacities, float), 0, None)\n    dem = np.asarray(customer_demands, float)\n    costs = np.asarray(assignment_costs, float)\n\n    # Build feasibility mask\n    feas_mask = caps[:, None] >= dem[None, :]\n    feas_idx = np.argwhere(feas_mask)\n    if feas_idx.size == 0:\n        return None, None\n\n    # Costs for feasible pairs\n    flat_costs = costs[feas_idx[:, 0], feas_idx[:, 1]]\n\n    # Determine number of candidates (top\u2011k)\n    k = min(5, len(flat_costs))  # always take at most 5\n    # Get indices of the k smallest costs\n    top_k_local = np.argpartition(flat_costs, k - 1)[:k]\n    # Extract the actual pairs\n    candidate_pairs = feas_idx[top_k_local]\n    candidate_costs = flat_costs[top_k_local]\n\n    # Identify ties at the kth cost\n    kth_cost = np.max(candidate_costs)\n    tied = candidate_costs == kth_cost\n    if np.any(tied):\n        # Shuffle tied indices to randomise tie\u2011breaking\n        rng.shuffle(candidate_pairs[tied])\n\n    # Randomly pick one pair from the candidate set\n    chosen_idx = rng.integers(0, len(candidate_pairs))\n    chosen_c = int(candidate_pairs[chosen_idx, 1])\n    chosen_f = int(candidate_pairs[chosen_idx, 0])\n    return chosen_c, chosen_f\n\n",
  "facility_median_capacity_then_best_customer_aug_282": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    rem = np.array(remaining_customers, dtype=int)\n    caps = np.array(remaining_capacities, dtype=float)\n    dem = np.array(customer_demands, dtype=float)\n    cost = np.array(assignment_costs, dtype=float)\n\n    # No customers left \u2013 nothing to assign\n    if rem.size == 0:\n        return None, None\n\n    # Avoid zero\u2011division in later calculations\n    caps = np.clip(caps, 1e-12, None)\n\n    # Pick the facility with the median remaining capacity\n    order = np.argsort(caps)\n    median_idx = len(order) // 2\n    f = int(order[median_idx])\n\n    # Find customers that can be served by facility f\n    feasible = rem[dem[rem] <= caps[f]]\n    if feasible.size == 0:\n        # Fallback: search other facilities in capacity order\n        for ff in order:\n            feas = rem[dem[rem] <= caps[ff]]\n            if feas.size:\n                f = int(ff)\n                break\n        else:\n            return None, None\n\n    # Add deterministic noise to break ties in cost\n    noise = 1e-9 * np.arange(feasible.size)\n    c_index = np.argmin(cost[f, feasible] + noise)\n    c = int(feasible[c_index])\n\n    return c, f\n\n",
  "facility_median_capacity_then_best_customer_aug_283": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    rem = np.array(remaining_customers, dtype=int)\n    caps = np.clip(np.array(remaining_capacities, dtype=float), 1e-12, None)\n    dem = np.array(customer_demands, dtype=float)\n    cost = np.array(assignment_costs, dtype=float)\n\n    if rem.size == 0:\n        return None, None\n\n    # Facility with median remaining capacity\n    f = int(np.argsort(caps)[len(caps)//2])\n\n    feasible = rem[dem[rem] <= caps[f]]\n    if feasible.size == 0:\n        # Search other facilities in descending capacity order\n        for ff in np.argsort(caps)[::-1]:\n            feas = rem[dem[rem] <= caps[ff]]\n            if feas.size:\n                f = int(ff)\n                break\n        else:\n            return None, None\n\n    eps = 1e-12\n    top_k = 7\n\n    # Scoring function: higher score \u2192 better candidate\n    cap_ratio = (caps[f] - dem[feasible]) / (caps[f] + eps)\n    cost_term = 1.0 / (cost[f, feasible] + eps)\n    score = 0.6 * cap_ratio + 0.4 * cost_term\n\n    # Pick one of the top\u2011k best customers\n    top_indices = np.argsort(-score)[:min(top_k, feasible.size)]\n    chosen = np.random.choice(top_indices)\n    c = int(feasible[chosen])\n\n    return c, f\n\n",
  "facility_median_capacity_then_best_customer_aug_284": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    rem = np.array(remaining_customers, dtype=int)\n    caps = np.clip(np.array(remaining_capacities, dtype=float), 1e-12, None)\n    dem = np.array(customer_demands, dtype=float)\n    cost = np.array(assignment_costs, dtype=float)\n\n    if rem.size == 0:\n        return None, None\n\n    # Facility index via np.median on facility indices\n    f = int(np.median(np.arange(len(caps))))\n\n    feasible = rem[dem[rem] <= caps[f]]\n    if feasible.size == 0:\n        # Fallback: try facilities sorted by capacity descending\n        for ff in np.argsort(caps)[::-1]:\n            feas = rem[dem[rem] <= caps[ff]]\n            if feas.size:\n                f = int(ff)\n                feasible = feas\n                break\n        else:\n            return None, None\n\n    # Choose the cheapest customer with deterministic tie\u2011breaking noise\n    costs_f = cost[f, feasible]\n    noise = 1e-9 * np.arange(costs_f.size)\n    c = int(feasible[np.argmin(costs_f + noise)])\n\n    return c, f\n\n",
  "facility_median_capacity_then_best_customer_aug_285": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    rem = np.array(remaining_customers, dtype=int)\n    caps = np.clip(np.array(remaining_capacities, dtype=float), 1e-12, None)\n    dem = np.array(customer_demands, dtype=float)\n    cost = np.array(assignment_costs, dtype=float)\n\n    if rem.size == 0:\n        return None, None\n\n    eps = 1e-12\n    tau = 1.0\n\n    # Facilities sorted by capacity descending\n    fac_order = np.argsort(caps)[::-1]\n    for f in fac_order:\n        feasible = rem[dem[rem] <= caps[f]]\n        if feasible.size == 0:\n            continue\n\n        # Softmin weights for the candidate customers\n        costs_f = cost[f, feasible]\n        w = np.exp(-costs_f / tau)\n        w_sum = np.sum(w) + eps\n        probs = w / w_sum\n\n        # Random weighted choice using softmin probabilities\n        rng = np.random.default_rng()\n        c = int(feasible[rng.choice(feasible.size, p=probs)])\n\n        return c, f\n\n    return None, None\n\n",
  "cost_with_utilization_cap_threshold_aug_286": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Greedy selection that prefers feasible assignments with utilisation <= 0.85.\n    Uses a soft\u2011min score (cost + 0.2 * utilisation) and a tiny random noise\n    to break ties deterministically.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    u_max = 0.85\n    rem_caps = np.asarray(remaining_capacities, dtype=float)\n    cust_dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    # current utilisation\n    used = np.array([sum(cust_dem[c] for c in custs) for custs in assignments], dtype=float)\n    total = np.maximum(used + rem_caps, 1e-12)          # avoid division by zero\n\n    best_any = (np.inf, None, None)   # (score, customer, facility)\n    best_good = (np.inf, None, None)\n\n    rng = np.random.default_rng(seed=42)  # deterministic noise\n\n    for cust in remaining_customers:\n        d = cust_dem[cust]\n        feasible = np.where(rem_caps >= d)[0]\n        if feasible.size == 0:\n            continue\n        for fac in feasible:\n            util_after = (used[fac] + d) / total[fac]\n            util_after = np.clip(util_after, 0.0, 1.0)\n            val = cost_mat[fac, cust]\n            # add tiny noise for deterministic tie\u2011breaking\n            val_noisy = val + rng.uniform(-1e-6, 1e-6)\n            score = val_noisy + 0.2 * util_after\n            if score < best_any[0]:\n                best_any = (score, cust, fac)\n            if util_after <= u_max and score < best_good[0]:\n                best_good = (score, cust, fac)\n\n    if best_good[1] is not None:\n        return best_good[1], best_good[2]\n    return (best_any[1], best_any[2]) if best_any[1] is not None else (None, None)\n\n",
  "cost_with_utilization_cap_threshold_aug_287": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a while\u2011loop to iterate customers and selects among the top\u20113 cheapest\n    feasible assignments. Utilisation threshold is relaxed to 0.90.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    u_max = 0.90\n    rem_caps = np.asarray(remaining_capacities, dtype=float)\n    cust_dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    used = np.array([sum(cust_dem[c] for c in custs) for custs in assignments], dtype=float)\n    total = np.maximum(used + rem_caps, 1e-12)\n\n    best_any = (np.inf, None, None)\n    best_good = (np.inf, None, None)\n\n    cust_iter = iter(remaining_customers)\n    while True:\n        try:\n            cust = next(cust_iter)\n        except StopIteration:\n            break\n\n        d = cust_dem[cust]\n        feasible = np.where(rem_caps >= d)[0]\n        if feasible.size == 0:\n            continue\n\n        # gather costs for all feasible facilities\n        costs = cost_mat[feasible, cust]\n        # pick top\u20113 cheapest\n        top_k = min(3, costs.size)\n        top_indices = np.argpartition(costs, top_k - 1)[:top_k]\n        for idx in top_indices:\n            fac = feasible[idx]\n            util_after = (used[fac] + d) / total[fac]\n            util_after = np.clip(util_after, 0.0, 1.0)\n            val = costs[idx]\n            score = val + 0.1 * util_after\n            if score < best_any[0]:\n                best_any = (score, cust, fac)\n            if util_after <= u_max and score < best_good[0]:\n                best_good = (score, cust, fac)\n\n    if best_good[1] is not None:\n        return best_good[1], best_good[2]\n    return (best_any[1], best_any[2]) if best_any[1] is not None else (None, None)\n\n",
  "cost_with_utilization_cap_threshold_aug_288": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Fully vectorised feasibility check. Utilisation is bounded with np.clip\n    and the best candidate is chosen via a weighted score (cost + 0.1*util).\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    u_max = 0.85\n    rem_caps = np.asarray(remaining_capacities, dtype=float)\n    cust_dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    used = np.array([sum(cust_dem[c] for c in custs) for custs in assignments], dtype=float)\n    total = np.maximum(used + rem_caps, 1e-12)\n\n    # feasibility matrix (facilities x customers)\n    feas_mat = rem_caps[:, None] >= cust_dem[None, :]\n    # cost matrix for remaining customers\n    cust_idx = np.array(remaining_customers, dtype=int)\n    costs = cost_mat[:, cust_idx]          # shape (fac, n_rem)\n\n    # utilisation after assignment\n    util_after = (used[:, None] + cust_dem[cust_idx]) / total[:, None]\n    util_after = np.clip(util_after, 0.0, 1.0)\n\n    # weighted score\n    score = costs + 0.1 * util_after\n\n    # mask infeasible entries\n    score = np.where(feas_mat[:, cust_idx], score, np.inf)\n\n    # indices of minimal score\n    flat_idx = np.argmin(score)\n    fac, c_local = np.unravel_index(flat_idx, score.shape)\n    cust = cust_idx[c_local]\n\n    # check if chosen candidate meets utilisation constraint\n    if util_after[fac, c_local] <= u_max:\n        return cust, fac\n\n    # otherwise find best among all feasible (still minimal score)\n    # (already the minimal overall)\n    return cust, fac\n\n",
  "cost_with_utilization_cap_threshold_aug_289": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Randomised top\u2011k selection with utilisation threshold 0.80.\n    Adds a small noise to costs for deterministic tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    u_max = 0.80\n    rem_caps = np.asarray(remaining_capacities, dtype=float)\n    cust_dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    used = np.array([sum(cust_dem[c] for c in custs) for custs in assignments], dtype=float)\n    total = np.maximum(used + rem_caps, 1e-12)\n\n    rng = np.random.default_rng(seed=123)\n\n    best_any = (np.inf, None, None)\n    best_good = (np.inf, None, None)\n\n    for cust in remaining_customers:\n        d = cust_dem[cust]\n        feasible = np.where(rem_caps >= d)[0]\n        if feasible.size == 0:\n            continue\n\n        # compute costs and utilisation for all feasible facilities\n        costs = cost_mat[feasible, cust]\n        util_after = (used[feasible] + d) / total[feasible]\n        util_after = np.clip(util_after, 0.0, 1.0)\n\n        # add deterministic noise\n        noisy_costs = costs + rng.uniform(-1e-5, 1e-5, size=costs.shape)\n\n        # top\u20115 cheapest\n        top_k = min(5, costs.size)\n        top_idx = np.argpartition(noisy_costs, top_k - 1)[:top_k]\n        for idx in top_idx:\n            fac = feasible[idx]\n            val = noisy_costs[idx]\n            score = val + 0.05 * util_after[idx]\n            if score < best_any[0]:\n                best_any = (score, cust, fac)\n            if util_after[idx] <= u_max and score < best_good[0]:\n                best_good = (score, cust, fac)\n\n    if best_good[1] is not None:\n        return best_good[1], best_good[2]\n    return (best_any[1], best_any[2]) if best_any[1] is not None else (None, None)\n\n",
  "harmonic_cost_slack_score_aug_290": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    w = 3.5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    cust_idx = np.asarray(remaining_customers, dtype=int)\n\n    # Feasibility mask: facility capacity >= customer demand\n    feas = caps[:, None] >= dem[cust_idx]\n\n    # Slack (available capacity after assigning a customer)\n    slack = caps[:, None] - dem[cust_idx]\n    slack = np.clip(slack, 0, None)          # avoid negative values\n\n    denom = slack + 1.0 + 1e-12              # epsilon to avoid division by zero\n    score = cost[:, cust_idx] * (1.0 + w / denom)\n    score = np.where(feas, score, np.inf)    # infeasible pairs get infinite score\n\n    flat_idx = np.argmin(score)\n    f, c_local = np.unravel_index(flat_idx, score.shape)\n    c = int(cust_idx[c_local])\n    f = int(f)\n    return c, f\n\n",
  "harmonic_cost_slack_score_aug_291": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    w = 4.0\n    top_k = 7\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    cust_idx = np.asarray(remaining_customers, dtype=int)\n\n    feas = caps[:, None] >= dem[cust_idx]\n    slack = caps[:, None] - dem[cust_idx]\n    slack = np.clip(slack, 0, None)\n    denom = slack + 1.0 + 1e-12\n    score = cost[:, cust_idx] * (1.0 + w / denom)\n    score = np.where(feas, score, np.inf)\n\n    # small deterministic noise for tie\u2011breaking\n    noise = np.random.rand(*score.shape) * 1e-6\n    score += noise\n\n    # pick one of the top\u2011k cheapest assignments\n    flat_idx = np.argpartition(score.ravel(), top_k)[:top_k]\n    chosen_idx = np.random.choice(flat_idx)\n    f, c_local = np.unravel_index(chosen_idx, score.shape)\n    c = int(cust_idx[c_local])\n    f = int(f)\n    return c, f\n\n",
  "harmonic_cost_slack_score_aug_292": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    w = 3.5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    cust_idx = np.asarray(remaining_customers, dtype=int)\n\n    # Compute slack for every facility\u2013customer pair\n    all_slack = caps[:, None] - dem[cust_idx]\n    all_slack = np.clip(all_slack, 0, None)\n\n    # Median slack per customer (across all facilities)\n    median_slack = np.median(all_slack, axis=0)\n    penalty = 1.0 + w / (median_slack + 1.0 + 1e-12)\n\n    feas = caps[:, None] >= dem[cust_idx]\n    score = cost[:, cust_idx] * penalty\n    score = np.where(feas, score, np.inf)\n\n    flat_idx = np.argmin(score)\n    f, c_local = np.unravel_index(flat_idx, score.shape)\n    c = int(cust_idx[c_local])\n    f = int(f)\n    return c, f\n\n",
  "harmonic_cost_slack_score_aug_293": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    w = 5.0\n    top_k = 5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    cust_idx = np.asarray(remaining_customers, dtype=int)\n\n    feas = caps[:, None] >= dem[cust_idx]\n    slack = caps[:, None] - dem[cust_idx]\n    slack = np.clip(slack, 0, None)\n    penalty = w * slack\n    score = cost + penalty\n    score = np.where(feas, score, np.inf)\n\n    # Randomly pick one of the top\u2011k cheapest assignments\n    flat_idx = np.argpartition(score.ravel(), top_k)[:top_k]\n    chosen = np.random.choice(flat_idx)\n    f, c_local = np.unravel_index(chosen, score.shape)\n    c = int(cust_idx[c_local])\n    f = int(f)\n    return c, f\n\n",
  "customer_high_cv_cost_priority_aug_294": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection using coefficient of variation and a noisy cost.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem  = np.asarray(customer_demands, float)\n    cost = np.asarray(assignment_costs, float)\n\n    best_cv = -np.inf\n    best_c  = None\n    best_f  = None\n\n    # iterate with a while loop to show structural rewriting\n    cust_iter = iter(remaining_customers)\n    while True:\n        try:\n            c = next(cust_iter)\n        except StopIteration:\n            break\n\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n\n        # add tiny deterministic noise to avoid exact ties\n        vals = cost[feas, int(c)] + np.random.uniform(0, 1e-6, size=feas.size)\n        mu   = float(np.median(vals))\n        sd   = float(np.std(vals))\n        cv   = sd / (mu + 1e-12)          # epsilon added to denominator\n\n        f = int(feas[np.argmin(vals)])\n        if cv > best_cv:\n            best_cv, best_c, best_f = cv, int(c), f\n\n    if best_c is None:\n        return None, None\n    return best_c, best_f\n\n",
  "customer_high_cv_cost_priority_aug_295": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Selection based on the sum of the three cheapest feasible costs.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps  = np.asarray(remaining_capacities, float)\n    dem   = np.asarray(customer_demands, float)\n    cost  = np.asarray(assignment_costs, float)\n\n    best_sum = np.inf\n    best_c   = None\n    best_f   = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n\n        vals = cost[feas, int(c)]\n        k    = min(3, feas.size)                 # top\u2011k cheapest\n        topk_idx = np.argpartition(vals, k-1)[:k]\n        topk_vals = vals[topk_idx]\n        sum_topk  = np.sum(topk_vals)\n\n        if sum_topk < best_sum:\n            best_sum = sum_topk\n            best_c   = int(c)\n            # random choice among the top\u2011k facilities\n            best_f   = int(feas[topk_idx[np.random.randint(0, k)]])\n\n    if best_c is None:\n        return None, None\n    return best_c, best_f\n\n",
  "customer_high_cv_cost_priority_aug_296": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"CV computation with clipping and deterministic facility choice.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps  = np.asarray(remaining_capacities, float)\n    dem   = np.asarray(customer_demands, float)\n    cost  = np.asarray(assignment_costs, float)\n\n    cvs            = []\n    chosen_facs    = []\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            cvs.append(-1.0)\n            chosen_facs.append(None)\n            continue\n\n        vals = cost[feas, int(c)]\n        mu   = float(np.median(vals))\n        sd   = float(np.std(vals))\n        cv   = sd / (mu + 1e-12)              # epsilon to avoid div\u2011by\u2011zero\n        cv   = np.clip(cv, 0.0, 1.0)          # bound the CV\n\n        cvs.append(cv)\n        # facility with the lowest cost\n        chosen_facs.append(int(feas[np.argmin(vals)]))\n\n    best_idx = int(np.argmax(cvs))\n    if cvs[best_idx] < 0:\n        return None, None\n    return remaining_customers[best_idx], chosen_facs[best_idx]\n\n",
  "facility_low_cost_variance_prefer_aug_297": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Choose a facility with the lowest mean assignment cost over the remaining customers\n    and then assign its cheapest feasible customer.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Convert inputs to numpy arrays and clip capacities to avoid negatives\n    caps = np.asarray(remaining_capacities, float)\n    caps = np.clip(caps, 0, np.inf)\n    dem = np.asarray(customer_demands, float)\n    C   = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    # Compute mean cost per facility for the remaining customers\n    mean_f = np.mean(C[:, rem], axis=1) if rem.size else np.mean(C, axis=1)\n\n    # Add a tiny deterministic noise to break ties deterministically\n    noise = 1e-6 * np.arange(len(mean_f))\n    mean_f_noisy = mean_f + noise\n\n    # Order facilities by increasing noisy mean cost\n    order = np.argsort(mean_f_noisy)\n\n    idx = 0\n    while idx < len(order):\n        f = order[idx]\n        # Feasible customers for this facility\n        feas_mask = dem[rem] <= caps[f]\n        feas_c = rem[feas_mask]\n        if feas_c.size == 0:\n            idx += 1\n            continue\n        # Cheapest feasible customer\n        costs_f = C[f, feas_c]\n        c = int(feas_c[np.argmin(costs_f)])\n        return c, int(f)\n        idx += 1\n\n    return None, None\n\n",
  "facility_low_cost_variance_prefer_aug_298": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Select a facility based on a weighted sum of variance and mean cost,\n    then assign a customer using a soft\u2011min probability distribution.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    caps = np.clip(caps, 0, np.inf)\n    dem = np.asarray(customer_demands, float)\n    C   = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    # Compute variance and mean cost per facility\n    var_f = np.var(C[:, rem], axis=1) if rem.size else np.var(C, axis=1)\n    mean_f = np.mean(C[:, rem], axis=1) if rem.size else np.mean(C, axis=1)\n\n    # Weighted combination of variance and mean\n    w_var, w_mean = 0.6, 0.4\n    score_f = w_var * var_f + w_mean * mean_f\n    order = np.argsort(score_f)\n\n    idx = 0\n    while idx < len(order):\n        f = order[idx]\n        feas_mask = dem[rem] <= caps[f]\n        feas_c = rem[feas_mask]\n        if feas_c.size == 0:\n            idx += 1\n            continue\n\n        costs_f = C[f, feas_c]\n        # Soft\u2011min weighting with temperature tau\n        tau = 1.0\n        exp_vals = np.exp(-costs_f / (tau + 1e-12))\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n        chosen_idx = np.random.choice(len(feas_c), p=probs)\n        c = int(feas_c[chosen_idx])\n        return c, int(f)\n        idx += 1\n\n    return None, None\n\n",
  "facility_low_cost_variance_prefer_aug_299": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Pick the facility with the lowest total assignment cost,\n    then randomly choose among the top\u2011k cheapest feasible customers.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    caps = np.clip(caps, 0, np.inf)\n    dem = np.asarray(customer_demands, float)\n    C   = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    # Sum of costs per facility over remaining customers\n    sum_f = np.sum(C[:, rem], axis=1) if rem.size else np.sum(C, axis=1)\n    order = np.argsort(sum_f)\n\n    top_k = 5\n    idx = 0\n    while idx < len(order):\n        f = order[idx]\n        feas_mask = dem[rem] <= caps[f]\n        feas_c = rem[feas_mask]\n        if feas_c.size == 0:\n            idx += 1\n            continue\n\n        costs_f = C[f, feas_c]\n        sorted_idx = np.argsort(costs_f)\n        k = min(top_k, len(sorted_idx))\n        top_k_idx = sorted_idx[:k]\n\n        chosen_idx = np.random.choice(top_k_idx)\n        c = int(feas_c[chosen_idx])\n        return c, int(f)\n        idx += 1\n\n    return None, None\n\n",
  "facility_low_cost_variance_prefer_aug_300": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Select the facility with the lowest maximum assignment cost\n    and assign its cheapest feasible customer.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    caps = np.clip(caps, 0, np.inf)\n    dem = np.asarray(customer_demands, float)\n    C   = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    # Max cost per facility over remaining customers\n    max_f = np.max(C[:, rem], axis=1) if rem.size else np.max(C, axis=1)\n    order = np.argsort(max_f)\n\n    idx = 0\n    while idx < len(order):\n        f = order[idx]\n        feas_mask = dem[rem] <= caps[f]\n        feas_c = rem[feas_mask]\n        if feas_c.size == 0:\n            idx += 1\n            continue\n\n        costs_f = C[f, feas_c]\n        c = int(feas_c[np.argmin(costs_f)])\n        return c, int(f)\n        idx += 1\n\n    return None, None\n\n",
  "top_regret_pool_then_best_fit_aug_301": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 1 \u2013 vectorised regret\u2011based selection with tight\u2011fit prioritisation.\n    \"\"\"\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # --- compute regret for each customer ----------------------------------\n    regrets = []\n    for c in remaining_customers:\n        idx = int(c)\n        feas = np.where(caps >= dem[idx])[0]\n        if feas.size == 0:\n            continue\n        sorted_cost = np.sort(costs[feas, idx])\n        regret = sorted_cost[1] - sorted_cost[0] if sorted_cost.size >= 2 else 1e12\n        regrets.append((regret, idx))\n\n    if not regrets:\n        return None, None\n\n    regrets.sort(key=lambda x: -x[0])          # descending regret\n    pool_size = 5                              # top\u2011P customers\n    pool = [c for _, c in regrets[:min(pool_size, len(regrets))]]\n\n    # --- pick the best (tightest slack, cheapest cost) --------------------\n    best = (np.inf, np.inf, None, None)       # (slack, cost, cust, fac)\n    for c in pool:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slacks = caps[feas] - d\n        min_slack = np.min(slacks) + 1e-12    # epsilon to avoid exact zero\n        tight = feas[slacks == min_slack]\n\n        # small deterministic noise for tie\u2011breaking\n        noise = np.random.rand(tight.size) * 1e-6\n        cand_cost = costs[tight, c] + noise\n        f = int(tight[np.argmin(cand_cost)])\n\n        key = (min_slack, costs[f, c], c, f)\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n\n",
  "top_regret_pool_then_best_fit_aug_302": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 2 \u2013 while\u2011loop construction, mean\u2011slack scoring, random tie\u2011break.\n    \"\"\"\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # --- build regret list using a while loop -----------------------------\n    regrets = []\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        ci = int(c)\n        feas = np.where(caps >= dem[ci])[0]\n        if feas.size > 0:\n            sorted_cost = np.sort(costs[feas, ci])\n            regret = sorted_cost[1] - sorted_cost[0] if sorted_cost.size >= 2 else 1e12\n            mean_slack = np.mean(caps[feas] - dem[ci])\n            regrets.append((regret, mean_slack, ci))\n        idx += 1\n\n    # invert conditional: if no feasible, exit early\n    if not regrets:\n        return None, None\n\n    # sort by regret descending\n    regrets.sort(key=lambda x: -x[0])\n    pool_size = 7\n    pool = [c for _, _, c in regrets[:min(pool_size, len(regrets))]]\n\n    # --- choose facility: random among tightest slacks -------------------\n    best = (np.inf, None, None)               # (slack, cust, fac)\n    for c in pool:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slacks = caps[feas] - d\n        min_slack = np.min(slacks) + 1e-12\n        tight = feas[slacks == min_slack]\n        # random choice among tight facilities\n        f = int(tight[np.random.randint(tight.size)])\n        key = (min_slack, c, f)\n        if key[0] < best[0]:\n            best = key\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n\n",
  "top_regret_pool_then_best_fit_aug_303": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 3 \u2013 median\u2011slack / max\u2011cost aggregation, soft\u2011min selection.\n    \"\"\"\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # --- compute combined score for each customer ------------------------\n    scores = []\n    for c in remaining_customers:\n        ci = int(c)\n        feas = np.where(caps >= dem[ci])[0]\n        if feas.size == 0:\n            continue\n        slacks = caps[feas] - dem[ci]\n        median_slack = np.median(slacks)\n        max_cost = np.max(costs[feas, ci])\n        # weighted sum (weights can be tuned)\n        score = 0.5 * median_slack + 0.5 * max_cost\n        scores.append((score, ci))\n\n    if not scores:\n        return None, None\n\n    # top\u2011k customers by score\n    scores.sort(key=lambda x: -x[0])\n    pool_size = 9\n    pool = [c for _, c in scores[:min(pool_size, len(scores))]]\n\n    # --- soft\u2011min over facilities --------------------------------------\n    best = (np.inf, None, None)               # (ratio, cust, fac)\n    for c in pool:\n        d = dem[c]\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slacks = caps[feas] - d\n        cost_vals = costs[feas, c]\n        # compute slack / (cost + epsilon)\n        ratio = slacks / (cost_vals + 1e-12)\n        # add deterministic noise for tie\u2011break\n        noise = np.random.rand(ratio.size) * 1e-6\n        ratio += noise\n        f = int(feas[np.argmin(ratio)])\n        key = (ratio.min(), c, f)\n        if key[0] < best[0]:\n            best = key\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n\n",
  "top_regret_pool_then_best_fit_aug_304": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Variant 4 \u2013 slack-to-cost ratio maximisation, deterministic tie\u2011break.\n    \"\"\"\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # --- build list of customers with feasible facilities ----------------\n    feas_list = []\n    for c in remaining_customers:\n        ci = int(c)\n        feas = np.where(caps >= dem[ci])[0]\n        if feas.size > 0:\n            feas_list.append((ci, feas))\n    if not feas_list:\n        return None, None\n\n    # --- compute ratio for each facility ---------------------------------\n    best = (0.0, None, None)                 # (ratio, cust, fac)\n    for ci, feas in feas_list:\n        d = dem[ci]\n        slacks = caps[feas] - d\n        cost_vals = costs[feas, ci]\n        ratio = slacks / (cost_vals + 1e-12)   # epsilon to avoid div\u2011by\u2011zero\n        # clip ratio to avoid extreme values\n        ratio = np.clip(ratio, 0.0, 1e6)\n        f_idx = int(feas[np.argmax(ratio)])\n        if ratio.max() > best[0]:\n            best = (ratio.max(), ci, f_idx)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n\n",
  "boost_new_facilities_first_aug_305": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that uses a deterministic noise term to break ties.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    bonus = 4.0  # tuned weight for unused facilities\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    used_flag = np.array([1.0 if len(a) > 0 else 0.0 for a in assignments], dtype=float)\n    adj_bonus = (1.0 - used_flag) * bonus\n\n    # Feasibility mask: facility capacity >= customer demand\n    feas_mask = caps_arr[:, None] >= dem_arr[None, :]\n\n    # Compute raw score and mask infeasible assignments\n    score_mat = cost_mat - adj_bonus[:, None]\n    score_mat = np.where(feas_mask, score_mat, np.inf)\n\n    if np.isinf(score_mat).all():\n        return None, None\n\n    # Deterministic noise for tie\u2011breaking\n    noise = np.arange(score_mat.size, dtype=float) * 1e-6\n    score_mat += noise.reshape(score_mat.shape)\n\n    # Global minimum\n    min_idx = np.argmin(score_mat)\n    f_idx, c_idx = divmod(min_idx, score_mat.shape[1])\n\n    return int(c_idx), int(f_idx)\n\n",
  "boost_new_facilities_first_aug_306": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Randomly selects among the top\u2011k cheapest feasible assignments.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    bonus = 5.5\n    caps_arr = np.clip(np.asarray(remaining_capacities, dtype=float), 0, np.inf)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    used_flag = np.array([1.0 if len(a) > 0 else 0.0 for a in assignments], dtype=float)\n    adj_bonus = (1.0 - used_flag) * bonus\n\n    feas_mask = caps_arr[:, None] >= dem_arr[None, :]\n    score_mat = cost_mat - adj_bonus[:, None]\n    score_mat = np.where(feas_mask, score_mat, np.inf)\n\n    if np.isinf(score_mat).all():\n        return None, None\n\n    flat_scores = score_mat.ravel()\n    top_k = 7\n    top_k_idx = np.argpartition(flat_scores, top_k)[:top_k]\n    chosen_idx = np.random.choice(top_k_idx)\n\n    f_idx, c_idx = divmod(chosen_idx, score_mat.shape[1])\n    return int(c_idx), int(f_idx)\n\n",
  "boost_new_facilities_first_aug_307": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Chooses the customer with the lowest median assignment score and then the\n    facility with the minimal score for that customer.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    bonus = 4.5\n    caps_arr = np.asarray(remaining_capacities, dtype=float)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    used_flag = np.array([1.0 if len(a) > 0 else 0.0 for a in assignments], dtype=float)\n    adj_bonus = (1.0 - used_flag) * bonus\n\n    feas_mask = caps_arr[:, None] >= dem_arr[None, :]\n    score_mat = cost_mat - adj_bonus[:, None]\n    score_mat = np.where(feas_mask, score_mat, np.inf)\n\n    if np.isinf(score_mat).all():\n        return None, None\n\n    # Median per customer\n    median_scores = np.median(score_mat, axis=0)\n    median_scores += np.arange(median_scores.size, dtype=float) * 1e-6  # tie\u2011break\n    c_idx = int(np.argmin(median_scores))\n\n    f_idx = int(np.argmin(score_mat[:, c_idx]))\n    return c_idx, f_idx\n\n",
  "boost_new_facilities_first_aug_308": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a soft\u2011min probability distribution to randomly pick a feasible assignment.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    bonus = 5.0\n    caps_arr = np.clip(np.asarray(remaining_capacities, dtype=float), 0, np.inf)\n    dem_arr = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    used_flag = np.array([1.0 if len(a) > 0 else 0.0 for a in assignments], dtype=float)\n    adj_bonus = (1.0 - used_flag) * bonus\n\n    feas_mask = caps_arr[:, None] >= dem_arr[None, :]\n    score_mat = cost_mat - adj_bonus[:, None]\n    score_mat = np.where(feas_mask, score_mat, np.inf)\n\n    if np.isinf(score_mat).all():\n        return None, None\n\n    # Soft\u2011min probabilities with temperature and epsilon\n    temp = 1.0\n    exp_neg = np.exp(-(score_mat - np.min(score_mat)) / (temp + 1e-12))\n    probs = exp_neg / (np.sum(exp_neg) + 1e-12)\n\n    flat_idx = np.random.choice(score_mat.size, p=probs.ravel())\n    f_idx, c_idx = divmod(flat_idx, score_mat.shape[1])\n\n    return int(c_idx), int(f_idx)\n\n",
  "penalize_overused_facilities_aug_309": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Vectorised greedy selection with deterministic tie\u2011breaking.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 0.8                                 # weight on current facility load\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n    cnt = np.asarray([len(a) for a in assignments], dtype=float)\n\n    # Feasibility mask: (capacity - demand) >= 0  (epsilon added to avoid 0\u2011division)\n    feas = (caps[:, None] - dem[remaining_customers] + 1e-12) >= 0\n\n    # Mask infeasible costs with +inf\n    masked_cost = np.where(feas, cost[:, remaining_customers], np.inf)\n\n    # Score = cost + lam * current load\n    score = masked_cost + lam * cnt[:, None]\n\n    # Small deterministic noise for tie\u2011breaking\n    noise = 1e-9 * np.arange(score.size).reshape(score.shape)\n    score += noise\n\n    # Clip to avoid numerical overflow\n    score = np.clip(score, 0, 1e12)\n\n    # Find global minimum\n    flat_idx = np.argmin(score)\n    f, c_idx = np.unravel_index(flat_idx, score.shape)\n\n    if np.isinf(score[flat_idx]):\n        return None, None\n\n    return int(remaining_customers[c_idx]), int(f)\n\n",
  "penalize_overused_facilities_aug_310": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection with softmin probability and while\u2011loop control.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 0.7\n    T = 1.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n    cost = np.clip(cost, 0, 1e9)          # keep values bounded\n    cnt = np.asarray([len(a) for a in assignments], dtype=float)\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n    i = 0\n    while i < len(remaining_customers):\n        c = remaining_customers[i]\n        feas_mask = caps >= dem[c]\n        feas_idx = np.where(feas_mask)[0]\n        if feas_idx.size == 0:\n            i += 1\n            continue\n\n        scores = cost[feas_idx, c] + lam * cnt[feas_idx]\n        # deterministic noise for reproducible tie\u2011breaking\n        scores += 1e-9 * np.arange(scores.size)\n\n        exp_vals = np.exp(-scores / (T + 1e-12))\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n        f = feas_idx[np.argmax(probs)]\n        val = float(scores[np.argmax(probs)])\n\n        if val < best_val:\n            best_val = val\n            best_c = c\n            best_f = int(f)\n\n        i += 1\n\n    if best_c is None:\n        return None, None\n\n    return best_c, best_f\n\n",
  "penalize_overused_facilities_aug_311": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Median\u2011based aggregation with deterministic noise and clipping.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 0.6\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n    cost = np.clip(cost, 0, 1e9)\n    cnt = np.asarray([len(a) for a in assignments], dtype=float)\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas_idx = np.where(caps >= dem[c])[0]\n        if feas_idx.size == 0:\n            continue\n\n        scores = cost[feas_idx, c] + lam * cnt[feas_idx]\n        scores += 1e-9 * np.arange(scores.size)          # deterministic noise\n\n        median_score = np.median(scores)\n        diff = np.abs(scores - median_score)\n        diff = np.clip(diff, 1e-12, None)                # avoid division by zero\n        f = feas_idx[np.argmin(diff)]\n        val = float(scores[np.argmin(diff)])\n\n        if val < best_val:\n            best_val = val\n            best_c = c\n            best_f = int(f)\n\n    if best_c is None:\n        return None, None\n\n    return best_c, best_f\n\n",
  "penalize_overused_facilities_aug_312": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Weighted random choice with softmax and epsilon\u2011safe normalisation.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    lam = 0.5\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n    cost = np.clip(cost, 0, 1e9)\n    cnt = np.asarray([len(a) for a in assignments], dtype=float)\n\n    best_val = np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas_idx = np.where(caps >= dem[c])[0]\n        if feas_idx.size == 0:\n            continue\n\n        scores = cost[feas_idx, c] + lam * cnt[feas_idx]\n        scores += 1e-9 * np.arange(scores.size)          # deterministic noise\n\n        exp_vals = np.exp(-scores / (1.0 + 1e-12))\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n        chosen_f = feas_idx[np.random.choice(feas_idx.size, p=probs)]\n        val = float(cost[chosen_f, c] + lam * cnt[chosen_f])\n\n        if val < best_val:\n            best_val = val\n            best_c = c\n            best_f = int(chosen_f)\n\n    if best_c is None:\n        return None, None\n\n    return best_c, best_f\n\n",
  "max_improvement_over_mean_cost_aug_313": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    best_cust = None\n    best_fac = None\n\n    for c in remaining_customers:\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size == 0:\n            continue\n        fac_costs = costs[feasible, c]\n        # use median instead of mean\n        median_cost = np.clip(np.median(fac_costs), 0, np.inf)\n        # deterministic noise for tie\u2011breaking\n        noise = 1e-6 * (c + 1)\n        score = median_cost - costs[feasible[np.argmin(fac_costs)], c] + noise\n        if score > best_score:\n            best_score, best_cust, best_fac = score, int(c), int(feasible[np.argmin(fac_costs)])\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "max_improvement_over_mean_cost_aug_314": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # feasibility mask and large penalty for infeasible pairs\n    large_val = 1e12\n    feasible_mask = caps[:, None] >= dem[None, :]\n    masked_costs = np.where(feasible_mask, costs, large_val)\n\n    # weighted improvement: 0.6 * mean \u2013 0.4 * best cost\n    mean_cost = np.mean(masked_costs, axis=0)\n    best_idx = np.argmin(masked_costs, axis=0)\n    best_cost = masked_costs[best_idx, np.arange(costs.shape[1])]\n    improvement = 0.6 * mean_cost - 0.4 * best_cost\n    improvement = np.clip(improvement, -np.inf, np.inf)\n\n    # choose customer with maximal improvement\n    best_cust = np.argmax(improvement)\n    if improvement[best_cust] <= 0:\n        return None, None\n\n    # soft\u2011min selection over facilities for the chosen customer\n    cust_idx = best_cust\n    costs_cust = masked_costs[:, cust_idx]\n    denom = np.sum(np.exp(-costs_cust / (1.0 + 1e-12))) + 1e-12\n    probs = np.exp(-costs_cust / (1.0 + 1e-12)) / denom\n    rng = np.random.default_rng(seed=42)\n    chosen_fac = rng.choice(costs.shape[0], p=probs)\n\n    return int(cust_idx), int(chosen_fac)\n\n",
  "max_improvement_over_mean_cost_aug_315": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    best_c = None\n    best_f = None\n\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size > 0:\n            fac_costs = costs[feasible, c]\n            total = np.sum(fac_costs)\n            min_cost = fac_costs.min()\n            # improvement with division; add epsilon to avoid divide\u2011by\u2011zero\n            improvement = (total - min_cost) / (min_cost + 1e-12)\n            improvement = np.clip(improvement, 0, 1)          # bound to [0,1]\n            noise = 1e-5 * (c + 1)                           # deterministic tie\u2011break\n            score = improvement + noise\n            if score > best_score:\n                best_score, best_c, best_f = score, int(c), int(feasible[np.argmin(fac_costs)])\n        idx += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "max_improvement_over_mean_cost_aug_316": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_cust = None\n    best_fac = None\n    best_metric = -np.inf\n\n    for c in remaining_customers:\n        feasible = np.where(caps >= dem[c])[0]\n        if feasible.size == 0:\n            continue\n        fac_costs = costs[feasible, c]\n        # weighted mean by remaining capacity\n        weights = caps[feasible]\n        weighted_mean = np.sum(weights * fac_costs) / (np.sum(weights) + 1e-12)\n        weighted_mean = np.clip(weighted_mean, 0, np.inf)\n\n        # pick among top\u20113 cheapest facilities\n        top_k = 3\n        idx_top = np.argpartition(fac_costs, top_k-1)[:top_k]\n        chosen = feasible[idx_top[np.argmin(fac_costs[idx_top])]]\n        metric = weighted_mean - costs[chosen, c]\n        if metric > best_metric:\n            best_metric, best_cust, best_fac = metric, int(c), int(chosen)\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "facility_mean_normalized_cost_aug_317": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that chooses the (customer, facility) pair with the\n    smallest cost divided by the mean facility cost over the remaining customers.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C   = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Mean cost of each facility over the remaining customers\n    mean_f = np.mean(C[:, rem], axis=1, keepdims=True)          # shape (F,1)\n    mean_f = np.clip(mean_f, 1e-12, None)                       # avoid zero division\n\n    # Feasibility mask: facility can serve customer if capacity >= demand\n    feas = caps[:, None] >= dem[rem]                            # shape (F, len(rem))\n\n    # Initialise scores with +inf for infeasible pairs\n    scores = np.full(feas.shape, np.inf, dtype=float)\n\n    # Compute score only for feasible pairs\n    scores[feas] = C[:, rem][feas] / (mean_f[feas] + 1e-12)\n\n    # Small deterministic noise to break ties deterministically\n    noise = (np.arange(caps.size)[:, None] * 1e-9 +\n             np.arange(rem.size)[None, :] * 1e-9)\n    scores += noise\n\n    # Locate the best pair\n    f_idx, c_idx = np.unravel_index(np.argmin(scores), scores.shape)\n    return int(rem[c_idx]), int(f_idx)\n\n",
  "facility_mean_normalized_cost_aug_318": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Implements the selection using a while\u2011loop and a sum\u2011based aggregation\n    for the facility mean. Randomly chooses one of the top\u20115 lowest scores.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C   = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Sum of costs per facility over remaining customers\n    mean_f = np.sum(C[:, rem], axis=1, keepdims=True)\n    mean_f = np.clip(mean_f, 1e-12, None)\n\n    feas = caps[:, None] >= dem[rem]\n    scores = np.full(feas.shape, np.inf, dtype=float)\n    scores[feas] = C[:, rem][feas] / (mean_f[feas] + 1e-12)\n\n    # Add deterministic noise\n    noise = (np.arange(caps.size)[:, None] * 1e-9 +\n             np.arange(rem.size)[None, :] * 1e-9)\n    scores += noise\n\n    # Flatten scores and pick top\u20115 indices\n    flat_scores = scores.ravel()\n    top5_idx = np.argpartition(flat_scores, 5)[:5]\n    top5_scores = flat_scores[top5_idx]\n    # Randomly choose one among the top\u20115\n    chosen_idx = np.random.choice(top5_idx, p=np.exp(-top5_scores) / np.exp(-top5_scores).sum())\n\n    f_idx, c_idx = divmod(chosen_idx, rem.size)\n    return int(rem[c_idx]), int(f_idx)\n\n",
  "facility_mean_normalized_cost_aug_319": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Inverts the selection logic: maximises the negative score. Uses the\n    maximum cost per facility as the aggregation instead of the mean.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C   = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Max cost per facility over the remaining customers\n    mean_f = np.max(C[:, rem], axis=1, keepdims=True)\n    mean_f = np.clip(mean_f, 1e-12, None)\n\n    feas = caps[:, None] >= dem[rem]\n    scores = np.full(feas.shape, -np.inf, dtype=float)   # initialise with -inf for maximisation\n    scores[feas] = -C[:, rem][feas] / (mean_f[feas] + 1e-12)  # negative score\n\n    # Deterministic noise to avoid ties\n    noise = (np.arange(caps.size)[:, None] * 1e-9 +\n             np.arange(rem.size)[None, :] * 1e-9)\n    scores += noise\n\n    # Find the pair with the maximum score\n    f_idx, c_idx = np.unravel_index(np.argmax(scores), scores.shape)\n    return int(rem[c_idx]), int(f_idx)\n\n",
  "customer_mean_normalized_cost_aug_320": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    assigns, custs, caps, dem, cost_mat = assignments, remaining_customers, remaining_capacities, customer_demands, assignment_costs\n    eps = 1e-12\n\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    idx = 0\n    while idx < len(custs):\n        c = custs[idx]\n        # Facilities that can serve customer c\n        feas = np.where(np.asarray(caps) >= dem[c])[0]\n        if feas.size > 0:\n            mean_cost = np.mean(cost_mat[feas, c])\n            for f in feas:\n                score = cost_mat[f, c] / (mean_cost + eps)\n                if score < best_score:\n                    best_score, best_cust, best_fac = score, c, f\n        idx += 1\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "customer_mean_normalized_cost_aug_321": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    assigns, custs, caps, dem, cost_mat = assignments, remaining_customers, remaining_capacities, customer_demands, assignment_costs\n    eps = 1e-12\n    top_k = 7  # hyper\u2011parameter\n\n    # Prepare arrays\n    caps_arr = np.asarray(caps, dtype=np.float64)\n    dem_arr = np.asarray(dem, dtype=np.int64)\n    cost_arr = np.asarray(cost_mat, dtype=np.float64)\n\n    candidate_scores = []\n    for c in custs:\n        feas = np.where(caps_arr >= dem_arr[c])[0]\n        if feas.size == 0:\n            continue\n        mean_cost = np.mean(cost_arr[feas, c]) + eps\n        # Weighted score: 0.6*cost + 0.4*mean_cost\n        scores = 0.6 * cost_arr[feas, c] + 0.4 * mean_cost\n        for f, sc in zip(feas, scores):\n            candidate_scores.append((sc, c, f))\n\n    if not candidate_scores:\n        return (None, None)\n\n    # Keep only the best top_k candidates\n    candidate_scores.sort(key=lambda x: x[0])\n    top_candidates = candidate_scores[:top_k]\n\n    # Randomly pick one among the top_k\n    rng = np.random.default_rng(0)\n    chosen = rng.choice(top_candidates)\n    return (chosen[1], chosen[2])\n\n",
  "customer_mean_normalized_cost_aug_322": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    assigns, custs, caps, dem, cost_mat = assignments, remaining_customers, remaining_capacities, customer_demands, assignment_costs\n    eps = 1e-12\n    top_k = 5\n    rng = np.random.default_rng(0)\n\n    best_cust = None\n    best_fac = None\n    best_score = np.inf\n\n    for c in custs:\n        feas = np.where(np.asarray(caps) >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        median_cost = np.median(cost_mat[feas, c]) + eps\n        # Deterministic tie\u2011breaking noise\n        noise = rng.random(feas.size) * 1e-6\n        scores = (cost_mat[feas, c] / median_cost) + noise\n\n        # Take the smallest top_k scores\n        if feas.size > top_k:\n            idx_top = np.argpartition(scores, top_k)[:top_k]\n        else:\n            idx_top = np.arange(feas.size)\n        chosen_idx = rng.choice(idx_top)\n        chosen_score = scores[chosen_idx]\n        if chosen_score < best_score:\n            best_score, best_cust, best_fac = chosen_score, c, feas[chosen_idx]\n\n    return (best_cust, best_fac) if best_cust is not None else (None, None)\n\n",
  "facility_capacity_percentile_gate_aug_323": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    fac_caps = np.asarray(remaining_capacities, dtype=float)\n    cust_dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    assigned_cnt = sum(len(a) for a in assignments)\n    rem_cnt = len(remaining_customers)\n    progress = assigned_cnt / max(1, assigned_cnt + rem_cnt + 1e-12)\n\n    pct = 0.70 if progress < 0.5 else 0.0\n    thr = np.clip(np.quantile(fac_caps, pct) if fac_caps.size else 0.0,\n                  a_min=0.0, a_max=None)\n\n    # Add a tiny deterministic noise for tie\u2011breaking\n    noise = np.arange(cost_mat.size).reshape(cost_mat.shape) * 1e-12\n    noisy_cost = cost_mat + noise\n\n    best_any_val = np.inf\n    best_any_idx = None\n    best_primary_val = np.inf\n    best_primary_idx = None\n\n    for c in remaining_customers:\n        d = cust_dem[c]\n        feas_mask = fac_caps >= d\n        if not feas_mask.any():\n            continue\n        costs = noisy_cost[feas_mask, c]\n        fac_indices = np.nonzero(feas_mask)[0]\n        local_min = np.argmin(costs)\n        f = fac_indices[local_min]\n        val = costs[local_min]\n\n        if val < best_any_val:\n            best_any_val = val\n            best_any_idx = (c, f)\n        if fac_caps[f] >= thr and val < best_primary_val:\n            best_primary_val = val\n            best_primary_idx = (c, f)\n\n    if best_primary_idx is not None:\n        return best_primary_idx\n    return best_any_idx if best_any_idx is not None else (None, None)\n\n",
  "facility_capacity_percentile_gate_aug_324": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    fac_caps = np.asarray(remaining_capacities, dtype=float)\n    cust_dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    assigned = sum(len(a) for a in assignments)\n    rem = len(remaining_customers)\n    progress = assigned / max(1, assigned + rem + 1e-12)\n\n    pct = 0.80 if progress < 0.6 else 0.0\n    thr = np.clip(np.quantile(fac_caps, pct) if fac_caps.size else 0.0,\n                  0.0, None)\n\n    # Small deterministic noise for tie\u2011breaking\n    noise = np.arange(cost_mat.size).reshape(cost_mat.shape) * 1e-6\n    noisy_cost = cost_mat + noise\n\n    best_any = (np.inf, None, None)\n    best_primary = (np.inf, None, None)\n\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        d = cust_dem[c]\n        feasible_fac = np.where(fac_caps >= d)[0]\n        for f in feasible_fac:\n            val = noisy_cost[f, c]\n            if val < best_any[0]:\n                best_any = (val, c, f)\n            if fac_caps[f] >= thr and val < best_primary[0]:\n                best_primary = (val, c, f)\n        idx += 1\n\n    if best_primary[1] is not None:\n        return best_primary[1], best_primary[2]\n    return (best_any[1], best_any[2]) if best_any[1] is not None else (None, None)\n\n",
  "facility_capacity_percentile_gate_aug_325": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    fac_caps = np.asarray(remaining_capacities, dtype=float)\n    cust_dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    assigned = sum(len(a) for a in assignments)\n    rem = len(remaining_customers)\n    progress = assigned / max(1, assigned + rem + 1e-12)\n\n    pct = 0.60 if progress < 0.4 else 0.0\n    thr = np.clip(np.quantile(fac_caps, pct) if fac_caps.size else 0.0,\n                  0.0, None)\n\n    # Build feasible mask\n    feas_mask = np.zeros_like(cost_mat, dtype=bool)\n    for c in remaining_customers:\n        d = cust_dem[c]\n        feas_mask[:, c] = fac_caps >= d\n\n    if not feas_mask.any():\n        return None, None\n\n    # Soft\u2011min probabilities\n    tau = 5.0\n    large_cost = np.full_like(cost_mat, np.inf)\n    masked_cost = np.where(feas_mask, cost_mat, large_cost)\n\n    exp_vals = np.exp(-masked_cost / (tau + 1e-12))\n    exp_vals = np.where(feas_mask, exp_vals, 0.0)\n    prob = exp_vals / (exp_vals.sum() + 1e-12)\n\n    flat_idx = np.argmax(prob)\n    f, c = np.unravel_index(flat_idx, prob.shape)\n\n    if not feas_mask[f, c]:\n        # fallback to deterministic argmin\n        feasible_indices = np.argwhere(feas_mask)\n        costs = cost_mat[feas_mask]\n        min_idx = np.argmin(costs)\n        f, c = feasible_indices[min_idx]\n\n    return int(c), int(f)\n\n",
  "facility_capacity_percentile_gate_aug_326": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    fac_caps = np.asarray(remaining_capacities, dtype=float)\n    cust_dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    assigned = sum(len(a) for a in assignments)\n    rem = len(remaining_customers)\n    progress = assigned / max(1, assigned + rem + 1e-12)\n\n    pct = 0.55 if progress < 0.3 else 0.0\n    thr = np.clip(np.percentile(fac_caps, pct * 100) if fac_caps.size else 0.0,\n                  0.0, None)\n\n    # Usage ratio: (remaining capacity) / (total capacity)\n    usage = np.divide(fac_caps[:, None] - cust_dem[None, :],\n                      fac_caps[:, None] + 1e-12,\n                      out=np.zeros_like(fac_caps[:, None]),\n                      where=fac_caps[:, None] > 0)\n    weight = 1.0 - np.clip(usage, 0.0, 1.0)\n    weighted_cost = cost_mat * (1.0 + (1.0 - weight))  # increase cost when facility is less used\n\n    best_any_val = np.inf\n    best_any_idx = None\n    best_primary_val = np.inf\n    best_primary_idx = None\n\n    for c in remaining_customers:\n        d = cust_dem[c]\n        feas_mask = fac_caps >= d\n        if not feas_mask.any():\n            continue\n        costs = weighted_cost[feas_mask, c]\n        fac_indices = np.nonzero(feas_mask)[0]\n        local_min = np.argmin(costs)\n        f = fac_indices[local_min]\n        val = costs[local_min]\n\n        if val < best_any_val:\n            best_any_val = val\n            best_any_idx = (c, f)\n        if fac_caps[f] >= thr and val < best_primary_val:\n            best_primary_val = val\n            best_primary_idx = (c, f)\n\n    if best_primary_idx is not None:\n        return best_primary_idx\n    return best_any_idx if best_any_idx is not None else (None, None)\n\n",
  "smallest_capacity_facility_first_aug_327": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Greedy assignment that scans facilities in ascending capacity order.\n    Adds a small deterministic noise and a load\u2011ratio term to the cost.\n    \"\"\"\n    # rename for readability\n    assign = assignments\n    rem_cust = remaining_customers\n    rem_cap = remaining_capacities\n    cust_dem = customer_demands\n    cost_mat = assignment_costs\n\n    if not rem_cust:\n        return None, None\n\n    caps = np.asarray(rem_cap, float)\n    dem = np.asarray(cust_dem, float)\n    C = np.asarray(cost_mat, float)\n    rem = np.asarray(rem_cust, int)\n\n    # ensure no division by zero in later calculations\n    caps = np.clip(caps, 1e-12, None)\n\n    order = np.argsort(caps)\n    idx = 0\n    while idx < len(order):\n        f = int(order[idx])\n        feas_idx = rem[dem[rem] <= caps[f]]\n        if feas_idx.size == 0:\n            idx += 1\n            continue\n\n        # deterministic tiny noise for tie\u2011breaking\n        noise = np.random.uniform(0, 1e-6, size=feas_idx.shape)\n\n        # load ratio with epsilon to avoid division by zero\n        load_ratio = caps[f] / (dem[feas_idx].sum() + 1e-12)\n\n        costs = C[f, feas_idx] + noise + 0.01 * load_ratio\n        c = int(feas_idx[np.argmin(costs)])\n        return c, f\n        idx += 1\n\n    return None, None\n\n",
  "smallest_capacity_facility_first_aug_328": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Fully vectorised implementation that uses a weighted cost combining\n    demand ratio and raw assignment cost. The top_k cheapest customers\n    per facility are considered and a random one is selected.\n    \"\"\"\n    rem_cust = np.asarray(remaining_customers, int)\n    rem_cap = np.asarray(remaining_capacities, float)\n    cust_dem = np.asarray(customer_demands, float)\n    cost_mat = np.asarray(assignment_costs, float)\n\n    if rem_cust.size == 0:\n        return None, None\n\n    # avoid division by zero\n    rem_cap = np.clip(rem_cap, 1e-12, None)\n\n    # feasibility matrix: customers x facilities\n    feas = cust_dem[rem_cust][:, None] <= rem_cap[None, :]\n\n    # weighted cost matrix\n    ratio = cust_dem[rem_cust][:, None] / (rem_cap[None, :] + 1e-12)\n    weighted = 0.6 * ratio + 0.4 * cost_mat[:, rem_cust]\n    weighted = np.clip(weighted, 0, None)\n\n    # choose the smallest\u2011capacity facility that can serve anyone\n    order = np.argsort(rem_cap)\n    for f in order:\n        if feas[:, f].any():\n            feas_idx = rem_cust[feas[:, f]]\n            costs = weighted[:, f][feas[:, f]]\n            top_k = 7\n            if costs.size <= top_k:\n                chosen_idx = np.argmin(costs)\n            else:\n                top_indices = np.argpartition(costs, top_k)[:top_k]\n                chosen_idx = np.random.choice(top_indices)\n            c = int(feas_idx[chosen_idx])\n            return c, f\n\n    return None, None\n\n",
  "smallest_capacity_facility_first_aug_329": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Inverted capacity order (descending). Uses the median of costs to filter\n    candidates and a deterministic tie\u2011breaker based on customer id parity.\n    Adds a demand\u2011to\u2011capacity ratio term to the cost.\n    \"\"\"\n    assign = assignments\n    rem_cust = remaining_customers\n    rem_cap = remaining_capacities\n    cust_dem = customer_demands\n    cost_mat = assignment_costs\n\n    if not rem_cust:\n        return None, None\n\n    caps = np.asarray(rem_cap, float)\n    dem = np.asarray(cust_dem, float)\n    C = np.asarray(cost_mat, float)\n    rem = np.asarray(rem_cust, int)\n\n    caps = np.clip(caps, 1e-12, None)\n\n    # descending capacity order\n    order = np.argsort(caps)[::-1]\n    for f in order:\n        feas_idx = rem[dem[rem] <= caps[f]]\n        if feas_idx.size == 0:\n            continue\n\n        # cost with ratio term\n        ratio_term = (dem[feas_idx] / (caps[f] + 1e-12))\n        costs = C[f, feas_idx] + 0.02 * ratio_term\n\n        median_cost = np.median(costs)\n        candidates = feas_idx[ costs <= median_cost ]\n        if candidates.size == 0:\n            continue\n\n        # deterministic tie\u2011breaker: pick first even customer id\n        tie_break = candidates % 2\n        idx = np.argmin(tie_break)\n        c = int(candidates[idx])\n        return c, f\n\n    return None, None\n\n",
  "remaining_capacity_to_median_target_aug_330": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised selection using weighted distance\u2011to\u2011median and cost.\n    Uses 0.6*dist + 0.4*cost and deterministic noise for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    # median of remaining capacities (with epsilon for safety)\n    med = float(np.median(caps) + 1e-12)\n\n    # Build matrices for vectorised operations\n    cust_idx = np.asarray(remaining_customers, dtype=int)\n    fac_idx = np.arange(len(caps), dtype=int)\n\n    # Demand matrix (customers \u00d7 1) and capacity matrix (1 \u00d7 facilities)\n    dem_mat = dem[cust_idx][:, None]          # shape (n_cust, 1)\n    cap_mat = caps[None, :]                   # shape (1, n_fac)\n\n    # Feasibility mask\n    feas = cap_mat >= dem_mat                 # shape (n_cust, n_fac)\n\n    # Remaining capacity after assignment\n    rem_after = cap_mat - dem_mat\n    rem_after = np.clip(rem_after, 0.0, None)  # prevent negative values\n\n    # Distance to median and cost matrices\n    dist_mat = np.abs(rem_after - med)\n    cost_mat = cost[np.ix_(cust_idx, fac_idx)]\n\n    # Normalise by maximum to keep scales comparable (avoid division by zero)\n    dist_norm = dist_mat / (np.max(dist_mat) + 1e-12)\n    cost_norm = cost_mat / (np.max(cost_mat) + 1e-12)\n\n    # Weighted score with deterministic noise for tie breaking\n    noise = 1e-9 * np.arange(dist_norm.size).reshape(dist_norm.shape)\n    score = 0.6 * dist_norm + 0.4 * cost_norm + noise\n\n    # Mask infeasible pairs by assigning a very large score\n    score[~feas] = np.inf\n\n    # Find best pair\n    flat_idx = np.argmin(score)\n    cust_pos, fac_pos = np.unravel_index(flat_idx, score.shape)\n    return int(cust_idx[cust_pos]), int(fac_idx[fac_pos])\n\n",
  "remaining_capacity_to_median_target_aug_331": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Random choice among the top\u2011k (k=3) candidates.\n    Uses weighted 0.7*dist + 0.3*cost and deterministic noise.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    cust_idx = np.asarray(remaining_customers, dtype=int)\n    fac_idx = np.arange(len(caps), dtype=int)\n\n    dem_mat = dem[cust_idx][:, None]\n    cap_mat = caps[None, :]\n    feas = cap_mat >= dem_mat\n    rem_after = np.clip(cap_mat - dem_mat, 0.0, None)\n\n    med = float(np.median(caps) + 1e-12)\n\n    dist = np.abs(rem_after - med)\n    cost_mat = cost[np.ix_(cust_idx, fac_idx)]\n\n    # Normalise\n    dist_norm = dist / (np.max(dist) + 1e-12)\n    cost_norm = cost_mat / (np.max(cost_mat) + 1e-12)\n\n    # Weighted score with noise\n    noise = 1e-9 * np.arange(dist_norm.size).reshape(dist_norm.shape)\n    score = 0.7 * dist_norm + 0.3 * cost_norm + noise\n\n    score[~feas] = np.inf\n\n    # Flatten and get top\u2011k indices\n    flat = score.ravel()\n    top_k = 3\n    top_idx = np.argpartition(flat, top_k)[:top_k]\n    rng = np.random.default_rng(42)  # deterministic\n    chosen = rng.choice(top_idx)\n\n    cust_pos, fac_pos = np.unravel_index(chosen, score.shape)\n    return int(cust_idx[cust_pos]), int(fac_idx[fac_pos])\n\n",
  "lookahead_for_biggest_customer_next_aug_332": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorised implementation that evaluates all feasible assignments at once.\n    The biggest remaining customer is protected by adding a penalty term.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Convert inputs to numpy arrays for broadcasting\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C   = np.asarray(assignment_costs, dtype=float)\n    custs = np.asarray(remaining_customers, dtype=int)\n\n    # Identify the biggest remaining customer\n    big = custs[np.argmax(dem[custs])]\n\n    # Feasibility mask: 1 where facility capacity >= customer demand\n    feas_mask = caps[:, None] >= dem[None, :custs.size]\n    # Base cost matrix (infinite where infeasible)\n    base = np.where(feas_mask, C[:, custs], np.inf)\n\n    # Penalty for the biggest customer: minimum cost among its feasible facilities\n    feas_big_mask = caps >= dem[big]\n    min_cost_big = np.min(C[feas_big_mask, big]) if np.any(feas_big_mask) else 1e9\n    penalty = np.full_like(base, min_cost_big, dtype=float)\n    # Infeasible assignments receive a huge penalty\n    penalty[~feas_mask] = 1e9\n    # No penalty for the biggest customer itself\n    penalty[:, custs == big] = 0.0\n\n    # Final score combines base cost and penalty\n    score = base + 0.4 * penalty\n    if np.all(np.isinf(score)):\n        return None, None\n\n    # Locate the assignment with the minimal score\n    f_idx, c_idx = np.unravel_index(np.argmin(score), score.shape)\n    return int(custs[c_idx]), int(f_idx)\n\n",
  "lookahead_for_biggest_customer_next_aug_333": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a top\u2011k strategy with deterministic noise for tie\u2011breaking.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng(0)  # deterministic\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    custs = np.asarray(remaining_customers, dtype=int)\n\n    big = custs[np.argmax(dem[custs])]\n\n    feas_mask = caps[:, None] >= dem[None, :custs.size]\n    base = np.where(feas_mask, C[:, custs], np.inf)\n\n    feas_big_mask = caps >= dem[big]\n    min_cost_big = np.min(C[feas_big_mask, big]) if np.any(feas_big_mask) else 1e9\n    penalty = np.full_like(base, min_cost_big, dtype=float)\n    penalty[~feas_mask] = 1e9\n    penalty[:, custs == big] = 0.0\n\n    # Weighting: 60% base cost, 40% penalty\n    score = 0.6 * base + 0.4 * penalty\n    # Add tiny deterministic noise to break ties\n    noise = rng.random(score.shape) * 1e-6\n    score += noise\n\n    if np.all(np.isinf(score)):\n        return None, None\n\n    # Extract top_k smallest scores\n    k = 7\n    flat_indices = np.argpartition(score.ravel(), k-1)[:k]\n    best_idx = flat_indices[0]\n    f_idx, c_idx = np.unravel_index(best_idx, score.shape)\n    return int(custs[c_idx]), int(f_idx)\n\n",
  "lookahead_for_biggest_customer_next_aug_334": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Uses a proxy penalty based on the worst (max) cost for the biggest customer.\n    Implements a simple while\u2011loop to ensure a feasible assignment is found.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    custs = np.asarray(remaining_customers, dtype=int)\n\n    big = custs[np.argmax(dem[custs])]\n\n    feas_mask = caps[:, None] >= dem[None, :custs.size]\n    base = np.where(feas_mask, C[:, custs], np.inf)\n\n    feas_big_mask = caps >= dem[big]\n    max_cost_big = np.max(C[feas_big_mask, big]) if np.any(feas_big_mask) else 1e9\n    penalty = np.full_like(base, max_cost_big, dtype=float)\n    penalty[~feas_mask] = 1e9\n    penalty[:, custs == big] = 0.0\n\n    score = base + 0.4 * penalty\n    if np.all(np.isinf(score)):\n        return None, None\n\n    # Find the minimal score\n    f_idx, c_idx = np.unravel_index(np.argmin(score), score.shape)\n    return int(custs[c_idx]), int(f_idx)\n\n",
  "maximize_demand_per_total_capacity_aug_335": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    fac_assign = assignments\n    custs_rem   = remaining_customers\n    caps_rem    = remaining_capacities\n    dem         = customer_demands\n    cost_mat    = assignment_costs\n\n    if not custs_rem:\n        return None, None\n\n    caps_arr  = np.asarray(caps_rem, dtype=float)\n    dem_arr   = np.asarray(dem, dtype=float)\n    cost_arr  = np.asarray(cost_mat, dtype=float)\n\n    # current usage per facility\n    used = np.zeros_like(caps_arr)\n    for f, custs in enumerate(fac_assign):\n        used[f] = np.sum(dem_arr[custs]) if custs else 0.0\n\n    total = used + caps_arr\n    total = np.clip(total, 1e-12, None)          # avoid division by zero\n\n    best_ratio, best_c, best_f = -np.inf, None, None\n\n    for c in custs_rem:\n        d = float(dem_arr[c])\n        feas = np.where(caps_arr >= d)[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(cost_arr[feas, c])])  # cheapest feasible\n        ratio = (d ** 1.1) / (total[f] ** 0.9 + 1e-12)\n        ratio += np.random.rand() * 1e-6            # deterministic tie\u2011breaker\n        if ratio > best_ratio:\n            best_ratio, best_c, best_f = ratio, int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "maximize_demand_per_total_capacity_aug_336": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    fac_assign = assignments\n    custs_rem   = remaining_customers\n    caps_rem    = remaining_capacities\n    dem         = customer_demands\n    cost_mat    = assignment_costs\n\n    if not custs_rem:\n        return None, None\n\n    caps_arr  = np.asarray(caps_rem, dtype=float)\n    dem_arr   = np.asarray(dem, dtype=float)\n    cost_arr  = np.asarray(cost_mat, dtype=float)\n\n    used = np.zeros_like(caps_arr)\n    for f, custs in enumerate(fac_assign):\n        used[f] = np.sum(dem_arr[custs]) if custs else 0.0\n\n    total = used + caps_arr\n    total = np.clip(total, 1e-12, None)\n\n    best_ratio, best_c, best_f = -np.inf, None, None\n    idx = 0\n    top_k = 5\n\n    while idx < len(custs_rem):\n        c = custs_rem[idx]\n        d = float(dem_arr[c])\n        feas = np.where(caps_arr >= d)[0]\n        if feas.size > 0:\n            costs = cost_arr[feas, c]\n            sorted_idx = np.argsort(costs)\n            top_feas = feas[sorted_idx[:top_k]]\n            f = int(np.random.choice(top_feas))\n            ratio = d / (total[f] + 1e-12)\n            ratio += np.random.rand() * 1e-6\n            if ratio > best_ratio:\n                best_ratio, best_c, best_f = ratio, int(c), int(f)\n        idx += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "maximize_demand_per_total_capacity_aug_337": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    fac_assign = assignments\n    custs_rem   = remaining_customers\n    caps_rem    = remaining_capacities\n    dem         = customer_demands\n    cost_mat    = assignment_costs\n\n    if not custs_rem:\n        return None, None\n\n    caps_arr  = np.asarray(caps_rem, dtype=float)\n    dem_arr   = np.asarray(dem, dtype=float)\n    cost_arr  = np.asarray(cost_mat, dtype=float)\n\n    used = np.zeros_like(caps_arr)\n    for f, custs in enumerate(fac_assign):\n        used[f] = np.sum(dem_arr[custs]) if custs else 0.0\n\n    total = np.mean(used) + caps_arr\n    total = np.clip(total, 1e-12, None)\n\n    best_ratio, best_c, best_f = -np.inf, None, None\n    temperature = 0.3\n    top_k = 3\n\n    for c in custs_rem:\n        d = float(dem_arr[c])\n        feas = np.where(caps_arr >= d)[0]\n        if feas.size == 0:\n            continue\n        costs = cost_arr[feas, c]\n        probs = np.exp(-costs / temperature)\n        probs /= np.sum(probs)\n        f = int(feas[np.argmax(probs)])            # soft\u2011min selection\n        ratio = (d / (total[f] + 1e-12)) * (1 - np.mean(costs) / (np.max(costs) + 1e-12))\n        ratio += np.random.rand() * 1e-6\n        if ratio > best_ratio:\n            best_ratio, best_c, best_f = ratio, int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "maximize_demand_per_total_capacity_aug_338": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    fac_assign = assignments\n    custs_rem   = remaining_customers\n    caps_rem    = remaining_capacities\n    dem         = customer_demands\n    cost_mat    = assignment_costs\n\n    if not custs_rem:\n        return None, None\n\n    num_fac = len(fac_assign)\n    num_cust = len(dem)\n\n    assign_mat = np.zeros((num_fac, num_cust), dtype=int)\n    for f, custs in enumerate(fac_assign):\n        assign_mat[f, custs] = 1\n\n    caps_arr  = np.asarray(caps_rem, dtype=float)\n    dem_arr   = np.asarray(dem, dtype=float)\n    cost_arr  = np.asarray(cost_mat, dtype=float)\n\n    used = assign_mat.dot(dem_arr)\n    caps_arr = np.clip(caps_arr, 0, None)\n    total = used + caps_arr\n    total = np.clip(total, 1e-12, None)\n\n    best_ratio, best_c, best_f = -np.inf, None, None\n    top_k = 4\n\n    for c in custs_rem:\n        d = float(dem_arr[c])\n        feas = np.where(caps_arr >= d)[0]\n        if feas.size == 0:\n            continue\n        costs = cost_arr[feas, c]\n        top_idx = np.argsort(costs)[:top_k]\n        f = int(feas[top_idx[np.random.randint(0, len(top_idx))]])\n        ratio = (d / (total[f] + 1e-12)) * (1 - used[f] / (total[f] + 1e-12))\n        ratio += np.random.rand() * 1e-6\n        if ratio > best_ratio:\n            best_ratio, best_c, best_f = ratio, int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "rank_based_sampling_pairs_aug_339": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    # Collect all feasible (cost, customer, facility) tuples\n    pairs = [(float(C[f, c]), int(c), int(f))\n             for c in remaining_customers\n             for f in np.where(caps >= dem[int(c)])[0]]\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    n = len(pairs)\n\n    # Soft\u2011min weighting with a tunable decay factor\n    alpha = 0.5\n    ranks = np.arange(1, n + 1, dtype=float) + 1e-12\n    w = np.exp(-alpha * ranks)\n    w = w / (np.sum(w) + 1e-12)\n\n    # Keep only the top_k most promising pairs\n    top_k = 7\n    if n > top_k:\n        w[top_k:] = 0.0\n    w = w / (np.sum(w) + 1e-12)          # re\u2011normalize after truncation\n    w = np.clip(w, 0, 1)\n\n    idx = int(rng.choice(n, p=w))\n    _, c, f = pairs[idx]\n    return c, f\n\n",
  "rank_based_sampling_pairs_aug_340": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    # Randomized tie\u2011breaking by adding stochastic noise to each cost\n    pairs = [(float(C[f, c]) + 1e-6 * rng.random(), int(c), int(f))\n             for c in remaining_customers\n             for f in np.where(caps >= dem[int(c)])[0]]\n\n    if not pairs:\n        return None, None\n\n    costs = np.array([p[0] for p in pairs], dtype=float)\n    beta = 1.0\n    w = np.exp(-beta * costs)                # soft\u2011min over cost\n    w = w / (np.sum(w) + 1e-12)              # normalize with epsilon\n    w = np.clip(w, 0, 1)\n\n    idx = int(rng.choice(len(pairs), p=w))\n    _, c, f = pairs[idx]\n    return c, f\n\n",
  "rank_based_sampling_pairs_aug_341": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    # Build pairs with an upper limit to control memory usage\n    pairs = []\n    max_pairs = 1000\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            pairs.append((float(C[f, c]), int(c), int(f)))\n            if len(pairs) >= max_pairs:\n                break\n        if len(pairs) >= max_pairs:\n            break\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    n = len(pairs)\n\n    # Rank\u2011based inverse weighting with epsilon\n    ranks = np.arange(1, n + 1, dtype=float) + 1e-12\n    w = 1.0 / ranks\n    w = w / (np.sum(w) + 1e-12)\n    w = np.clip(w, 0, 1)\n\n    idx = int(rng.choice(n, p=w))\n    _, c, f = pairs[idx]\n    return c, f\n\n",
  "facility_best_mean_cost_then_customer_aug_342": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Greedy selection using mean cost with deterministic noise and while-loop control flow.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Convert inputs to numpy arrays for vectorised operations\n    rem = np.asarray(remaining_customers, dtype=int)\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    # Clip capacities to avoid negative or zero values\n    caps = np.clip(caps, 0.0, np.inf)\n\n    # Compute mean cost per facility with an epsilon to avoid division by zero\n    sum_cost = np.sum(cost[:, rem], axis=1)\n    mean_f = sum_cost / (rem.size + 1e-12)\n\n    # Add deterministic noise to break ties in a reproducible way\n    noise = 1e-8 * np.arange(cost.shape[0])\n    order = np.argsort(mean_f + noise)\n\n    # Iterate over facilities using a while loop\n    idx = 0\n    while idx < len(order):\n        f = int(order[idx])\n        # Find customers that can fit in facility f\n        feas = rem[dem[rem] <= caps[f]]\n        if feas.size > 0:\n            # Choose the cheapest feasible customer\n            c = int(feas[np.argmin(cost[f, feas])])\n            return c, f\n        idx += 1\n\n    return None, None\n\n",
  "facility_best_mean_cost_then_customer_aug_343": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Weighted mean scoring with top\u2011k facilities and random choice among top\u2011k cheapest customers.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    # Ensure capacities are never zero to avoid division by zero\n    caps = np.clip(caps, 1e-12, np.inf)\n\n    # Weighted scoring: 60% cost per capacity, 40% raw mean cost\n    cost_per_cap = cost / (caps[:, None] + 1e-12)\n    weighted_score = 0.6 * cost_per_cap.mean(axis=1) + 0.4 * cost.mean(axis=1)\n\n    # Consider only the top\u2011k (k=7) facilities with the lowest score\n    top_k = 7\n    top_facilities = np.argsort(weighted_score)[:top_k]\n\n    for f in top_facilities:\n        feas = rem[dem[rem] <= caps[f]]\n        if feas.size == 0:\n            continue\n\n        # Randomly pick one of the three cheapest feasible customers\n        sorted_idx = np.argsort(cost[f, feas])[:3]\n        chosen = feas[sorted_idx[np.random.randint(0, len(sorted_idx))]]\n        return int(chosen), int(f)\n\n    return None, None\n\n",
  "facility_best_mean_cost_then_customer_aug_344": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Median\u2011based soft\u2011min facility selection with random tie\u2011breaking for customers.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    caps = np.clip(caps, 1e-12, np.inf)\n\n    # Median cost per facility across remaining customers\n    med_f = np.median(cost[:, rem], axis=1)\n\n    # Soft\u2011min weighting with a temperature parameter\n    alpha = 5.0\n    weights = np.exp(-alpha * med_f)\n    probs = weights / (weights.sum() + 1e-12)\n\n    # Sample a facility according to the soft\u2011min probabilities\n    f = int(np.random.choice(len(probs), p=probs))\n\n    feas = rem[dem[rem] <= caps[f]]\n    if feas.size == 0:\n        # Fallback to facility with the largest capacity\n        f = int(np.argmax(caps))\n        feas = rem[dem[rem] <= caps[f]]\n        if feas.size == 0:\n            return None, None\n\n    # Choose the cheapest feasible customer, breaking ties randomly\n    costs_f = cost[f, feas]\n    min_cost = costs_f.min()\n    tied_customers = feas[costs_f == min_cost]\n    c = int(tied_customers[np.random.randint(0, tied_customers.size)])\n    return c, f\n\n",
  "facility_best_mean_cost_then_customer_aug_345": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Sum\u2011based weighted scoring with top\u2011k facilities and random tie\u2011breaking among cheapest customers.\"\"\"\n    if not remaining_customers:\n        return None, None\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    caps = np.clip(caps, 1e-12, np.inf)\n\n    # Sum of costs per facility over remaining customers\n    sum_cost = np.sum(cost[:, rem], axis=1)\n\n    # Weight by capacity (product) to favour larger facilities\n    weighted = sum_cost * caps\n\n    # Consider the top\u2011k (k=5) facilities with the highest weighted score\n    top_k = 5\n    top_facilities = np.argsort(weighted)[-top_k:][::-1]\n\n    for f in top_facilities:\n        feas = rem[dem[rem] <= caps[f]]\n        if feas.size == 0:\n            continue\n\n        # Randomly pick one of the four cheapest feasible customers\n        idxs = np.argsort(cost[f, feas])[:4]\n        chosen = feas[idxs[np.random.randint(0, len(idxs))]]\n        return int(chosen), int(f)\n\n    return None, None\n\n",
  "risk_averse_customer_cvar_aug_346": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    # Convert inputs to numpy arrays for vectorised operations\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    # Parameters\n    alpha = 0.8\n    best_tail = -np.inf\n    best_c = None\n    best_f = None\n\n    # Use a while loop instead of a for loop\n    idx = 0\n    while idx < len(remaining_customers):\n        c = remaining_customers[idx]\n        # Feasible facilities for customer c\n        feas_idx = np.where(caps >= dem[c])[0]\n        if feas_idx.size == 0:\n            idx += 1\n            continue\n\n        # Sorted assignment costs for the feasible facilities\n        sorted_vals = np.sort(cost_mat[feas_idx, c])\n        k = int(np.ceil(alpha * sorted_vals.size))\n        k = np.clip(k, 0, sorted_vals.size)\n        tail = sorted_vals[k:] if k < sorted_vals.size else sorted_vals[-1:]\n        tail_mean = np.sum(tail) / (tail.size + 1e-12)  # epsilon in denominator\n\n        # Cheapest facility among the feasible ones\n        f = feas_idx[np.argmin(cost_mat[feas_idx, c])]\n        if tail_mean > best_tail:\n            best_tail, best_c, best_f = tail_mean, c, f\n\n        idx += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "risk_averse_customer_cvar_aug_347": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    # Tuned parameters\n    alpha = 0.6          # lower tail emphasis\n    best_tail = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas_idx = np.where(caps >= dem[c])[0]\n        if feas_idx.size == 0:\n            continue\n\n        sorted_vals = np.sort(cost_mat[feas_idx, c])\n        k = int(np.ceil(alpha * sorted_vals.size))\n        k = np.clip(k, 0, sorted_vals.size)\n        tail = sorted_vals[k:] if k < sorted_vals.size else sorted_vals[-1:]\n        tail_median = np.median(tail)                # use median instead of mean\n\n        f = feas_idx[np.argmin(cost_mat[feas_idx, c])]\n        if tail_median > best_tail:\n            best_tail, best_c, best_f = tail_median, c, f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "risk_averse_customer_cvar_aug_348": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    alpha = 0.8\n    top_k = 3\n    best_tail = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas_idx = np.where(caps >= dem[c])[0]\n        if feas_idx.size == 0:\n            continue\n\n        sorted_vals = np.sort(cost_mat[feas_idx, c])\n        k = int(np.ceil(alpha * sorted_vals.size))\n        k = np.clip(k, 0, sorted_vals.size)\n        tail = sorted_vals[k:] if k < sorted_vals.size else sorted_vals[-1:]\n        tail_mean = np.sum(tail) / (tail.size + 1e-12)   # epsilon in denominator\n\n        # Random\u2011style selection among the top\u2011k cheapest facilities with deterministic noise\n        costs = cost_mat[feas_idx, c]\n        noise = 1e-6 * (feas_idx + c)                    # deterministic tie\u2011breaker\n        noisy_costs = costs + noise\n        top_idx = np.argpartition(noisy_costs, top_k)[:top_k]\n        chosen_idx = top_idx[np.argmin(noisy_costs[top_idx])]\n        f = feas_idx[chosen_idx]\n\n        if tail_mean > best_tail:\n            best_tail, best_c, best_f = tail_mean, c, f\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "risk_averse_customer_cvar_aug_349": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost_mat = np.asarray(assignment_costs, dtype=float)\n\n    alpha = 0.7\n    best_tail = -np.inf\n    best_c = None\n    best_f = None\n\n    i = 0\n    while i < len(remaining_customers):\n        c = remaining_customers[i]\n        feas_idx = np.where(caps >= dem[c])[0]\n        if feas_idx.size == 0:\n            i += 1\n            continue\n\n        sorted_vals = np.sort(cost_mat[feas_idx, c])\n        k = int(np.ceil(alpha * sorted_vals.size))\n        k = np.clip(k, 0, sorted_vals.size)\n        tail = sorted_vals[k:] if k < sorted_vals.size else sorted_vals[-1:]\n        tail_max = np.max(tail)                           # use worst\u2011case tail\n\n        # Deterministic noise for facility choice\n        costs = cost_mat[feas_idx, c]\n        noise = 1e-7 * (feas_idx + c)\n        noisy_costs = costs + noise\n        f = feas_idx[np.argmin(noisy_costs)]\n\n        if tail_max > best_tail:\n            best_tail, best_c, best_f = tail_max, c, f\n\n        i += 1\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "maximize_min_slack_after_pair_aug_350": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demand_arr = np.asarray(customer_demands, dtype=float)\n    cost_matrix = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    best_cost = np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        d = float(demand_arr[int(c)])\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n\n        # Vectorized capacity update for all feasible facilities\n        caps_tmp = caps.copy()\n        caps_tmp[feasible] -= d\n        caps_tmp = np.clip(caps_tmp, 0.0, np.inf)\n        min_after = float(np.min(caps_tmp))\n\n        cost_vals = cost_matrix[feasible, int(c)]\n        for f_idx, f in enumerate(feasible):\n            cost = float(cost_vals[f_idx])\n            # Higher min_after is better; lower cost is better\n            if min_after > best_score or (abs(min_after - best_score) < 1e-12 and cost < best_cost):\n                best_score = min_after\n                best_cost = cost\n                best_c = int(c)\n                best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "maximize_min_slack_after_pair_aug_351": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demand_arr = np.asarray(customer_demands, dtype=float)\n    cost_matrix = np.asarray(assignment_costs, dtype=float)\n\n    score_list = []\n    pair_list = []\n\n    for c in remaining_customers:\n        d = float(demand_arr[int(c)])\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n\n        caps_tmp = caps.copy()\n        caps_tmp[feasible] -= d\n        caps_tmp = np.clip(caps_tmp, 0.0, np.inf)\n        min_after = float(np.min(caps_tmp))\n\n        for f in feasible:\n            cost = float(cost_matrix[int(f), int(c)])\n            # Weighted score: higher remaining capacity, lower cost\n            score = min_after - 0.4 * cost\n            # Deterministic noise for tie\u2011breaking\n            noise = 1e-9 * (int(c) * 31 + int(f) * 17)\n            score += noise\n            score_list.append(score)\n            pair_list.append((int(c), int(f)))\n\n    if not score_list:\n        return None, None\n\n    top_k = 5\n    top_indices = np.argpartition(-np.array(score_list), top_k - 1)[:top_k]\n    chosen_idx = np.random.choice(top_indices)\n    chosen_c, chosen_f = pair_list[chosen_idx]\n    return (chosen_c, chosen_f)\n\n",
  "maximize_min_slack_after_pair_aug_352": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demand_arr = np.asarray(customer_demands, dtype=float)\n    cost_matrix = np.asarray(assignment_costs, dtype=float)\n\n    scores = []\n    pairs = []\n\n    for c in remaining_customers:\n        d = float(demand_arr[int(c)])\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n\n        caps_tmp = caps.copy()\n        caps_tmp[feasible] -= d\n        caps_tmp = np.clip(caps_tmp, 0.0, np.inf)\n        min_after = float(np.min(caps_tmp))\n\n        for f in feasible:\n            cost = float(cost_matrix[int(f), int(c)])\n            # Use median of remaining capacity and negative cost for robustness\n            score = np.median([min_after, -cost])\n            scores.append(score)\n            pairs.append((int(c), int(f)))\n\n    if not scores:\n        return None, None\n\n    scores_arr = np.array(scores, dtype=float)\n    temp = 0.5\n    exp_scores = np.exp(temp * scores_arr)\n    prob = exp_scores / (np.sum(exp_scores) + 1e-12)  # epsilon in denominator\n    chosen_idx = np.random.choice(len(scores_arr), p=prob)\n    return pairs[chosen_idx]\n\n",
  "maximize_min_slack_after_pair_aug_353": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    demand_arr = np.asarray(customer_demands, dtype=float)\n    cost_matrix = np.asarray(assignment_costs, dtype=float)\n\n    best_val = -np.inf\n    best_cost = np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        d = float(demand_arr[int(c)])\n        feasible = np.where(caps >= d)[0]\n        if feasible.size == 0:\n            continue\n\n        for f in feasible:\n            caps_tmp = caps.copy()\n            caps_tmp[int(f)] -= d\n            caps_tmp = np.clip(caps_tmp, 0.0, np.inf)\n\n            # Sum of remaining capacities as primary score\n            score = np.sum(caps_tmp) * 0.6\n            cost = float(cost_matrix[int(f), int(c)]) * 0.4\n            val = score - cost\n\n            # Deterministic tie\u2011breaking noise\n            noise = 1e-8 * (int(c) + int(f))\n            val += noise\n\n            if val > best_val or (abs(val - best_val) < 1e-12 and cost < best_cost):\n                best_val = val\n                best_cost = cost\n                best_c = int(c)\n                best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n\n",
  "probabilistic_customer_then_pair_bestofm_aug_354": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    M = 6\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.clip(np.asarray(assignment_costs, dtype=float), 0, 1e9)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    if rem.size == 0:\n        return None, None\n\n    sample = rng.choice(rem, size=M, replace=True)\n\n    best_cost = np.inf\n    best_cust = None\n    best_fac = None\n    idx = 0\n    while idx < M:\n        c = int(sample[idx])\n        feas_idx = np.where(caps >= dem[c])[0]\n        if feas_idx.size > 0:\n            # small deterministic noise to break ties\n            noise = np.arange(feas_idx.size) * 1e-6\n            costs_with_noise = cost[feas_idx, c] + noise\n            f = int(feas_idx[np.argmin(costs_with_noise)])\n            val = float(cost[f, c])\n            if val < best_cost:\n                best_cost = val\n                best_cust = c\n                best_fac = f\n        idx += 1\n\n    if best_cust is not None:\n        return best_cust, best_fac\n\n    # deterministic fallback: cheapest feasible pair\n    for c in remaining_customers:\n        feas_idx = np.where(caps >= dem[c])[0]\n        if feas_idx.size:\n            f = int(feas_idx[np.argmin(cost[feas_idx, c])])\n            return int(c), int(f)\n\n    return None, None\n\n",
  "probabilistic_customer_then_pair_bestofm_aug_355": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    M = 6\n    temperature = 0.5\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    if rem.size == 0:\n        return None, None\n\n    sample = rng.choice(rem, size=M, replace=True)\n\n    # feasibility mask and cost masking\n    feas_mask = caps[:, None] >= dem[None, :]\n    large = 1e12\n    cost_masked = np.where(feas_mask, cost, large)\n\n    # softmin probabilities\n    exp_neg = np.exp(-cost_masked / (temperature + 1e-12))\n    probs = exp_neg / (np.sum(exp_neg, axis=0, keepdims=True) + 1e-12)\n    probs = np.clip(probs, 0, 1)\n\n    best_cust = None\n    best_fac = None\n    best_val = np.inf\n    for c in sample:\n        fac_idx = np.argmax(probs[:, c])\n        val = float(cost[fac_idx, c])\n        if val < best_val:\n            best_val = val\n            best_cust = int(c)\n            best_fac = int(fac_idx)\n\n    if best_cust is not None:\n        return best_cust, best_fac\n\n    # deterministic fallback\n    min_idx = np.unravel_index(np.argmin(cost_masked, axis=None), cost_masked.shape)\n    return int(min_idx[1]), int(min_idx[0])\n\n",
  "probabilistic_customer_then_pair_bestofm_aug_356": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    M = 6\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    if rem.size == 0:\n        return None, None\n\n    sample = rng.choice(rem, size=M, replace=True)\n\n    best_cust = None\n    best_fac = None\n    best_score = np.inf\n    for c in sample:\n        feas_idx = np.where(caps >= dem[c])[0]\n        if feas_idx.size == 0:\n            continue\n        # mean cost of each feasible facility over all customers\n        mean_costs = np.mean(cost[feas_idx, :], axis=1)\n        noise = np.arange(feas_idx.size) * 1e-6\n        scores = mean_costs + noise\n        f = int(feas_idx[np.argmin(scores)])\n        val = float(cost[f, c])\n        if val < best_score:\n            best_score = val\n            best_cust = int(c)\n            best_fac = int(f)\n\n    if best_cust is not None:\n        return best_cust, best_fac\n\n    # deterministic fallback\n    feas_mask = caps[:, None] >= dem[None, :]\n    large = 1e12\n    cost_masked = np.where(feas_mask, cost, large)\n    min_idx = np.unravel_index(np.argmin(cost_masked, axis=None), cost_masked.shape)\n    return int(min_idx[1]), int(min_idx[0])\n\n",
  "probabilistic_customer_then_pair_bestofm_aug_357": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    M = 8\n    top_k = 3\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    cost = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    if rem.size == 0:\n        return None, None\n\n    sample = rng.choice(rem, size=min(M, rem.size), replace=False)\n\n    best_cust = None\n    best_fac = None\n    best_val = np.inf\n    for c in sample:\n        feas_idx = np.where(caps >= dem[c])[0]\n        if feas_idx.size == 0:\n            continue\n        idx_sorted = np.argsort(cost[feas_idx, c])[:top_k]\n        top_facs = feas_idx[idx_sorted]\n        f = int(rng.choice(top_facs))\n        val = float(cost[f, c])\n        if val < best_val:\n            best_val = val\n            best_cust = int(c)\n            best_fac = f\n\n    if best_cust is not None:\n        return best_cust, best_fac\n\n    # deterministic fallback\n    feas_mask = caps[:, None] >= dem[None, :]\n    large = 1e12\n    cost_masked = np.where(feas_mask, cost, large)\n    min_idx = np.unravel_index(np.argmin(cost_masked, axis=None), cost_masked.shape)\n    return int(min_idx[1]), int(min_idx[0])\n\n",
  "capacity_fragmentation_penalty_aug_358": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Vectorized selection of the next customer\u2013facility assignment.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    # Convert inputs to numpy arrays\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    demands = np.asarray(customer_demands, dtype=np.float64)\n    costs = np.asarray(assignment_costs, dtype=np.float64)\n\n    # Indices of remaining customers\n    cust_idx = np.asarray(remaining_customers, dtype=int)\n\n    # Scale based on the median demand of the remaining customers\n    scale = np.median(demands[cust_idx])\n    scale = max(scale, 1e-9)  # epsilon to avoid division by zero\n\n    # Remaining capacity after assigning each remaining customer to each facility\n    rem_cap = caps[:, None] - demands[cust_idx]\n\n    # Feasibility mask\n    feasible = rem_cap >= 0\n\n    # Fragment factor and scoring\n    frag = np.exp(-rem_cap / scale)\n    frag = np.where(feasible, frag, np.inf)  # infeasible assignments get infinite score\n\n    lam = 2.5\n    score = costs[:, cust_idx] + lam * frag\n\n    # Tiny deterministic noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=score.shape)\n    score += noise\n\n    # Find the minimal score\n    min_pos = np.argmin(score)\n    fac, cust_pos = np.unravel_index(min_pos, score.shape)\n\n    if not feasible[fac, cust_pos]:\n        return None, None\n\n    return int(cust_idx[cust_pos]), int(fac)\n\n",
  "capacity_fragmentation_penalty_aug_359": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Greedy assignment using a while loop and list comprehensions.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    demands = np.asarray(customer_demands, dtype=np.float64)\n    costs = np.asarray(assignment_costs, dtype=np.float64)\n\n    cust_idx = np.asarray(remaining_customers, dtype=int)\n\n    # Scale from mean demand, clipped to avoid zero\n    scale = np.mean(demands[cust_idx])\n    scale = max(scale, 1e-9)\n\n    lam = 4.0\n    best_score = np.inf\n    best_cust = None\n    best_fac = None\n\n    # Use while loop over customers\n    rem_list = list(cust_idx)\n    while rem_list:\n        c = rem_list.pop()\n        d = demands[c]\n        # Find facilities that can accommodate this customer\n        feasible_facs = [f for f, cap in enumerate(caps) if cap >= d]\n        for f in feasible_facs:\n            rem_after = caps[f] - d\n            frag = np.exp(-rem_after / scale)\n            score = costs[f, c] + lam * np.sqrt(frag)  # use sqrt of fragment factor\n            # Add tiny deterministic noise for tie breaking\n            score += 1e-7 * (f + c)\n            if score < best_score:\n                best_score = score\n                best_cust = c\n                best_fac = f\n\n    if best_cust is None:\n        return None, None\n\n    return int(best_cust), int(best_fac)\n\n",
  "capacity_fragmentation_penalty_aug_360": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Softmin selection with random choice among top\u2011k candidates.\n    \"\"\"\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=np.float64)\n    demands = np.asarray(customer_demands, dtype=np.float64)\n    costs = np.asarray(assignment_costs, dtype=np.float64)\n\n    cust_idx = np.asarray(remaining_customers, dtype=int)\n\n    # Scale based on mean demand of remaining customers\n    scale = np.mean(demands[cust_idx])\n    scale = max(scale, 1e-9)\n\n    lam = 2.8\n    rem_cap = caps[:, None] - demands[cust_idx]\n    feasible = rem_cap >= 0\n\n    frag = np.exp(-rem_cap / scale)\n    # Penalise infeasible assignments by setting score very high\n    score = costs[:, cust_idx] + lam * frag\n    score = np.where(feasible, score, np.inf)\n\n    # Softmin probabilities\n    temperature = 1.0\n    logits = -score / temperature\n    # Numerical stability\n    logits -= np.max(logits)\n    exp_logits = np.exp(logits)\n    probs = exp_logits / (np.sum(exp_logits) + 1e-12)\n\n    # Choose a random assignment among the top\u2011k highest probabilities\n    top_k = 5\n    top_k_idx = np.argpartition(probs.ravel(), -top_k)[-top_k:]\n    chosen_flat = np.random.choice(top_k_idx)\n    fac, cust_pos = np.unravel_index(chosen_flat, probs.shape)\n\n    if not feasible[fac, cust_pos]:\n        return None, None\n\n    return int(cust_idx[cust_pos]), int(fac)\n\n",
  "customer_near_capacity_90pct_risk_aug_361": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps_arr = np.asarray(remaining_capacities, dtype=np.float64)\n    dem_arr = np.asarray(customer_demands, dtype=np.float64)\n    cost_arr = np.asarray(assignment_costs, dtype=np.float64)\n\n    # 90th\u2011percentile capacity reference, clipped to be non\u2011negative\n    cap90 = np.clip(np.quantile(caps_arr, 0.9) if caps_arr.size else 0.0,\n                    a_min=0.0,\n                    a_max=np.inf)\n\n    best_key = (np.inf, np.inf, None, None)  # (distance, cost, customer, facility)\n\n    for c in remaining_customers:\n        feas = np.where(caps_arr >= dem_arr[c])[0]\n        if feas.size == 0:\n            continue\n        dist = abs(dem_arr[c] - cap90)\n        f = feas[np.argmin(cost_arr[feas, c])]\n        cost = float(cost_arr[f, c])\n        key = (dist, cost, int(c), int(f))\n        if key[:2] < best_key[:2]:\n            best_key = key\n\n    return (best_key[2], best_key[3]) if best_key[2] is not None else (None, None)\n\n",
  "customer_near_capacity_90pct_risk_aug_362": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps_arr = np.asarray(remaining_capacities, dtype=np.float64)\n    dem_arr = np.asarray(customer_demands, dtype=np.float64)\n    cost_arr = np.asarray(assignment_costs, dtype=np.float64)\n\n    cap90 = np.clip(np.quantile(caps_arr, 0.9) if caps_arr.size else 0.0,\n                    a_min=0.0,\n                    a_max=np.inf)\n\n    best_score = np.inf\n    best_choice = (None, None)\n    top_k = 7\n\n    for c in remaining_customers:\n        feas = np.where(caps_arr >= dem_arr[c])[0]\n        if feas.size == 0:\n            continue\n\n        sorted_idx = np.argsort(cost_arr[feas, c])\n        top_idx = feas[sorted_idx[:min(top_k, feas.size)]]\n\n        dist = abs(dem_arr[c] - cap90)\n        costs_top = cost_arr[top_idx, c]\n        scores = 0.6 * dist + 0.4 * costs_top\n        noise = 1e-6 * (c + top_idx)\n        scores += noise\n        min_idx = np.argmin(scores)\n        f = int(top_idx[min_idx])\n        score = float(scores[min_idx])\n        if score < best_score:\n            best_score = score\n            best_choice = (int(c), f)\n\n    return best_choice\n\n",
  "customer_near_capacity_90pct_risk_aug_363": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps_arr = np.asarray(remaining_capacities, dtype=np.float64)\n    dem_arr = np.asarray(customer_demands, dtype=np.float64)\n    cost_arr = np.asarray(assignment_costs, dtype=np.float64)\n\n    cap90 = np.clip(np.quantile(caps_arr, 0.9) if caps_arr.size else 0.0,\n                    a_min=0.0,\n                    a_max=np.inf)\n\n    beta = 10.0\n    top_k = 5\n    best_choice = (None, None)\n    best_score = np.inf\n\n    for c in remaining_customers:\n        feas = np.where(caps_arr >= dem_arr[c])[0]\n        if feas.size == 0:\n            continue\n\n        sorted_idx = np.argsort(cost_arr[feas, c])\n        top_idx = feas[sorted_idx[:min(top_k, feas.size)]]\n        costs_top = cost_arr[top_idx, c]\n\n        logits = -beta * costs_top\n        max_logit = np.max(logits)\n        exp_vals = np.exp(logits - max_logit)\n        probs = exp_vals / (np.sum(exp_vals) + 1e-12)\n\n        noise = 1e-6 * (c + top_idx)\n        probs += noise\n        probs /= np.sum(probs) + 1e-12\n\n        chosen_idx = top_idx[np.argmax(probs)]\n        dist = abs(dem_arr[c] - cap90)\n        score = 0.6 * dist + 0.4 * float(cost_arr[chosen_idx, c])\n\n        if score < best_score:\n            best_score = score\n            best_choice = (int(c), int(chosen_idx))\n\n    return best_choice\n\n",
  "customer_near_capacity_90pct_risk_aug_364": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps_arr = np.asarray(remaining_capacities, dtype=np.float64)\n    dem_arr = np.asarray(customer_demands, dtype=np.float64)\n    cost_arr = np.asarray(assignment_costs, dtype=np.float64)\n\n    cap90 = np.clip(np.quantile(caps_arr, 0.9) if caps_arr.size else 0.0,\n                    a_min=0.0,\n                    a_max=np.inf)\n\n    best_choice = (None, None)\n    best_score = np.inf\n\n    for c in remaining_customers:\n        feas = np.where(caps_arr >= dem_arr[c])[0]\n        if feas.size == 0:\n            continue\n\n        slack = caps_arr[feas] - dem_arr[c]\n        slack = np.clip(slack, a_min=0.0, a_max=np.inf)\n\n        max_slack = np.max(slack)\n        mask = slack >= max_slack - 1e-6\n        candidate_idx = feas[mask]\n\n        costs_candidates = cost_arr[candidate_idx, c]\n        f = candidate_idx[np.argmin(costs_candidates)]\n        dist = abs(dem_arr[c] - cap90)\n        score = 0.6 * dist + 0.4 * float(cost_arr[f, c])\n\n        if score < best_score:\n            best_score = score\n            best_choice = (int(c), int(f))\n\n    return best_choice\n\n"
}