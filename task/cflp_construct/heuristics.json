{
  "greedy_lowest_cost_first_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(costs[feas, c])])\n        return int(c), f\n\n    return None, None\n",
  "global_best_pair_min_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        j = int(feas[np.argmin(costs[feas, c])])\n        val = float(costs[j, c])\n        if val < best[0]:\n            best = (val, int(c), int(j))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "min_regret_2_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_regret = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            regret = 1e12\n            f = int(feas[0])\n        else:\n            order = np.argsort(c_costs)\n            regret = float(c_costs[order[1]] - c_costs[order[0]])\n            f = int(feas[order[0]])\n        if regret > best_regret:\n            best_regret = regret\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "max_savings_vs_second_best": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    pick_c = None\n    pick_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            savings = 1e12\n            f = int(feas[0])\n        else:\n            order = np.argsort(c_costs)\n            savings = float(c_costs[order[1]] - c_costs[order[0]])\n            f = int(feas[order[0]])\n        if savings > best_score:\n            best_score = savings\n            pick_c = int(c)\n            pick_f = int(f)\n\n    return (pick_c, pick_f) if pick_c is not None else (None, None)\n",
  "most_constrained_customer_fewest_facilities": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_key = None\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        k = int(feas.size)\n        if k == 0:\n            continue\n        j = int(feas[np.argmin(costs[feas, c])])\n        key = (k, float(costs[j, c]))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(j)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "largest_demand_then_cheapest": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    order = sorted(remaining_customers, key=lambda c: (-dem[c], c))\n    for c in order:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(costs[feas, c])])\n        return int(c), f\n\n    return None, None\n",
  "smallest_demand_greedy_fill": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    order = sorted(remaining_customers, key=lambda c: (dem[c], c))\n    for c in order:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(costs[feas, c])])\n        return int(c), f\n\n    return None, None\n",
  "min_cost_per_demand": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-9\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        j = int(feas[np.argmin(costs[feas, c])])\n        score = float(costs[j, c]) / (d + eps)\n        if score < best[0]:\n            best = (score, int(c), int(j))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "tightest_fit_then_min_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (slack, cost, c, f)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slacks = caps[feas] - d\n        min_slack = float(np.min(slacks))\n        cand_fs = feas[np.where(slacks == min_slack)[0]]\n        j = int(cand_fs[np.argmin(costs[cand_fs, c])])\n        key = (min_slack, float(costs[j, c]), int(c), int(j))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "slack_weighted_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    lam = 10.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        score = costs[feas, c] + lam / (slack + 1.0)\n        idx = int(np.argmin(score))\n        j = int(feas[idx])\n        val = float(score[idx])\n        if val < best[0]:\n            best = (val, int(c), int(j))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "load_balance_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    alpha = 5.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    used = np.zeros_like(caps)\n    for f, custs in enumerate(assignments):\n        s = 0.0\n        for c in custs:\n            s += float(dem[c])\n        used[f] = s\n    total_cap = used + caps\n    total_cap = np.maximum(total_cap, 1e-9)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        util_after = (used[feas] + d) / total_cap[feas]\n        score = costs[feas, c] + alpha * util_after\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_fill_first_then_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    used = np.zeros_like(caps)\n    for f, custs in enumerate(assignments):\n        used[f] = sum(float(dem[c]) for c in custs)\n    total_cap = np.maximum(used + caps, 1e-9)\n    rem_frac = caps / total_cap\n\n    best = (np.inf, np.inf, None, None)  # (rem_frac_after, cost, c, f)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        rem_after = (caps[feas] - d) / total_cap[feas]\n        k = int(np.argmin(rem_after))\n        f = int(feas[k])\n        key = (float(rem_after[k]), float(costs[f, c]), int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "k_best_pairs_random_pick": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    K = 10\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            pairs.append((float(costs[f, c]), int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    top = pairs[: min(K, len(pairs))]\n    pick = top[int(rng.integers(0, len(top)))]\n    return pick[1], pick[2]\n",
  "epsilon_greedy_global_pair": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    epsilon = 0.15\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    feasible_pairs = []\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            val = float(costs[f, c])\n            feasible_pairs.append((int(c), int(f)))\n            if val < best[0]:\n                best = (val, int(c), int(f))\n\n    if not feasible_pairs:\n        return None, None\n\n    if float(rng.random()) < epsilon:\n        c, f = feasible_pairs[int(rng.integers(0, len(feasible_pairs)))]\n        return int(c), int(f)\n\n    return best[1], best[2]\n",
  "softmax_sampling_over_pairs": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    tau = 20.0  # temperature; higher -> flatter\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    pair_c = []\n    pair_f = []\n    pair_cost = []\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            pair_c.append(int(c))\n            pair_f.append(int(f))\n            pair_cost.append(float(costs[f, c]))\n\n    if not pair_cost:\n        return None, None\n\n    x = np.asarray(pair_cost, dtype=float)\n    m = float(np.min(x))\n    w = np.exp(-(x - m) / max(1e-9, tau))\n    w = w / np.sum(w)\n    idx = int(rng.choice(len(w), p=w))\n    return pair_c[idx], pair_f[idx]\n",
  "progressive_explore_then_exploit": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    n_rem = len(remaining_customers)\n    n_fac = len(remaining_capacities)\n    progress = 1.0 - (n_rem / max(1, n_rem + sum(len(a) for a in assignments)))\n\n    K = int(np.clip(np.ceil((1.0 - progress) * 20), 3, 20))\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        for f in feas:\n            pairs.append((float(costs[f, c]), int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    if n_rem <= max(2, n_fac // 2):\n        _, c, f = pairs[0]\n        return c, f\n\n    top = pairs[: min(K, len(pairs))]\n    _, c, f = top[int(rng.integers(0, len(top)))]\n    return c, f\n",
  "lookahead_scarcity_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    beta = 2.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem_dem = np.asarray([float(dem[c]) for c in remaining_customers], dtype=float)\n    if rem_dem.size == 0:\n        return None, None\n\n    # scarcity of facility f: fraction of remaining customers it could still serve\n    feas_frac = []\n    for f in range(len(caps)):\n        feas_frac.append(float(np.mean(caps[f] >= rem_dem)))\n    feas_frac = np.asarray(feas_frac, dtype=float)\n    scarcity = 1.0 - feas_frac  # higher = more scarce\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        # If facility is scarce, consuming capacity is riskier\n        slack = caps[feas] - d\n        risk = scarcity[feas] * (d / np.maximum(1.0, slack + 1.0))\n        score = costs[feas, c] + beta * risk\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_first_pick_best_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # Choose facility with most remaining capacity to reduce risk of fragmentation.\n    f_order = np.argsort(-caps)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    for f in f_order:\n        feas_c_mask = dem[rem] <= caps[f]\n        if not np.any(feas_c_mask):\n            continue\n        feas_customers = rem[np.where(feas_c_mask)[0]]\n        j = int(feas_customers[np.argmin(costs[int(f), feas_customers])])\n        return int(j), int(f)\n\n    return None, None\n",
  "facility_most_constrained_then_best_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    feas_counts = []\n    for f in range(len(caps)):\n        feas_counts.append(int(np.sum(dem[rem] <= caps[f])))\n    feas_counts = np.asarray(feas_counts, dtype=int)\n\n    # Most constrained = smallest positive count\n    cand_fs = np.where(feas_counts > 0)[0]\n    if cand_fs.size == 0:\n        return None, None\n    f = int(cand_fs[np.argmin(feas_counts[cand_fs])])\n\n    feas_customers = rem[np.where(dem[rem] <= caps[f])[0]]\n    c = int(feas_customers[np.argmin(costs[f, feas_customers])])\n    return c, f\n",
  "two_step_lookahead_best_remaining_min": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = list(remaining_customers)\n\n    best = (np.inf, None, None)\n\n    for c in rem:\n        d = float(dem[c])\n        feas_fs = np.where(caps0 >= d)[0]\n        if feas_fs.size == 0:\n            continue\n        for f in feas_fs:\n            caps = caps0.copy()\n            caps[f] -= d\n            base = float(costs[f, c])\n\n            # find best next assignment cost (no penalties) among remaining\\{c}\n            best2 = np.inf\n            for c2 in rem:\n                if c2 == c:\n                    continue\n                d2 = float(dem[c2])\n                feas2 = np.where(caps >= d2)[0]\n                if feas2.size == 0:\n                    continue\n                best2 = min(best2, float(np.min(costs[feas2, c2])))\n            if not np.isfinite(best2):\n                best2 = 0.0\n\n            score = base + 0.5 * best2\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "cheapest_with_capacity_reserve_for_large": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    gamma = 8.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_full = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    rem_dem = dem_full[rem]\n    if rem_dem.size == 0:\n        return None, None\n\n    q = float(np.quantile(rem_dem, 0.75))\n    big = rem_dem[rem_dem >= q]\n    big = big if big.size > 0 else rem_dem\n\n    best = (np.inf, None, None)\n    for c in rem:\n        d = float(dem_full[c])\n        feas_fs = np.where(caps >= d)[0]\n        if feas_fs.size == 0:\n            continue\n        for f in feas_fs:\n            cap_after = caps[f] - d\n            # how many big demands would still fit in this facility after assignment\n            able_after = float(np.mean(cap_after >= big))\n            penalty = gamma * (1.0 - able_after)\n            score = float(costs[f, c]) + penalty\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "demand_weighted_regret": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_score = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        if c_costs.size == 1:\n            regret = 1e12\n            f = int(feas[0])\n        else:\n            order = np.argsort(c_costs)\n            regret = float(c_costs[order[1]] - c_costs[order[0]])\n            f = int(feas[order[0]])\n        score = regret * float(dem[c])\n        if score > best_score:\n            best_score = score\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "median_cost_customer_priority": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (median_cost, best_cost, c, f)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        med = float(np.median(c_costs))\n        f = int(feas[np.argmin(c_costs)])\n        key = (med, float(costs[f, c]), int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "min_average_cost_facility_bias": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    eta = 0.3\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    mean_fac = np.mean(costs[:, rem], axis=1) if rem.size > 0 else np.mean(costs, axis=1)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        score = costs[feas, c] + eta * mean_fac[feas]\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "max_compatibility_margin": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    max_cap = float(np.max(caps)) if caps.size > 0 else 0.0\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (-np.inf, np.inf, None, None)  # (ratio, cost, c, f)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0 or max_cap <= 0:\n            continue\n        ratio = float(dem[c] / max_cap)\n        f = int(feas[np.argmin(costs[feas, c])])\n        key = (ratio, float(costs[f, c]), int(c), int(f))\n        if key[0] > best[0] or (key[0] == best[0] and key[1] < best[1]):\n            best = (key[0], key[1], key[2], key[3])\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "min_cost_plus_quadratic_demand": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    alpha = 0.05\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        d2 = float(dem[c] ** 2)\n        score = costs[feas, c] + alpha * d2\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "min_cost_plus_demand_over_slack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    alpha = 6.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        score = costs[feas, c] + alpha * (d / (slack + 1.0))\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_popularity_then_assign": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    pop = np.zeros(len(caps), dtype=float)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        c_costs = costs[feas, c]\n        k = min(2, int(feas.size))\n        topk = feas[np.argsort(c_costs)[:k]]\n        pop[topk] += 1.0\n\n    cand_fs = np.where(pop > 0)[0]\n    if cand_fs.size == 0:\n        return None, None\n\n    f = int(cand_fs[np.argmax(pop[cand_fs])])\n\n    # Assign the cheapest feasible customer to this popular facility\n    rem = np.asarray(remaining_customers, dtype=int)\n    feas_customers = rem[np.where(dem[rem] <= caps[f])[0]]\n    if feas_customers.size == 0:\n        return None, None\n    c = int(feas_customers[np.argmin(costs[f, feas_customers])])\n    return c, f\n",
  "customer_priority_by_gap_to_capacity": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (gap, cost, c, f)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        # pick the tightest facility that still fits\n        gaps = caps[feas] - d\n        t = int(feas[np.argmin(gaps)])\n        gap = float(np.min(gaps))\n        # assign to cheapest feasible (not necessarily tightest) but use gap for priority\n        f = int(feas[np.argmin(costs[feas, c])])\n        key = (gap, float(costs[f, c]), int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "cheapest_customer_per_facility_round_robin": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    # choose facility with currently smallest number of assigned customers (fairness)\n    loads = np.asarray([len(a) for a in assignments], dtype=int)\n    f_order = np.argsort(loads)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    for f in f_order:\n        feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n        if feas_c.size == 0:\n            continue\n        c = int(feas_c[np.argmin(costs[int(f), feas_c])])\n        return c, int(f)\n\n    return None, None\n",
  "cheapest_pair_with_tie_break_by_remaining_capacity": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, -np.inf, None, None)  # (cost, rem_after, c, f) where rem_after higher is better\n\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            cost = float(costs[f, c])\n            rem_after = float(caps[f] - d)\n            key = (cost, rem_after)\n            if (cost < best[0]) or (cost == best[0] and rem_after > best[1]):\n                best = (cost, rem_after, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "adaptive_alpha_cost_plus_slack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    n_assigned = sum(len(a) for a in assignments)\n    n_rem = len(remaining_customers)\n    progress = n_assigned / max(1, n_assigned + n_rem)\n    alpha = 1.0 + 12.0 * progress\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slack = caps[feas] - d\n        score = costs[feas, c] + alpha * (1.0 / (slack + 1.0))\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "randomized_customer_order_cheapest": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    perm = list(remaining_customers)\n    rng.shuffle(perm)\n\n    for c in perm:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(costs[feas, c])])\n        return int(c), f\n\n    return None, None\n",
  "customer_best_cost_then_high_demand_tiebreak": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, -np.inf, None, None)  # (best_cost, demand, c, f) where higher demand wins tie\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        k = int(np.argmin(costs[feas, c]))\n        f = int(feas[k])\n        bc = float(costs[f, c])\n        key = (bc, float(dem[c]))\n        if (bc < best[0]) or (bc == best[0] and key[1] > best[1]):\n            best = (bc, key[1], int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "greedy_with_facility_risk_of_starvation": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    delta = 1.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # identify, for each customer, its best feasible facility\n    best_fac = {}\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        best_fac[int(c)] = int(feas[np.argmin(costs[feas, c])])\n\n    # count how many customers \"belong\" to each facility as their best\n    belong = np.zeros(len(caps), dtype=float)\n    for c, f in best_fac.items():\n        belong[f] += 1.0\n\n    # facility fragility: small capacity + many dependents\n    frag = (belong + 1.0) / (caps + 1.0)\n\n    best = (np.inf, None, None)\n    for c in rem:\n        d = float(dem[c])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        # score each feasible facility: cost + delta*fragility(f)\n        score = costs[feas, int(c)] + delta * frag[feas]\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "max_avg_cost_customer_then_best_facility": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    costs = np.asarray(assignment_costs, dtype=float)\n\n    best_key = None\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        mean_cost = float(np.mean(costs[feas, c]))\n        f = int(feas[np.argmin(costs[feas, c])])\n        key = (-mean_cost, float(costs[f, c]))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "thresholded_options_count_priority": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    # Threshold = 30th percentile over all currently feasible pairs (fallback to global percentile)\n    feas_vals = []\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size:\n            feas_vals.extend(C[feas, c].tolist())\n    if len(feas_vals) == 0:\n        return None, None\n    thr = float(np.quantile(np.asarray(feas_vals, dtype=float), 0.30))\n\n    best_key = None\n    best_c = None\n    best_f = None\n\n    for c in rem:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size == 0:\n            continue\n        good = int(np.sum(C[feas, c] <= thr))\n        f = int(feas[np.argmin(C[feas, c])])\n        key = (good, float(C[f, c]))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "minimize_variance_of_remaining_capacities": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (var_after, cost, c, f)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            var_after = float(np.var(caps))\n            cost = float(C[int(f), int(c)])\n            key = (var_after, cost)\n            if key < best[:2]:\n                best = (var_after, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "gini_balance_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef _gini(x: np.ndarray) -> float:\n    x = np.asarray(x, dtype=float)\n    x = np.clip(x, 0.0, None)\n    if x.size == 0:\n        return 0.0\n    s = float(np.sum(x))\n    if s <= 1e-12:\n        return 0.0\n    xs = np.sort(x)\n    n = xs.size\n    idx = np.arange(1, n + 1, dtype=float)\n    return float((2.0 * np.sum(idx * xs) / (n * s)) - (n + 1.0) / n)\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    lam = 10.0\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            score = float(C[int(f), int(c)]) + lam * _gini(caps)\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "entropy_utilization_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef _entropy(p: np.ndarray) -> float:\n    p = np.asarray(p, dtype=float)\n    p = np.clip(p, 1e-12, None)\n    p = p / float(np.sum(p))\n    return float(-np.sum(p * np.log(p)))\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    beta = 3.0\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            ent = _entropy(caps + 1e-9)\n            score = float(C[int(f), int(c)]) - beta * ent\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "zscore_facility_preference": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # Facility stats over remaining customers\n    mu = np.mean(C[:, rem], axis=1)\n    sd = np.std(C[:, rem], axis=1)\n    sd = np.maximum(sd, 1e-9)\n\n    best = (np.inf, None, None)\n    for c in rem:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        z = (C[feas, int(c)] - mu[feas]) / sd[feas]\n        k = int(np.argmin(z))\n        f = int(feas[k])\n        val = float(z[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "rank_sum_cost_and_slack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            slack = float(caps0[int(f)] - d)\n            pairs.append((float(C[int(f), int(c)]), slack, int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    costs = np.asarray([p[0] for p in pairs], dtype=float)\n    slacks = np.asarray([p[1] for p in pairs], dtype=float)\n\n    cost_rank = np.argsort(np.argsort(costs))\n    slack_rank = np.argsort(np.argsort(slacks))  # smaller slack => smaller rank\n\n    score = cost_rank + slack_rank\n    idx = int(np.argmin(score))\n    return pairs[idx][2], pairs[idx][3]\n",
  "pareto_front_weighted_pick": "import numpy as np\nfrom typing import List, Tuple\n\ndef _pareto_mask(vals: np.ndarray) -> np.ndarray:\n    # vals shape (n,2) where we minimize both columns\n    n = vals.shape[0]\n    mask = np.ones(n, dtype=bool)\n    for i in range(n):\n        if not mask[i]:\n            continue\n        dominated = np.all(vals <= vals[i], axis=1) & np.any(vals < vals[i], axis=1)\n        mask[dominated] = False\n    return mask\n\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    w_cost = 1.0\n    w_slack = 0.5\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    crit = []\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            cost = float(C[int(f), int(c)])\n            slack = float(caps0[int(f)] - d)\n            pairs.append((int(c), int(f), cost, slack))\n            crit.append((cost, slack))\n\n    if not pairs:\n        return None, None\n\n    crit = np.asarray(crit, dtype=float)\n    # We want low cost AND low slack (tighter fits) on Pareto front\n    mask = _pareto_mask(crit)\n    idxs = np.where(mask)[0]\n\n    best = (np.inf, None)\n    for i in idxs:\n        c, f, cost, slack = pairs[int(i)]\n        score = w_cost * cost + w_slack * slack\n        if score < best[0]:\n            best = (score, (c, f))\n\n    return best[1] if best[1] is not None else (None, None)\n",
  "log_barrier_utilization": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    mu = 4.0\n    eps = 1e-9\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            slack = float(caps0[int(f)] - d)\n            score = float(C[int(f), int(c)]) - mu * float(np.log(slack + eps + 1.0))\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "roulette_customer_by_demand_then_best_facility": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    candidates = []\n    weights = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[c])[0]\n        if feas.size:\n            candidates.append(int(c))\n            weights.append(float(dem[c]))\n\n    if not candidates:\n        return None, None\n\n    w = np.asarray(weights, dtype=float)\n    w = w / float(np.sum(w))\n    c = int(rng.choice(np.asarray(candidates, dtype=int), p=w))\n\n    feas = np.where(caps >= dem[c])[0]\n    f = int(feas[np.argmin(C[feas, c])])\n    return c, f\n",
  "roulette_facility_by_capacity_then_best_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    # filter facilities that can serve at least one remaining customer\n    feasible_fac = []\n    weights = []\n    for f in range(len(caps)):\n        if np.any(dem[rem] <= caps[f]):\n            feasible_fac.append(int(f))\n            weights.append(float(caps[f]))\n\n    if not feasible_fac:\n        return None, None\n\n    w = np.asarray(weights, dtype=float)\n    w = w / float(np.sum(w))\n    f = int(rng.choice(np.asarray(feasible_fac, dtype=int), p=w))\n\n    feas_customers = rem[np.where(dem[rem] <= caps[f])[0]]\n    if feas_customers.size == 0:\n        return None, None\n    c = int(feas_customers[np.argmin(C[f, feas_customers])])\n    return c, f\n",
  "top_quantile_demand_focus": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    q = float(np.quantile(dem_all[rem], 0.75))\n    subset = rem[dem_all[rem] >= q]\n    subset = subset if subset.size else rem\n\n    best = (np.inf, None, None)\n    for c in subset:\n        feas = np.where(caps >= dem_all[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        val = float(C[f, int(c)])\n        if val < best[0]:\n            best = (val, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "bottom_quantile_demand_pack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    q = float(np.quantile(dem_all[rem], 0.25))\n    subset = rem[dem_all[rem] <= q]\n    subset = subset if subset.size else rem\n\n    best = (np.inf, None, None)\n    for c in subset:\n        feas = np.where(caps >= dem_all[int(c)])[0]\n        for f in feas:\n            val = float(C[int(f), int(c)])\n            if val < best[0]:\n                best = (val, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "mini_batch_top_demand_best_pair": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    M = 8\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    order = rem[np.argsort(-dem[rem])]\n    batch = order[: min(M, order.size)]\n\n    best = (np.inf, None, None)\n    for c in batch:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            val = float(C[int(f), int(c)])\n            if val < best[0]:\n                best = (val, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "maximize_future_feasibility_count": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = list(remaining_customers)\n\n    best = (-np.inf, np.inf, None, None)  # (feas_count_after, cost, c, f)\n\n    for c in rem:\n        d = float(dem_all[c])\n        feas_fs = np.where(caps0 >= d)[0]\n        for f in feas_fs:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            # count feasible options for remaining customers (excluding c)\n            cnt = 0\n            for c2 in rem:\n                if c2 == c:\n                    continue\n                cnt += int(np.sum(caps >= dem_all[int(c2)]))\n            cost = float(C[int(f), int(c)])\n            if (cnt > best[0]) or (cnt == best[0] and cost < best[1]):\n                best = (float(cnt), cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "minimize_feasibility_loss": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = list(remaining_customers)\n\n    # baseline feasible edges count\n    base_edges = 0\n    for c in rem:\n        base_edges += int(np.sum(caps0 >= dem_all[int(c)]))\n\n    best = (np.inf, np.inf, None, None)  # (loss, cost, c, f)\n\n    for c in rem:\n        d = float(dem_all[int(c)])\n        feas_fs = np.where(caps0 >= d)[0]\n        for f in feas_fs:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            edges = 0\n            for c2 in rem:\n                if c2 == c:\n                    continue\n                edges += int(np.sum(caps >= dem_all[int(c2)]))\n            loss = float(base_edges - edges)\n            cost = float(C[int(f), int(c)])\n            key = (loss, cost)\n            if key < best[:2]:\n                best = (loss, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "facility_opportunity_cost_customer_choice": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    best_gap = -np.inf\n    best_pair = (None, None)\n\n    for f in range(len(caps)):\n        feas_customers = rem[np.where(dem[rem] <= caps[f])[0]]\n        if feas_customers.size == 0:\n            continue\n        vals = C[int(f), feas_customers]\n        if vals.size == 1:\n            gap = 1e12\n            c = int(feas_customers[0])\n        else:\n            order = np.argsort(vals)\n            gap = float(vals[order[1]] - vals[order[0]])\n            c = int(feas_customers[order[0]])\n        if gap > best_gap:\n            best_gap = gap\n            best_pair = (c, int(f))\n\n    return best_pair if best_pair[0] is not None else (None, None)\n",
  "shadow_price_capacity_scarcity": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Shadow price: inverse of remaining capacity (scarcer => higher)\n    pi = 1.0 / (caps + 1.0)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        score = C[feas, int(c)] + pi[feas] * d\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "cost_minus_capacity_bonus": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    kappa = 0.2\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            rem_after = float(caps0[int(f)] - d)\n            score = float(C[int(f), int(c)]) - kappa * rem_after\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "balanced_used_capacity_increment": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    lam = 8.0\n    caps_rem = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    used = np.zeros_like(caps_rem)\n    for f, custs in enumerate(assignments):\n        used[f] = sum(float(dem[int(c)]) for c in custs)\n    total = np.maximum(used + caps_rem, 1e-9)\n    util0 = used / total\n    peak0 = float(np.max(util0)) if util0.size else 0.0\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps_rem >= d)[0]\n        for f in feas:\n            used2 = used.copy()\n            used2[int(f)] += d\n            util2 = used2 / total\n            peak2 = float(np.max(util2))\n            score = float(C[int(f), int(c)]) + lam * (peak2 - peak0)\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_cheapest_customer_with_best_fit": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n    rem = np.asarray(remaining_customers, dtype=int)\n\n    best = (np.inf, np.inf, None, None)  # (slack, cost, c, f)\n\n    for f in range(len(caps)):\n        feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n        if feas_c.size == 0:\n            continue\n        c = int(feas_c[np.argmin(C[int(f), feas_c])])\n        slack = float(caps[int(f)] - dem[int(c)])\n        cost = float(C[int(f), int(c)])\n        key = (slack, cost, int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "customer_cheapest_facility_with_best_fit": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (slack, cost, c, f)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        slack = float(caps[int(f)] - dem[int(c)])\n        cost = float(C[int(f), int(c)])\n        key = (slack, cost, int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "quantile_clipped_cost_selection": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    feas_vals = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size:\n            feas_vals.extend(C[feas, int(c)].tolist())\n    if len(feas_vals) == 0:\n        return None, None\n\n    clip = float(np.quantile(np.asarray(feas_vals, dtype=float), 0.90))\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            val = float(min(C[int(f), int(c)], clip))\n            if val < best[0]:\n                best = (val, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "stochastic_ranking_cost_vs_slack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    p = 0.7\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            pairs.append((int(c), int(f), float(C[int(f), int(c)]), float(caps[int(f)] - d)))\n\n    if not pairs:\n        return None, None\n\n    # Perform a few bubble-like passes\n    pairs = list(pairs)\n    for _ in range(8):\n        swapped = False\n        for i in range(len(pairs) - 1):\n            a = pairs[i]\n            b = pairs[i + 1]\n            if float(rng.random()) < p:\n                better = a[2] <= b[2]\n            else:\n                better = a[3] <= b[3]\n            if not better:\n                pairs[i], pairs[i + 1] = pairs[i + 1], pairs[i]\n                swapped = True\n        if not swapped:\n            break\n\n    c, f, _, _ = pairs[0]\n    return c, f\n",
  "min_cost_under_capacity_fraction_rule": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    frac = 0.40\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    avg_d = float(np.mean(dem_all[rem])) if rem.size else float(np.mean(dem_all))\n    target = frac * max(1e-9, avg_d)\n\n    best = (np.inf, np.inf, None, None)  # (viol, cost, c, f)\n\n    for c in rem:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            rem_after = float(caps[int(f)] - d)\n            viol = 0.0 if rem_after >= target else (target - rem_after)\n            cost = float(C[int(f), int(c)])\n            key = (viol, cost)\n            if key < best[:2]:\n                best = (viol, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "most_dependent_on_single_facility": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best_margin = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        if vals.size == 1:\n            margin = 1e12\n            f = int(feas[0])\n        else:\n            order = np.argsort(vals)\n            margin = float(vals[order[1]] - vals[order[0]])\n            f = int(feas[order[0]])\n        if margin > best_margin:\n            best_margin = margin\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "favor_underutilized_facilities_cost_adjusted": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rho = 0.35\n    caps_rem = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    used = np.zeros_like(caps_rem)\n    for f, custs in enumerate(assignments):\n        used[f] = sum(float(dem[int(c)]) for c in custs)\n    total = np.maximum(used + caps_rem, 1e-9)\n    util = used / total\n    discount = 1.0 - rho * (1.0 - util)\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps_rem >= d)[0]\n        if feas.size == 0:\n            continue\n        adj = C[feas, int(c)] * discount[feas]\n        k = int(np.argmin(adj))\n        f = int(feas[k])\n        val = float(adj[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "min_cost_with_facility_quota_pressure": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    lam = 0.8\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    counts = np.asarray([len(a) for a in assignments], dtype=float)\n    target = float(np.mean(counts)) if counts.size else 0.0\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        pressure = np.abs((counts[feas] + 1.0) - target)\n        score = C[feas, int(c)] + lam * pressure\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "bottleneck_facility_capacity_protection": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    lam = 5.0\n    caps0 = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    # Smaller capacity => larger penalty coefficient\n    cap_scale = (np.max(caps0) + 1.0) / (caps0 + 1.0)\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            penalty = lam * float(cap_scale[int(f)]) * (d / (caps0[int(f)] + 1.0))\n            score = float(C[int(f), int(c)]) + penalty\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "two_stage_customer_cluster_by_cost_profile": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (np.inf, np.inf, None, None)  # (std, best_cost, c, f)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        s = float(np.std(vals))\n        f = int(feas[np.argmin(vals)])\n        key = (s, float(C[int(f), int(c)]), int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "max_cost_spread_customer_priority": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best_spread = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        spread = float(np.max(vals) - np.min(vals))\n        f = int(feas[np.argmin(vals)])\n        if spread > best_spread:\n            best_spread = spread\n            best_c = int(c)\n            best_f = int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "min_cost_with_demand_percentile_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    alpha = 2.0\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    dvals = dem_all[rem]\n    if dvals.size == 0:\n        return None, None\n\n    # compute percentile rank per customer\n    order = np.argsort(dvals)\n    ranks = np.empty_like(order, dtype=float)\n    ranks[order] = np.linspace(0.0, 1.0, num=order.size)\n    pct = {int(rem[i]): float(ranks[i]) for i in range(rem.size)}\n\n    best = (np.inf, None, None)\n\n    for c in rem:\n        feas = np.where(caps >= dem_all[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        score = float(C[int(f), int(c)]) + alpha * pct[int(c)]\n        if score < best[0]:\n            best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "adaptive_topk_by_remaining_density": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n\n    n_rem = len(remaining_customers)\n    K = int(np.clip(np.ceil(0.15 * n_rem), 3, 25))\n\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            pairs.append((float(C[int(f), int(c)]), int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    top = pairs[: min(K, len(pairs))]\n\n    # Pick the median-cost option in top-K to avoid always extreme greediness\n    idx = int(len(top) // 2)\n    _, c, f = top[idx]\n    # small chance to randomize within top\n    if float(rng.random()) < 0.10:\n        _, c, f = top[int(rng.integers(0, len(top)))]\n\n    return c, f\n",
  "min_cost_with_customer_degrees_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.6\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    deg = {}\n    for c in remaining_customers:\n        deg[int(c)] = int(np.sum(caps >= dem_all[int(c)]))\n\n    best = (np.inf, None, None)\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem_all[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        score = float(C[int(f), int(c)]) + beta * float(deg[int(c)])\n        if score < best[0]:\n            best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "min_cost_with_facility_degree_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    beta = 0.4\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    rem = np.asarray(remaining_customers, dtype=int)\n    deg_f = np.zeros(len(caps), dtype=float)\n    for f in range(len(caps)):\n        deg_f[f] = float(np.sum(dem_all[rem] <= caps[f]))\n\n    best = (np.inf, None, None)\n\n    for c in rem:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        score = C[feas, int(c)] + beta * deg_f[feas]\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "max_demand_to_cost_ratio": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-9\n    caps = np.asarray(remaining_capacities, dtype=float)\n    dem_all = np.asarray(customer_demands, dtype=float)\n    C = np.asarray(assignment_costs, dtype=float)\n\n    best = (-np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        cost = float(C[int(f), int(c)])\n        ratio = d / (cost + eps)\n        if ratio > best[0]:\n            best = (ratio, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "minimax_customer_best_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick the hardest customer: highest (best feasible cost), assign to its best facility\n    if not remaining_customers:\n        return None, None\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best_c = None\n    best_f = None\n    worst_best = -np.inf\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        j = int(feas[np.argmin(vals)])\n        bb = float(C[j, int(c)])\n        if bb > worst_best:\n            worst_best = bb\n            best_c, best_f = int(c), int(j)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "minimax_pair_cost_then_slack": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Choose pair minimizing max(cost, normalized_slack_penalty); tie-break by cost\n    if not remaining_customers:\n        return None, None\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    cmax = float(np.max(C)) if C.size else 1.0\n    cmax = max(cmax, 1e-9)\n\n    best = (np.inf, np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            slack = float(caps[int(f)] - d)\n            cost = float(C[int(f), int(c)])\n            crit = max(cost / cmax, 1.0 / (slack + 1.0))\n            key = (crit, cost)\n            if key < best[:2]:\n                best = (crit, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "annealed_softmax_pairs": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Softmax sampling over feasible pairs with temperature decreasing as progress increases\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    n_assigned = sum(len(a) for a in assignments)\n    n_rem = len(remaining_customers)\n    progress = n_assigned / max(1, n_assigned + n_rem)\n    tau = 40.0 * (1.0 - progress) + 2.0\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    cs, fs, vals = [], [], []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            cs.append(int(c))\n            fs.append(int(f))\n            vals.append(float(C[int(f), int(c)]))\n\n    if not vals:\n        return None, None\n\n    x = np.asarray(vals, float)\n    m = float(np.min(x))\n    w = np.exp(-(x - m) / max(1e-9, tau))\n    w = w / float(np.sum(w))\n\n    idx = int(rng.choice(len(w), p=w))\n    return cs[idx], fs[idx]\n",
  "grasp_rcl_pairs": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # GRASP-style: build restricted candidate list (RCL) and pick randomly from it\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    alpha = 0.20  # top 20% cheapest feasible pairs\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            pairs.append((float(C[int(f), int(c)]), int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    k = max(1, int(np.ceil(alpha * len(pairs))))\n    rcl = pairs[:k]\n    _, c, f = rcl[int(rng.integers(0, len(rcl)))]\n    return c, f\n",
  "demand_bin_round_robin": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Round-robin across demand bins (high/medium/low) based on step count\n    if not remaining_customers:\n        return None, None\n\n    step = sum(len(a) for a in assignments)\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    rem = np.asarray(remaining_customers, int)\n    dvals = dem[rem]\n    if dvals.size == 0:\n        return None, None\n\n    q1 = float(np.quantile(dvals, 0.33))\n    q2 = float(np.quantile(dvals, 0.66))\n\n    mode = step % 3\n    if mode == 0:\n        subset = rem[dvals >= q2]\n    elif mode == 1:\n        subset = rem[(dvals >= q1) & (dvals < q2)]\n    else:\n        subset = rem[dvals < q1]\n    if subset.size == 0:\n        subset = rem\n\n    best = (np.inf, None, None)\n    for c in subset:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        val = float(C[int(f), int(c)])\n        if val < best[0]:\n            best = (val, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_median_capacity_then_best_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick facility with median remaining capacity; assign its cheapest feasible customer\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    order = np.argsort(caps)\n    f = int(order[len(order) // 2]) if order.size else None\n    if f is None:\n        return None, None\n\n    feas_c = rem[np.where(dem[rem] <= caps[f])[0]]\n    if feas_c.size == 0:\n        # fallback: choose any facility that can serve someone\n        for ff in order:\n            feas_c = rem[np.where(dem[rem] <= caps[int(ff)])[0]]\n            if feas_c.size:\n                f = int(ff)\n                break\n        if feas_c.size == 0:\n            return None, None\n\n    c = int(feas_c[np.argmin(C[f, feas_c])])\n    return c, int(f)\n",
  "cost_with_utilization_cap_threshold": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Prefer assignments that keep utilization <= u_max when possible; otherwise fallback to cheapest feasible\n    if not remaining_customers:\n        return None, None\n\n    u_max = 0.85\n    caps_rem = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    used = np.zeros_like(caps_rem)\n    for f, custs in enumerate(assignments):\n        used[f] = sum(float(dem[int(c)]) for c in custs)\n    total = np.maximum(used + caps_rem, 1e-9)\n\n    best_good = (np.inf, None, None)\n    best_any = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps_rem >= d)[0]\n        if feas.size == 0:\n            continue\n        for f in feas:\n            util_after = float((used[int(f)] + d) / total[int(f)])\n            val = float(C[int(f), int(c)])\n            if val < best_any[0]:\n                best_any = (val, int(c), int(f))\n            if util_after <= u_max and val < best_good[0]:\n                best_good = (val, int(c), int(f))\n\n    if best_good[1] is not None:\n        return best_good[1], best_good[2]\n    return (best_any[1], best_any[2]) if best_any[1] is not None else (None, None)\n",
  "harmonic_cost_slack_score": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Score = cost * (1 + w/(slack+1)) (harmonic-style penalty for tight slack)\n    if not remaining_customers:\n        return None, None\n\n    w = 3.5\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            slack = float(caps[int(f)] - d)\n            score = float(C[int(f), int(c)]) * (1.0 + w / (slack + 1.0))\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "customer_high_cv_cost_priority": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick customer with highest coefficient of variation of feasible costs; assign cheapest feasible facility\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best_cv = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        mu = float(np.mean(vals))\n        sd = float(np.std(vals))\n        cv = sd / max(1e-9, mu)\n        f = int(feas[np.argmin(vals)])\n        if cv > best_cv:\n            best_cv, best_c, best_f = cv, int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "facility_low_cost_variance_prefer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Prefer facilities with low variance of costs over remaining customers, then assign its cheapest feasible customer\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    var_f = np.var(C[:, rem], axis=1) if rem.size else np.var(C, axis=1)\n    order = np.argsort(var_f)\n\n    for f in order:\n        feas_c = rem[np.where(dem[rem] <= caps[int(f)])[0]]\n        if feas_c.size == 0:\n            continue\n        c = int(feas_c[np.argmin(C[int(f), feas_c])])\n        return c, int(f)\n\n    return None, None\n",
  "top_regret_pool_then_best_fit": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Take top-P customers by regret, then choose pair with tightest fit among them (tie by cost)\n    if not remaining_customers:\n        return None, None\n\n    P = 7\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    reg = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = np.sort(C[feas, int(c)])\n        r = float(vals[1] - vals[0]) if vals.size >= 2 else 1e12\n        reg.append((r, int(c)))\n\n    if not reg:\n        return None, None\n\n    reg.sort(key=lambda x: -x[0])\n    pool = [c for _, c in reg[: min(P, len(reg))]]\n\n    best = (np.inf, np.inf, None, None)  # (slack, cost, c, f)\n    for c in pool:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        if feas.size == 0:\n            continue\n        slacks = caps[feas] - d\n        k = int(np.argmin(slacks))\n        f_tight = int(feas[k])\n        # among tightest slack facilities, pick cheapest\n        min_slack = float(slacks[k])\n        cand = feas[np.where(slacks == min_slack)[0]]\n        f = int(cand[np.argmin(C[cand, int(c)])])\n        key = (min_slack, float(C[int(f), int(c)]), int(c), int(f))\n        if key < best:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "boost_new_facilities_first": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Encourage using facilities with zero assignments: score = cost - bonus_if_unused\n    if not remaining_customers:\n        return None, None\n\n    bonus = 5.0\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    used_flag = np.asarray([1.0 if len(a) > 0 else 0.0 for a in assignments], float)\n    adj_bonus = (1.0 - used_flag) * bonus\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            score = float(C[int(f), int(c)]) - float(adj_bonus[int(f)])\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "penalize_overused_facilities": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Penalize facilities with many assigned customers: score = cost + lam*count\n    if not remaining_customers:\n        return None, None\n\n    lam = 0.9\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    cnt = np.asarray([len(a) for a in assignments], float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        score = C[feas, int(c)] + lam * cnt[feas]\n        k = int(np.argmin(score))\n        f = int(feas[k])\n        val = float(score[k])\n        if val < best[0]:\n            best = (val, int(c), f)\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "max_improvement_over_mean_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick customer with biggest improvement: mean feasible cost - best feasible cost\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best_imp = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = C[feas, int(c)]\n        j = int(feas[np.argmin(vals)])\n        imp = float(np.mean(vals) - float(C[j, int(c)]))\n        if imp > best_imp:\n            best_imp, best_c, best_f = imp, int(c), int(j)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "facility_mean_normalized_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Normalize cost by facility mean over remaining customers: score = cost / (mean_f + eps)\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-9\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    mean_f = np.mean(C[:, rem], axis=1) if rem.size else np.mean(C, axis=1)\n\n    best = (np.inf, None, None)\n    for c in rem:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            score = float(C[int(f), int(c)]) / (float(mean_f[int(f)]) + eps)\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "customer_mean_normalized_cost": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Normalize by customer mean feasible cost: score = cost / (mean_c + eps), pick best pair\n    if not remaining_customers:\n        return None, None\n\n    eps = 1e-9\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best = (np.inf, None, None)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        mean_c = float(np.mean(C[feas, int(c)]))\n        for f in feas:\n            score = float(C[int(f), int(c)]) / (mean_c + eps)\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "facility_capacity_percentile_gate": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Prefer using high-capacity facilities early: gate to top-capacity percentile when progress is low\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    n_assigned = sum(len(a) for a in assignments)\n    n_rem = len(remaining_customers)\n    progress = n_assigned / max(1, n_assigned + n_rem)\n\n    pct = 0.70 if progress < 0.5 else 0.0\n    thr = float(np.quantile(caps, pct)) if caps.size else 0.0\n\n    best_primary = (np.inf, None, None)\n    best_any = (np.inf, None, None)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            val = float(C[int(f), int(c)])\n            if val < best_any[0]:\n                best_any = (val, int(c), int(f))\n            if caps[int(f)] >= thr and val < best_primary[0]:\n                best_primary = (val, int(c), int(f))\n\n    if best_primary[1] is not None:\n        return best_primary[1], best_primary[2]\n    return (best_any[1], best_any[2]) if best_any[1] is not None else (None, None)\n",
  "smallest_capacity_facility_first": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick smallest remaining-capacity facility that can serve someone; assign its cheapest feasible customer\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    order = np.argsort(caps)\n    for f in order:\n        feas_c = rem[np.where(dem[rem] <= caps[int(f)])[0]]\n        if feas_c.size == 0:\n            continue\n        c = int(feas_c[np.argmin(C[int(f), feas_c])])\n        return c, int(f)\n\n    return None, None\n",
  "remaining_capacity_to_median_target": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Choose pair whose facility remaining capacity after assignment is closest to the median remaining capacity\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    med = float(np.median(caps0)) if caps0.size else 0.0\n\n    best = (np.inf, np.inf, None, None)  # (dist_to_med, cost, c, f)\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            rem_after = float(caps0[int(f)] - d)\n            dist = abs(rem_after - med)\n            cost = float(C[int(f), int(c)])\n            key = (dist, cost)\n            if key < best[:2]:\n                best = (dist, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "lookahead_for_biggest_customer_next": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # One-step lookahead focused on the biggest remaining customer: preserve its feasibility/cost\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    rem = list(map(int, remaining_customers))\n    big = max(rem, key=lambda c: dem[c])\n\n    best = (np.inf, None, None)\n\n    for c in rem:\n        d = float(dem[c])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            base = float(C[int(f), int(c)])\n\n            # After this assignment, estimate best achievable cost for biggest customer\n            if c == big:\n                penalty = 0.0\n            else:\n                feas_big = np.where(caps >= dem[int(big)])[0]\n                if feas_big.size == 0:\n                    penalty = 1e9\n                else:\n                    penalty = float(np.min(C[feas_big, int(big)]))\n\n            score = base + 0.4 * penalty\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "maximize_demand_per_total_capacity": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Choose customer maximizing demand / (facility_total_capacity) using cheapest feasible facility\n    if not remaining_customers:\n        return None, None\n\n    caps_rem = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    used = np.zeros_like(caps_rem)\n    for f, custs in enumerate(assignments):\n        used[f] = sum(float(dem[int(c)]) for c in custs)\n    total = np.maximum(used + caps_rem, 1e-9)\n\n    best_ratio = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps_rem >= d)[0]\n        if feas.size == 0:\n            continue\n        # cheapest facility for cost, but ratio uses total capacity of that facility\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        ratio = d / float(total[int(f)])\n        if ratio > best_ratio:\n            best_ratio, best_c, best_f = ratio, int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "rank_based_sampling_pairs": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Sample feasible pair by rank: probability proportional to 1/rank(cost)\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    pairs = []\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        for f in feas:\n            pairs.append((float(C[int(f), int(c)]), int(c), int(f)))\n\n    if not pairs:\n        return None, None\n\n    pairs.sort(key=lambda x: x[0])\n    n = len(pairs)\n    ranks = np.arange(1, n + 1, dtype=float)\n    w = 1.0 / ranks\n    w = w / float(np.sum(w))\n\n    idx = int(rng.choice(n, p=w))\n    _, c, f = pairs[idx]\n    return c, f\n",
  "facility_best_mean_cost_then_customer": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Choose facility with lowest mean cost to remaining customers, then assign its cheapest feasible customer\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n    rem = np.asarray(remaining_customers, int)\n\n    mean_f = np.mean(C[:, rem], axis=1) if rem.size else np.mean(C, axis=1)\n    for f in np.argsort(mean_f):\n        feas_c = rem[np.where(dem[rem] <= caps[int(f)])[0]]\n        if feas_c.size == 0:\n            continue\n        c = int(feas_c[np.argmin(C[int(f), feas_c])])\n        return c, int(f)\n\n    return None, None\n",
  "risk_averse_customer_cvar": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Pick customer with highest CVaR (tail mean) of feasible costs; assign cheapest feasible facility\n    if not remaining_customers:\n        return None, None\n\n    alpha = 0.8  # tail starts at 80th percentile\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best_tail = -np.inf\n    best_c = None\n    best_f = None\n\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        vals = np.sort(C[feas, int(c)].astype(float))\n        k = int(np.ceil(alpha * vals.size))\n        k = min(max(k, 0), vals.size)\n        tail = vals[k:] if k < vals.size else vals[-1:]\n        cvar = float(np.mean(tail))\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        if cvar > best_tail:\n            best_tail, best_c, best_f = cvar, int(c), int(f)\n\n    return (best_c, best_f) if best_c is not None else (None, None)\n",
  "maximize_min_slack_after_pair": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Choose pair maximizing the minimum remaining capacity across facilities after assignment; tie-break by cost\n    if not remaining_customers:\n        return None, None\n\n    caps0 = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    best = (-np.inf, np.inf, None, None)  # (min_cap_after, cost, c, f)\n\n    for c in remaining_customers:\n        d = float(dem[int(c)])\n        feas = np.where(caps0 >= d)[0]\n        for f in feas:\n            caps = caps0.copy()\n            caps[int(f)] -= d\n            min_after = float(np.min(caps)) if caps.size else 0.0\n            cost = float(C[int(f), int(c)])\n            if (min_after > best[0]) or (min_after == best[0] and cost < best[1]):\n                best = (min_after, cost, int(c), int(f))\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n",
  "probabilistic_customer_then_pair_bestofm": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Sample M customers uniformly (with replacement), pick best feasible assignment among them\n    if not remaining_customers:\n        return None, None\n\n    rng = np.random.default_rng()\n    M = 6\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    rem = np.asarray(remaining_customers, int)\n    if rem.size == 0:\n        return None, None\n\n    sample = rem[int(rng.integers(0, rem.size, size=M))]\n\n    best = (np.inf, None, None)\n    for c in sample:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        val = float(C[int(f), int(c)])\n        if val < best[0]:\n            best = (val, int(c), int(f))\n\n    if best[1] is not None:\n        return best[1], best[2]\n\n    # fallback: deterministic cheapest feasible pair\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size:\n            f = int(feas[np.argmin(C[feas, int(c)])])\n            return int(c), int(f)\n\n    return None, None\n",
  "capacity_fragmentation_penalty": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Penalize leaving small unusable fragments: score = cost + lam * exp(-rem_after/scale)\n    if not remaining_customers:\n        return None, None\n\n    lam = 3.0\n    caps = np.asarray(remaining_capacities, float)\n    dem_all = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    rem = np.asarray(remaining_customers, int)\n    scale = float(np.median(dem_all[rem])) if rem.size else 1.0\n    scale = max(scale, 1e-9)\n\n    best = (np.inf, None, None)\n    for c in rem:\n        d = float(dem_all[int(c)])\n        feas = np.where(caps >= d)[0]\n        for f in feas:\n            rem_after = float(caps[int(f)] - d)\n            frag = float(np.exp(-rem_after / scale))\n            score = float(C[int(f), int(c)]) + lam * frag\n            if score < best[0]:\n                best = (score, int(c), int(f))\n\n    return (best[1], best[2]) if best[1] is not None else (None, None)\n",
  "customer_near_capacity_90pct_risk": "import numpy as np\nfrom typing import List, Tuple\n\ndef select_next_assignment(assignments: List[List[int]], remaining_customers: List[int], remaining_capacities: List[int], customer_demands: List[int], assignment_costs: List[List[int]]) -> Tuple[int, int]:\n    # Prioritize customers whose demand is near the 90th percentile of remaining capacities (risk of becoming infeasible)\n    if not remaining_customers:\n        return None, None\n\n    caps = np.asarray(remaining_capacities, float)\n    dem = np.asarray(customer_demands, float)\n    C = np.asarray(assignment_costs, float)\n\n    cap90 = float(np.quantile(caps, 0.90)) if caps.size else 0.0\n\n    best = (np.inf, np.inf, None, None)  # (distance_to_cap90, cost, c, f)\n    for c in remaining_customers:\n        feas = np.where(caps >= dem[int(c)])[0]\n        if feas.size == 0:\n            continue\n        dist = abs(float(dem[int(c)]) - cap90)\n        f = int(feas[np.argmin(C[feas, int(c)])])\n        cost = float(C[int(f), int(c)])\n        key = (dist, cost, int(c), int(f))\n        if key[:2] < best[:2]:\n            best = key\n\n    return (best[2], best[3]) if best[2] is not None else (None, None)\n"
}
