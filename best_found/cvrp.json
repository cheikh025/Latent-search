{
 "EoH": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n  \"\"\"Design a novel algorithm to select the next node in each step.\n  Args:\n    current_node: ID of the current node.\n    depot: ID of the depot.\n    unvisited_nodes: Array of IDs of unvisited nodes.\n    rest_capacity: rest capacity of vehicle\n    demands: demands of nodes\n    distance_matrix: Distance matrix of nodes.\n  Return:\n    ID of the next node to visit.\n  \"\"\"\n  if len(unvisited_nodes) == 0:\n    return -1\n  \n  distances = distance_matrix[current_node][unvisited_nodes]\n  demands_arr = demands[unvisited_nodes]\n  \n  # Compute immediate feasibility\n  feasible_mask = demands_arr <= rest_capacity\n  \n  # Compute entropy of demand distribution (uncertainty in remaining demand)\n  # If all unvisited nodes have similar demands, the system is in high uncertainty\n  # We penalize nodes that lead to high entropy in future demand distribution\n  from scipy.stats import entropy\n  from numpy import log\n  \n  # Group unvisited nodes by demand level to simulate clustering\n  demand_bins = np.histogram(demands_arr, bins=5, range=(0, np.max(demands_arr) + 1))[1]\n  demand_groups = np.digitize(demands_arr, demand_bins)\n  \n  # Compute group-wise entropy of demand distribution after selecting a node\n  # Entropy reduction = -sum(p_i * log(p_i)) after node selection\n  # We aim to reduce uncertainty by selecting nodes that help \"compress\" the demand distribution\n  \n  # Compute the prior entropy of unvisited nodes\n  prior_prob = np.bincount(demand_groups, minlength=5) / len(unvisited_nodes)\n  prior_entropy = -np.sum(prior_prob * np.log(prior_prob + 1e-6)) if np.any(prior_prob > 0) else 0\n  \n  # For each node, compute the new entropy after selection\n  node_entropy_change = []\n  for i, node_id in enumerate(unvisited_nodes):\n    if not feasible_mask[i]:\n      continue\n      \n    # Simulate removal of this node from the unvisited set\n    new_demands = demands_arr.copy()\n    new_demands[i] = 0 # temporarily remove node's demand\n    new_demand_groups = np.digitize(new_demands, demand_bins)\n    new_prob = np.bincount(new_demand_groups, minlength=5) / (len(unvisited_nodes) - 1)\n    new_entropy = -np.sum(new_prob * np.log(new_prob + 1e-6)) if np.any(new_prob > 0) else 0\n    \n    # Entropy reduction = prior_entropy - new_entropy\n    entropy_reduction = prior_entropy - new_entropy\n    node_entropy_change.append(entropy_reduction)\n  \n  if len(node_entropy_change) == 0:\n    # Fallback to proximity and capacity\n    feasible_mask = feasible_mask & (distances <= np.max(distances) * 0.9)\n    if not np.any(feasible_mask):\n      return unvisited_nodes[np.argmin(distances)]\n    \n    proximity_score = 1 / (distances[feasible_mask] + 1e-6)\n    utilization_score = np.clip(demands_arr[feasible_mask] / (rest_capacity + 1e-6), 0.2, 0.6)\n    final_score = proximity_score * 0.5 + utilization_score * 0.3\n    return unvisited_nodes[np.argmax(final_score)]\n  \n  # Combine entropy gain with proximity and capacity\n  proximity_score = 1 / (distances[feasible_mask] + 1e-6)\n  utilization_score = np.clip(demands_arr[feasible_mask] / (rest_capacity + 1e-6), 0.2, 0.6)\n  entropy_score = np.array(node_entropy_change)[feasible_mask]\n  \n  final_score = proximity_score * 0.4 + utilization_score * 0.3 + entropy_score * 0.3\n  \n  best_idx = np.argmax(final_score)\n  return unvisited_nodes[feasible_mask][best_idx]\n\n",
 "funsearch": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n  \"\"\"Design a novel algorithm to select the next node in each step.\n  Args:\n    current_node: ID of the current node.\n    depot: ID of the depot.\n    unvisited_nodes: Array of IDs of unvisited nodes.\n    rest_capacity: rest capacity of vehicle\n    demands: demands of nodes\n    distance_matrix: Distance matrix of nodes.\n  Return:\n    ID of the next node to visit.\n  \"\"\"\n  best_score = -1\n  next_node = -1\n\n  # Precompute distances and demands for unvisited nodes\n  unvisited_distances = distance_matrix[current_node][unvisited_nodes]\n  unvisited_demands = demands[unvisited_nodes]\n\n  # Thresholds for flexibility and diversity\n  FLEX_THRESHOLD = 0.1 # Future capacity < 10% of demand \u2192 risky\n  DEPOT_DISTANCE = distance_matrix[current_node][depot]\n  DEMAND_THRESHOLD = 0.5 * np.max(unvisited_demands) if unvisited_demands.size > 0 else 0\n\n  for i, node in enumerate(unvisited_nodes):\n    demand = unvisited_demands[i]\n    distance = unvisited_distances[i]\n\n    # Skip if demand exceeds capacity\n    if demand > rest_capacity:\n      continue\n\n    # Avoid division by zero\n    if distance == 0:\n      # Only depot has zero distance; we skip non-depot zero-distance nodes\n      if node == depot:\n        score = 0 # Safe, no cost\n      else:\n        score = float('inf')\n      base_score = score\n    else:\n      # Base score: demand / distance (higher is better)\n      base_score = demand / distance\n\n      # --- 1. Future Capacity Flexibility Penalty ---\n      future_capacity = rest_capacity - demand\n      if future_capacity < FLEX_THRESHOLD * demand:\n        # This visit leaves very little buffer \u2192 risky for future small nodes\n        base_score *= 2.5 # Strong penalty\n\n      # --- 2. Proximity to Depot: Bonus for being closer than going directly to depot ---\n      if distance < DEPOT_DISTANCE:\n        base_score *= 1.15\n\n      # --- 3. Diversity Bonus: Favor distant, dissimilar nodes ---\n      # Compute similarity to other nodes in the neighborhood (simple heuristic)\n      # Nodes with similar demand and short distance \u2192 cluster \u2192 penalize\n      # We compute average demand of nearby nodes (within a small distance threshold)\n      distance_threshold = 0.7 * DEPOT_DISTANCE\n      similar_nodes = []\n      for j, other_node in enumerate(unvisited_nodes):\n        if other_node != node:\n          d = distance_matrix[current_node][other_node]\n          if d < distance_threshold and unvisited_demands[j] > 0.5 * demand:\n            similar_nodes.append(other_node)\n\n      # If this node is similar to many others in a tight cluster \u2192 penalize\n      if len(similar_nodes) > 1:\n        # Penalize if it's part of a small cluster\n        base_score *= 0.85 # Reduce score for clustering\n\n      # --- 4. Bonus for small-demand, nearby nodes (local refinement) ---\n      if demand < DEMAND_THRESHOLD and distance < DEPOT_DISTANCE * 0.6:\n        base_score *= 1.2 # Encourage visiting small, nearby nodes\n\n      # --- 5. Global diversity bonus: if node is far from depot (good for exploration) ---\n      dep_dist = distance_matrix[node][depot] # Distance from node to depot\n      if dep_dist > 0.8 * DEPOT_DISTANCE:\n        base_score *= 1.2 # Encourages visiting nodes far from depot\n\n  # Final selection\n  if next_node == -1:\n    # Fallback: pick closest unvisited node\n    closest_dist = np.inf\n    closest_node = -1\n    for node in unvisited_nodes:\n      d = distance_matrix[current_node][node]\n      if d < closest_dist:\n        closest_dist = d\n        closest_node = node\n    return closest_node if closest_node != -1 else unvisited_nodes[0]\n\n  return next_node\n\n",
 "mctsahd": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n  \"\"\"Design a novel algorithm to select the next node in each step.\n  Args:\n    current_node: ID of the current node.\n    depot: ID of the depot.\n    unvisited_nodes: Array of IDs of unvisited nodes.\n    rest_capacity: rest capacity of vehicle\n    demands: demands of nodes\n    distance_matrix: Distance matrix of nodes.\n  Return:\n    ID of the next node to visit.\n  \"\"\"\n  if len(unvisited_nodes) == 0:\n    return -1\n  \n  n = len(unvisited_nodes)\n  time_to_serve = np.zeros(n)\n  capacity_gap_penalty = np.zeros(n)\n  \n  for i, node in enumerate(unvisited_nodes):\n    dist = distance_matrix[current_node][node]\n    demand_util = demands[node] / (rest_capacity + 1e-6)\n    \n    # Demand urgency: higher demand leads to higher urgency\n    urgency = demands[node] * 1.5\n    \n    # Capacity gap penalty: penalize nodes where demand exceeds median demand of unvisited nodes\n    demand_list = [demands[n] for n in unvisited_nodes]\n    median_demand = np.median(demand_list)\n    capacity_gap = max(0, demands[node] - median_demand)\n    capacity_gap_penalty[i] = capacity_gap * 2.0\n    \n    # Time-to-serve scaled by urgency and capacity gap penalty\n    time_to_serve[i] = dist * (1 + urgency + capacity_gap_penalty[i])\n  \n  # Dynamic threshold: 75th percentile to allow more flexibility while maintaining balance\n  threshold = np.percentile(time_to_serve, 75)\n  \n  # Filter nodes below threshold (efficient and capacity-aware)\n  eligible_nodes = unvisited_nodes[time_to_serve < threshold]\n  \n  if len(eligible_nodes) > 0:\n    # Among eligible, pick the one with minimum distance\n    best_idx = np.argmin([distance_matrix[current_node][node] for node in eligible_nodes])\n    return eligible_nodes[best_idx]\n  \n  # Fallback to nearest neighbor\n  best_idx = np.argmin([distance_matrix[current_node][node] for node in unvisited_nodes])\n  return unvisited_nodes[best_idx]\n\n",
 "reevo": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: np.ndarray, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n  \"\"\"Design a novel algorithm to select the next node in each step.\n  Args:\n    current_node: ID of the current node.\n    depot: ID of the depot.\n    unvisited_nodes: Array of IDs of unvisited nodes.\n    rest_capacity: rest capacity of vehicle\n    demands: demands of nodes\n    distance_matrix: Distance matrix of nodes.\n  Return:\n    ID of the next node to visit.\n  \"\"\"\n  best_score = -1\n  next_node = -1\n\n  for node in unvisited_nodes:\n    demand = demands[node]\n    distance = distance_matrix[current_node][node]\n\n    if distance == 0:\n      continue # Skip zero distance (same node or unreachable)\n    \n    if demand > rest_capacity:\n      continue # Skip nodes that exceed remaining capacity\n\n    # Compute capacity utilization to reward efficient load usage\n    capacity_utilization = (rest_capacity - demand) / rest_capacity if rest_capacity > 0 else 0\n    \n    # Prioritize high demand relative to distance, with amplification for underutilized capacity\n    # Efficiency score emphasizes high-demand, low-distance nodes\n    efficiency_score = demand / (distance + 1e-8)\n    \n    # Capacity bias: amplify for underutilized capacity and partial load efficiency\n    # 1.5 multiplier for underutilized capacity encourages filling gaps\n    # 0.3 multiplier for remaining capacity incentivizes balanced load distribution\n    capacity_bias = 1.5 * capacity_utilization + 0.3 * (rest_capacity / (demand + 1e-6))\n    \n    # Final score: balance between demand efficiency and capacity utilization\n    score = efficiency_score * (1.0 + capacity_bias)\n\n    if score > best_score:\n      best_score = score\n      next_node = node\n\n  # Fallback: if no valid node found, return the first unvisited node\n  return next_node if next_node != -1 else unvisited_nodes[0] if len(unvisited_nodes) > 0 else depot\n\n",
 "LHS": "import numpy as np\n\ndef select_next_node(current_node: int, depot: int, unvisited_nodes: np.ndarray, rest_capacity: float, demands: np.ndarray, distance_matrix: np.ndarray) -> int:\n  if len(unvisited_nodes) == 0:\n    return depot\n  \n  cap = float(rest_capacity)\n  feasible = np.array([n for n in unvisited_nodes if demands[n] <= cap], dtype=int)\n  if len(feasible) == 0:\n    return depot\n  \n  d_cur = distance_matrix[current_node, feasible]\n  d_dep = distance_matrix[depot, feasible]\n  \n  d_cur_adj = d_cur - d_dep\n  d_cur_adj = np.clip(d_cur_adj, -np.inf, 1e12)\n  \n  d_cur_adj = np.clip(d_cur_adj, -np.inf, 1e12)\n  return int(feasible[np.argmin(d_cur_adj)])\n\n"
}