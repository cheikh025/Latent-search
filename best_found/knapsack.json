{
 "EoH": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Tuple[int, int, int] | None:\n  \"\"\"\n  Select the item with the highest value-to-weight ratio that fits in the remaining capacity.\n\n  Args:\n    remaining_capacity: The remaining capacity of the knapsack.\n    remaining_items: List of tuples containing (weight, value, index) of remaining items.\n\n  Returns:\n    The selected item as a tuple (weight, value, index), or None if no item fits.\n  \"\"\"\n  if not remaining_items:\n    return None\n  \n  best_item = None\n  max_ratio = -1\n  \n  for weight, value, index in remaining_items:\n    if weight <= remaining_capacity:\n      ratio = value / weight\n      if ratio > max_ratio:\n        max_ratio = ratio\n        best_item = (weight, value, index)\n  \n  return best_item if best_item else None\n\n",
 "funsearch": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Tuple[int, int, int] | None:\n  \"\"\"\n  Select the item with the highest value-to-weight ratio that fits in the remaining capacity.\n\n  Args:\n    remaining_capacity: The remaining capacity of the knapsack.\n    remaining_items: List of tuples containing (weight, value, index) of remaining items.\n\n  Returns:\n    The selected item as a tuple (weight, value, index), or None if no item fits.\n  \"\"\"\n  best_item = None\n  best_ratio = -1 # Initialize with a negative value to ensure any item will have a higher ratio\n\n  for item in remaining_items:\n    weight, value, index = item\n    if weight <= remaining_capacity:\n      ratio = value / weight # Calculate value-to-weight ratio\n      if ratio > best_ratio:\n        best_ratio = ratio\n        best_item = item\n\n  return best_item\n\n",
 "mctsahd": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Tuple[int, int, int] | None:\n  \"\"\"\n  Select the item with the highest value-to-weight ratio that fits in the remaining capacity.\n\n  Args:\n    remaining_capacity: The remaining capacity of the knapsack.\n    remaining_items: List of tuples containing (weight, value, index) of remaining items.\n\n  Returns:\n    The selected item as a tuple (weight, value, index), or None if no item fits.\n  \"\"\"\n  if not remaining_items:\n    return None\n  \n  best_item = None\n  best_ratio = -1\n  adjustment_factor = 1.0 # Dynamic factor that increases as capacity decreases\n  \n  # Adjust factor based on remaining capacity: more aggressive in tight spaces\n  if remaining_capacity <= 10:\n    adjustment_factor = 1.5\n  elif remaining_capacity <= 20:\n    adjustment_factor = 1.2\n  \n  # Apply adaptive ratio calculation with a smoothing term\n  for weight, value, index in remaining_items:\n    if weight <= remaining_capacity:\n      # Modified ratio: value/weight \u00d7 adjustment factor + smoothing term based on item consistency\n      ratio = (value / weight) * adjustment_factor + (value / 100) # Small consistency bonus\n      if ratio > best_ratio:\n        best_ratio = ratio\n        best_item = (weight, value, index)\n  \n  return best_item\n\n",
 "reevo": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Tuple[int, int, int] | None:\n  \"\"\"\n  Select the item with the highest value-to-weight ratio that fits in the remaining capacity.\n\n  Args:\n    remaining_capacity: The remaining capacity of the knapsack.\n    remaining_items: List of tuples containing (weight, value, index) of remaining items.\n\n  Returns:\n    The selected item as a tuple (weight, value, index), or None if no item fits.\n  \"\"\"\n  if not remaining_items:\n    return None\n  \n  # Track frequency of each item index to promote diversity\n  item_freq = {}\n  for item in remaining_items:\n    index = item[2]\n    item_freq[index] = item_freq.get(index, 0) + 1\n  \n  # Identify underrepresented items (frequency < 2) to encourage diversity\n  underrepresented = [item for item in remaining_items if item_freq[item[2]] < 2]\n  \n  # Phase detection: early, mid, late based on capacity and item count\n  total_items = len(remaining_items)\n  capacity_threshold = remaining_capacity\n  \n  # Early phase: high capacity, many items \u2192 prioritize high ratio and value\n  if total_items > 5 and capacity_threshold > 30:\n    best_item = None\n    best_ratio = -1\n    best_value = -1\n    \n    for item in remaining_items:\n      weight, value, index = item\n      if weight <= remaining_capacity:\n        ratio = value / weight\n        if (ratio > best_ratio or \n          (ratio == best_ratio and value > best_value)):\n          best_ratio = ratio\n          best_value = value\n          best_item = item\n    return best_item\n  \n  # Mid-phase: moderate capacity \u2192 balance value, ratio, and diversity\n  elif total_items > 3 and capacity_threshold > 10:\n    candidates = []\n    for item in remaining_items:\n      weight, value, index = item\n      if weight <= remaining_capacity:\n        # Dynamic penalty for high-weight items (e.g., > 0.6 capacity)\n        weight_penalty = 0.0\n        if weight > remaining_capacity * 0.6:\n          weight_penalty = 1.5\n        \n        # Diversity boost for underrepresented items\n        diversity_factor = 1.0 if item_freq.get(index, 0) < 2 else 0.7\n        \n        # Adjusted score: value, ratio, and diversity\n        ratio = value / weight\n        score = (ratio * value * diversity_factor) - weight_penalty\n        \n        candidates.append((score, weight, value, index))\n    \n    if not candidates:\n      return None\n      \n    candidates.sort(key=lambda x: x[0], reverse=True)\n    selected = candidates[0]\n    return (selected[1], selected[2], selected[3])\n  \n  # Late phase: low capacity \u2192 prioritize stability, diversity, and small items\n  else:\n    candidates = []\n    for item in remaining_items:\n      weight, value, index = item\n      if weight <= remaining_capacity:\n        # Strong penalty for large items; favor small, diverse, high-value items\n        weight_penalty = 0.0\n        if weight > remaining_capacity * 0.4:\n          weight_penalty = 2.0\n        \n        # Strong diversity bonus for underrepresented items\n        diversity_factor = 1.5 if item_freq.get(index, 0) < 2 else 0.5\n        \n        # Score: value + diversity, penalize large weights\n        ratio = value / weight\n        score = (ratio * value * diversity_factor) - weight_penalty\n        \n        candidates.append((score, weight, value, index))\n    \n    if not candidates:\n      return None\n      \n    candidates.sort(key=lambda x: x[0], reverse=True)\n    selected = candidates[0]\n    return (selected[1], selected[2], selected[3])\n\n",
 "LHS": "import numpy as np\nfrom typing import List, Tuple, Optional\n\ndef select_next_item(remaining_capacity: int, remaining_items: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n  fit = [(w, v, idx) for (w, v, idx) in remaining_items if w <= remaining_capacity]\n  if not fit:\n    return None\n\n  for w, v, idx in fit:\n    if w == 0:\n      return (w, v, idx)\n\n  # Compute densities of all remaining items\n  densities = [float(v) / max(1e-12, float(w)) for (w, v, idx) in fit]\n  median = np.median(densities)\n  mean = np.mean(densities)\n\n  # Choose the best item based on a deterministic scoring function\n  best_score = -np.inf\n  best_item = None\n  for w, v, idx in fit:\n    if w == 0:\n      score = v\n    else:\n      score = (v / max(1e-12, float(w))) * (1.0 + 0.5 * (w / remaining_capacity))\n    if score > best_score:\n      best_score = score\n      best_item = (w, v, idx)\n\n  return best_item\n\n"
}